/* 
 * Copyright (C) 2015 ETH Zurich and University of Bologna
 * All rights reserved.
 *
 * This software may be modified and distributed under the terms
 * of the BSD license.  See the LICENSE file for details.
 *
 * Authors: Germain Haugou (germain.haugou@gmail.com)
 */

#ifndef __RT__RT_API_SCHED_H__
#define __RT__RT_API_SCHED_H__

#define PLP_TASK_PERIODIC  (1<<0)
#define PLP_TASK_ONESHOT   (1<<1)

/** @name Scheduler API
 * The following API gives access to the scheduler, which has the following properties:
 *   - One instance of the scheduler is running on each cluster, and also on the fabric controller, if it is present.
 *   - Each scheduler instance is used by only one core at the same time, so there is no race condition from within a scheduler task.
 *   - It is a run-to-completion scheduler. It takes tasks from a FIFO, and executes each one until it returns.
 *   - It has 2 priority queues. The scheduler always takes tasks from the high priority queue unless it is empty and then takes them from the low priority queue.
 *   - Tasks can be enqueued locally or remotly.
 *   - A task is a function pointer and an argument. Both information are compacted inside a 32-bit word and thus the argument is not a full 32-bit word. When the task is executed, the scheduler calls the task entry with the task argument as first argument.
 *   - Each scheduler instance has its own stack, on which all tasks are executed.
 *   - It is not guaranteed that the scheduler will always run on the same core. On a cluster, tasks can be executed on a different core to improve cluster utilization.
 *   - A task should be short in order to ensure the system is reactive as tasks are never preempted. In case a task must run for a long time, it can yield the scheduler to let him execute tasks in the middle. However, be careful with the task usage, as the executed tasks will grow the stack from the synchronization point.
 *   - Tasks can also be enqueued by the runtime after specific events like a DMA transfer completion.
 *   - The scheduler is not automatically started, it must be started explicitly by the user.
 *   - A task handler must be of type plp_task_handler_t, i.e. void (*)(unsigned int).
 */
/**@{*/

/** Handler creation. 
 * This produces a 32 bits word containing both the handler entry and the handler argument. Once enqueued, this handler is executed immediatly, thus most of the time from an inteerupt handler.
 * 
  \param   handler  The handler entry which is a function pointer of type plp_task_handler_t, i.e. void (*)(unsigned int).
  \param   arg      The handler argument. This argument has a reduced number of bits given by PLP_TASK_ARG_BITS.
  \return  The handler descriptor. As it is a 32-bits word, the handler can be passed as it is to other runtime calls, like DMA transfers
  */
static inline plp_task_t plp_handler(plp_task_handler_t handler, unsigned int arg);

/** Handler creation with no argument. 
 * This produces a 32 bits word containing both the handler entry and the handler argument. Once enqueued, this handler is executed immediatly, thus most of the time from an inteerupt handler.
 * 
  \param   handler  The handler entry which is a function pointer of type plp_task_handler_t, i.e. void (*)(unsigned int).
  \param   arg      The handler argument. This argument has a reduced number of bits given by PLP_TASK_ARG_BITS.
  \return  The handler descriptor. As it is a 32-bits word, the handler can be passed as it is to other runtime calls, like DMA transfers
  */
static inline plp_task_t plp_handler_noarg(plp_task_handler_t handler);

/** Normal task creation. 
 * This produces a 32 bits word containing both the task entry and the task argument. Once enqueued, this task will go to the low-priority queue.
 * 
  \param   handler  The task entry which is a function pointer of type plp_task_handler_t, i.e. void (*)(unsigned int).
  \param   arg      The task argument. This argument has a reduced number of bits given by PLP_TASK_ARG_BITS.
  \return  The task descriptor. As it is a 32-bits word, the task can be passed as it is to other runtime calls, like DMA transfers
  */
static inline plp_task_t plp_task(plp_task_handler_t handler, unsigned int arg);

/** Normal task creation with no argument
 * This produces a 32 bits word containing both the task entry and the task argument. Once enqueued, this task will go to the low-priority queue.
 * This task descriptor is required by a few API functions where the argument cannot be specified, most of the time because the argument is generated by the runtime.
 * 
  \param   handler  The task entry which is a function pointer of type plp_task_handler_t, i.e. void (*)(unsigned int).
  \return  The task descriptor. As it is a 32-bits word, the task can be passed as it is to other runtime calls, like DMA transfers
  */
static inline plp_task_t plp_task_noarg(plp_task_handler_t handler);

/** High-priority task creation. 
 * This produces a 32 bits word containing both the task entry and the task argument. Once enqueued, this task will go to the high-priority queue.
 * 
  \param   handler  The task entry which is a function pointer of type plp_task_handler_t, i.e. void (*)(unsigned int).
  \param   arg      The task argument. This argument has a reduced number of bits given by PLP_TASK_ARG_BITS.
  \return  The task descriptor. As it is a 32-bits word, the task can be passed as it is to other runtime calls, like DMA transfers
  */
static inline plp_task_t plp_prioTask(plp_task_handler_t handler, unsigned int arg);

/** High-priority task creation. 
 * This produces a 32 bits word containing both the task entry and the task argument. Once enqueued, this task will go to the high-priority queue.
 * This task descriptor is required by a few API functions where the argument cannot be specified, most of the time because the argument is generated by the runtime.
 * 
  \param   handler  The task entry which is a function pointer of type plp_task_handler_t, i.e. void (*)(unsigned int).
  \return  The task descriptor. As it is a 32-bits word, the task can be passed as it is to other runtime calls, like DMA transfers
  */
static inline plp_task_t plp_prioTask_noarg(plp_task_handler_t handler);

/** Utility function to produce a compact argument from a local memory pointer.
 * This will return the pointer if it is an aliased pointer or the same pointer minus the local memory base if it is a global pointer. This is useful for giving a local variable pointer as a task argument.
 * 
  \param   arg      The local pointer to be compacted.
  \return  The compacted pointer.
  */
static inline unsigned int plp_task_localOffset(unsigned int arg);

/** Enqueue a task into the local scheduler.
 * 
  \param   task The task to be enqueued
  \return  0 if it was successfully enqueued or 1 if the scheduler queue was full.
  */
int plp_sched_enqueue(plp_task_t task);

/** NOT YET IMPLEMENTED. Enqueue a task into a remote scheduler.
 * In case the remote scheduler queue is full, the task is dropped, so the SW must make sure the queue is not full
 * 
  \param   cluster The cluster of the remote scheduler. Can also be the FC cluster number.
  \param   task The task to be enqueued
  */
void plp_sched_remote_enqueue(int cluster, plp_task_t task);

/** Start the local scheduler.
 * The caller is blocked until the scheduler is stopped and tasks are executed using the caller context.
 * 
 \return The exit status that was given to the call to plp_sched_stop that stopped the scheduler.
  */
int plp_sched_start();

/** Yield the local scheduler.
 * This is a synchronization point to let the scheduler execute other tasks in the middle of a long task. 
 * 
  \param   evtMask A mask of events that should wake-up the scheduler. If -1, the scheduler won't go to sleep and will give back control to the caller in case there is no more task to execute. This option is useful in case the caller is waiting for an event and want to let the scheduler execute until the event is received.
  \param   status In case the scheduler is stopped, this returns the exit status.
  \return 1 if the scheduler has been stopped and has no more tasks to execute, 0 otherwise
  */
int plp_sched_yield(int evtMask, unsigned int *status);

/** Stop the local scheduler.
 * This will force the scheduler to stop after all tasks have been executed and to give back execution to the one which called plp_sched_start. 
 * 
  \param   status The exit status that will be returned to the caller of plp_sched_start
  */
void plp_sched_stop(int status);

/** Put core to sleep until something can be executed.
 * This can be called when the core has nothing to do and wants to wait until something happens like and end of transfer.
  */
static inline void plp_sched_wait();

// TODO
void plp_sched_enqueue_delayed(plp_task_delayed_t *task);

// TODO
static inline void plp_task_delayed_ms(plp_task_delayed_t *taskDesc, plp_task_t task, unsigned int conf, unsigned int time);

//!@}

#endif