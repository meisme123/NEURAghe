<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>How to debug memory corruptions or invalid accesses &mdash; howto 1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="howto 1 documentation" href="index.html" />
    <link rel="next" title="How to use GDB with virtual platform" href="howtoSimulatorGdb.html" />
    <link rel="prev" title="How to use virtual platform VCD traces" href="howtoSimulatorVcd.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="how-to-debug-memory-corruptions-or-invalid-accesses">
<h1>How to debug memory corruptions or invalid accesses<a class="headerlink" href="#how-to-debug-memory-corruptions-or-invalid-accesses" title="Permalink to this headline">¶</a></h1>
<p>Note that this howto can only be used on the virtual platform and is strongly relying on platform traces described here: <a class="reference internal" href="howtoUseAssemblyTraces.html#howtoassemblytraces"><span>How to use platform traces</span></a>.</p>
<div class="section" id="first-identify-the-reason-of-the-memory-corruption-or-the-invalid-access">
<h2>First identify the reason of the memory corruption or the invalid access<a class="headerlink" href="#first-identify-the-reason-of-the-memory-corruption-or-the-invalid-access" title="Permalink to this headline">¶</a></h2>
<p>Such bugs can show-up in different ways.</p>
<p>The first one is that an invalid access is reported by the platform like the following:</p>
<div class="highlight-python"><div class="highlight"><pre>58988800000: [/soc/fabric/noc/warning              ] Invalid access (offset: 0x3f14fc00, size: 0x10, isRead: 1)
58988800000: [/soc/fabric/cluster0/pe0/warning     ] Invalid access during instruction fetch (offset: 0x3f14fc0c, size: 0x4)
</pre></div>
</div>
<p>These ones are the easiest to debug as they are explicitly reported by the platform, as some kind of asserts. In this case, there was an invalid access reported by the interconnect (in the architecture at <em>/soc/fabric/noc</em>) which ends up being reported by the core doing the access as an invalid instruction fetch.</p>
<p>They can also be reported by other warnings reported by the platform like invalid use of peripherals or registers.</p>
<p>Unfortunatly most of the bugs will just lead to invalid results or hanging application. In this case, the application should be debugged using printf of gdb (soon available).</p>
</div>
<div class="section" id="get-more-information-using-platform-traces">
<h2>Get more information using platform traces<a class="headerlink" href="#get-more-information-using-platform-traces" title="Permalink to this headline">¶</a></h2>
<p>In case a platform warning is raised, the following method can be applied to get more information.</p>
<p>As the platform is stopped as soon as the invalid access is raised (by default warnings are considered as errors), it is really easy to have more information by dumping the end of the executed instructions using platform traces:</p>
<div class="highlight-python"><div class="highlight"><pre>58988690000: [ESC[34m/soc/fabric/cluster0/pe0/iss         ESC[0m] 1c003c5c l.jr                r9                   r9 :3f14fc0d
58988700000: [ESC[34m/soc/fabric/cluster0/pe0/iss         ESC[0m] 1c003c60 l.lwz               r30, -12(r1 )        r30=3eda278d r1 :00003424  PA:00003418
58988800000: [ESC[34m/soc/fabric/cluster0/pe0/iss         ESC[0m] 3f14fc0c l.j                 0
</pre></div>
</div>
<p>We see here that the core is jumping to an invalid address (0x3f14fc0c), which is also more or less the one reported as being the address of the invalid access. This faulting address is a bit different as it is actually a program cache line refill. The jump to this invalid address is done because the return register (r9) is containing this invalid address.</p>
<p>The next step is to find out how we ended-up having this invalid address in r9, which can be done by looking for r9 in the platform traces from the end to the beginning. If for example you open the trace file with the tool <em>less</em>, you can look for it by typing /, followed by r9 and enter, and then shift + n to go backward or n to go forward. Doing that we see that r9 is written by the following operation:</p>
<div class="highlight-python"><div class="highlight"><pre>58988420000: [ESC[34m/soc/fabric/cluster0/pe0/iss         ESC[0m] 1c003c38 l.lwz               r9 , -4(r1 )         r9 =3f14fc0d r1 :00003424  PA:00003420
</pre></div>
</div>
<p>This operation is loading the invalid address from memory at address 0x3420 (which is an L1 address through the cluster alias), and storing it to r9. As you can see on the operands part, the address is computed from r1 which is the stack pointer. Probably the address was stored on the stack earlier (e.g. before calling a function) and is now being restored in order to return to the caller (r9 is the return address). In such cases, most of the time, another unrelated code stored something else at the same location illegaly, for example with a buffer overflow.</p>
<p>The next step is to find out which code is storing this invalid address on top of the valid one which was saved. To do that, just continue to search in the platform traces from the end to the start by looking for <em>PA:00003420</em>. Each time a core is accessing this address, this pattern will appear on the line containing the instruction doing the access. In this example, the following instruction is doing the access:</p>
<div class="highlight-python"><div class="highlight"><pre>58945820000: [ESC[34m/soc/fabric/cluster0/pe0/iss         ESC[0m] 1c0038b0 l.sw                8(r6 !), r7          r6 =00003428 r6 :00003420  PA:00003420 r7 :3f14fc0d
</pre></div>
</div>
<p>This instruction is very suspicious, first because it stores something in a location used to save registers on the stack, and is not computing the address using the stack pointer (it is using r6), and also because it is storing a value at a location where a pointer is expected.</p>
<p>To know why is the code doing this, just disassemble the application binary (using or1kle-elf-objdump -d -l or riscv32-elf-objdump -d -l) and look for address 0x1c0038b0 (the address of the instruction), this should give the source code file and the line of the code doing that. In this example, this points out to a code which was writing to this address due to a buffer overflow (an array was too small) and then overwriting something on the stack as the array was on the stack.</p>
</div>
<div class="section" id="get-more-information-using-platform-debugger">
<h2>Get more information using platform debugger<a class="headerlink" href="#get-more-information-using-platform-debugger" title="Permalink to this headline">¶</a></h2>
<p>If you look at the pulp-run command launched to start the execution, you should see a &#8211;pdb-no-break, which tells the platform to not enter the debugger at start-up. If you replace it with &#8211;pdb-break, the platform should first enter the debugger before executing the first instruction and you should get the following prompt:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">Cmd</span><span class="p">)</span>
</pre></div>
</div>
<p>You can use the bkp command to register a breakpoint on a memory address so that the platform stop in case this address is accessed. For that just enters:</p>
<div class="highlight-python"><div class="highlight"><pre>(Cmd) bkp 0x3420
(Cmd) run
</pre></div>
</div>
<p>This will run the platform and you should see something like this when the address is accessed:</p>
<div class="highlight-python"><div class="highlight"><pre>403350000: [/soc/fabric/cluster0/pe0/userTrace   ] Reached breakpoint (matchAddr: 0x00003420, matchAccess: w)
(Cmd)
</pre></div>
</div>
<p>In case this is not the access you are looking for, you can retype the run command or execute the following to get the PC of all cores:</p>
<div class="highlight-python"><div class="highlight"><pre>(Cmd) state
/soc/fabric/cluster0/pe0
  PC: 0x1c001ed4
/soc/fabric/cluster0/pe1
  PC: 0x1c004b0c
/soc/fabric/cluster0/pe2
  PC: 0x1c004b0c
/soc/fabric/cluster0/pe3
  PC: 0x1c004b0c
</pre></div>
</div>
<p>You can then use the PC information and objdump to know which source code is doing this access.</p>
</div>
<div class="section" id="get-more-information-using-gdb">
<h2>Get more information using GDB<a class="headerlink" href="#get-more-information-using-gdb" title="Permalink to this headline">¶</a></h2>
<p>GDB should soon be available for tracking memory accesses using watchpoints.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">How to debug memory corruptions or invalid accesses</a><ul>
<li><a class="reference internal" href="#first-identify-the-reason-of-the-memory-corruption-or-the-invalid-access">First identify the reason of the memory corruption or the invalid access</a></li>
<li><a class="reference internal" href="#get-more-information-using-platform-traces">Get more information using platform traces</a></li>
<li><a class="reference internal" href="#get-more-information-using-platform-debugger">Get more information using platform debugger</a></li>
<li><a class="reference internal" href="#get-more-information-using-gdb">Get more information using GDB</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="howtoSimulatorVcd.html" title="previous chapter">How to use virtual platform VCD traces</a></li>
      <li>Next: <a href="howtoSimulatorGdb.html" title="next chapter">How to use GDB with virtual platform</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/howtoDebugMemoryCorruption.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Germain Haugou.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
      |
      <a href="_sources/howtoDebugMemoryCorruption.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>