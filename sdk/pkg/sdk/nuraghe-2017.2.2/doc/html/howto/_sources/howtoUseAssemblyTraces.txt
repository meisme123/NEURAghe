.. _howtoAssemblyTraces:

How to use platform traces
--------------------------

Platform traces are information dumped by the platform in order to help the developper debugging his application.
These traces correspond to HW events like an executed instruction and thus give details about what is happenning in the system.
Although these traces are available on several platforms (currently virtual platform and RTL platform), the supported events can differ.

How to activate them
....................

On the RTL platform, the traces are always active and can be found in the test build folder (the one given to pulp-run through option *--dir*). As it only supports core instruction traces, there is one file per core with the name trace_core_<clusterId>_<coreId>.log.

On the virtual platform, they are by default not active and can be activated and configured through the runner option *--gv-trace*. This option can be either passed directly to the *pulp-run* command or through the makefile using: ::

  $ make run PLT_OPT=--gv-trace=.*

The traces are also generated in the test build folder. As it is dumping not only core instruction traces but also system-wide traces, there is a single file called *trace.txt*, which is generated and contains everything.

How to configure them
.....................

On RTL platform, the traces cannot be configured as only core instruction traces are always generated. See below for more information about these traces.

The virtual platform allows dumping all kind of architecture events to help the developper debugging his application by better showing what is happening in the system.

For example, it can show instructions being executed, DMA transfers, events generated, memory accesses and so on.

This feature can be configured through the *--gv-trace* option. This option takes an argument which specifies the path in the architecture where the traces must be enabled. All components included in this path will dump traces. Each path is a regular expression, so it can be partial paths, use wildcards and so on. Several paths can be specified by using several times the option. Here is an example that activates instruction traces for core 0 and core 1: ::

  $ make run PLT_OPT="--gv-trace=pe0/iss --gv-trace=pe1/iss"

One difficulty is usually to find out which paths should be activated to get the needed information. One method is to dump all the events with *--gv-trace=.**, then find out which one are insteresting and then put them on the command line. Here are the paths for the main components:

================================== ===============================
Path                               Description
================================== ===============================
/soc/fabric/cluster0/pe0           Processing element, useful to see the IOs made by the core, and the instruction it executes. You can add */iss* to just get instruction events
/soc/fabric/cluster0/ckg           Hardware synchronizer events, useful for debugging inter-core synchronization mechanisms
/soc/fabric/cluster0/pcache        Shared program cache accesses
/soc/fabric/cluster0/l1ico         Shared L1 interconnect
/soc/fabric/cluster0/l1_X          L1 memory banks (the X should be replaced by the bank number)
/soc/fabric/l2                     L2 memory accesses
/soc/fabric/cluster0/dma           DMA events
================================== ===============================


Traces content
..............

The trace file should look like the following: ::

  20830000: [/soc/fabric/cluster0/pe1/iss    ]      1c0001f0 l.lwz               r6 , 540(r6 )    r6 =00000000 r6 :00204000  PA:0020421c

There is usually one line per event, although an event can sometimes takes several lines to display more information.

The number on the left gives the timestamp of the event, in picoseconds. This is not using cycles because different blocks like clusters can have different frequencies.

The second part, which is a string, gives the path in the architecture where the event occured. This is useful to differentiate blocks of the same kind that generate the same event. This path can also be used with the *--gv-trace* option to reduce the number of events.

The third part, which is also a string, is the information dumped by the event, and is totally specific to this event. In our example, the core simulator is just printing information about the instruction that has been executed.

Core instruction traces
....................

Core instruction traces are available on both the RTL platform and the virtual platform. As they are showing not only the instructions executed but also the registers accessed, their content and the memory accesses, they are very useful for debugging bugs like memory corruptions.

If we take back the previous example: ::

  20830000: [/soc/fabric/cluster0/pe1/iss    ]      1c0001f0 l.lwz               r6 , 540(r6 )    r6 =00000000 r6 :00204000  PA:0020421c

The event information dumped for executed instructions is using the following format: ::

  <address> <instruction> <operands> <operands info>

<address> is the address of the instruction.

<instruction> is the instruction label.

<operands> is the part of the decoded operands.

<operands info> is giving details about the operands values and how they are used.

The latter information is using the following convention:

  - When a register is accessed, its name is displayed followed by *=* if it is written or *:* if it is read. In case it is read and written, the register appears twice. It is then following by its value, which is the new one in case it is written.

  - When a memory access is done, *PA:* is displayed, followed by the address of the access.

  - The order of the statements is following the order on the decoded instruction

The memory accesses which are displayed are particularly interesting for tracking memory corruptions as they can be used to look for accesses to specific locations.
