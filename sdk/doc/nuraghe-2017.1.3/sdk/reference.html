<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Reference &mdash; SDK 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="SDK 1.0 documentation" href="index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="reference">
<h1>Reference<a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="configuration">
<h2>Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h2>
<p>When compiling an application relying on the makefiles provided by the SDK, several options can be specified either in the application makefile or on the command line to specify the Pulp configuration.</p>
<p>The configuration includes selecting the platform, the architecture, as well as the runtime. All the available options can be displayed from the application folder with this command:</p>
<div class="highlight-python"><div class="highlight"><pre>$ make config
</pre></div>
</div>
<p>For example, the pulp architecture and the stack size can be specified with this command:</p>
<div class="highlight-python"><div class="highlight"><pre>$ make config pulpArchi=pulp4 stackSize=2048
</pre></div>
</div>
<p>You should see in the new printed table that your options has been taken into account. A few options like the pulp architecture have impacts on default values, so you may see different values for options that you didn't specify.</p>
<p>You can also set these options directly from the application makefile to make them permanent, which can be useful for example for the stack size:</p>
<div class="highlight-python"><div class="highlight"><pre>PULP_APP = test
PULP_APP_SRCS = test.c

stackSize=2048

include $(PULP_SDK_HOME)/install/rules/pulp.mk
</pre></div>
</div>
</div>
<div class="section" id="tools-flags">
<h2>Tools flags<a class="headerlink" href="#tools-flags" title="Permalink to this headline">¶</a></h2>
<p>The flags used for compiling and running the application are automatically generated by the SDK makefiles depending on the specified options.</p>
<p>To see the generated flags, you can execute this command:</p>
<div class="highlight-python"><div class="highlight"><pre>$ make flags
</pre></div>
</div>
<p>If you add an option to the command or to the makefile, you should see the impact on the flags.</p>
<p>An application can specify additional flags, for example to specify the level of optimization. You can for example add this in the application makefile:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">PULP_APP</span> <span class="o">=</span> <span class="n">test</span>
<span class="n">PULP_APP_SRCS</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">c</span>
<span class="n">PULP_CFLAGS</span> <span class="o">=</span> <span class="o">-</span><span class="n">O3</span>
</pre></div>
</div>
<p>Note that the flags you specify there are not displayed by the <em>make config</em> command.</p>
<p>Here is the list of available flags that you can add to the application makefile:</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Flag</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>PULP_DEFS</td>
<td>Specifies definitions (=D&lt;name&gt;=&lt;value&gt;)</td>
</tr>
<tr class="row-odd"><td>PULP_INC_PATHS</td>
<td>Specifies include folders where to look for headers</td>
</tr>
<tr class="row-even"><td>PULP_CFLAGS</td>
<td>Specifies compiler flags</td>
</tr>
<tr class="row-odd"><td>PULP_LDFLAGS</td>
<td>Specifies linker flags</td>
</tr>
<tr class="row-even"><td>PLT_OPT</td>
<td>Specifies platform runner flags</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="makefile-targets">
<h2>Makefile targets<a class="headerlink" href="#makefile-targets" title="Permalink to this headline">¶</a></h2>
<p>The common makefiles provides several targets for compiling, running and profiling applications. You can get the full list of targets and their description by executing this command:</p>
<div class="highlight-python"><div class="highlight"><pre>$ make help
</pre></div>
</div>
<p>You can also execute it with the configuration options specified, as some targets may be specific to a configuration.</p>
</div>
<div class="section" id="gvsoc-traces">
<h2>Gvsoc traces<a class="headerlink" href="#gvsoc-traces" title="Permalink to this headline">¶</a></h2>
<p>The virtual platform allows dumping architecture events to help the developper debugging his application by better showing what is happening in the system.</p>
<p>For example, it can show instructions being executed, DMA transfers, events generated, memory accesses and so on.</p>
<p>This feature can be enabled and configured through the <em>--gv-trace</em> option. This option takes an argument which specifies the path in the architecture where the traces must be enabled. All components included in this path will dump traces. Several paths can be specified by using several times the option. Here is an example that activates instruction traces for core 0 and core 1:</p>
<div class="highlight-python"><div class="highlight"><pre>$ make run PLT_OPT=&quot;--gv-trace=pe0/iss --gv-trace=pe1/iss&quot;
</pre></div>
</div>
<p>The traces are dumped into a file which is named <em>trace.txt</em> and which is located inside the build folder. To find out where is the build folder you can have a look at the command which is used to launch the simulator.</p>
<p>The trace file should look like the following:</p>
<div class="highlight-python"><div class="highlight"><pre>27600000: [/soc/fabric/cluster0/pe1/iss  ] r9 =00000000         1c0000a4 l.movhi r9,0
27600000: [/soc/fabric/cluster0/pe0/iss  ] r9 =00000000         1c0000a4 l.movhi r9,0
</pre></div>
</div>
<p>There is usually one line per event, although an event can sometimes takes several lines to display more information.</p>
<p>The number on the left gives the timestamp of the event, in picoseconds. This is not using cycles because different blocks like clusters can have different frequencies.</p>
<p>The second part, which is a string, gives the path in the architecture where the event occured. This is useful to differentiate blocks of the same kind that generate the same event. This path can also be used with the <em>--gv-trace</em> option to reduce the number of events.</p>
<p>The third part, which is also a string, is the information dumped by the event, and is totally specific to this event. In our example, the core simulator is just printing information about the instruction that has been executed.</p>
<p>One difficulty is usually to find out which paths should be activated to get the needed information. One method is to dump all the events with <em>--gv-trace=.*</em>, then find out which one are insteresting and then put them on the command line. Here are the paths for the main components:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Path</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>/soc/fabric/cluster0/pe0</td>
<td>Processing element, useful to see the IOs made by the core, and the instruction it executes. You can add <em>/iss</em> to just get instruction events</td>
</tr>
<tr class="row-odd"><td>/soc/fabric/cluster0/ckg</td>
<td>Hardware synchronizer events, useful for debugging inter-core synchronization mechanisms</td>
</tr>
<tr class="row-even"><td>/soc/fabric/cluster0/pcache</td>
<td>Shared program cache accesses</td>
</tr>
<tr class="row-odd"><td>/soc/fabric/cluster0/l1ico</td>
<td>Shared L1 interconnect</td>
</tr>
<tr class="row-even"><td>/soc/fabric/cluster0/l1_X</td>
<td>L1 memory banks (the X should be replaced by the bank number)</td>
</tr>
<tr class="row-odd"><td>/soc/fabric/l2</td>
<td>L2 memory accesses</td>
</tr>
<tr class="row-even"><td>/soc/fabric/cluster0/dma</td>
<td>DMA events</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="runtime">
<h2>Runtime<a class="headerlink" href="#runtime" title="Permalink to this headline">¶</a></h2>
<p>The runtime is made of a first layer that contains architecture files (mainly register mapping), HAL files (mainly header files hiding register accesses) and a system library providing higher-level features like memory allocation.</p>
<p>You can have access to these 3 layers by including the following file:</p>
<div class="highlight-python"><div class="highlight"><pre>include &lt;rt/pulp.h&gt;
</pre></div>
</div>
</div>
<div class="section" id="getting-cycles">
<h2>Getting cycles<a class="headerlink" href="#getting-cycles" title="Permalink to this headline">¶</a></h2>
<p>The best way to get a cycle count is to use the cluster timer. Once activated, this 64-bits counter is counting cycles whatever the state of the cores. Just be careful about the fact this is a shared counter, so only one core should reset it while all the cores can read it.</p>
<p>To use it, you must first activate it, which can be done with the following code:</p>
<div class="highlight-python"><div class="highlight"><pre>if (get_core_id() == 0) {
  reset_timer();
  start_timer();
}
</pre></div>
</div>
<p>This is usually core 0 which activates it at the beginning of the application.</p>
<p>Then you can execute the following code to get the number of cycles (on 32bits):</p>
<div class="highlight-python"><div class="highlight"><pre>if (get_core_id() == 0) {
  stop_timer();
  time = get_time();
}
</pre></div>
</div>
<p>The first line is used to stop the timer. It can be used together with <em>start_timer</em> to stop and resume the timer in order to cumulate the time over several portions of code. However, you may not use that if you want to share the timer between several cores.</p>
</div>
<div class="section" id="performance-counters">
<h2>Performance counters<a class="headerlink" href="#performance-counters" title="Permalink to this headline">¶</a></h2>
<p>In order to get more understanding about the application, you can use the HW counters that give you detailed information about several events like cache misses, stalls and so on.</p>
<p>Here is an example showing how to use them:</p>
<div class="highlight-python"><div class="highlight"><pre>#include &quot;omp.h&quot;
#include &lt;rt/pulp.h&gt;

int main()
{
  hw_perf_t perf;
  hw_perf_init(&amp;perf);

  while (hw_perf_step(&amp;perf))
  {
    hw_perf_start(&amp;perf);

    #pragma omp parallel
    {
      int i;
      for (i=0; i&lt;1000; i++)
        {
          *(volatile int *)0x10000000;
        }
      for (i=0; i&lt;1000; i++)
        {
          *(volatile int *)0x1c000000;
        }
    }

    hw_perf_stop(&amp;perf);
    hw_perf_commit(&amp;perf);
  }

  int i;
  printf(&quot;HW performance counters results\n&quot;);

  for (i=0; i&lt;hw_perf_nb_events(&amp;perf); i++)
  {
    printf(&quot;%20s: %d\n&quot;, hw_perf_get_name(&amp;perf, i), hw_perf_get_value(&amp;perf, i));
  }

  return 0;
}
</pre></div>
</div>
<p>Each core contains a set of HW counters, whose numbers depends on the platform. The prototyping platforms, such as the virtual platform, the RTL simulator and the FPGA contains one counter per event, so that you can get all the information in one shot. The chips contains a single counter that can be configured to count a single event, so you will have to iterate several times to get all the information.</p>
<p>The API provided in the <em>hwPerf.h</em> file allows you to write a portable code that will get all the information, whatever the platform. For that you have to first initialize a structure with <em>hw_perf_init</em> and loop on the code you want to benchmark until <em>hw_perf_step</em> returns 0. Inside the code to be profiled, you have to use <em>hw_perf_start</em> and <em>hw_perf_stop</em> to define the exact region to be profiled and <em>hw_perf_commit</em> to read the events from the counters and put them in the structure. Once done, there are other functions to help you getting and displaying the results.</p>
<p>Once this test is executed, you should get something like:</p>
<div class="highlight-python"><div class="highlight"><pre>     CYCLES: 12966
      INSTR: 6325
   LD_STALL: 13
  JMP_STALL: 0
      IMISS: 638
    WBRANCH: 0
WBRANCH_CYC: 0
         LD: 2044
         ST: 66
       JUMP: 8
     BRANCH: 24
  DELAY_NOP: 10
     LD_EXT: 1001
     ST_EXT: 4
 LD_EXT_CYC: 5001
 ST_EXT_CYC: 0
  TCDM_CONT: 998
</pre></div>
</div>
<p>CYCLES are the number of cycles while the core is not in sleep mode, so it should correspond to the timer count except if the core was in idle mode.</p>
<p>INSTR gives the number of instructions. If you compare it to the number of cycles, you can quickly know if you reach a good ratio of instruction per cycle, which tells you how much the core was stalled (ideally you have number of instructions equal to the number of cycles).</p>
<p>The rest of the events gives you more details about the reasons why the core was stalled, you can get more details in the core architecture documentation.</p>
<p>Note that the performance counters have been added recently and are only available since the pulp4 architecture. They are for example not available in the mia architecture which is the default one.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Reference</a><ul>
<li><a class="reference internal" href="#configuration">Configuration</a></li>
<li><a class="reference internal" href="#tools-flags">Tools flags</a></li>
<li><a class="reference internal" href="#makefile-targets">Makefile targets</a></li>
<li><a class="reference internal" href="#gvsoc-traces">Gvsoc traces</a></li>
<li><a class="reference internal" href="#runtime">Runtime</a></li>
<li><a class="reference internal" href="#getting-cycles">Getting cycles</a></li>
<li><a class="reference internal" href="#performance-counters">Performance counters</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/reference.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, ETH - Unibo.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
      |
      <a href="_sources/reference.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>