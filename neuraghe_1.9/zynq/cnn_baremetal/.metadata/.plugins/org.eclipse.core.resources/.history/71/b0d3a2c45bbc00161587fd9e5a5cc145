/*
 * main file of nuraghe_test.
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */

#include "cnn.h"
#include <stdio.h>
#include "platform.h"
#include "soc_drivers.h"
#include <string.h>
#include "xtime_l.h"

///If FIXED_CONVNET is defined then the Convolutional neural network will work on fixed-point types.
//Otherwise it will work on floating-point types
#define FIXED_CONVNET
//#define BINARY_FILE


void print_stream (int len, data_t * x){
	int i;
	for(i=0;i<len;i++) {
			printf("0x%04x\n", x[i]);

	}

}

void zeros_fill(int16_t *w, int len_B){
    int i;
    for (i=0; i<len_B/2; i++)
        w[i]=0;
}

void copy_w(int16_t * dest, int16_t * src, int len_B){
    int i;
    for (i=0;i<len_B/2;i++){
        dest[i]=src[i];
    }

}

void round4_features (int16_t * dest, int16_t * src, int in_f){

    int if_round, j;

    if_round=in_f/4;
    if (in_f%4>0) if_round++;
    if_round=if_round*4;

    printf ("if: %d if_round %d\n", in_f, if_round);

	for (j=0;j<if_round;j++){
		if (j<in_f){
			copy_w(&dest[j*28*28], &src[j*28*28], 28*28*2);
			//printf("first w: %d bias: %d\n", w[(i*IF + j)*25], b[i]);
		}
		else{
			zeros_fill(&dest[j*28*28],28*28*2);
			//printf("Zerofill: if:%d of:%d\n", j, i);
		}
	}


}

void interlace (int * dest, int * src, int n_feat, int len_B){ // len is the number of bytes of a dest
    int stride = 4;

    int gr = n_feat/stride;
    if (n_feat%4>0) gr++;


    int i, j, g;
    for (g=0; g<gr;g++){
      for (j=0; j<stride; j++) {
	    for (i=0; i< len_B /4; i++) {
		  dest[g*stride*len_B/4 + j + i*stride]=src [g*stride*len_B/4 + i+j*len_B /4];
		}
	  }
  }
}

void deinterlace (int * dest, int * src, int n_feat, int len_dest_B){ // len is the number of bytes of a dest
    int stride = 4;

    int gr = n_feat/stride;
    if (n_feat%4>0) gr++;


    int i, j, g;
    for (g=0; g<gr;g++){
      for (j=0; j<stride; j++) {
	    for (i=0; i< len_dest_B /4; i++) {
		  dest[g*stride*len_dest_B/4 + i+j*len_dest_B /4]=src [g*stride*len_dest_B/4 + j + i*stride];
		}
	  }
  }
}


void print(char *str);

/************************************/
/* ███╗   ███╗ █████╗ ██╗███╗   ██╗ */
/* ████╗ ████║██╔══██╗██║████╗  ██║ */
/* ██╔████╔██║███████║██║██╔██╗ ██║ */
/* ██║╚██╔╝██║██╔══██║██║██║╚██╗██║ */
/* ██║ ╚═╝ ██║██║  ██║██║██║ ╚████║ */
/* ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝ */
/************************************/
int main()
{
   //init_platform();

	cleanup_platform();

    printf("\n\n***************  Start Test  ***************\n\n");

    load_code();

    XTime tStart, tEnd;
    int if_round;



	///An interface of all changeable parameters follows
	int in_height        = 28; //input parameters
	int in_width         = 28;
	int in_ft            = 1;


	if_round=in_ft/4;
	if (in_ft%4>0) if_round++;
	if_round=if_round*4;



	int c0_out_ft        = 8;
	int c0_filter_height = 5;
	int c0_filter_width  = 5;

	int p0_height;
	int p0_width;
	int p0_pool_height   = 2;
	int p0_pool_width    = 2;
	int p0_out_height;
	int p0_out_width;
	int p0_stride        = 2;

	int c1_out_ft        = 16;
	int c1_filter_height = 5;
	int c1_filter_width  = 5;

	int p1_height;
	int p1_width;
	int p1_pool_height   = 2;
	int p1_pool_width    = 2;
	int p1_out_height;
	int p1_out_width;
	int p1_stride        = 2;

	int fc_out_ft        = 128;
	int fc_out_height    = 1;
	int fc_out_width     = 1;

	int nr_classes       = 10;

	///Calculation of sizes of all features for each internal hidden layer
	p0_height     = in_height-c0_filter_height+1; ///because stride=1 and there is not zero-padding (N-K)/S + 1 where S represents the stride
	p0_width      = in_width-c0_filter_width+1;
	p0_out_height = out_feat_size(p0_height,p0_pool_height,p0_stride);
	p0_out_width  = out_feat_size(p0_width,p0_pool_width,p0_stride);

	p1_height     = p0_out_height-c1_filter_height+1;
	p1_width      = p0_out_width-c1_filter_width+1;
	p1_out_height = out_feat_size(p1_height,p1_pool_height,p1_stride);
	p1_out_width  = out_feat_size(p1_width,p1_pool_width,p1_stride);

	//int dim_c0    = in_ft*c0_out_ft*c0_filter_height*c0_filter_width;

	//int dim_c1    = c0_out_ft*c1_out_ft*c1_filter_height*c1_filter_width;

	int dim_fw    = c1_out_ft*fc_out_ft*p1_out_height*p1_out_width;
	int dim_fb    = fc_out_ft;

	int dim_sw    = fc_out_ft*fc_out_height*fc_out_width*nr_classes;
	int dim_sb    = nr_classes;

	///Memory allocation of all arrays that we need such as the main input x and the main output y.
	data_t x[in_ft*in_height*in_width];


	// *************************** LAYER STRUCT ALLOCATING ***************************


	ConvLayer    *conv_layer0 = (ConvLayer *)   malloc(sizeof(ConvLayer));
	PoolLayer    *pool_layer0 = (PoolLayer *)   malloc(sizeof(PoolLayer));
	ConvLayer    *conv_layer1 = (ConvLayer *)   malloc(sizeof(ConvLayer));
	PoolLayer    *pool_layer1 = (PoolLayer *)   malloc(sizeof(PoolLayer));
	FullLayer    *fc_layer    = (FullLayer *)   malloc(sizeof(FullLayer));
	SoftmaxLayer *sfm_layer   = (SoftmaxLayer *)malloc(sizeof(SoftmaxLayer));


	// *************************** DATA ARRAY *******************************
	//conv0
//	data_t * y0       = (data_t *)malloc(c0_out_ft*p0_height*p0_width*sizeof(data_t));
	data_t * x0_zerofill       = (data_t *)malloc(if_round*in_height*in_width*sizeof(data_t));

	data_t * x0_hwce    = (data_t *)(DDR_REMAP + 0x100);
	data_t * c0_wb_hwce = (data_t *)(DDR_REMAP + 0x10000);
	data_t * y0_hwce    = (data_t *)(DDR_REMAP + 0x20000);

    //poll0
	data_t * deintrlaced_array = (data_t *)calloc(28*28*16,sizeof(data_t));

    //conv1
//	data_t * y1       = (data_t *)malloc(c1_out_ft*p1_height*p1_width*sizeof(data_t));

	data_t * x1_hwce    = (data_t *)(DDR_REMAP + 0x30000);
	data_t * c1_wb_hwce = (data_t *)(DDR_REMAP + 0x40000);
	data_t * y1_hwce    = (data_t *)(DDR_REMAP + 0x50000);

    //pool1
	data_t * y1_pool1 = (data_t *)malloc(c1_out_ft*p1_out_height*p1_out_width*sizeof(data_t));
	data_t * y1_pool1_deintr = (data_t *)calloc(c1_out_ft*p1_out_height*p1_out_width,sizeof(data_t));


    //fullconnected
	data_t *fc_w      = (data_t *)malloc(c1_out_ft*fc_out_ft*p1_out_height*p1_out_width*sizeof(data_t));
	data_t *fc_b      = (data_t *)malloc(fc_out_ft*sizeof(data_t));
	data_t *y_full    = (data_t *)malloc(fc_out_ft*fc_out_height*fc_out_width*sizeof(data_t));

    //softmax
	data_t *sfm_w     = (data_t *)malloc(fc_out_ft*fc_out_height*fc_out_width*nr_classes*sizeof(data_t));
	data_t *sfm_b     = (data_t *)malloc(nr_classes*sizeof(data_t));
	data_t *y         = (data_t *)malloc(nr_classes*sizeof(data_t));



	// *************************** Sampling of weights and biases ***************************
	int k;



	    for(k=0;k<28*4*8;k++)
	    	//c0_wb_hwce[k]=conversion_float_to_data_t(wb_layer0[k]);
	    	c0_wb_hwce[k]=(wb_layer0[k]);

	    for(k=0;k<28*8*16;k++)
	    	//c1_wb_hwce[k]=conversion_float_to_data_t(wb_layer1[k]);
	        c1_wb_hwce[k]=(wb_layer1[k]);


		for(k=0;k<dim_fw;k++)
			fc_w[k]=conversion_float_to_data_t(weights_full[k]);
		for(k=0;k<dim_fb;k++)
			fc_b[k]=conversion_float_to_data_t(bias_full[k]);
		for(k=0;k<dim_sw;k++)
			sfm_w[k]=conversion_float_to_data_t(weights_softmax[k]);
		for(k=0;k<dim_sb;k++)
			sfm_b[k]=conversion_float_to_data_t(bias_softmax[k]);

		//for (i=0; i<28*4;i++)
	//		printf ("w[%d]: 0x%x\n", i, c0_wb_hwce[i]);

		// Layer setup
	ConvLayer_new(
			conv_layer0,
			c0_wb_hwce,
			if_round,
			c0_out_ft,
			c0_filter_height,
			c0_filter_width,
			in_height,
			in_width,
			p0_height,
			p0_width,
			1,
			1);

	PoolLayer_new(
			pool_layer0,
			c0_out_ft,
			p0_pool_height,
			p0_pool_width,
			p0_height,
			p0_width,
			p0_out_height,
			p0_out_width,
			p0_stride);

	ConvLayer_new(
			conv_layer1,
			c1_wb_hwce,
			c0_out_ft,
			c1_out_ft,
			c1_filter_height,
			c1_filter_width,
			p0_out_height,
			p0_out_width,
			p1_height,
			p1_width,
			1,
			1);

	PoolLayer_new(
			pool_layer1,
			c1_out_ft,
			p1_pool_height,
			p1_pool_width,
			p1_height,
			p1_width,
			p1_out_height,
			p1_out_width,
			p1_stride);

	FullLayer_new(
			fc_layer,
			c1_out_ft,
			fc_out_ft,
			p1_out_height,
			p1_out_width,
			1,
			fc_w,
			fc_b);

	SoftmaxLayer_new(
			sfm_layer,
			fc_out_ft,
			nr_classes,
			1,
			1,
			sfm_w,
			sfm_b);



	int tries;
	int score=0;
	int number_tries=1;  ///number_tries is the number of images we are going to test. score is the number of scores

	float percentage;                               ///percentage represents the test accuracy


    int ii;
    //for (ii=0;ii<200;ii++)
    //  printf ("w[%d]: 0x%x\n", ii, c0_wb_hwce[ii]);

	fetch_enable ();
    wait_for_conv();


	///Loop of test images
	for(tries=0;tries<number_tries;tries++){
		XTime_GetTime(&tStart);
		//int pos=rand() % 4999; //No more than 4999
		int pos=tries;
		int j=0,i;
		int label = labels[pos];

		///Sampling of the i-th image
		for(i=pos*in_height*in_width;i<pos*in_height*in_width+in_height*in_width;i++){
		   // float temp = mnist_first_image[i];
			float temp = features[i];
			#ifdef FIXED_CONVNET
				if(temp!=0){
					x[j]=conversion_float_to_data_t(temp);
				}
				else{
					x[j]=0;
				}
				//if (j<100)
				//  printf ("x[%d]: %f; 0x%x\n", j, temp, x[j]);
			#else
				x[j]=temp;
			#endif // FIXED_CONVNET
			j++;
		}

		short int z[in_height*in_width];
		zeros(z,in_height*in_width);



		#ifdef BINARY_FILE
			read_file(x,"image.bin");
			label=4;
			number_tries=1;
		#else
		#endif

		//Image print on console
		for(i=0;i<28;i++) {
			for(j=0;j<28;j++){
				if(x[i*28+j]==0)
					printf("█");
				else
					printf("░");
			}
			printf("\n");
		}

		//for (i=0; i<28*28;i++)
	    //	printf ("x[%d]: 0x%x\n", i, x[i]);


		///FIRST HIDDEN LAYER
		///Execution of the first Convolutional Layer
		//XTime_GetTime(&tStart);

		//interlace4 ((int*)x, (int*)z,(int*)z,(int*)z,(int*)x0_hwce, in_height*in_width*2);
		int s = 0;
		int n_mag=0;
		round4_features (x0_zerofill, x, 1);
		interlace ((int*)x0_hwce, (int*)x0_zerofill, 4, 28*28*2);
		// FOR DEBUG PURPUSES ONLY
		/*deinterlace ((int*)deintrlaced_array, (int*)x0_hwce, 4, 28*28*2);
		for (i=0; i<28*28;i++)
					//if (i<250 && i>=200)
						printf ("x_in[%d]: 0x%x\n", i, deintrlaced_array[28*28*0+i]);
*/

		ConvLayer_exec(conv_layer0,x0_hwce,y0_hwce);
		//XTime_GetTime(&tEnd);

		// FOR DEBUG PURPUSES ONLY
	/*	deinterlace ((int*)deintrlaced_array, (int*)y0_hwce, 8, 24*24*2);
		s=0;
		n_mag=0;
		for (i=0; i<24*24*8;i++){
			printf ("y0_hwce[%d %d %d]: 0x%x\n", i/(24*24), i%(24*24), i, deintrlaced_array[24*24*0+i]);
			s+=deintrlaced_array[8*8*0+i];
			if (deintrlaced_array[8*8*0+i]>0) n_mag++;
		}
		printf("s: %x n_mag: %d \n", s, n_mag);*/
		///Execution of the first Max Pooling Layer
		//XTime_GetTime(&tStart);
		PoolLayer_exec(pool_layer0,y0_hwce,x1_hwce);
		//XTime_GetTime(&tEnd);

	/*	// FOR DEBUG PURPUSES ONLY
		deinterlace ((int*)deintrlaced_array, (int*)c1_wb_hwce, 8*16, 28*2);
		for (i=0; i<28*8*16;i++)
			//if (i<250 && i>=200)
			printf ("wb1[%d]: 0x%x\n", i, deintrlaced_array[12*12*0+i]);


		// FOR DEBUG PURPUSES ONLY
		deinterlace ((int*)deintrlaced_array, (int*)x1_hwce, 8, 12*12*2);
		for (i=0; i<12*12;i++)
			//if (i<250 && i>=200)
			printf ("x1_hwce[%d %d %d]: 0x%x\n", i/(12*12), i%(12*12), i, deintrlaced_array[8*8*0+i]);
*/
		s=0;
		n_mag=0;
		deinterlace ((int*)deintrlaced_array, (int*)x1_hwce, 8, 12*12*2);
	/*	for (i=0; i<12*12*8;i++){
			printf ("x1_hwce[%d %d %d]: 0x%x\n", i/(12*12), i%(12*12), i, deintrlaced_array[i]);
			s+=deintrlaced_array[i];
			if (deintrlaced_array[i]>0) n_mag++;
		}
		printf("s: %x n_mag: %d \n", s, n_mag);
*/

		///SECOND HIDDEN LAYER
		///Execution of the second Convolutional Layer
		//XTime_GetTime(&tStart);
		ConvLayer_exec(conv_layer1,x1_hwce,y1_hwce);
		//XTime_GetTime(&tEnd);

	//	read_tcdm ((volatile int *)TCDM_BASE_ADDRESS, 40);

/*
		// FOR DEBUG PURPUSES ONLY
		deinterlace ((int*)deintrlaced_array, (int*)y1_hwce, 16, 8*8*2);

		for (i=0; i<8*8*16;i++){
			//if (i<250 && i>=200)
			printf ("y1_hwce[%d %d %d]: 0x%x\n", i/64, i%64, i, deintrlaced_array[8*8*0+i]);
			s+=deintrlaced_array[8*8*0+i];
			if (deintrlaced_array[8*8*0+i]>0) n_mag++;
		}
		printf("s: %x n_mag: %d \n", s, n_mag);
*/
		///Execution of the second Max Pooling Layer
		//XTime_GetTime(&tStart);
		PoolLayer_exec(pool_layer1,y1_hwce,y1_pool1);
		//XTime_GetTime(&tEnd);

		deinterlace ((int*)y1_pool1_deintr, (int*)y1_pool1, 16, p1_out_height*p1_out_width*2);

		for (i=0; i<4*4*16;i++)
		    printf ("y1_pool[%d %d %d]: 0x%x\n", i/(4*4), i%(4*4), i, y1_pool1_deintr[i]);

		///Execution of the Full Connected Layer
		//XTime_GetTime(&tStart);
		FullLayer_exec(fc_layer,y1_pool1_deintr,y_full);
		//XTime_GetTime(&tEnd);



		///Execution of the Softmax Layer
		//XTime_GetTime(&tStart);
		SoftmaxLayer_exec(sfm_layer,y_full,y);
		//XTime_GetTime(&tEnd);

		//for (ii=0;ii<10;ii++)
		//			      printf ("y[%d]: 0x%x\n", ii, y[ii]);

		XTime_GetTime(&tEnd);

		///Calculation of the most correlated class
		data_t max_d=*(y+0);
		int posit=0;
		for(i=1;i<nr_classes;i++){
			if(max_d<*(y+i)){
				max_d=*(y+i);
				posit=i;
			}
		}

		for(i=0;i<nr_classes;i++){
			#ifdef FIXED_CONVNET
				printf("Cl[%d]  █",i);
				int j;
				for (j=0;j<(int)(conversion_data_t_to_float(*(y+i),16)*20);j++)
					printf ("█");

				printf(" %f\n",conversion_data_t_to_float(*(y+i),16));
			#else
				//printf("%f\n",*(y+i));
			#endif // FIXED_CONVNET
		}

		printf("Posit: %d Label: %d\n",posit, label);
		///If the most correlated class is the correct one then we score one point
		if(posit==label)
			score++;
	}

	///Calculation and print of test accuracy
	percentage = (float)score/number_tries;

	printf("percentage = %f\n",percentage*100);
	printf("Output took %llu clock cycles.\n", 2*(tEnd - tStart));


    printf("\n\n***************  End of test  ***************\n\n");


    cleanup_platform();

    return 0;
}
void zeros (short int * array, int len){
	int i;
	for (i=0; i< len; i++) {
		array[i]=0;
    }
}
/* OLD

void interlace4 (int * s0, int * s1, int * s2, int * s3, int * dest, int len_src_B){ // len is the number of bytes of a source
  int * src [4];

  src [0] = s0;
  src [1] = s1;
  src [2] = s2;
  src [3] = s3;
  int i, j;
  for (i=0; i< len_src_B /4; i++) {
    for (j=0; j<4; j++) {
      dest [i*4+j]= src[j][i];
    }
  }
}

void deinterlace4 (int * d0, int * d1, int * d2, int * d3, int * src, int len_dest_B){ // len is the number of bytes of a dest
  int * dest [4];

  dest [0] = d0;
  dest [1] = d1;
  dest [2] = d2;
  dest [3] = d3;
  int i, j;
  for (i=0; i< len_dest_B /4; i++) {
    for (j=0; j<4; j++) {
      dest[j][i]=src [i*4+j];
    }
  }
}
void deinterlace (int * dest, int * src, int n, int len_dest_B){ // len is the number of bytes of a dest

    int gr = n/4;
    if (n%4>0) gr++;


    int i, j, g;
    for (g=0; g<gr;g++){
	  for (i=0; i< len_dest_B /4; i++) {
		for (j=0; j<4; j++) {
		  dest[g*4*len_dest_B/4 + j*len_dest_B /4 + i]=src [g*4*len_dest_B/4 + i*4+j];
		}
	  }
  }
}

void interlace (int * dest, int * src, int n, int len_dest_B){ // len is the number of bytes of a dest

    int gr = n/4;
    if (n%4>0) gr++;


    int i, j, g;
    for (g=0; g<gr;g++){
      for (j=0; j<4; j++) {
	    for (i=0; i< len_dest_B /4; i++) {
		  dest[g*4*len_dest_B/4 + j + i*4]=src [g*4*len_dest_B/4 + i+j*len_dest_B /4];
		}
	  }
  }
}*/
