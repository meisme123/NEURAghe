/*
 * main file of nuraghe_test.
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */

#include "cnn.h"
#include <stdio.h>
#include "platform.h"
#include "soc_drivers.h"
#include <string.h>
#include "xtime_l.h"

///If FIXED_CONVNET is defined then the Convolutional neural network will work on fixed-point types.
//Otherwise it will work on floating-point types
#define FIXED_CONVNET
//#define BINARY_FILE


void print_stream (int len, data_t * x){
	int i;
	for(i=0;i<len;i++) {
			printf("0x%04x\n", x[i]);

	}

}


void print(char *str);



int main()
{
    init_platform();

    printf("\n\n***************  Start Test  ***************\n\n");

    //load_code();

    XTime tStart, tEnd;


	///An interface of all changeable parameters follows
	int in_height        = 28; //input parameters
	int in_width         = 28;
	int in_ft            = 1;

	int c0_out_ft        = 8;
	int c0_filter_height = 5;
	int c0_filter_width  = 5;

	int p0_height;
	int p0_width;
	int p0_pool_height   = 2;
	int p0_pool_width    = 2;
	int p0_out_height;
	int p0_out_width;
	int p0_stride        = 2;

	int c1_out_ft        = 16;
	int c1_filter_height = 5;
	int c1_filter_width  = 5;

	int p1_height;
	int p1_width;
	int p1_pool_height   = 2;
	int p1_pool_width    = 2;
	int p1_out_height;
	int p1_out_width;
	int p1_stride        = 2;

	int fc_out_ft        = 128;
	int fc_out_height    = 1;
	int fc_out_width     = 1;

	int nr_classes       = 10;

	///Calculation of sizes of all features for each internal hidden layer
	p0_height     = in_height-c0_filter_height+1; ///because stride=1 and there is not zero-padding (N-K)/S + 1 where S represents the stride
	p0_width      = in_width-c0_filter_width+1;
	p0_out_height = out_feat_size(p0_height,p0_pool_height,p0_stride);
	p0_out_width  = out_feat_size(p0_width,p0_pool_width,p0_stride);

	p1_height     = p0_out_height-c1_filter_height+1;
	p1_width      = p0_out_width-c1_filter_width+1;
	p1_out_height = out_feat_size(p1_height,p1_pool_height,p1_stride);
	p1_out_width  = out_feat_size(p1_width,p1_pool_width,p1_stride);

	int dim_c0    = in_ft*c0_out_ft*c0_filter_height*c0_filter_width;
	int dim_b0    = c0_out_ft;

	int dim_c1    = c0_out_ft*c1_out_ft*c1_filter_height*c1_filter_width;
	int dim_b1    = c1_out_ft;

	int dim_fw    = c1_out_ft*fc_out_ft*p1_out_height*p1_out_width;
	int dim_fb    = fc_out_ft;

	int dim_sw    = fc_out_ft*fc_out_height*fc_out_width*nr_classes;
	int dim_sb    = nr_classes;

	///Memory allocation of all arrays that we need such as the main input x and the main output y.
	data_t x[in_ft*in_height*in_width];


	// *************************** LAYER STRUCT ALLOCATING ***************************


	ConvLayer    *conv_layer0 = (ConvLayer *)   malloc(sizeof(ConvLayer));
	PoolLayer    *pool_layer0 = (PoolLayer *)   malloc(sizeof(PoolLayer));
	ConvLayer    *conv_layer1 = (ConvLayer *)   malloc(sizeof(ConvLayer));
	PoolLayer    *pool_layer1 = (PoolLayer *)   malloc(sizeof(PoolLayer));
	FullLayer    *fc_layer    = (FullLayer *)   malloc(sizeof(FullLayer));
	SoftmaxLayer *sfm_layer   = (SoftmaxLayer *)malloc(sizeof(SoftmaxLayer));


	// *************************** DATA ARRAY *******************************
	//conv0
	data_t * c0_w     = (data_t *)malloc(in_ft*c0_out_ft*c0_filter_height*c0_filter_width*sizeof(data_t));
	data_t * c0_b     = (data_t *)malloc(c0_out_ft*sizeof(data_t));
	data_t * y0       = (data_t *)malloc(c0_out_ft*p0_height*p0_width*sizeof(data_t));

    //poll0
	data_t * y0_pool0 = (data_t *)malloc(c0_out_ft*p0_out_height*p0_out_width*sizeof(data_t));

    //conv1
	data_t * c1_w     = (data_t *)malloc(c0_out_ft*c1_out_ft*c1_filter_height*c1_filter_width*sizeof(data_t));
	data_t * c1_b     = (data_t *)malloc(c1_out_ft*sizeof(data_t));
	data_t * y1       = (data_t *)malloc(c1_out_ft*p1_height*p1_width*sizeof(data_t));

    //pool1
	data_t * y1_pool1 = (data_t *)malloc(c1_out_ft*p1_out_height*p1_out_width*sizeof(data_t));


    //fullconnected
	data_t *fc_w      = (data_t *)malloc(c1_out_ft*fc_out_ft*p1_out_height*p1_out_width*sizeof(data_t));
	data_t *fc_b      = (data_t *)malloc(fc_out_ft*sizeof(data_t));
	data_t *y_full    = (data_t *)malloc(fc_out_ft*fc_out_height*fc_out_width*sizeof(data_t));

    //softmax
	data_t *sfm_w     = (data_t *)malloc(fc_out_ft*fc_out_height*fc_out_width*nr_classes*sizeof(data_t));
	data_t *sfm_b     = (data_t *)malloc(nr_classes*sizeof(data_t));
	data_t *y         = (data_t *)malloc(nr_classes*sizeof(data_t));



	// *************************** Sampling of weights and biases ***************************
	int k;
	#ifdef FIXED_CONVNET
		for(k=0;k<dim_c0;k++){
			c0_w[k]=conversion_float_to_data_t(weights_layer0[k]);
			//printf ("float: %f, int: %x\n", weights_layer0[k], c0_w[k]);
		}
		for(k=0;k<dim_b0;k++)
			c0_b[k]=conversion_float_to_data_t(bias_layer0[k]);
		for(k=0;k<dim_c1;k++){
			c1_w[k]=conversion_float_to_data_t(weights_layer1[k]);
			//if (k<20) printf ("float: %f, int: %x\n", weights_layer1[k], c1_w[k]);
		}
		for(k=0;k<dim_b1;k++)
			c1_b[k]=conversion_float_to_data_t(bias_layer1[k]);
		for(k=0;k<dim_fw;k++)
			fc_w[k]=conversion_float_to_data_t(weights_full[k]);
		for(k=0;k<dim_fb;k++)
			fc_b[k]=conversion_float_to_data_t(bias_full[k]);
		for(k=0;k<dim_sw;k++)
			sfm_w[k]=conversion_float_to_data_t(weights_softmax[k]);
		for(k=0;k<dim_sb;k++)
			sfm_b[k]=conversion_float_to_data_t(bias_softmax[k]);
	#else
		for(k=0;k<dim_c0;k++)
			c0_w[k]=conversion_float_to_data_t(weights_layer0[k]);
		for(k=0;k<dim_b0;k++)
			c0_b[k]=conversion_float_to_data_t(bias_layer0[k]);
		for(k=0;k<dim_c1;k++)
			c1_w[k]=conversion_float_to_data_t(weights_layer1[k]);
		for(k=0;k<dim_b1;k++)
			c1_b[k]=conversion_float_to_data_t(bias_layer1[k]);
		for(k=0;k<dim_fw;k++)
			fc_w[k]=conversion_float_to_data_t(weights_full[k]);
		for(k=0;k<dim_fb;k++)
			fc_b[k]=conversion_float_to_data_t(bias_full[k]);
		for(k=0;k<dim_sw;k++)
			sfm_w[k]=conversion_float_to_data_t(weights_softmax[k]);
		for(k=0;k<dim_sb;k++)
			sfm_b[k]=conversion_float_to_data_t(bias_softmax[k]);
	#endif // FIXED_CONVNET


		// Layer setup
	ConvLayer_new(
			conv_layer0,
			c0_w,
			c0_b,
			in_ft,
			c0_out_ft,
			c0_filter_height,
			c0_filter_width,
			in_height,
			in_width,
			p0_height,
			p0_width,
			1,
			1);

	PoolLayer_new(
			pool_layer0,
			c0_out_ft,
			p0_pool_height,
			p0_pool_width,
			p0_height,
			p0_width,
			p0_out_height,
			p0_out_width,
			p0_stride);

	ConvLayer_new(
			conv_layer1,
			c1_w,
			c1_b,
			c0_out_ft,
			c1_out_ft,
			c1_filter_height,
			c1_filter_width,
			p0_out_height,
			p0_out_width,
			p1_height,
			p1_width,
			1,
			1);

	PoolLayer_new(
			pool_layer1,
			c1_out_ft,
			p1_pool_height,
			p1_pool_width,
			p1_height,
			p1_width,
			p1_out_height,
			p1_out_width,
			p1_stride);

	FullLayer_new(
			fc_layer,
			c1_out_ft,
			fc_out_ft,
			p1_out_height,
			p1_out_width,
			1,
			fc_w,
			fc_b);

	SoftmaxLayer_new(
			sfm_layer,
			fc_out_ft,
			nr_classes,
			1,
			1,
			sfm_w,
			sfm_b);



	int tries;
	int score=0;
	int number_tries=5;  ///number_tries is the number of images we are going to test. score is the number of scores

	float percentage;                               ///percentage represents the test accuracy


	fetch_enable ();

	///Loop of test
	for(tries=0;tries<number_tries;tries++){
		XTime_GetTime(&tStart);
		//int pos=rand() % 4999; //No more than 4999
		int pos=tries;
		int j=0,i;
		int label = labels[pos];

		///Sampling of the i-th image
		for(i=pos*in_height*in_width;i<pos*in_height*in_width+in_height*in_width;i++){
		   // float temp = mnist_first_image[i];
			float temp = features[i];
			#ifdef FIXED_CONVNET
				if(temp!=0){
					x[j]=conversion_float_to_data_t(temp);
				}
				else{
					x[j]=0;
				}
			#else
				x[j]=temp;
			#endif // FIXED_CONVNET
			j++;
		}

		short int z[in_height*in_width];
		zeros(z,in_height*in_width);

		short int *dest = (short int *) (0x10000000+ 0x10);
		interlace ((int*)x, (int*)z,(int*)z,(int*)z,(int*)dest, in_height*in_width*2);


		#ifdef BINARY_FILE
			read_file(x,"image.bin");
			label=4;
			number_tries=1;
		#else
		#endif
/*
		//Image print on console
		for(i=0;i<28;i++) {
			for(j=0;j<28;j++){
				if(x[i*28+j]==0)
					printf("█");
				else
					printf("░");
			}
			printf("\n");
		}

*/
		///FIRST HIDDEN LAYER
		///Execution of the first Convolutional Layer
		//XTime_GetTime(&tStart);
		ConvLayer_exec(conv_layer0,x,y0);
		//XTime_GetTime(&tEnd);

		///Execution of the first Max Pooling Layer
		//XTime_GetTime(&tStart);
		PoolLayer_exec(pool_layer0,y0,y0_pool0);
		//XTime_GetTime(&tEnd);


		///SECOND HIDDEN LAYER
		///Execution of the second Convolutional Layer
		//XTime_GetTime(&tStart);
		ConvLayer_exec(conv_layer1,y0_pool0,y1);
		//XTime_GetTime(&tEnd);

		///Execution of the second Max Pooling Layer
		//XTime_GetTime(&tStart);
		PoolLayer_exec(pool_layer1,y1,y1_pool1);
		//XTime_GetTime(&tEnd);

		///Execution of the Full Connected Layer
		//XTime_GetTime(&tStart);
		FullLayer_exec(fc_layer,y1_pool1,y_full);
		//XTime_GetTime(&tEnd);

		///Execution of the Softmax Layer
		//XTime_GetTime(&tStart);
		SoftmaxLayer_exec(sfm_layer,y_full,y);
		//XTime_GetTime(&tEnd);



		XTime_GetTime(&tEnd);

		///Calculation of the most correlated class
		data_t max_d=*(y+0);
		int posit=0;
		for(i=1;i<nr_classes;i++){
			if(max_d<*(y+i)){
				max_d=*(y+i);
				posit=i;
			}
		}

		for(i=0;i<nr_classes;i++){
			#ifdef FIXED_CONVNET
				printf("Cl[%d]  █",i);
				int j;
				for (j=0;j<(int)(conversion_data_t_to_float(*(y+i),16)*10);j++)
					printf ("█");

				printf(" %f\n",conversion_data_t_to_float(*(y+i),16));
			#else
				//printf("%f\n",*(y+i));
			#endif // FIXED_CONVNET
		}

		printf("Posit: %d Label: %d\n",posit, label);
		///If the most correlated class is the correct one then we score one point
		if(posit==label)
			score++;
	}

	///Calculation and print of test accuracy
	percentage = (float)score/number_tries;

	printf("percentage = %f\n",percentage*100);
	printf("Output took %llu clock cycles.\n", 2*(tEnd - tStart));


    printf("\n\n***************  End of test  ***************\n\n");



    cleanup_platform();

    return 0;
}
void zeros (short int * array, int len){
	int i;
	for (i=0; i< len; i++) {
		array[i]=0;
    }
}

void interlace (int * s0, int * s1, int * s2, int * s3, int * dest, int len_src_B){ // len is the number of bytes of a source
  int * src [4];

  src [0] = s0;
  src [1] = s1;
  src [2] = s2;
  src [3] = s3;
  int i, j;
  for (i=0; i< len_src_B /4; i++) {
    for (j=0; j<4; j++) {
      dest [i*4+j]= src[j][i];
    }
  }
}

void deinterlace (int * d0, int * d1, int * d2, int * d3, int * src, int len_dest_B){ // len is the number of bytes of a dest
  int * dest [4];

  dest [0] = d0;
  dest [1] = d1;
  dest [2] = d2;
  dest [3] = d3;
  int i, j;
  for (i=0; i< len_dest_B /4; i++) {
    for (j=0; j<4; j++) {
      dest[j][i]=src [i*4+j];
    }
  }
}
