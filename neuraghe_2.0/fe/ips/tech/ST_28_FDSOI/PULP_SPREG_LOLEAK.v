//  
//  
//  ------------------------------------------------------------
//    STMicroelectronics N.V. 2013
//   All rights reserved. Reproduction in whole or part is prohibited  without the written consent of the copyright holder.                                                                                                                                                                                                                                                                                                                           
//    STMicroelectronics RESERVES THE RIGHTS TO MAKE CHANGES WITHOUT  NOTICE AT ANY TIME.
//  STMicroelectronics MAKES NO WARRANTY,  EXPRESSED, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO ANY IMPLIED  WARRANTY OR MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE,  OR THAT THE USE WILL NOT INFRINGE ANY THIRD PARTY PATENT,  COPYRIGHT OR TRADEMARK.
//  STMicroelectronics SHALL NOT BE LIABLE  FOR ANY LOSS OR DAMAGE ARISING FROM THE USE OF ITS LIBRARIES OR  SOFTWARE.
//    STMicroelectronics
//   850, Rue Jean Monnet
//   BP 16 - 38921 Crolles Cedex - France
//   Central R&D / DAIS.
//                                                                                                                                                                                                                                                                                                                                                                             
//    
//  
//  ------------------------------------------------------------
//  
//  
//    User           : antonio pullini-ext     
//    Project        : ULPSOC                  
//    Division       : Not known               
//    Creation date  : 12 November 2013        
//    Generator mode : MemConfMAT10/distributed
//    
//    WebGen configuration               : C28SOI_MEM_SRAM_SPREG_LOLEAK:754,3:MemConfMAT10/distributed:1.0-03
//  
//    HDL C32_ST_SP_ROM Compiler version : 1.2@20130423.0 at Apr-23-2013 (PTBL date)                          
//    
//  
//  For more information about the cuts or the generation environment, please
//  refer to files uk.env and ugnGuiSetupDB in directory DESIGN_DATA.
//   
//  
//  



/****************************************************************
--  Description         : Verilog Model 
--  ModelVersion        : 1.2
--  Date                : Apr, 2013
--  Changes Made by	: PS
--  Revision History    : 
 
****************************************************************/


/******************** START OF HEADER****************************
   This Header Gives Information about the parameters & options present in the Model
   
   words = 32
   bits  = 24
   mux   = 4 
   
   
   
   write_mask = no 
   
   margin_control = yes 
   
   
   Dft = Yes  

    ------------------------------------------------------------------------------------
     Signal Name             | Description       |             Port Mode        | Active When
                             |                   |          r    |  w   | rw    |
   ------------------------------------------------------------------------------------

    D 	        Data in                     na     x      na       -  
    IG    Input Gate Enable           x      x      na       High     
    ATP            ATPG Enable                 x      x      na       High     
    INITN                 INITN pin                   x      x      na       Low
    
    
     
    Q 	        Data out	            x      na     na       -
    A              Address                     x      x      na       high and low
    
    CK                Clock	                    x      x      na       posedge
    CSN          Chip Enable                 x      x      na       low
    
    RM         Read Margins                 x      x      na       High 
    SCTRLI         Scan Input (Control)
    SCTRLO        Scan Output (Control)
    SDLI         Scan Input (Data-Left)
    SDLO        Scan Output (Data-Left)
    SDRI         Scan Input (Data-Right)
    SDRO        Scan Output (Data-Right)
    SE          Scan Enable pin 
    STDBY              Standby pin                 x      x      na       High
    
    SLEEP                        Sleep pin                   x      x      na        High 
    
     
     
    TBIST          Bist Enable Pin 
    
    TBYPASS                      Memory Bypass                na     na     na        High
    
    TED        Bist Even Data pin
    TOD         Bist Odd Data Pin
     
    TA         Bist Read Address
    TCSN     Bist Read Chip Select
    
    TWEN    Bist Write Enable 
    WEN         Write Enable                na     x      na       Low 
    
    WM        Write Margins Code          x      x      na       -
     

******************** END OF HEADER ****************************/


//********************************************//
// ST_SPREG_LOLEAK_32x24m4_Tl Verilog Model                 //  
//********************************************//




`ifdef slm
        `define functional
`endif

`celldefine
`suppress_faults
  `ifdef functional
   `delay_mode_unit
  `else
   `delay_mode_path
  `endif

`define setup_time 0.0
`define hold_time 0.0
`define access_time 1.0
`define retain_time 0.9
`define cycle_time 0.0
`define pulse_width_time 0.0
`define initin_low_pulse 0.0



 






`timescale 1ns / 1ps


module ST_SPREG_LOLEAK_32x24m4_Tl (A,ATP,CK,CSN,D ,IG,INITN , Q ,RM    ,SCTRLI,SCTRLO,SDLI,SDLO,SDRI,SDRO,SE,SLEEP   , STDBY  ,TA,TBIST   ,TBYPASS ,TCSN,TED ,TOD   ,TWEN ,WEN,WM  );

 parameter
  Words = 32,
  Bits = 24,
  Addr = 5,
  mux = 4,
  repair_address_width = 3,
  write_margin_size = 2, 
  read_margin_size = 3; 

 //  INPUT OUTPUT PORTS DECLARATION DONE SEPARATELY FOR SPREG and ROM
 // ========================


        output [Bits-1 : 0] Q;
         
        output SCTRLO;
        input SE,SCTRLI;
        
        input [Addr-1 : 0] A;
        
        input [read_margin_size-1 : 0] RM;
        
         
        input CK,CSN,INITN,IG,ATP; 
        
        
        input [Addr-1 :0 ] TA;
input TBIST,TCSN ;
        
        input STDBY;
        
        input SLEEP; 
        
         
        
        
         
        output SDLO;
        output SDRO;
        
        
        
        
        input [Bits-1 : 0] D ;
	
          
         
        
        input [write_margin_size-1 : 0] WM;
        
        
        input TBYPASS;
        
        input WEN;
        
        
         
        input SDLI,SDRI  ; 
        
        
        
        //Bist inputs
        // ===========
        input TWEN,TED,TOD; 
        
        
        
        

        






    parameter
        Fault_file_name = "ST_SPREG_LOLEAK_32x24m4_Tl_faults.txt",
        `ifdef ConfigFault
        ConfigFault = 1,
        `else
        ConfigFault = 0,
        `endif
        max_faults = 34,
        
        MEM_INITIALIZE  = 1'b0,
        BinaryInit = 1'b0, 
        InitFileName = "ST_SPREG_LOLEAK_32x24m4_Tl.cde",
        Debug_mode = "all_warning_mode",
        File_load_time=0,
        Initn_reset_value={24{1'b0}},
        InstancePath = "ST_SPREG_LOLEAK_32x24m4_Tl";
    
    parameter
        
        bank = 1, 
        mux_bits=2,
        Red_extrabit=0,
        bank_bits = 0,
        RedWords = mux * 2 * bank,
        max_address_bits = 15 ,
        Rows = Words/mux;

  
    parameter 

     

        
           scanchains=3,    
          
        
        scanlen_ctrl=15,
        
        

      

        
        scanlen_r=(Bits)/2,
        
        scanlen_l=(Bits+1)/2 ; 
      
      

    parameter
        
        `ifdef functional  
            RW_assertions_en = 0,
        `endif
        WordX = {Bits{1'bx}},
        AddrX = {Addr{1'bx}},
        Word0 = {Bits{1'b0}},
        X = 1'bx;
   



//  WIRE DECLARATION RELATED TO POWER PINS
//  ======================================
	
        wire supply_ok, full_shutdown;
        
        wire core_supply_ok;
        wire peri_supply_ok;

        wire gndmint, gndsmint;
         
        
        wire vddmpint;
        wire vddmoint;
        wire vddmaint;
        wire vddsmpint;  
        wire vddsmaint;  
        
        

//  WIRE DECLARATION 
//  ==================
        wire [Bits-1 : 0] CSWEMTBYPASS;
        wire [Bits-1 : 0] Dint, Dsys;
        wire [Bits-1 : 0] Mint; 
        wire [24-1:0] Msys;
	wire [Addr-1 : 0] Aint;
        wire [Addr-1 : 0] Asys;

       


        wire [max_address_bits-1 : 0] A_int; 
                
	wire CKint_dft;
	wire CKint_func;
	wire CSNint;
        wire MEMEN;
        wire MEMEN_dft;
        wire TSE;

	wire WENint;
	wire WENsys;
        wire SLEEPint;
        wire STDBYint;
        wire SEint;
        wire SEsys;
        wire SCTRLIint;
        wire SDLIint;
        wire SDRIint;
        
        wire INITNint;
        wire TBYPASSint;
        wire TBYPASSsys;
        wire LSint; 
        wire HSint; 
        wire ATPint;
        wire DEint;
        
        wire [Addr-1 : 0] TAint;
        wire TBISTint;
        wire TBISTsys;
        wire TCSNint;
        wire TEDint;
        wire TODint;
        wire TEMint;
        wire TOMint;
        wire [Bits-1 : 0] TMint;
        wire [Bits-1 : 0] TDint;
        wire TWENint;
        wire IGint;
        wire IGbuf;
        wire CSNbuf;
        wire WENbuf;
        wire [read_margin_size-1:0] RMint;
        wire [write_margin_size-1:0] WMint;

        //Wires for scan chains
        //  ====================     
        wire [scanlen_ctrl -1:0]scanreg_ctrl_wire;
        wire [scanlen_l -1:0]  scanreg_dl_wire; 
        wire [scanlen_r -1:0]  scanreg_dr_wire; 
   
        wire [scanlen_l -1:0]  scanreg_ml_wire; 
        wire [scanlen_r -1:0]  scanreg_mr_wire; 


        wire [repair_address_width -1 : 0] RRAint;
        wire RRAEint;
        wire TRRAEint;    
        wire red_en;
        wire [repair_address_width -1 : 0] repair_add, next_repair_add;


//  REG DECLARATION
//  ====================     
        reg MEMEN_reg;
        reg MEMEN_prev;
        reg reg_mem_block;
        reg flag_mem_block;
        reg SCTRLIint_temp;
        reg SDLIint_temp;
        reg SDRIint_temp;
        reg SMLIint_temp;
        reg SMRIint_temp;

        //  REG DECLARATION
        //  ====================
        reg SCTRLOint;
        
        reg SDLOint,SDROint;
         
        
        reg next_cycle_corrupt_func;
        reg next_cycle_corrupt_dft;
        reg [Bits-1 : 0] delOutReg_data;//delayed Output Register
        reg [Bits-1 : 0] OutReg_data;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_tbypass;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_scan;   // Data Output registe
        reg [Bits-1 : 0] OutReg_rado_retained;   // register for retaining rado data when SLEEP --> 1
        reg delSCTRLO_data,SCTRLO_data;      // delayed Output Register
        reg delSDLO_data,SDLO_data;      // delayed Output Register
        reg delSDRO_data,SDRO_data;      // delayed Output Register
        
        
        // SCAN CHAINS register
        reg scanreg_ctrl; 
        reg scanreg_dl; 
        reg scanreg_dr; 
        
        
        reg CK_sc;
        reg Latch_open=0;
        reg lastCK_dft,CKreg_dft;
        reg lastCK_func,CKreg_func;
        reg lastSLEEP;
        reg lastPSWLARGEMP,lastPSWLARGEMA,lastPSWSMALLMP,lastPSWSMALLMA;
        reg CSNreg;
        reg init_pulse_done; //if == 1 then it implies that initb low pulse has been applied
        reg power_up_done; //if == 1 then it implies that power up has been done
        `ifdef slm
        `else
	      
             reg [Bits-1 : 0] Mem [Words-1 : 0];
             reg [Bits-1 : 0] RedMem [RedWords-1 : 0];
 
        `endif
        
	reg [Bits-1 :0] Mem_temp;
        reg [Bits-1 :0] Mem_slm; 
	reg ValidAddress;
	reg ValidDebugCode;
        reg decoding_start;
        reg file_loaded;
        reg [Bits-1 :0] Dreg;
        reg [Bits-1 :0] Mreg;
        reg WENreg;
        reg [Addr-1 :0] Areg;
        reg SE_reg;
        reg TBYPASS_reg;
        reg INITNreg;
        reg IGreg;
        reg DEreg;
        reg SLEEPreg;
        reg STDBYreg;
        reg ATPreg;
        reg MEMEN_dft_reg;
        reg MEMEN_dft_prev;
        reg RRMATCHreg;
        reg RRMATCHreg_last;//changes_made
        reg RRMATCHreg_glitch;
        reg [repair_address_width -1 : 0] repair_add_last;
        reg RRAEint_last;
        reg [Addr-mux_bits-1:0] row_add_temp;
        reg [Addr-mux_bits-bank_bits-1:0] row_add_cmp_temp;

       
        //parameter registers
        reg [2047:0] reg_Fault_file_name;
        reg reg_ConfigFault;
        reg reg_MEM_INITIALIZE;
        reg reg_BinaryInit;
        reg [2047:0] reg_InitFileName;
        reg [Bits -1 :0] reg_Initn_reset_value;
        time reg_File_load_time;

        //Power Supply Registers        
        reg vddmireg;
        reg vddmreg;
        reg vddsmreg;
        reg gndmreg;
        reg gndsmreg;   
        reg vddmpreg;
        reg vddmpireg;
        reg vddmareg;
        reg vddsmpreg;
        reg vddsmareg;
        reg vddmoreg;
        time vddmp_rise_time;
        time vddmp_fall_time;
        time vddsmp_rise_time;
        time vddsmp_fall_time;
        time vddma_rise_time;
        time vddma_fall_time;
        time vddsma_rise_time;
        time vddsma_fall_time;
        reg reg_check_rise;
        reg reg_check_fall;
        reg reg_check_rise_vddma;
        reg reg_check_fall_vddsma;
        reg  reg_check_rise_vddm, reg_check_fall_vddsm ;
        time vddm_fall_time,  vddm_rise_time,  vddsm_fall_time, vddsm_rise_time ;
  /* This register is used to force all warning messages 
  ** OFF during run time.
  ** It is a 2 bit register.
  ** USAGE :
  ** debug_level_off = 2'b00 -> ALL MESSAGES(INFO/WARNINGS/ERRORS) will be DISPLAYED 
  ** debug_level = 2'b01     -> ONLY WARNINGS/ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b10     -> ONLY ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b11     -> NO MESSAGES will be DISPLAYED.
  */ 
        reg [1:0] debug_level;
        reg [8*10: 0] operating_mode;
        reg [8*44: 0] message_status;

        integer i, k, j, l,m,q,w,r,s,num1,redcnt,n,num2,FirstHalf,Bfaileff,memcnt,ptr;
        integer decoder[Bits-1:0];
        `ifdef slm
           integer MemAddr;
        `endif


        //************************************************************
        //****** CONFIG FAULT IMPLEMENTATION VARIABLES*************** 
        //************************************************************ 

        integer file_ptr, ret_val;
        integer fault_word;
        integer fault_bit;
        integer fcnt, Fault_in_memory,faultnum,stop_loop,count;
        integer t;  
        integer FailureLocn [max_faults -1 :0];
        integer Failurebit [max_faults -1 :0];
        reg [100 : 0] stuck_at;
        reg [100 : 0] fault_array;
        reg [200 : 0] tempStr;
        reg [7:0] fault_char;
        reg [7:0] fault_char1; // 8 Bit File Pointer
        reg [Addr -1 : 0] std_fault_word;
        reg [Addr -1 : mux_bits] fault_row_add [max_faults -1 :0];
        reg [max_faults -1 :0] fault_repair_flag;
        reg [max_faults -1 :0] dont_insert_fault;
        reg [max_faults -1 :0] repair_flag;
        reg [100 : 0] array_stuck_at[max_faults -1 : 0] ;
        reg [100 : 0] mem_red_array_stuck_at[max_faults -1 : 0] ; 
        reg msgcnt;
        
       
        reg [Bits - 1: 0] stuck_at_0fault [max_faults -1 : 0];
        reg [Bits - 1: 0] stuck_at_1fault [max_faults -1 : 0];
        reg [Bits -1 : 0] stuck0;
        reg [Bits -1 : 0] stuck1;

        reg [Bits+Red_extrabit :0] Mem_last;
        

        `ifdef slm
        reg [Bits -1 : 0] slm_temp_data;
        `endif
        
        real time_CK_func_rise , time_RADCK_rise;
        real time_fall_sleep,time_fall_PSWLARGEMP,time_fall_PSWLARGEMP_0,time_fall_PSWLARGEMA,time_fall_PSWLARGEMA_0,time_fall_PSWSMALLMP,time_fall_PSWSMALLMA;
        integer flag_error;
        
//BUFFER INSTANTIATION
//=========================
       `ifdef functional
       
         buf (SCTRLO,delSCTRLO_data); 
         buf bufq [Bits-1:0] (Q,delOutReg_data);
      `else
       
         buf (SCTRLO,SCTRLO_data);
         buf bufq [Bits-1:0] (Q,OutReg_data);
      `endif
      
  
        buf (SEsys,SE);
	buf (SCTRLIint, SCTRLI);
   

	buf (CKint_func, CK);
	buf (CKint_dft, CK);
        buf bufaddr [Addr-1:0] (Asys,A);
        buf (INITNint,INITN);
        
        buf (LSint,1'b0); 
        buf (IGbuf,IG);
        buf (ATPint,ATP);

        buf bufTaddr [Addr-1 : 0] (TAint,TA);
        buf (TBISTsys,TBIST);
        buf (TCSNint,TCSN);

        buf (CSNsys,CSN);
        buf (STDBYint,STDBY );   
        
        buf (SLEEPint,SLEEP ); 

        buf bufrm [read_margin_size-1:0] (RMint, RM); 

        
        

        assign RRAEint = 1'b0;
        assign TRRAEint = 1'b0;
        assign repair_add = 0;
        assign next_repair_add = 0;
        assign red_en = 1'b0; 
        
        
        
        
        
        
        
        buf (PSWLARGEMPint,1'b0);
        buf (PSWSMALLMPint,1'b0); 
        buf (PSWLARGEMAint,1'b0);
        buf (PSWSMALLMAint,1'b0);   

      `ifdef functional
       
       
         buf (SDLO,delSDLO_data);
         buf (SDRO,delSDRO_data);
        
      `else
       
         buf (SDLO,SDLO_data);
         buf (SDRO,SDRO_data);
         
      `endif
       
         
       
        buf bufdata [Bits-1:0] (Dsys,D);
        
        
        assign Msys=24'b0; 
	

        
        buf (TBYPASSsys, TBYPASS);
        


        buf (WENsys,WEN);
	 
	buf (SDLIint, SDLI);
	buf (SDRIint, SDRI);
	 
        
        buf (HSint,1'b0); 

        
        buf (TEDint,TED);
        buf (TODint,TOD);
         
        buf (TWENint,TWEN);
        
        
        buf bufwm [write_margin_size-1:0] (WMint, WM); 
        



//      assign scanreg_ctrl_wire={scanreg_ctrl[scanlen_ctrl - 2:0],SCTRLIint};
//      assign scanreg_dl_wire={scanreg_dl[scanlen_l - 2:0],SDLIint};
//      assign scanreg_dr_wire={scanreg_dr[scanlen_r - 2:0],SDRIint};
      
        
      assign Aint   = (TBISTint === 1'b0 ) ? Asys : (TBISTint === 1'bx ) ? {Addr{1'bx}} : TAint;  

        
//        assign A_int = Aint;
	
        
                
        assign Dint[0] = (TBISTint === 1'b0) ? Dsys[0] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[1] = (TBISTint === 1'b0) ? Dsys[1] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[2] = (TBISTint === 1'b0) ? Dsys[2] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[3] = (TBISTint === 1'b0) ? Dsys[3] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[4] = (TBISTint === 1'b0) ? Dsys[4] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[5] = (TBISTint === 1'b0) ? Dsys[5] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[6] = (TBISTint === 1'b0) ? Dsys[6] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[7] = (TBISTint === 1'b0) ? Dsys[7] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[8] = (TBISTint === 1'b0) ? Dsys[8] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[9] = (TBISTint === 1'b0) ? Dsys[9] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[10] = (TBISTint === 1'b0) ? Dsys[10] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[11] = (TBISTint === 1'b0) ? Dsys[11] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[12] = (TBISTint === 1'b0) ? Dsys[12] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[13] = (TBISTint === 1'b0) ? Dsys[13] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[14] = (TBISTint === 1'b0) ? Dsys[14] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[15] = (TBISTint === 1'b0) ? Dsys[15] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[16] = (TBISTint === 1'b0) ? Dsys[16] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[17] = (TBISTint === 1'b0) ? Dsys[17] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[18] = (TBISTint === 1'b0) ? Dsys[18] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[19] = (TBISTint === 1'b0) ? Dsys[19] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[20] = (TBISTint === 1'b0) ? Dsys[20] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[21] = (TBISTint === 1'b0) ? Dsys[21] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[22] = (TBISTint === 1'b0) ? Dsys[22] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[23] = (TBISTint === 1'b0) ? Dsys[23] : (TBISTint === 1'b1) ? TODint : 1'bx;          
	 
        assign Mint = 24'b0;
         

        assign WENbuf = (TBISTint === 1'b0 ) ? WENsys : (TBISTint === 1'bx ) ? 1'bx : TWENint;  
        assign WENint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? WENbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[13] : (ATPint === 1'b0 ) ? WENsys : 1'bx ; 
        
        assign CSNbuf = (TBISTint === 1'b0 ) ? CSNsys : (TBISTint === 1'bx ) ? 1'bx : TCSNint;  
        assign CSNint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? CSNbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[11] : (ATPint === 1'b0 ) ? CSNsys : 1'bx ; 
        assign IGint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? IGbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[14] : (ATPint === 1'b0 ) ? IGbuf : 1'bx;

        
        assign DEint = (LSint === 1'bx || (LSint === 1'b0 && HSint === 1'bx) || ^RMint !== 1'b0 || ^WMint !== 1'b0 ) ? 1'bx : 1'b0;
        
     
     and (TBISTint, ATPint, TBISTsys);
     and (SEint, ATPint, SEsys);
     and (TBYPASSint, ATPint, TBYPASSsys);
     and (TSE,TBYPASSint,!SEsys);
     and (MEMEN,INITNint,!CSNint,!SLEEPint,!TBYPASSint,!SEint,!IGint,!DEint,!STDBYint );
     and (MEMEN_dft,INITNint, !SLEEPint, ATPint,!STDBYint);

 `ifdef functional
/*****************assertions added to optimize dynamic power consumption**********/

//psl a_M: assert always ({( RW_assertions_en);(MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1))  } |-> (stable(Msys))) @(posedge CK); 

//psl a_WEN: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(WENsys))) @(posedge CK); 

//psl a_A: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(Asys))) @(posedge CK); 

//psl a_D: assert always ({( RW_assertions_en);((MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1)) && TBYPASSint === 1'b0)  } |-> (stable(Dsys))) @(posedge CK); 

/**********************************************************************************************/
`endif       

     

         
reg vddmp,vddmo, vddma, vddsmp, vddsma, gndsm, gndm,  vddmpi ; 
 
initial 
begin

        vddmp = 1'b1 ; 
        vddmo = 1'b1 ;
        vddma = 1'b1 ;
        
        vddsmp = 1'b1 ;
        
        
         gndm = 1'b0 ;
          
end

        
         assign gndmint = (reg_mem_block === 0) ? gndm : 1'b1;
         
         
         
         
         assign vddmpint = vddmp;
         assign vddmoint = vddmo;
         assign vddmaint = vddma;
         
          
        
         

        //CPF Changes

        
                
        initial
        begin : cpfvddmp 
           vddmpreg = vddmpint;
        end

        always @(vddmpint) begin
           vddmpreg = vddmpint;
        end
        
        initial
        begin : cpfvddmo 
           vddmoreg = vddmoint;
        end

        always @(vddmoint) begin
           vddmoreg = vddmoint;
        end
        
        initial
        begin : cpfvddma 
           vddmareg = vddmaint;
        end

        always @(vddmaint) begin
           vddmareg = vddmaint;
        end

        
        
 
        initial
        begin : cpfgndm 
           gndmreg = gndmint;
        end

        always @(gndmint) begin
           gndmreg = gndmint;
        end

        
        



 `ifdef functional
  `else
  initial begin
    if (debug_level < 1) begin
     $display ("%m  INFORMATION");
     $display ("***************************************");
     $display ("The Model is Operating in TIMING MODE");
     $display ("Please make sure that SDF is properly annotated otherwise dummy values will be used");
     $display ("%s", message_status);
     $display ("***************************************");
    end
  end

//////////////////////////
 //REG DECLARATIONS
   //======================

   reg [Bits-1 : 0] TimingViol_data;
   reg  [Bits-1 : 0] TimingViol_mask;
   reg [Bits-1 : 0] TimingViol_data_last, TimingViol_mask_last;
	reg TimingViol_data_0;
	reg TimingViol_data_1;
	reg TimingViol_data_2;
	reg TimingViol_data_3;
	reg TimingViol_data_4;
	reg TimingViol_data_5;
	reg TimingViol_data_6;
	reg TimingViol_data_7;
	reg TimingViol_data_8;
	reg TimingViol_data_9;
	reg TimingViol_data_10;
	reg TimingViol_data_11;
	reg TimingViol_data_12;
	reg TimingViol_data_13;
	reg TimingViol_data_14;
	reg TimingViol_data_15;
	reg TimingViol_data_16;
	reg TimingViol_data_17;
	reg TimingViol_data_18;
	reg TimingViol_data_19;
	reg TimingViol_data_20;
	reg TimingViol_data_21;
	reg TimingViol_data_22;
	reg TimingViol_data_23;
 reg TimingViol_mask_0;
 reg TimingViol_mask_1;
 reg TimingViol_mask_2;
 reg TimingViol_mask_3;
 reg TimingViol_mask_4;
 reg TimingViol_mask_5;
 reg TimingViol_mask_6;
 reg TimingViol_mask_7;
 reg TimingViol_mask_8;
 reg TimingViol_mask_9;
 reg TimingViol_mask_10;
 reg TimingViol_mask_11;
 reg TimingViol_mask_12;
 reg TimingViol_mask_13;
 reg TimingViol_mask_14;
 reg TimingViol_mask_15;
 reg TimingViol_mask_16;
 reg TimingViol_mask_17;
 reg TimingViol_mask_18;
 reg TimingViol_mask_19;
 reg TimingViol_mask_20;
 reg TimingViol_mask_21;
 reg TimingViol_mask_22;
 reg TimingViol_mask_23;

   reg TimingViol_addr;
   reg TimingViol_CSN, TimingViol_WEN, TimingViol_tbypass;
   reg TimingViol_tckh, TimingViol_tckl, TimingViol_tcycle;
   reg TimingViol_tckh_se, TimingViol_tckl_se, TimingViol_tcycle_se;
   reg TimingViol_sctrli,TimingViol_sdli,TimingViol_sdri,TimingViol_se;
   reg TimingViol_smli,TimingViol_smri;
   reg TimingViol_sctrli_flag,TimingViol_sdli_flag,TimingViol_sdri_flag;
   reg TimingViol_smli_flag,TimingViol_smri_flag;
   reg TimingViol_initnl;
   reg TimingViol_initn;
   reg TimingViol_ls;
   reg TimingViol_hs;
   reg TimingViol_sleep;
   reg TimingViol_stdby;
   reg TimingViol_rm;
   reg TimingViol_wm;
   reg TimingViol_tbist,TimingViol_ig,TimingViol_atp,TimingViol_TED,TimingViol_TOD,TimingViol_TEM,TimingViol_TOM;
   reg TimingViolRRAE,TimingViolRRA;

   wire CSTBYPASSN,cond_sdf_tas,cond_sdf_tds,cond_sdf_tms,cond_sdf_tws,cond_sdf_tbas,cond_sdf_tbps,cond_sdf_tbws,cond_sdf_tbdes,cond_sdf_tbdos,cond_sdf_tbmes,cond_sdf_tbmos;
   wire SETB_EN,CSIG_EN,MEM_ACT,EN_ADM,CS_EN,CS_ADM,cond_sdf_tps,IG_EN,IG_ADM,cond_sdf_tigs,cond_sdf_taa,cond_sdf_taa_ls1,cond_sdf_taa_hs1,cond_tseq_tm;
   wire cond_sdf_tcycle,cond_sdf_tcycle_ls1,cond_sdf_tcycle_hs1,cond_sdf_tcycle_se,cond_sdf_tckl_se,cond_sdf_tsctrlis,cond_sdf_tsdlis,cond_sdf_tsdris,cond_sdf_tsmlis,cond_sdf_tsmris;
   wire cond_sdf_tckh_se,cond_sdf_taa_sctrlo_se,cond_sdf_taa_sdlo_se,cond_sdf_taa_sdro_se,cond_sdf_taa_smlo_se,cond_sdf_taa_smro_se,cond_sdf_tckl,cond_sdf_tckh;
   wire cond_sdf_ttms,cond_sdf_tbists,INITNandnotSLEEPandATPandnotSE,cond_sdf_taa_sctrlo,cond_sdf_taa_sdlo,cond_sdf_taa_sdro,cond_sdf_taa_smlo,cond_sdf_taa_smro;
   wire cond_sdf_taa_tm,cond_sdf_taa_tm_ls1, cond_sdf_taa_tm_hs1,cond_sdf_taa_tckq_tm,cond_sdf_taa_tseq_tm;

   wire CSWETBYPASSN;
   wire cond_sdf_tstdbys,cond_sdf_tsls,sleep_en,atp_csn_en;
   wire cond_sdf_tlss,cond_sdf_thss,cond_sdf_trms,cond_sdf_twms; 
   wire cond_sdf_tses,cond_sdf_tinitns;
   wire tby_se_en;
   wire rra_en;
   wire tbist_atp_en;
   wire rrae_en;
   wire tbist_rrae_en;
   wire cond_sdf_trraes;
   wire cond_sdf_ttrraes;
   wire cond_sdf_taa_trramatch;
   wire cond_sdf_ttrraematch;
   wire cond_sdf_tamatch;
   wire cond_sdf_ttamatch;
   wire cond_sdf_tatpmatch;
   wire cond_sdf_ttbistmatch;



 and (CSWEMTBYPASS[0], !Mreg[0], CSWETBYPASSN);
 and (CSWEMTBYPASS[1], !Mreg[1], CSWETBYPASSN);
 and (CSWEMTBYPASS[2], !Mreg[2], CSWETBYPASSN);
 and (CSWEMTBYPASS[3], !Mreg[3], CSWETBYPASSN);
 and (CSWEMTBYPASS[4], !Mreg[4], CSWETBYPASSN);
 and (CSWEMTBYPASS[5], !Mreg[5], CSWETBYPASSN);
 and (CSWEMTBYPASS[6], !Mreg[6], CSWETBYPASSN);
 and (CSWEMTBYPASS[7], !Mreg[7], CSWETBYPASSN);
 and (CSWEMTBYPASS[8], !Mreg[8], CSWETBYPASSN);
 and (CSWEMTBYPASS[9], !Mreg[9], CSWETBYPASSN);
 and (CSWEMTBYPASS[10], !Mreg[10], CSWETBYPASSN);
 and (CSWEMTBYPASS[11], !Mreg[11], CSWETBYPASSN);
 and (CSWEMTBYPASS[12], !Mreg[12], CSWETBYPASSN);
 and (CSWEMTBYPASS[13], !Mreg[13], CSWETBYPASSN);
 and (CSWEMTBYPASS[14], !Mreg[14], CSWETBYPASSN);
 and (CSWEMTBYPASS[15], !Mreg[15], CSWETBYPASSN);
 and (CSWEMTBYPASS[16], !Mreg[16], CSWETBYPASSN);
 and (CSWEMTBYPASS[17], !Mreg[17], CSWETBYPASSN);
 and (CSWEMTBYPASS[18], !Mreg[18], CSWETBYPASSN);
 and (CSWEMTBYPASS[19], !Mreg[19], CSWETBYPASSN);
 and (CSWEMTBYPASS[20], !Mreg[20], CSWETBYPASSN);
 and (CSWEMTBYPASS[21], !Mreg[21], CSWETBYPASSN);
 and (CSWEMTBYPASS[22], !Mreg[22], CSWETBYPASSN);
 and (CSWEMTBYPASS[23], !Mreg[23], CSWETBYPASSN);

and (atp_csn_en,!ATPint,!CSNint,!IGint);
or (sleep_en,atp_csn_en,ATPint);
or (SETB_EN,SEint,TBISTint);
and (ATP_SETB_EN,ATPint,SETB_EN); 
or (CSIG_EN,IGint,CSNint);
and (MEM_ACT,!ATPint,CSIG_EN);
or (EN_ADM,MEM_ACT,ATP_SETB_EN);
and (CS_EN,!ATPint,IGint);
or (CS_ADM,CS_EN,ATP_SETB_EN);
and (atp_ig_csn_en,!ATPint,!CSNint,!IGint);
and (atp_se_en,!SEsys,ATPint);
or (cycle_en,atp_ig_csn_en,atp_se_en);
and (atp_ig_csn_en_reg,!ATPreg,!CSNreg,!IGreg);
and (atp_se_en_reg,!SE_reg,ATPreg);
or (cycle_en_reg,atp_ig_csn_en,atp_se_en);
and (INITNandnotSLEEPandATPandnotSE,cond_gac,!SEsys,ATPint);
and (csn_ig_en,!IGint,!CSNint);
and (atp_tby_ls_en,atp_se_en,cond_ls_tby_en);
and (IG_EN,!ATPint,!CSNint);
or (IG_ADM,IG_EN,atp_se_en);
and (CSWETBYPASSN, !WENreg, 1'b1);



assign cond_sdf_tsls=((sleep_en && INITNint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tstdbys=((sleep_en && INITNint && !SLEEPint) !==0) ? 1:0;
assign cond_sdf_atps=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_gac=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tas=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tds=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tms=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tws=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tps=((cond_gac && !CS_ADM) !==0) ? 1:0;
assign cond_sdf_tcycle=((cond_gac && cycle_en && !LSint && !HSint) !==0) ? 1:0;  
assign cond_sdf_tcycle_ls1=((cond_gac && cycle_en && LSint) !==0) ? 1:0;
assign cond_sdf_tcycle_hs1=((cond_gac && cycle_en && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_tckh=((cond_gac && cycle_en_reg) !==0) ? 1:0;
assign cond_sdf_tckl=((cond_gac && cycle_en) !==0) ? 1:0;
assign cond_sdf_tcycle_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckl_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsctrlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckh_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_ttms=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_tbists=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_tckq_tm=((cond_gac && SE_reg && ATPreg && TBYPASSsys) !==0) ? 1:0;
assign cond_ls_en=((atp_ig_csn_en || atp_tby_ls_en) !==0) ? 1:0;
assign cond_sdf_tlss=((cond_ls_en && cond_gac) !==0) ? 1:0;
assign cond_sdf_thss=((cond_ls_en && cond_gac && !LSint) !==0) ? 1:0;
assign cond_sdf_trms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_twms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_tses=((cond_gac && ATPint) !==0) ? 1:0;
assign cond_sdf_tbas=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbps=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbws=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tigs=((cond_gac && IG_ADM) !==0) ? 1:0;
assign cond_sdf_taa=((MEMEN_reg && WENreg && !LSint && !HSint) !==0) ? 1:0; 
// assign cond_sdf_taa_tbypass_q = ((MEMEN_reg && ATPint && TBYPASSint) !== 1'b0) ? 1'b1 : 1'b0;
assign cond_sdf_taa_ls1=((MEMEN_reg && WENreg && LSint) !==0) ? 1:0; 
assign cond_sdf_taa_hs1=((MEMEN_reg && WENreg && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && !HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_ls1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && LSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_hs1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tseq_tm=((cond_gac && TBYPASSint) !==0) ? 1:0;
assign cond_sdf_tinitns =(( sleep_en && !STDBYint && !SLEEPint) !==0) ? 1:0;
assign cond_ls_tby_en=((TBYPASSsys || csn_ig_en) !==0) ? 1:0;



//specify block begins

specify
    specparam
    
         PATHPULSE$CK$Q = 0,
         PATHPULSE$CK$SCTRLO = 0,

         PATHPULSE$CK$SDLO = 0,
         PATHPULSE$CK$SDRO = 0,
        
         PATHPULSE$SE$Q = 0,
         
//         PATHPULSE$TBYPASS$Q = 0,


        
         
        
         tsls = `setup_time,
         tslh = `hold_time ,
         tstdbys = `setup_time,
         tstdbyh = `hold_time , 
	 

         
         tcycle = `cycle_time,
         
         
         tckh = `pulse_width_time,
         tckl = `pulse_width_time,
         tcycle_se = `cycle_time,
         tckh_se = `pulse_width_time,
         tckl_se = `pulse_width_time,
         
         ttms = `setup_time,
         ttmh = `hold_time ,
         tps = `setup_time,
         tph = `hold_time ,
         tws = `setup_time,
         twh = `hold_time ,
         tds = `setup_time,
         tdh = `hold_time , 
         tas = `setup_time,
         tah = `hold_time ,
         tses= `setup_time,
         tseh= `hold_time ,
         tsctrlis=`setup_time,
         tsctrlih=`hold_time ,
         tsdlis=`setup_time,
         tsdlih=`hold_time ,
         tsdris=`setup_time,
         tsdrih=`hold_time , 
         tbists=`setup_time,
         tbisth=`hold_time ,
         tbps=`setup_time,
         tbph=`hold_time ,
         tbws=`setup_time,
         tbwh=`hold_time ,
         tbdes=`setup_time,
         tbdeh=`hold_time ,
         tbdos=`setup_time,
         tbdoh=`hold_time ,
         
         tbas=`setup_time,
         tbah=`hold_time ,
         tinitnl=`initin_low_pulse,
         tinitns=`setup_time,
         tinitnh=`hold_time ,
         tatps=`setup_time,
         tatph=`hold_time ,
         tigs=`setup_time,
         tigh=`hold_time ,
         
         
         trms=`setup_time,
         trmh=`hold_time ,
         twms=`setup_time,
         twmh=`hold_time , 

/*************************************************************************************************/
           // taa_tbypass_q = `access_time,
           // th_tbypass_q  = `retain_time,
            taa =`access_time,
            th = `retain_time,

 


            taa_tm =`access_time,
            th_tm = `retain_time,

            
            taa_tseq_tm =`access_time,
            th_tseq_tm = `retain_time,
            taa_tckq_tm   = `access_time,
            th_tckq_tm    = `retain_time,
            taa_sctrlo=`access_time,
            th_sctrlo= `retain_time,
            taa_sdlo=`access_time,
            th_sdlo= `retain_time,
            taa_sdro=`access_time,
            th_sdro= `retain_time,
            
         
            taa_sctrlo_se=`access_time,
            th_sctrlo_se= `retain_time
,
            taa_sdlo_se=`access_time,
            th_sdlo_se= `retain_time,
            taa_sdro_se=`access_time,
            th_sdro_se= `retain_time
         ;  


        /*---------------------- Timing Checks ---------------------*/

	$setup(posedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[4], tah, TimingViol_addr);

	$setup(posedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(posedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(posedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(posedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(posedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(posedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(posedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(posedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(posedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(posedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(posedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(posedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(posedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(posedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(posedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(posedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(posedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(posedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(posedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(posedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(posedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(posedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$setup(posedge D[22], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_22);
	$setup(posedge D[23], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_23);
	$setup(negedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(negedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(negedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(negedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(negedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(negedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(negedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(negedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(negedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(negedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(negedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(negedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(negedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(negedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(negedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(negedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(negedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(negedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(negedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(negedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(negedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(negedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$setup(negedge D[22], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_22);
	$setup(negedge D[23], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_23);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[21], tdh, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[22], tdh, TimingViol_data_22);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[23], tdh, TimingViol_data_23);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[21], tdh, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[22], tdh, TimingViol_data_22);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[23], tdh, TimingViol_data_23);

        



        $setup(posedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $setup(negedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, posedge WEN, twh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, negedge WEN, twh, TimingViol_WEN); 
        $setup(posedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$setup(negedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, posedge CSN, tph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, negedge CSN, tph, TimingViol_CSN);
        $period(posedge CK &&& cond_sdf_tcycle, tcycle, TimingViol_tcycle);  

        
        $width(posedge CK  &&& cond_sdf_tckh, tckh, 0, TimingViol_tckh);
        $width(negedge CK  &&& cond_sdf_tckl, tckl, 0, TimingViol_tckl);
        $period(posedge CK &&& cond_sdf_tcycle_se, tcycle_se, TimingViol_tcycle_se);
        $width(posedge CK  &&& cond_sdf_tckh_se, tckh_se, 0, TimingViol_tckh_se);
        $width(negedge CK  &&& cond_sdf_tckl_se, tckl_se, 0, TimingViol_tckl_se);

        
        $setup(posedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $setup(negedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $hold(posedge CK &&& cond_sdf_ttms, posedge TBYPASS, ttmh, TimingViol_tbypass); 
        $hold(posedge CK &&& cond_sdf_ttms, negedge TBYPASS, ttmh, TimingViol_tbypass); 
 



        
        $setup(posedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $setup(negedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $hold(posedge CK &&& cond_sdf_tsls, posedge SLEEP, tslh, TimingViol_sleep);        
        $hold(posedge CK &&& cond_sdf_tsls, negedge SLEEP, tslh, TimingViol_sleep);

        $setup(posedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $setup(negedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $hold(posedge CK &&& cond_sdf_tstdbys, posedge STDBY, tstdbyh, TimingViol_stdby);        
        $hold(posedge CK &&& cond_sdf_tstdbys, negedge STDBY, tstdbyh, TimingViol_stdby); 
        
        
        $setup (posedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
	$setup (negedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
        
        $hold (posedge CK &&& cond_sdf_tses, posedge SE ,tseh,TimingViol_se);
	$hold (posedge CK &&& cond_sdf_tses, negedge SE ,tseh,TimingViol_se);
        
        $setup(posedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis , tsctrlis, TimingViol_sctrli);
        $setup(negedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis, tsctrlis, TimingViol_sctrli);
        $hold(posedge CK &&& cond_sdf_tsctrlis , posedge SCTRLI, tsctrlih, TimingViol_sctrli);        
        $hold(posedge CK &&& cond_sdf_tsctrlis , negedge SCTRLI, tsctrlih, TimingViol_sctrli);

        $setup(posedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $setup(negedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $hold(posedge CK &&& cond_sdf_tsdlis, posedge SDLI, tsdlih, TimingViol_sdli);        
        $hold(posedge CK &&& cond_sdf_tsdlis, negedge SDLI, tsdlih, TimingViol_sdli);

        $setup(posedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $setup(negedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $hold(posedge CK &&& cond_sdf_tsdris, posedge SDRI, tsdrih, TimingViol_sdri);        
        $hold(posedge CK &&& cond_sdf_tsdris, negedge SDRI, tsdrih, TimingViol_sdri);
        
 
	
         
        $width(negedge INITN , tinitnl, 0, TimingViol_initnl);
        
        $setup(posedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        $setup(negedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        
        $hold (posedge CK &&& cond_sdf_tinitns,posedge INITN, tinitnh, TimingViol_initn);
        $hold (posedge CK &&& cond_sdf_tinitns,negedge INITN, tinitnh, TimingViol_initn);

        $setup(posedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $setup(negedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $hold(posedge CK &&& cond_sdf_atps, posedge ATP, tatph, TimingViol_atp);        
        $hold(posedge CK &&& cond_sdf_atps, negedge ATP, tatph, TimingViol_atp);
        
        $setup(posedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $setup(negedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $hold(posedge CK &&& cond_sdf_tigs, posedge IG, tigh, TimingViol_ig);        
        $hold(posedge CK &&& cond_sdf_tigs, negedge IG, tigh, TimingViol_ig);



         
$setup(posedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[2], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[2], trmh, TimingViol_rm); 

        
$setup(posedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(posedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[1], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[1], twmh, TimingViol_wm);
 
        
        $setup(posedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $setup(negedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $hold(posedge CK &&& cond_sdf_tbists, posedge TBIST, tbisth, TimingViol_tbist);        
        $hold(posedge CK &&& cond_sdf_tbists, negedge TBIST, tbisth, TimingViol_tbist);
        
        	$setup(posedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$setup(negedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[4], tbah, TimingViol_addr);
       	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[4], tbah, TimingViol_addr);

        $setup(posedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$setup(negedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, posedge TCSN, tbph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, negedge TCSN, tbph, TimingViol_CSN); 
       
        $setup(posedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $setup(negedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, posedge TWEN, tbwh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, negedge TWEN, tbwh, TimingViol_WEN);
       
       
        $setup(posedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $setup(negedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, posedge TED, tbdeh, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, negedge TED, tbdeh, TimingViol_TED);

        $setup(posedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $setup(negedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, posedge TOD, tbdoh, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, negedge TOD, tbdoh, TimingViol_TOD);

          


          

          /*-------------------- Propagation Delays ------------------*/
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[22] +: OutReg_data[22])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[23] +: OutReg_data[23])) = (taa, taa, th, taa, th, taa);
                 

/* // //	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[0] +: OutReg_data[0])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[1] +: OutReg_data[1])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[2] +: OutReg_data[2])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[3] +: OutReg_data[3])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[4] +: OutReg_data[4])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[5] +: OutReg_data[5])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[6] +: OutReg_data[6])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[7] +: OutReg_data[7])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[8] +: OutReg_data[8])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[9] +: OutReg_data[9])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[10] +: OutReg_data[10])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[11] +: OutReg_data[11])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[12] +: OutReg_data[12])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[13] +: OutReg_data[13])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[14] +: OutReg_data[14])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[15] +: OutReg_data[15])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[16] +: OutReg_data[16])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[17] +: OutReg_data[17])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[18] +: OutReg_data[18])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[19] +: OutReg_data[19])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[20] +: OutReg_data[20])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[21] +: OutReg_data[21])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[22] +: OutReg_data[22])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[23] +: OutReg_data[23])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q); */ 








	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[22] +: OutReg_data[22])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[23] +: OutReg_data[23])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                





	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[22] +: OutReg_data[22])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[22] +: OutReg_data[22])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[23] +: OutReg_data[23])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[23] +: OutReg_data[23])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                 

	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[0] +: OutReg_data[0])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[1] +: OutReg_data[1])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[2] +: OutReg_data[2])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[3] +: OutReg_data[3])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[4] +: OutReg_data[4])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[5] +: OutReg_data[5])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[6] +: OutReg_data[6])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[7] +: OutReg_data[7])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[8] +: OutReg_data[8])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[9] +: OutReg_data[9])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[10] +: OutReg_data[10])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[11] +: OutReg_data[11])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[12] +: OutReg_data[12])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[13] +: OutReg_data[13])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[14] +: OutReg_data[14])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[15] +: OutReg_data[15])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[16] +: OutReg_data[16])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[17] +: OutReg_data[17])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[18] +: OutReg_data[18])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[19] +: OutReg_data[19])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[20] +: OutReg_data[20])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[21] +: OutReg_data[21])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[22] +: OutReg_data[22])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[23] +: OutReg_data[23])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                



if (cond_sdf_taa_sctrlo) 
        (posedge CK *> (SCTRLO :  SCTRLI)) = (taa_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo); 

if (cond_sdf_taa_sctrlo_se) 
        (negedge CK *> (SCTRLO : SCTRLI)) = (taa_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se); 
 

if (cond_sdf_taa_sdlo) 
        (posedge CK *> (SDLO :  SDLI)) = (taa_sdlo,taa_sdlo,th_sdlo,taa_sdlo,th_sdlo,taa_sdlo); 

if (cond_sdf_taa_sdlo_se) 
        (negedge CK *> (SDLO : SDLI)) = (taa_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se);

if (cond_sdf_taa_sdro) 
        (posedge CK *> (SDRO :  SDRI)) = (taa_sdro,taa_sdro,th_sdro,taa_sdro,th_sdro,taa_sdro); 

if (cond_sdf_taa_sdro_se) 
        (negedge CK *> (SDRO : SDRI)) = (taa_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se); 

  
     




endspecify //specify block ends






// conversion from registers to array elements for data setup violation notifiers

always @(TimingViol_data_0   or TimingViol_TED  )
begin
        TimingViol_data[0]=~TimingViol_data[0];   
end


always @(TimingViol_data_1   or TimingViol_TOD  )
begin
        TimingViol_data[1]=~TimingViol_data[1];   
end


always @(TimingViol_data_2   or TimingViol_TED  )
begin
        TimingViol_data[2]=~TimingViol_data[2];   
end


always @(TimingViol_data_3   or TimingViol_TOD  )
begin
        TimingViol_data[3]=~TimingViol_data[3];   
end


always @(TimingViol_data_4   or TimingViol_TED  )
begin
        TimingViol_data[4]=~TimingViol_data[4];   
end


always @(TimingViol_data_5   or TimingViol_TOD  )
begin
        TimingViol_data[5]=~TimingViol_data[5];   
end


always @(TimingViol_data_6   or TimingViol_TED  )
begin
        TimingViol_data[6]=~TimingViol_data[6];   
end


always @(TimingViol_data_7   or TimingViol_TOD  )
begin
        TimingViol_data[7]=~TimingViol_data[7];   
end


always @(TimingViol_data_8   or TimingViol_TED  )
begin
        TimingViol_data[8]=~TimingViol_data[8];   
end


always @(TimingViol_data_9   or TimingViol_TOD  )
begin
        TimingViol_data[9]=~TimingViol_data[9];   
end


always @(TimingViol_data_10   or TimingViol_TED  )
begin
        TimingViol_data[10]=~TimingViol_data[10];   
end


always @(TimingViol_data_11   or TimingViol_TOD  )
begin
        TimingViol_data[11]=~TimingViol_data[11];   
end


always @(TimingViol_data_12   or TimingViol_TED  )
begin
        TimingViol_data[12]=~TimingViol_data[12];   
end


always @(TimingViol_data_13   or TimingViol_TOD  )
begin
        TimingViol_data[13]=~TimingViol_data[13];   
end


always @(TimingViol_data_14   or TimingViol_TED  )
begin
        TimingViol_data[14]=~TimingViol_data[14];   
end


always @(TimingViol_data_15   or TimingViol_TOD  )
begin
        TimingViol_data[15]=~TimingViol_data[15];   
end


always @(TimingViol_data_16   or TimingViol_TED  )
begin
        TimingViol_data[16]=~TimingViol_data[16];   
end


always @(TimingViol_data_17   or TimingViol_TOD  )
begin
        TimingViol_data[17]=~TimingViol_data[17];   
end


always @(TimingViol_data_18   or TimingViol_TED  )
begin
        TimingViol_data[18]=~TimingViol_data[18];   
end


always @(TimingViol_data_19   or TimingViol_TOD  )
begin
        TimingViol_data[19]=~TimingViol_data[19];   
end


always @(TimingViol_data_20   or TimingViol_TED  )
begin
        TimingViol_data[20]=~TimingViol_data[20];   
end


always @(TimingViol_data_21   or TimingViol_TOD  )
begin
        TimingViol_data[21]=~TimingViol_data[21];   
end


always @(TimingViol_data_22   or TimingViol_TED  )
begin
        TimingViol_data[22]=~TimingViol_data[22];   
end


always @(TimingViol_data_23   or TimingViol_TOD  )
begin
        TimingViol_data[23]=~TimingViol_data[23];   
end


`endif


// TASK DEFINITION DESCRIPTION
// ================================



task task_insert_faults_in_memory;
begin
   if (reg_ConfigFault)
   begin   
     for(i = 0;i< fcnt;i = i+ 1) begin
        if(mem_red_array_stuck_at[i] === "mem_array") begin
          if (array_stuck_at[i] === "sa0") begin
           `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data & stuck_at_0fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
          `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] & stuck_at_0fault[i];
          `endif
         end //if(array_stuck_at)
                                        
         if(array_stuck_at[i] === "sa1") begin
         `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data | stuck_at_1fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
         `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] | stuck_at_1fault[i]; 
         `endif
         end //if(array_stuck_at)
       end //if mem_red_array_stuck_at
    
    
     end    // end of for
   end  
end
endtask



task task_read_fault_file;
begin
/*  -----------Implemetation for config fault starts------*/
   msgcnt = X;
   t = 0;
   fault_repair_flag = {max_faults{1'b1}};
   repair_flag = {max_faults{1'b1}};
   if(reg_ConfigFault) 
   begin
      file_ptr = $fopen(reg_Fault_file_name , "r");
      if(file_ptr == 0)
      begin     
          if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: File cannot be opened ",$realtime);
      end        
      else                
      begin : read_fault_file
        t = 0;
        for (i = 0; i< max_faults; i= i + 1)
        begin
         
           stuck0 = {Bits{1'b1}};
           stuck1 = {Bits{1'b0}};
           fault_char1 = $fgetc (file_ptr);
           if (fault_char1 == 8'b11111111)
              disable read_fault_file;
           ret_val = $ungetc (fault_char1, file_ptr);
           ret_val = $fgets(tempStr, file_ptr);
           ret_val = $sscanf(tempStr, "%s %d %d %s",fault_array,fault_word, fault_bit, stuck_at) ;
           flag_error = 0; 
           if(ret_val !== 0)
           begin         
              if(ret_val == 3 || ret_val == 4)
              begin
                if(ret_val == 3)
                   stuck_at = "sa0";

                if(stuck_at !== "sa0" && stuck_at !== "sa1" && stuck_at !== "none")
                begin
                    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: Wrong value for stuck at in fault file ",$realtime);
                   flag_error = 1;
                end    
                      
                if(fault_word >= Words)
                begin
                   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Address out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                if(fault_bit >= Bits)
                begin  
                    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Faulty bit out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                
                        
                if(fault_array !== "mem_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array is not mem_array ",$realtime);
                  flag_error = 1;
                end

                if(fault_array === "red_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array can't be on redundancy array in non redundancy cut.",$realtime);
                  flag_error = 1;
                end

                
                

                if(flag_error == 0)
                //Correct Inputs
                begin
                   if(stuck_at === "none")
                   begin
                       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
                   end
                   else
                   //Adding the faults
                   begin
                      FailureLocn[t] = fault_word;
                      Failurebit[t]  = fault_bit ;
                      std_fault_word = fault_word;
                      fault_row_add[t] = std_fault_word[Addr-1:mux_bits];
                      mem_red_array_stuck_at[t] = fault_array;
                      fault_repair_flag[t] = 1'b0;
                      if (stuck_at === "sa0" )
                      begin
                         stuck0[fault_bit] = 1'b0;         
                         stuck_at_0fault[t] = stuck0;
                      end     
                      if (stuck_at === "sa1" )
                      begin
                         stuck1[fault_bit] = 1'b1;
                         stuck_at_1fault[t] = stuck1; 
                      end

                      array_stuck_at[t] = stuck_at;
                      t = t + 1;
                   end //if(stuck_at === "none")  
                end //if(flag_error == 0)
              end //if(ret_val == 2 || ret_val == 3 
              else
              //wrong number of arguments
              begin
                if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: WRONG VALUES ENTERED FOR FAULTY WORD OR FAULTY BIT OR STUCK_AT IN Fault_file_name ",$realtime); 
                flag_error = 1;
              end
           end //if(ret_val !== 0)
           else
           begin 
               if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
           end    
        end //for (i = 0; i< m
      end //begin: read_fault_file  
      $fclose (file_ptr);

      fcnt = t;
      
      //fault injection at time 0.
      task_insert_faults_in_memory;
  end // config_fault 
end
endtask


task WriteMemX;
begin

`ifdef slm
   $slm_ResetMemory(MemAddr, WordX);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = WordX;
   
`endif        
 task_insert_faults_in_memory;
end
endtask

task WriteMem0;
begin
`ifdef slm
   $slm_ResetMemory(MemAddr, Word0);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = Word0;
  
`endif 
   task_insert_faults_in_memory;
end
endtask


task WriteOutX;                
begin
   OutReg_data <= #0 WordX;
end
endtask


task Invalid_next_cycle_func;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_func = 1;
     `else 
       #0 next_cycle_corrupt_func = 0; 
     `endif  
   end 
end
endtask

task Invalid_next_cycle_dft;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_dft = 1;
     `else 
       #0 next_cycle_corrupt_dft = 0; 
     `endif  
  end
end
endtask

task Invalid_next_cycle_func_tim;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
   #0 next_cycle_corrupt_func <= 1;
  end 
end
endtask

task Invalid_next_cycle_dft_tim;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
  #0 next_cycle_corrupt_dft <= 1;
  end
end
endtask


task ScanOutX;                
begin
   
   dff_SCTRLO_SE.Q <= 1'bx;   
   dff_SDLO_SE.Q <= 1'bx; 
   dff_SDRO_SE.Q <= 1'bx; 
    
   
   SCTRLOint=X;
   SDLOint=X;
   SDROint=X;
    
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   SDLO_data<=1'bx;
   SDRO_data<=1'bx;
    
   `endif
end
endtask

task delScanOutX;                
begin
   delSCTRLO_data<=X;
   delSDLO_data<=X;
   delSDRO_data<=X;
    
end
endtask

task ScanChainX;                
begin
 scanreg_ctrl=1'bx; 
 scanreg_dl=1'bx; 
 scanreg_dr =1'bx; 
  
end
endtask

task mem_blocked;
begin
 
   WriteMemX;
   WriteOutX;
   ScanChainX;
   ScanOutX;//immediately;
   delScanOutX;//immediately
   `ifdef POWER_SEQUENCING_OFF
   `else
   reg_mem_block=1;
   `endif
   debug_level = 2'b11;
end
endtask

task corrupt_all;
begin
 
  WriteMemX;
  WriteOutX;
  ScanChainX;
  ScanOutX;
  delScanOutX;//immediately;
  OutReg_data = WordX; 
  delOutReg_data=WordX;
  
end
endtask

task WriteCycle;                  
input [Addr-1 : 0] Address;
reg [Bits-1:0] tempReg1;
reg [Bits-1:0] tempReg_slm;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;


reg repair_flag;

integer po,i,num,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;
begin

   tempReg1 = WordX;
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];

   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};
   
   if (ValidAddress === X )   begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
        WriteMemX;
        if (INITNint !== 0) begin
        `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
           #0 next_cycle_corrupt_func = 1;
       `else 
           #0 next_cycle_corrupt_func = 0; 
       `endif  
   end 

   end


   if (ValidAddress !== X && next_cycle_corrupt_func === 0  )
   begin
         if (red_en === 1 && ((Row_Add_cmp === repair_add) || (Row_Add_cmp === next_repair_add)) ) begin
             repair_flag = 1'b1;
             
             Bank_sel_integer = 0;
                     
             if (Row_Add_cmp === repair_add) begin
               Col_Add_integer  = Col_Add; 
             end
             else if (Row_Add_cmp === next_repair_add) begin
               Col_Add_integer  = Col_Add + mux; 
             end  
             RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
        end  

        if(repair_flag === 0 && ValidAddress === 1) begin
           `ifdef slm
              $slm_ReadMemoryS(MemAddr, Address, tempReg_slm);
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = Mem[Address];
            `endif
          end  
        else if(repair_flag === 1) begin
           `ifdef slm
//              $slm_ReadMemoryS(RedMemAddr, RedMem_address, tempReg_slm);
          
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = RedMem[RedMem_address];
            `endif
        end
        
        for (num=0;num<Bits;num=num+1) begin
             po=num;        
             if ( Dint [num] !== tempReg1 [po]) begin
                if (Mint[num] === 1'b0)
                   tempReg1[po] = Dint[num];
                else if (Mint[num] === 1'bX)
                   tempReg1[po] = 1'bx;
             end                
        end //for (num=0
            
         if(repair_flag === 0 ) begin    
            if(ValidAddress === 1) begin  
              `ifdef slm
                  tempReg_slm=tempReg1; 
                  $slm_WriteMemory(MemAddr, Address, tempReg_slm);
              `else
                   Mem[Address] = tempReg1;
              `endif
            end
            else begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address Out Of Range. ",$realtime);
            end        
         end
         else if (repair_flag === 1 ) begin
            `ifdef slm
                tempReg_slm=tempReg1; 
//                $slm_WriteMemory(RedMemAddr, RedMem_address, tempReg_slm);
            `else
                RedMem[RedMem_address] = tempReg1;
            `endif
         end
   end //if (ValidAddress !== X
   task_insert_faults_in_memory;
end
endtask 

task ReadCycle;
input [Addr-1 : 0] Address;

reg [Bits-1:0] MemData_tmp;
reg [Bits-1:0] MemData;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;

reg repair_flag;

integer a,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;

begin
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];
   
   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};

   

   if (ValidAddress !== X && next_cycle_corrupt_func === 0 ) begin   
       if(red_en === 1 && ( Row_Add_cmp === repair_add ||  Row_Add_cmp === next_repair_add )) begin
              repair_flag = 1;
              
              Bank_sel_integer = 0;
               
              if(Row_Add_cmp === repair_add) begin
                Col_Add_integer = Col_Add;
              end
              else if (Row_Add_cmp === next_repair_add) begin
                Col_Add_integer = Col_Add + mux; 
              end
              RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
       end

      if(repair_flag === 0) begin
          if(ValidAddress === 1) begin 
           `ifdef slm
              $slm_ReadMemory(MemAddr, Address, MemData);
           `else
              MemData = Mem[Address];
           `endif
          end
          else begin
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Address Out Of Range. Output Corrupted ",$realtime);
             MemData = WordX;
          end
     end
      else if(repair_flag === 1) begin
        `ifdef slm
//           $slm_ReadMemory(RedMemAddr, RedMem_address, MemData);
        `else
           MemData = RedMem[RedMem_address];
        `endif
      end
   end //if (ValidAddress)  
   
   if(ValidAddress === X)
   begin
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Illegal Value on Address Bus. Memory and Output Corrupted ",$realtime); 
         Invalid_next_cycle_func;
   end 
   
  if(ValidAddress !== X && next_cycle_corrupt_func === 0 )
   begin
   for (a = 0; a < Bits; a = a + 1)
   begin
      if (MemData[a] !== OutReg_data[a])
         OutReg_data[a] = WordX[a];
   end//for (a = 0; a <  
         OutReg_data <= MemData;
   end     
end
endtask



// SCAN CHAINS
supply0 gnd;
buf (A_int[0], Aint[0]);
buf (A_int[1], Aint[1]);
buf (A_int[2], Aint[2]);
buf (A_int[3], Aint[3]);
buf (A_int[4], Aint[4]);                  //used for capturing
buf (A_int[5], gnd);
buf (A_int[6], gnd);
buf (A_int[7], gnd);
buf (A_int[8], gnd);
buf (A_int[9], gnd);
buf (A_int[10], gnd);
buf (A_int[11], gnd);
buf (A_int[12], gnd);
buf (A_int[13], gnd);
buf (A_int[14], gnd);   //used for capturing

buf (WEN_int, WENint);
buf (CSN_int, CSNint);
buf (IG_int, IGint);


// Scan flops



// CONTROL SCAN CHAIN
     ST_SPREG_LOLEAK_32x24m4_Tl_SCFF cntrl_scff_0 (.D(1'b0), .TI(SCTRLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[0]), .OUTX(scanreg_ctrl));

      
 ST_SPREG_LOLEAK_32x24m4_Tl_SCFF cntrl_scff_1 (.D(A_int[3]), .TI(scanreg_ctrl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[1]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m4_Tl_SCFF cntrl_scff_2 (.D(A_int[5]), .TI(scanreg_ctrl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[2]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m4_Tl_SCFF cntrl_scff_3 (.D(A_int[8]), .TI(scanreg_ctrl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[3]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m4_Tl_SCFF cntrl_scff_4 (.D(A_int[2]), .TI(scanreg_ctrl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[4]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m4_Tl_SCFF cntrl_scff_5 (.D(A_int[10]), .TI(scanreg_ctrl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[5]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m4_Tl_SCFF cntrl_scff_6 (.D(A_int[9]), .TI(scanreg_ctrl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[6]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m4_Tl_SCFF cntrl_scff_7 (.D(A_int[1]), .TI(scanreg_ctrl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[7]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m4_Tl_SCFF cntrl_scff_8 (.D(A_int[0]), .TI(scanreg_ctrl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[8]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m4_Tl_SCFF cntrl_scff_9 (.D(A_int[4]), .TI(scanreg_ctrl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[9]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m4_Tl_SCFF cntrl_scff_10 (.D(A_int[6]), .TI(scanreg_ctrl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[10]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m4_Tl_SCFF cntrl_scff_11 (.D(CSN_int), .TI(scanreg_ctrl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[11]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m4_Tl_SCFF cntrl_scff_12 (.D(A_int[7]), .TI(scanreg_ctrl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[12]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m4_Tl_SCFF cntrl_scff_13 (.D(WEN_int), .TI(scanreg_ctrl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[13]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m4_Tl_SCFF cntrl_scff_14 (.D(scanreg_ctrl_wire[14]), .TI(scanreg_ctrl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[14]), .OUTX(scanreg_ctrl));  

reg LP_CK_gate;

// Lock Up Latch
wire SCTRLO_temp;
 ST_SPREG_LOLEAK_32x24m4_Tl_lock_up_latch  dff_SCTRLO_SE (Latch_open, scanreg_ctrl_wire[14], SCTRLO_temp);

always @(SCTRLO_temp) begin
     SCTRLOint= SCTRLO_temp;
 `ifdef functional
 `else
 if (SCTRLOint !== SCTRLO_data) begin 
  if (SCTRLOint !==X)
   SCTRLO_data=1'bx;
   SCTRLO_data <= SCTRLOint;
 end 
 `endif
end  


// LEFT DATA SCAN CHAIN
     ST_SPREG_LOLEAK_32x24m4_Tl_SCFF ldata_scff_0 (.D(Dint[11]), .TI(SDLI), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[0]), .OUTX(scanreg_dl));
      
   
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF ldata_scff_1 (.D(Dint[10]), .TI(scanreg_dl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[1]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF ldata_scff_2 (.D(Dint[9]), .TI(scanreg_dl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[2]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF ldata_scff_3 (.D(Dint[8]), .TI(scanreg_dl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[3]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF ldata_scff_4 (.D(Dint[7]), .TI(scanreg_dl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[4]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF ldata_scff_5 (.D(Dint[6]), .TI(scanreg_dl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[5]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF ldata_scff_6 (.D(Dint[5]), .TI(scanreg_dl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[6]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF ldata_scff_7 (.D(Dint[4]), .TI(scanreg_dl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[7]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF ldata_scff_8 (.D(Dint[3]), .TI(scanreg_dl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[8]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF ldata_scff_9 (.D(Dint[2]), .TI(scanreg_dl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[9]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF ldata_scff_10 (.D(Dint[1]), .TI(scanreg_dl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[10]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF ldata_scff_11 (.D(Dint[0]), .TI(scanreg_dl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[11]), .OUTX(scanreg_dl));



// Lock Up Latch
wire SDLO_temp;
 ST_SPREG_LOLEAK_32x24m4_Tl_lock_up_latch  dff_SDLO_SE (Latch_open, scanreg_dl_wire[11], SDLO_temp);

always @(SDLO_temp) begin
     SDLOint= SDLO_temp;
 `ifdef functional
 `else
 if (SDLOint !== SDLO_data) begin 
  if (SDLOint !==X)
   SDLO_data=1'bx;
   SDLO_data <= SDLOint;
 end 
 `endif
end  






// RIGHT DATA SCAN CHAIN

     ST_SPREG_LOLEAK_32x24m4_Tl_SCFF rdata_scff_0 (.D(Dint[23]), .TI(SDRI), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[0]), .OUTX(scanreg_dr));
     
 
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF rdata_scff_1 (.D(Dint[22]), .TI(scanreg_dr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[1]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF rdata_scff_2 (.D(Dint[21]), .TI(scanreg_dr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[2]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF rdata_scff_3 (.D(Dint[20]), .TI(scanreg_dr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[3]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF rdata_scff_4 (.D(Dint[19]), .TI(scanreg_dr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[4]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF rdata_scff_5 (.D(Dint[18]), .TI(scanreg_dr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[5]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF rdata_scff_6 (.D(Dint[17]), .TI(scanreg_dr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[6]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF rdata_scff_7 (.D(Dint[16]), .TI(scanreg_dr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[7]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF rdata_scff_8 (.D(Dint[15]), .TI(scanreg_dr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[8]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF rdata_scff_9 (.D(Dint[14]), .TI(scanreg_dr_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[9]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF rdata_scff_10 (.D(Dint[13]), .TI(scanreg_dr_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[10]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m4_Tl_SCFF rdata_scff_11 (.D(Dint[12]), .TI(scanreg_dr_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[11]), .OUTX(scanreg_dr)); 


// Lock Up Latch
wire SDRO_temp;
 ST_SPREG_LOLEAK_32x24m4_Tl_lock_up_latch  dff_SDRO_SE (Latch_open, scanreg_dr_wire[11], SDRO_temp);


always @(SDRO_temp) begin
     SDROint= SDRO_temp;
 `ifdef functional
 `else
 if (SDROint !== SDRO_data) begin 
  if (SDROint !==X)
   SDRO_data=1'bx;
   SDRO_data <= SDROint;
 end 
 `endif
end






//


 //////// CAPTURE TASK //////
task scan_acquire;
begin
   if (supply_ok === 1) begin 
      if ( SEsys === 0 && ((LP_CK_gate === 0 && TBYPASSsys !== 1'bx)|| TBYPASSsys===0)) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
         
         Latch_open=1;
         

      end //if ( SEint === 0
   end//if(supply_ok 
end
endtask

task scan_shift;
begin
 if (supply_ok === 1) begin
   if (STDBYint === 0 && SLEEPint === 0) begin
      if (CKint_dft === X && INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0) begin
         ScanChainX;
         ScanOutX;
      end
      else if (CKint_dft === 1 && lastCK_dft === 0 ) begin
          //// SHIFT
        if (SEsys === 1) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
           
        //// SHIFT Ends
        end //if (SEsys === 1
        else if (SEsys === X) begin
            ScanChainX;
            ScanOutX;
            delScanOutX;
        end//if (SEint ==X
      
      end///if (CKint === 
    
      else if (CKint_dft === 0 && lastCK_dft === 1 ) begin
        Latch_open=1;
      end
    end  //if (STDByint === 0 && SLEEPint === 0
 end//if(supply_ok
end
endtask






// BEHAVIOURAL MODULE DESCRIPTION
// ================================

initial
begin
  // Define format for timing value
  $timeformat (-9, 3, " ns", 0);
  `ifdef slm
  $slm_RegisterMemory(MemAddr, Words, Bits);
  `endif   
   reg_mem_block=0;
   flag_mem_block=0;
  `ifdef functional
  `else
   TimingViol_data=0;
   TimingViol_mask=0;
   `endif
   decoding_start=0;
  
   //Parameter Assignment
   
   reg_Fault_file_name = Fault_file_name; 
   reg_ConfigFault     = ConfigFault;
   reg_MEM_INITIALIZE  = MEM_INITIALIZE;
   reg_BinaryInit      = BinaryInit;
   reg_InitFileName    = InitFileName;
   reg_Initn_reset_value = Initn_reset_value;
   reg_File_load_time    = File_load_time;

   time_fall_sleep=0;
   time_fall_PSWLARGEMP=0;
   time_fall_PSWLARGEMP_0=0;
   time_fall_PSWLARGEMA=0;
   time_fall_PSWLARGEMA_0=0;
   time_fall_PSWSMALLMP=0;
   time_fall_PSWSMALLMA=0;

   vddmp_rise_time=0;
   vddmp_fall_time=0;
   vddsmp_rise_time=0;
   vddsmp_fall_time=0;
   vddma_rise_time=0;
   vddma_fall_time=0;
   vddsma_rise_time=0;
   vddsma_fall_time=0;
   vddm_fall_time=0;  
   vddm_rise_time=0;  
   vddsm_fall_time=0; 
   vddsm_rise_time=0;

   next_cycle_corrupt_func=0;
   next_cycle_corrupt_dft=0;
   init_pulse_done = 0;
   power_up_done = 0;
   file_loaded=1;
   debug_level= 2'b01;
   message_status = "ONLY WARNINGS/ERRORS are Switched ON.For INFO also use debug_level=2'b00";
  `ifdef  NO_WARNING_MODE
     debug_level = 2'b11;
     message_status = "All Warning/Errors/Info Messages are Switched OFF";
  `endif  
  `ifdef  ONLY_ERROR_MODE
     debug_level = 2'b10;
     message_status = "All Warning/Info Messages are Switched OFF.Errors are switched on";
  `endif 
  `ifdef  ALL_MSG_MODE
     debug_level = 2'b00;
     message_status = "All Messages are Switched ON";
  `endif 
  
  `ifdef slm
     operating_mode = "SLM";
   `else
      `ifdef functional
         operating_mode = "FUNCTIONAL";
       `else
         operating_mode = "TIMING";
      `endif
   `endif   
  
  if (debug_level < 1) begin
  $display ("%m INFORMATION ");
  $display ("***************************************");
  $display ("The Model is Operating in %s MODE", operating_mode);
  $display ("%s", message_status);
  if(reg_ConfigFault)
  $display ("Configurable Fault Functionality is ON");   
  else
  $display ("Configurable Fault Functionality is OFF");   
  $display("Fault File used by the model Fault_File_Name=%s" ,reg_Fault_file_name);
  $display("Values of Config_fault used in model=%d" ,reg_ConfigFault);
  $display("Values of Mem_INITALIZE used in model=%d" ,reg_MEM_INITIALIZE);
  $display("Values of BinaryInit used in model=%d" ,reg_BinaryInit);
  $display("Values of InitFileName used in model=%s" ,reg_InitFileName);
  $display("Values of Initn_reset_value used in model=%d" ,reg_Initn_reset_value);
  $display("Values of File_load_time used in model=%t" ,reg_File_load_time);

  $display ("***************************************");
  end
     
  task_read_fault_file; 
   if(!INITNint) begin
    if(supply_ok ) begin 
      init_pulse_done = 1;
      power_up_done = 1;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif 
    end 
   end 
        
   lastCK_func = CKint_func;
   lastCK_dft = CKint_dft;

 `ifdef MEM_CONTENTS_SLEEP
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","w");
   $fclose(ptr);
 `endif 

   
end  // initial block ends



//+++++++++++++++++++++++++++++++ CONFIG FAULT IMPLEMETATION ENDS+++++++++++++++++++++++++++++++//
        




//INITN block starts
//================================
always @(INITNint  or supply_ok )
begin
 if (INITNint === 1'b0) begin
   if(supply_ok) begin
     init_pulse_done = 1;
     power_up_done = 1;
     lastCK_func=CKint_func;
     lastCK_dft=CKint_dft;
     next_cycle_corrupt_func = 0;
     next_cycle_corrupt_dft = 0;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif     
   end 
 end        

 if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && INITNint !== 1)
   begin
     ScanOutX;
     ScanChainX;
     delScanOutX;
   end  
         
 if (init_pulse_done === 0 && INITNint !== 0) begin
     if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) INFO: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
 end
 
end//always @(INITNint)


// Clock Generation 
//wire gated_clock;
//wire clock_gate_en;
//ST_SPREG_LOLEAK_32x24m4_Tl_lock_up_latch CK_SE_latch (!CK , SE, SE_latch_CK);
//and (clock_gate_en, ATP, TBYPASS, !SE_latch_CK);

//ST_SPREG_LOLEAK_32x24m4_Tl_lock_up_latch LP_latch (!CK , scanreg_ctrl_wire[14], LP_latch_CK);
//and (gated_clock,CK,!LP_latch_CK);
//assign CK_new= clock_gate_en ===0 ? CK : (clock_gate_en ===1 ? gated_clock: (CK===0) ? 0 :1'bx);


// Clock Generation Ends


// Functional CK block starts
//======================================
always @(CKint_func)
begin
   lastCK_func=CKreg_func;  
   CKreg_func=CKint_func;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
        if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
      if (CKreg_func === 1'bX || (CKreg_func === 1'b1 && lastCK_func === 1'bx)) begin
        if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
         
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
         Invalid_next_cycle_func;
        end
      end
      else if (CKreg_func === 1'b1 && lastCK_func === 1'b0 ) begin
        time_CK_func_rise=$realtime;
        MEMEN_prev = MEMEN_reg;
        MEMEN_reg = MEMEN;
        CSNreg = CSNint;
        IGreg = IGint;
        DEreg = DEint;
        SE_reg = SEsys;
        TBYPASS_reg = TBYPASSsys;
        ATPreg = ATPint;
        INITNreg = INITNint;
        SLEEPreg = SLEEPint;
        STDBYreg = STDBYint;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 

    `ifdef functional
    `else
        Mem_last=Mem[Aint];
    `endif 
        if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.INITN pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SLEEP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.STANDBY pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg === X && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.chip select  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg === X && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.IG pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg === X && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.Debug pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg === X && (SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.ATP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg === X && TBYPASS_reg !== 1) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SE pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg !== 1 && TBYPASS_reg === X) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.TBYPASS pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end

        else if ((INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0))) && WENint === X) begin
            // Uncertain write cycle
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: write enable going to X  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end 
        else if (next_cycle_corrupt_func === 1) begin
          next_cycle_corrupt_func = X;
        end
        else if (next_cycle_corrupt_func === 1'bx) begin
          next_cycle_corrupt_func = 0;
        end 
        
//        if (next_cycle_corrupt_func === 0 ) begin 
         
          /*---------------------- File initialization -----------------*/
          
          if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0)) && flag_mem_block === 1'b0) begin
                 Areg=Aint;
                 Dreg=Dint;
                 Mreg=Mint;
                 WENreg=WENint;     
             if (reg_MEM_INITIALIZE === 1'b1 && $realtime >= reg_File_load_time && file_loaded ) begin   
                `ifdef slm
                  if (reg_BinaryInit)
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_BIN");
                  else
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_HEX");
   
                `else
                  if (reg_BinaryInit)
                     $readmemb(reg_InitFileName, Mem, 0, Words-1);
                  else
                     $readmemh(reg_InitFileName, Mem, 0, Words-1);
                `endif
                 file_loaded = 0;
             end
   
             if (^Aint === X)
               ValidAddress = X;
             else if (Aint < Words)
               ValidAddress = 1;
             else    
               ValidAddress = 0;
   
             if(red_en === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Redundancy Enable is Invalid. Either RRAE is X or TRRAE is X",$realtime);
                ValidAddress = X; 
           end
           else if(red_en === 1'b1 && ^repair_add === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Repair Address is invalid.RRA is X",$realtime);
                ValidAddress = X;
           end
             
             if (ValidAddress)
               `ifdef slm
                   $slm_ReadMemoryS(MemAddr, Aint, Mem_temp);
               `else
                    Mem_temp = Mem[Aint];
               `endif
             else
                Mem_temp = WordX;  
          
     /*---------------------- Normal Read and Write -----------------*/
     
             if (WENint === 1) begin
               ReadCycle(Aint);
             end
       
             else if (WENint === 0) begin
               WriteCycle(Aint);
             end 
                
          
          end //  if (MEMEN === 1'b1 
       
//        end  // if (next_cycle_corrupt_func === 0
      
      end // if (CKint = 1   
   end // if (init_pulse_done === 1           
 end 
end // always @(CKint_func)
        
always @(MEMEN)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) && CKint_func === 1'bx) begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.clock pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
    Invalid_next_cycle_func;
  end
 end 
end

// DFT CK block starts
//======================================
always @(CKint_dft) 
begin
   lastCK_dft=CKreg_dft;
   CKreg_dft=CKint_dft;
   
   Latch_open=0;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
     if (CKreg_dft === 1'bX || (CKreg_dft === 1'b1 && lastCK_dft === 1'bx)) begin
       if (INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0 ) begin
        
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: DFT clock  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime); 
         Invalid_next_cycle_dft;
         if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
           WriteOutX;
         end
       end
     end 

     if(CKint_dft === 0 && lastCK_dft === 1) begin
      if(ATPreg === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
       if(SE_reg === 1'b1 && SEsys === 1'b0) begin
        if(TBYPASSint === 1'b1) begin   
    
       
       
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],
scanreg_dr_wire[10],
scanreg_dr_wire[11],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9],
scanreg_dl_wire[10], scanreg_dl_wire[scanlen_l-1]}; 
       


         for (i = 0; i < Bits; i = i + 1)
         begin
          if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
         end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
        end 
       end
      end
     end 
     
     else if (CKreg_dft === 1'b1 && lastCK_dft === 1'b0 ) begin
       SE_reg = SEsys;
       TBYPASS_reg = TBYPASSsys;
       ATPreg = ATPint;
       INITNreg = INITNint;
       SLEEPreg = SLEEPint;
       STDBYreg = STDBYint;
       MEMEN_dft_prev = MEMEN_dft_reg;
       MEMEN_dft_reg = MEMEN_dft;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 
       if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ) begin 
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
 //     else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys === X && TBYPASSsys !== 1) begin
///           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
//           Invalid_next_cycle_dft;
//        end       
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys === X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
        end 
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys !== 0 && LP_CK_gate===X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: LP FLOP Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           ScanChainX;
           ScanOutX;   
          if( TBYPASSint !== 0 && SEint !== 1) begin
            WriteOutX;
          end
          next_cycle_corrupt_dft=0;
        end        
       else if (next_cycle_corrupt_dft === 1'b1) begin 
         next_cycle_corrupt_dft = X;
       end 
       else if (next_cycle_corrupt_dft === 1'bx) begin
         next_cycle_corrupt_dft = 0;
       end
       
       if (next_cycle_corrupt_dft === 0 ) begin
         
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1 && flag_mem_block === 1'b0) begin
           
           if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0  && LP_CK_gate===0) begin
              OutReg_data_tbypass = Dint;
              for (i = 0; i < Bits; i = i + 1)
              begin
               if (OutReg_data_tbypass[i] !== OutReg_data[i])
                 OutReg_data[i] = WordX[i];
              end//for (i = 0; i < */ 
              OutReg_data <= OutReg_data_tbypass;
           end
           
             scan_acquire;
         end //MEMEN_dft == 1        
       end // if ( next_cycle_corrupt_dft
       
     end // if (CKint_dft === 1'b1
      //  if (next_cycle_corrupt_dft === 0 ) begin 
       if (SE_reg !== 0) begin
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1  && flag_mem_block === 1'b0) begin
           next_cycle_corrupt_dft = 0;
           if ( next_cycle_corrupt_func === 1) begin
	    next_cycle_corrupt_func = 0 ;
	   end	
           scan_shift;
         end
       end
     //end // if ( next_cycle_corrupt_dft    
     if ((!(TBYPASSsys!==0 && SEsys!==1 && LP_CK_gate!==0 ) && next_cycle_corrupt_dft === 0) || CKint_dft !==1) begin          
       CK_sc=INITNreg & !STDBYreg & !SLEEPreg & ATPreg & CKreg_dft ;
     end     
   end // if (init_pulse_done 
 end // if (supply_ok 
end // always @(CKint_dft)

always @(MEMEN_dft)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) && CKint_dft === 1'bx)  begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.MEMEN_dft and clock should not be X at this time instant. ScanChains and ScanOuts Corrupted ",$realtime); 
    Invalid_next_cycle_dft;
    
    if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
      WriteOutX;
    end
  end
  if ( MEMEN_dft !== 0 && TBYPASSsys !== 0 && SEsys !== 1) begin
     WriteOutX;
     OutReg_data = WordX; 
     delOutReg_data=WordX;
 end 
end
end //always @(MEMEN_dft

always @(TBYPASSsys or ATPint)
begin
   if(supply_ok === 1'b1) begin 
    if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0 && INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1) begin
      if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
    end  
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint === X && SEsys !== 1) ) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end 
end //always @(TBYPASSint





always @(SEsys)
begin
 if(supply_ok === 1'b1) begin 
  if(CKint_dft === 0 && ATPint === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
    if(SE_reg === 1'b1 && SEsys === 1'b0) begin
      if(TBYPASSsys === 1'b1) begin
  
     
         
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],
scanreg_dr_wire[10],
scanreg_dr_wire[11],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9],
scanreg_dl_wire[10], scanreg_dl_wire[scanlen_l-1]};
           
      


        for (i = 0; i < Bits; i = i + 1)
        begin
         if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
        end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
      end
    end
  end
  if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0) begin
      if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
  end 
  else if ((TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint === X && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end   
end

//assign output data
`ifdef functional        

   
always @(SDLOint)
#0.001 delSDLO_data<=SDLOint;

always @(SDROint)
#0.001 delSDRO_data<=SDROint;

 
always @(SCTRLOint)
#0.001 delSCTRLO_data<=SCTRLOint;


always @(OutReg_data)
   #0.001 delOutReg_data = OutReg_data;
`else
`endif

/***************************** Embeded switch functionality starts here ***********************************/





always @(STDBYint)
begin
  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0 && STDBYint !== 1'b0)
    begin
      ScanOutX;
      ScanChainX;
     delScanOutX;     
    end
  end
end



always @(SLEEPint)
begin


  if (SLEEPint !== 1'b1) begin
    time_fall_sleep = $realtime;
  end

  if (power_up_done === 0)
    begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
    end
  else begin
    if (SLEEPint === 1'b1 && lastSLEEP === 1'b0 ) begin 
      
    end
    else if (SLEEPint !== 1'b1 && lastSLEEP === 1'b1 && full_shutdown !== 1) begin 
      
      if (supply_ok !== 1 && ($realtime > 0)) begin
         if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID LOW_POWER) ERROR: ISOLATION signal removed from the memory but array and periphery supply is not completely switched on.Very High Current would be drawn by the memory. All further operations on memory are blocked",$realtime);
          WriteMemX;
          WriteOutX;
          ScanChainX;
          OutReg_data = WordX; 
          delOutReg_data=WordX;
          ScanOutX;//immediately;
          delScanOutX;//immediately;
          init_pulse_done = 0;
          power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            debug_level = 2'b11;
          `endif
          
      end        
      
       
    end   
    else if (SLEEPint === X && lastSLEEP === 1'b0 && full_shutdown !== 1'b1) begin 
     
    end 
  end  


  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && SLEEPint !== 0)
    begin
      ScanOutX;
      ScanChainX;
        delScanOutX;      
    end
  end

// if (init_pulse_done === 0)
//   begin
//     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
//   end
//
// else if ( SLEEPint !== 1 && (supply_ok !==1) ) begin
//    
//    WriteOutX;
//    OutReg_data = WordX; 
//    delOutReg_data=WordX;
//    ScanOutX;//immediately;
//    delScanOutX;//immediately;
//    ScanChainX;
//    WriteMemX;
//    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies with sleep/Power down signal being low.This scenario can lead to high dc currents and some reliability issues Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
// end

 print_sleep;    
 lastSLEEP=SLEEPint;
end

/********************************** Embeded switch functionality ends here *******************************/

task print_sleep;
begin
  if (SLEEPint === 1'b0) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been deasserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end  
  else if (SLEEPint === 1'b1) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been asserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_ACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif

  end        
  else begin
      if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) ERROR: SLEEP pin is at an invalid state.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INVALID in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end        
end
endtask





 

//// C28SOI non flip compiler power functionality 
always @(gndmreg )
begin
 if (power_up_done === 1 && $realtime > 0) begin    
    if(gndmreg !== 1'b0 ) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or gndsm is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
        corrupt_all;
        init_pulse_done = 0;
        power_up_done = 0;
     `ifdef NO_BLOCK_MEM
     `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of ground pins.Ground must be maintained at 0 Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime);
        debug_level = 2'b11;
     `endif   

    end   
 end

end




always @(vddmareg )
begin

if (vddmareg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddma(Array Supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 
    end
   end   
   else if (SLEEPint === 1) begin
    WriteMemX;
   end

end

if ((vddmareg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1 ) && $realtime > 0) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddm or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         corrupt_all;
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif

end


end

always @(vddmpreg )
begin
 if (vddmpreg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or vddsmp is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmp(Periphery Supply)/vddsmp(Substrate power supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 

    end
   end   
   else if (SLEEPint === 1) begin
    WriteOutX;
    ScanChainX;
    ScanOutX;
    delScanOutX;//immediately;
    OutReg_data = WordX; 
    delOutReg_data=WordX;
   end
 end

if( (vddmpreg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1'b1 )  && $realtime > 0) begin
         corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif
end
 
 
end


always @(vddmoreg)
begin
  if (power_up_done === 1 && $realtime > 0) begin   
      if (vddmoreg !== 1'b1)  begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin
           corrupt_all;
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
         end //if (vddmareg === 1'b1 

      else if (vddmareg === 1'b0 && vddmpreg === 1'b0   && SLEEPint === 1'b1 &&  $realtime > 0)
        begin 
            if((debug_level < 2) && ($realtime > 0)) $display("%m - %t WARNING: Illegal Value on power pin(s). Memory and Output Corrupted ", $realtime);
 
           corrupt_all;
        end //else if (vddmareg === 1'b 
     end   // if (vddmoreg !== 1'b1)
     else if (vddmoreg === 1'b1 && $realtime > 0 ) begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin     
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           corrupt_all;
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
        end        
     end // else if (vddmoreg === 1'b1
  end 
end // always @(vddmoreg)












always @(gndmreg) begin
 if (gndmreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 0. ",$realtime);
 end
 else if (gndmreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 1. ",$realtime);
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to invalid state. ",$realtime);
 end
end




 
always @(vddmareg) begin
 if (vddmareg === 0) begin 
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 0. ",$realtime);
  vddma_fall_time = $realtime;
 end
 else if (vddmareg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 1. ",$realtime);
  vddma_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to invalid state. ",$realtime);
  vddma_fall_time = $realtime;
 end 

 

end

always @(vddmpreg) begin
 if (vddmpreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 0. ",$realtime);
  vddmp_fall_time = $realtime;
 end
 else if (vddmpreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 1. ",$realtime);
  vddmp_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to invalid state. ",$realtime);
  vddmp_fall_time = $realtime;
 end

 
 
end



// end of C28SOI power functionality 
 


assign supply_ok          =  (vddmareg === 1'b1 && vddmpreg  === 1'b1  && gndmreg === 1'b0 && vddmoreg === 1'b1 ) ? 1'b1 : 1'b0;
assign core_supply_ok     =  (vddmoreg === 1'b1 && vddmareg === 1'b1 && gndmreg === 1'b0 ) ? 1'b1 : 1'b0;
assign peri_supply_ok     =  (vddmoreg === 1'b1 && vddmpreg === 1'b1 && gndmreg === 1'b0  ) ? 1'b1 : 1'b0;

assign full_shutdown = (vddmpreg === 1'b0 && vddmareg === 1'b0   ) ? 1'b1 : 1'b0 ;




`ifdef functional
`else


task WriteLocMskX_bwise;
   input [Addr-1 : 0] Address;
   input [Bits-1 : 0] Mask;

reg [Bits+Red_extrabit:0] tempReg1;
integer num1; 
begin
   tempReg1 = WordX;
   if (^Address !== X )
   begin
      tempReg1 = Mem[Address];
             
      for (j = 0;j< Bits; j=j+1) begin
         num1=j;
        if (Mask[j] === 1'bx)
            tempReg1[num1] = 1'bx;
      end
      Mem[Address] = tempReg1;
      task_insert_faults_in_memory;
   end//if (^Address !== X
   else begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      WriteMemX;
   end   
end
endtask


/****************Actions taken on timing violations*****************/

 always @(TimingViol_data)
// tds or tdh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  for (l = 0; l < Bits; l = l + 1) begin   
    if (CSWEMTBYPASS[l] !== 0) begin
     if((TimingViol_data[l] !== TimingViol_data_last[l])) begin


         Mreg[l] = 1'bx;
     end    
     WriteLocMskX_bwise(Areg,Mreg);
    end   
   end 
  end
    if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin
     scanreg_dl =1'bx; 
     scanreg_dr =1'bx; 
     SDLOint=X;
     SDROint=X;
     `ifdef functional
     `else
     SDLO_data<=1'bx;
     SDRO_data<=1'bx;
     `endif
    end
     TimingViol_data_last = TimingViol_data; 
end





always @(TimingViol_addr)
// tas or tah
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
      scanreg_ctrl=1'bx; 
      SCTRLOint=X;
      `ifdef functional
      `else
      SCTRLO_data<=1'bx;
      `endif
  end
end


always @(TimingViol_WEN)
//tws or twh
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WEN pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end 

always @(TimingViol_CSN )
// tps or tph 
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;

   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CSN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end

always @(TimingViol_tcycle )
//tcycle
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
   if (MEMEN !== 0 && MEMEN_prev !== 0) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckl )
// tckl 
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckh) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end


always @(TimingViol_tcycle_se )
//tcycle_se
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckl_se  )
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckh_se) begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tbist) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
   end
   if (TBYPASSint !== 1'b0) begin 
    WriteOutX;
   end 
   if (INITNreg !==0 && STDBYreg !== 1 && TBYPASS_reg !== 1 && SLEEPreg !== 1 && SE_reg !== 1 && IGreg !== 1 && DEreg !== 1) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBIST pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end






always @(TimingViol_tbypass)
//ttmck
begin
#0  
  WriteOutX;
  if (INITNreg !== 0 && SLEEPreg !== 1 && SE_reg !== 1 && STDBYreg !== 1 &&  DEreg !== 1) begin
   Invalid_next_cycle_dft_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
end



always @(TimingViol_sleep)
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_stdby)
begin
#0
  if (CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin 
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (ATPreg !== 0) begin 
   Invalid_next_cycle_dft_tim;
  end
end






always @(TimingViol_se) begin
#0
   if (TBYPASS_reg !== 0) begin 
    WriteOutX;
   end 
  if (TBYPASS_reg === 0) begin
     WriteOutX;
     WriteMemX;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE timing violation  Memory State Machine is corrupted. Output Corrupted ",$realtime); 
  end 
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
  end
end

always @(TimingViol_sctrli) begin
  scanreg_ctrl=1'bx; 
end


always @(TimingViol_sdli) begin
 scanreg_dl=1'bx; 
end

always @(TimingViol_sdri) begin
   scanreg_dr=1'bx;
end

 

always @(TimingViol_initnl) begin
init_pulse_done=0;
WriteOutX;
OutReg_data = WordX; 
delOutReg_data=WordX;
ScanOutX;
delScanOutX;
ScanChainX;
WriteMemX;
end

always @(TimingViol_initn) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end

always @(TimingViol_ig) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && INITNreg !== 0 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: IG pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   ScanChainX;
   ScanOutX;
   delScanOutX;       
  end
end

always @(TimingViol_atp) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin  
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_rm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^WMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: RM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
   end
end
 
always @(TimingViol_wm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^RMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);        
   end
end 


`endif


endmodule




module ST_SPREG_LOLEAK_32x24m4_Tl_lock_up_latch (EN,D,Q);
input EN,D;
output reg Q;

  always @ (EN or D) begin
    if (EN === 1) begin
       Q = D;
    end
    else if ((EN === 1'bz || EN === 1'bx  )&& D !== Q) begin
        Q=1'bx;
    end    
  end
endmodule

module ST_SPREG_LOLEAK_32x24m4_Tl_SCFF (D,TI,TE,CP,Q,OUTX);
input D,TI,TE,CP;
input OUTX;
output reg Q;
wire Dint;
assign Dint= (TE===1)?TI:(TE===0)?D:1'bx;

always @(posedge CP)
        begin
          if(Dint === 1'bZ || CP ===1'bx || OUTX === 1'bx)
          begin
                  Q = 1'bx;
          end
          else
          begin
                  Q = Dint;
          end        
        end
always @(posedge OUTX)
Q = 1'bx;
endmodule



`undef setup_time
`undef hold_time
`undef access_time
`undef retain_time
`undef cycle_time
`undef pulse_width_time
`undef initin_low_pulse


`delay_mode_path
`endcelldefine
`nosuppress_faults






/****************************************************************
--  Description         : Verilog Model 
--  ModelVersion        : 1.2
--  Date                : Apr, 2013
--  Changes Made by	: PS
--  Revision History    : 
 
****************************************************************/


/******************** START OF HEADER****************************
   This Header Gives Information about the parameters & options present in the Model
   
   words = 128
   bits  = 22
   mux   = 2 
   
   
   
   write_mask = no 
   
   margin_control = yes 
   
   
   Dft = Yes  

    ------------------------------------------------------------------------------------
     Signal Name             | Description       |             Port Mode        | Active When
                             |                   |          r    |  w   | rw    |
   ------------------------------------------------------------------------------------

    D 	        Data in                     na     x      na       -  
    IG    Input Gate Enable           x      x      na       High     
    ATP            ATPG Enable                 x      x      na       High     
    INITN                 INITN pin                   x      x      na       Low
    
    
     
    Q 	        Data out	            x      na     na       -
    A              Address                     x      x      na       high and low
    
    CK                Clock	                    x      x      na       posedge
    CSN          Chip Enable                 x      x      na       low
    
    RM         Read Margins                 x      x      na       High 
    SCTRLI         Scan Input (Control)
    SCTRLO        Scan Output (Control)
    SDLI         Scan Input (Data-Left)
    SDLO        Scan Output (Data-Left)
    SDRI         Scan Input (Data-Right)
    SDRO        Scan Output (Data-Right)
    SE          Scan Enable pin 
    STDBY              Standby pin                 x      x      na       High
    
    SLEEP                        Sleep pin                   x      x      na        High 
    
     
     
    TBIST          Bist Enable Pin 
    
    TBYPASS                      Memory Bypass                na     na     na        High
    
    TED        Bist Even Data pin
    TOD         Bist Odd Data Pin
     
    TA         Bist Read Address
    TCSN     Bist Read Chip Select
    
    TWEN    Bist Write Enable 
    WEN         Write Enable                na     x      na       Low 
    
    WM        Write Margins Code          x      x      na       -
     

******************** END OF HEADER ****************************/


//********************************************//
// ST_SPREG_LOLEAK_128x22m2_Tl Verilog Model                 //  
//********************************************//




`ifdef slm
        `define functional
`endif

`celldefine
`suppress_faults
  `ifdef functional
   `delay_mode_unit
  `else
   `delay_mode_path
  `endif

`define setup_time 0.0
`define hold_time 0.0
`define access_time 1.0
`define retain_time 0.9
`define cycle_time 0.0
`define pulse_width_time 0.0
`define initin_low_pulse 0.0



 






`timescale 1ns / 1ps


module ST_SPREG_LOLEAK_128x22m2_Tl (A,ATP,CK,CSN,D ,IG,INITN , Q ,RM    ,SCTRLI,SCTRLO,SDLI,SDLO,SDRI,SDRO,SE,SLEEP   , STDBY  ,TA,TBIST   ,TBYPASS ,TCSN,TED ,TOD   ,TWEN ,WEN,WM  );

 parameter
  Words = 128,
  Bits = 22,
  Addr = 7,
  mux = 2,
  repair_address_width = 6,
  write_margin_size = 2, 
  read_margin_size = 3; 

 //  INPUT OUTPUT PORTS DECLARATION DONE SEPARATELY FOR SPREG and ROM
 // ========================


        output [Bits-1 : 0] Q;
         
        output SCTRLO;
        input SE,SCTRLI;
        
        input [Addr-1 : 0] A;
        
        input [read_margin_size-1 : 0] RM;
        
         
        input CK,CSN,INITN,IG,ATP; 
        
        
        input [Addr-1 :0 ] TA;
input TBIST,TCSN ;
        
        input STDBY;
        
        input SLEEP; 
        
         
        
        
         
        output SDLO;
        output SDRO;
        
        
        
        
        input [Bits-1 : 0] D ;
	
          
         
        
        input [write_margin_size-1 : 0] WM;
        
        
        input TBYPASS;
        
        input WEN;
        
        
         
        input SDLI,SDRI  ; 
        
        
        
        //Bist inputs
        // ===========
        input TWEN,TED,TOD; 
        
        
        
        

        






    parameter
        Fault_file_name = "ST_SPREG_LOLEAK_128x22m2_Tl_faults.txt",
        `ifdef ConfigFault
        ConfigFault = 1,
        `else
        ConfigFault = 0,
        `endif
        max_faults = 130,
        
        MEM_INITIALIZE  = 1'b0,
        BinaryInit = 1'b0, 
        InitFileName = "ST_SPREG_LOLEAK_128x22m2_Tl.cde",
        Debug_mode = "all_warning_mode",
        File_load_time=0,
        Initn_reset_value={22{1'b0}},
        InstancePath = "ST_SPREG_LOLEAK_128x22m2_Tl";
    
    parameter
        
        bank = 1, 
        mux_bits=1,
        Red_extrabit=0,
        bank_bits = 0,
        RedWords = mux * 2 * bank,
        max_address_bits = 15 ,
        Rows = Words/mux;

  
    parameter 

     

        
           scanchains=3,    
          
        
        scanlen_ctrl=15,
        
        

      

        
        
        scanlen_r=(2*(Bits/4)),
        
        scanlen_l=(Bits-(2*(Bits/4)))  ; 
      
      

    parameter
        
        `ifdef functional  
            RW_assertions_en = 0,
        `endif
        WordX = {Bits{1'bx}},
        AddrX = {Addr{1'bx}},
        Word0 = {Bits{1'b0}},
        X = 1'bx;
   



//  WIRE DECLARATION RELATED TO POWER PINS
//  ======================================
	
        wire supply_ok, full_shutdown;
        
        wire core_supply_ok;
        wire peri_supply_ok;

        wire gndmint, gndsmint;
         
        
        wire vddmpint;
        wire vddmoint;
        wire vddmaint;
        wire vddsmpint;  
        wire vddsmaint;  
        
        

//  WIRE DECLARATION 
//  ==================
        wire [Bits-1 : 0] CSWEMTBYPASS;
        wire [Bits-1 : 0] Dint, Dsys;
        wire [Bits-1 : 0] Mint; 
        wire [22-1:0] Msys;
	wire [Addr-1 : 0] Aint;
        wire [Addr-1 : 0] Asys;

       


        wire [max_address_bits-1 : 0] A_int; 
                
	wire CKint_dft;
	wire CKint_func;
	wire CSNint;
        wire MEMEN;
        wire MEMEN_dft;
        wire TSE;

	wire WENint;
	wire WENsys;
        wire SLEEPint;
        wire STDBYint;
        wire SEint;
        wire SEsys;
        wire SCTRLIint;
        wire SDLIint;
        wire SDRIint;
        
        wire INITNint;
        wire TBYPASSint;
        wire TBYPASSsys;
        wire LSint; 
        wire HSint; 
        wire ATPint;
        wire DEint;
        
        wire [Addr-1 : 0] TAint;
        wire TBISTint;
        wire TBISTsys;
        wire TCSNint;
        wire TEDint;
        wire TODint;
        wire TEMint;
        wire TOMint;
        wire [Bits-1 : 0] TMint;
        wire [Bits-1 : 0] TDint;
        wire TWENint;
        wire IGint;
        wire IGbuf;
        wire CSNbuf;
        wire WENbuf;
        wire [read_margin_size-1:0] RMint;
        wire [write_margin_size-1:0] WMint;

        //Wires for scan chains
        //  ====================     
        wire [scanlen_ctrl -1:0]scanreg_ctrl_wire;
        wire [scanlen_l -1:0]  scanreg_dl_wire; 
        wire [scanlen_r -1:0]  scanreg_dr_wire; 
   
        wire [scanlen_l -1:0]  scanreg_ml_wire; 
        wire [scanlen_r -1:0]  scanreg_mr_wire; 


        wire [repair_address_width -1 : 0] RRAint;
        wire RRAEint;
        wire TRRAEint;    
        wire red_en;
        wire [repair_address_width -1 : 0] repair_add, next_repair_add;


//  REG DECLARATION
//  ====================     
        reg MEMEN_reg;
        reg MEMEN_prev;
        reg reg_mem_block;
        reg flag_mem_block;
        reg SCTRLIint_temp;
        reg SDLIint_temp;
        reg SDRIint_temp;
        reg SMLIint_temp;
        reg SMRIint_temp;

        //  REG DECLARATION
        //  ====================
        reg SCTRLOint;
        
        reg SDLOint,SDROint;
         
        
        reg next_cycle_corrupt_func;
        reg next_cycle_corrupt_dft;
        reg [Bits-1 : 0] delOutReg_data;//delayed Output Register
        reg [Bits-1 : 0] OutReg_data;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_tbypass;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_scan;   // Data Output registe
        reg [Bits-1 : 0] OutReg_rado_retained;   // register for retaining rado data when SLEEP --> 1
        reg delSCTRLO_data,SCTRLO_data;      // delayed Output Register
        reg delSDLO_data,SDLO_data;      // delayed Output Register
        reg delSDRO_data,SDRO_data;      // delayed Output Register
        
        
        // SCAN CHAINS register
        reg scanreg_ctrl; 
        reg scanreg_dl; 
        reg scanreg_dr; 
        
        
        reg CK_sc;
        reg Latch_open=0;
        reg lastCK_dft,CKreg_dft;
        reg lastCK_func,CKreg_func;
        reg lastSLEEP;
        reg lastPSWLARGEMP,lastPSWLARGEMA,lastPSWSMALLMP,lastPSWSMALLMA;
        reg CSNreg;
        reg init_pulse_done; //if == 1 then it implies that initb low pulse has been applied
        reg power_up_done; //if == 1 then it implies that power up has been done
        `ifdef slm
        `else
	      
             reg [Bits-1 : 0] Mem [Words-1 : 0];
             reg [Bits-1 : 0] RedMem [RedWords-1 : 0];
 
        `endif
        
	reg [Bits-1 :0] Mem_temp;
        reg [Bits-1 :0] Mem_slm; 
	reg ValidAddress;
	reg ValidDebugCode;
        reg decoding_start;
        reg file_loaded;
        reg [Bits-1 :0] Dreg;
        reg [Bits-1 :0] Mreg;
        reg WENreg;
        reg [Addr-1 :0] Areg;
        reg SE_reg;
        reg TBYPASS_reg;
        reg INITNreg;
        reg IGreg;
        reg DEreg;
        reg SLEEPreg;
        reg STDBYreg;
        reg ATPreg;
        reg MEMEN_dft_reg;
        reg MEMEN_dft_prev;
        reg RRMATCHreg;
        reg RRMATCHreg_last;//changes_made
        reg RRMATCHreg_glitch;
        reg [repair_address_width -1 : 0] repair_add_last;
        reg RRAEint_last;
        reg [Addr-mux_bits-1:0] row_add_temp;
        reg [Addr-mux_bits-bank_bits-1:0] row_add_cmp_temp;

       
        //parameter registers
        reg [2047:0] reg_Fault_file_name;
        reg reg_ConfigFault;
        reg reg_MEM_INITIALIZE;
        reg reg_BinaryInit;
        reg [2047:0] reg_InitFileName;
        reg [Bits -1 :0] reg_Initn_reset_value;
        time reg_File_load_time;

        //Power Supply Registers        
        reg vddmireg;
        reg vddmreg;
        reg vddsmreg;
        reg gndmreg;
        reg gndsmreg;   
        reg vddmpreg;
        reg vddmpireg;
        reg vddmareg;
        reg vddsmpreg;
        reg vddsmareg;
        reg vddmoreg;
        time vddmp_rise_time;
        time vddmp_fall_time;
        time vddsmp_rise_time;
        time vddsmp_fall_time;
        time vddma_rise_time;
        time vddma_fall_time;
        time vddsma_rise_time;
        time vddsma_fall_time;
        reg reg_check_rise;
        reg reg_check_fall;
        reg reg_check_rise_vddma;
        reg reg_check_fall_vddsma;
        reg  reg_check_rise_vddm, reg_check_fall_vddsm ;
        time vddm_fall_time,  vddm_rise_time,  vddsm_fall_time, vddsm_rise_time ;
  /* This register is used to force all warning messages 
  ** OFF during run time.
  ** It is a 2 bit register.
  ** USAGE :
  ** debug_level_off = 2'b00 -> ALL MESSAGES(INFO/WARNINGS/ERRORS) will be DISPLAYED 
  ** debug_level = 2'b01     -> ONLY WARNINGS/ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b10     -> ONLY ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b11     -> NO MESSAGES will be DISPLAYED.
  */ 
        reg [1:0] debug_level;
        reg [8*10: 0] operating_mode;
        reg [8*44: 0] message_status;

        integer i, k, j, l,m,q,w,r,s,num1,redcnt,n,num2,FirstHalf,Bfaileff,memcnt,ptr;
        integer decoder[Bits-1:0];
        `ifdef slm
           integer MemAddr;
        `endif


        //************************************************************
        //****** CONFIG FAULT IMPLEMENTATION VARIABLES*************** 
        //************************************************************ 

        integer file_ptr, ret_val;
        integer fault_word;
        integer fault_bit;
        integer fcnt, Fault_in_memory,faultnum,stop_loop,count;
        integer t;  
        integer FailureLocn [max_faults -1 :0];
        integer Failurebit [max_faults -1 :0];
        reg [100 : 0] stuck_at;
        reg [100 : 0] fault_array;
        reg [200 : 0] tempStr;
        reg [7:0] fault_char;
        reg [7:0] fault_char1; // 8 Bit File Pointer
        reg [Addr -1 : 0] std_fault_word;
        reg [Addr -1 : mux_bits] fault_row_add [max_faults -1 :0];
        reg [max_faults -1 :0] fault_repair_flag;
        reg [max_faults -1 :0] dont_insert_fault;
        reg [max_faults -1 :0] repair_flag;
        reg [100 : 0] array_stuck_at[max_faults -1 : 0] ;
        reg [100 : 0] mem_red_array_stuck_at[max_faults -1 : 0] ; 
        reg msgcnt;
        
       
        reg [Bits - 1: 0] stuck_at_0fault [max_faults -1 : 0];
        reg [Bits - 1: 0] stuck_at_1fault [max_faults -1 : 0];
        reg [Bits -1 : 0] stuck0;
        reg [Bits -1 : 0] stuck1;

        reg [Bits+Red_extrabit :0] Mem_last;
        

        `ifdef slm
        reg [Bits -1 : 0] slm_temp_data;
        `endif
        
        real time_CK_func_rise , time_RADCK_rise;
        real time_fall_sleep,time_fall_PSWLARGEMP,time_fall_PSWLARGEMP_0,time_fall_PSWLARGEMA,time_fall_PSWLARGEMA_0,time_fall_PSWSMALLMP,time_fall_PSWSMALLMA;
        integer flag_error;
        
//BUFFER INSTANTIATION
//=========================
       `ifdef functional
       
         buf (SCTRLO,delSCTRLO_data); 
         buf bufq [Bits-1:0] (Q,delOutReg_data);
      `else
       
         buf (SCTRLO,SCTRLO_data);
         buf bufq [Bits-1:0] (Q,OutReg_data);
      `endif
      
  
        buf (SEsys,SE);
	buf (SCTRLIint, SCTRLI);
   

	buf (CKint_func, CK);
	buf (CKint_dft, CK);
        buf bufaddr [Addr-1:0] (Asys,A);
        buf (INITNint,INITN);
        
        buf (LSint,1'b0); 
        buf (IGbuf,IG);
        buf (ATPint,ATP);

        buf bufTaddr [Addr-1 : 0] (TAint,TA);
        buf (TBISTsys,TBIST);
        buf (TCSNint,TCSN);

        buf (CSNsys,CSN);
        buf (STDBYint,STDBY );   
        
        buf (SLEEPint,SLEEP ); 

        buf bufrm [read_margin_size-1:0] (RMint, RM); 

        
        

        assign RRAEint = 1'b0;
        assign TRRAEint = 1'b0;
        assign repair_add = 0;
        assign next_repair_add = 0;
        assign red_en = 1'b0; 
        
        
        
        
        
        
        
        buf (PSWLARGEMPint,1'b0);
        buf (PSWSMALLMPint,1'b0); 
        buf (PSWLARGEMAint,1'b0);
        buf (PSWSMALLMAint,1'b0);   

      `ifdef functional
       
       
         buf (SDLO,delSDLO_data);
         buf (SDRO,delSDRO_data);
        
      `else
       
         buf (SDLO,SDLO_data);
         buf (SDRO,SDRO_data);
         
      `endif
       
         
       
        buf bufdata [Bits-1:0] (Dsys,D);
        
        
        assign Msys=22'b0; 
	

        
        buf (TBYPASSsys, TBYPASS);
        


        buf (WENsys,WEN);
	 
	buf (SDLIint, SDLI);
	buf (SDRIint, SDRI);
	 
        
        buf (HSint,1'b0); 

        
        buf (TEDint,TED);
        buf (TODint,TOD);
         
        buf (TWENint,TWEN);
        
        
        buf bufwm [write_margin_size-1:0] (WMint, WM); 
        



//      assign scanreg_ctrl_wire={scanreg_ctrl[scanlen_ctrl - 2:0],SCTRLIint};
//      assign scanreg_dl_wire={scanreg_dl[scanlen_l - 2:0],SDLIint};
//      assign scanreg_dr_wire={scanreg_dr[scanlen_r - 2:0],SDRIint};
      
        
      assign Aint   = (TBISTint === 1'b0 ) ? Asys : (TBISTint === 1'bx ) ? {Addr{1'bx}} : TAint;  

        
//        assign A_int = Aint;
	
        
                
        assign Dint[0] = (TBISTint === 1'b0) ? Dsys[0] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[1] = (TBISTint === 1'b0) ? Dsys[1] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[2] = (TBISTint === 1'b0) ? Dsys[2] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[3] = (TBISTint === 1'b0) ? Dsys[3] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[4] = (TBISTint === 1'b0) ? Dsys[4] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[5] = (TBISTint === 1'b0) ? Dsys[5] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[6] = (TBISTint === 1'b0) ? Dsys[6] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[7] = (TBISTint === 1'b0) ? Dsys[7] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[8] = (TBISTint === 1'b0) ? Dsys[8] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[9] = (TBISTint === 1'b0) ? Dsys[9] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[10] = (TBISTint === 1'b0) ? Dsys[10] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[11] = (TBISTint === 1'b0) ? Dsys[11] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[12] = (TBISTint === 1'b0) ? Dsys[12] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[13] = (TBISTint === 1'b0) ? Dsys[13] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[14] = (TBISTint === 1'b0) ? Dsys[14] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[15] = (TBISTint === 1'b0) ? Dsys[15] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[16] = (TBISTint === 1'b0) ? Dsys[16] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[17] = (TBISTint === 1'b0) ? Dsys[17] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[18] = (TBISTint === 1'b0) ? Dsys[18] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[19] = (TBISTint === 1'b0) ? Dsys[19] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[20] = (TBISTint === 1'b0) ? Dsys[20] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[21] = (TBISTint === 1'b0) ? Dsys[21] : (TBISTint === 1'b1) ? TODint : 1'bx;          
	 
        assign Mint = 22'b0;
         

        assign WENbuf = (TBISTint === 1'b0 ) ? WENsys : (TBISTint === 1'bx ) ? 1'bx : TWENint;  
        assign WENint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? WENbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[13] : (ATPint === 1'b0 ) ? WENsys : 1'bx ; 
        
        assign CSNbuf = (TBISTint === 1'b0 ) ? CSNsys : (TBISTint === 1'bx ) ? 1'bx : TCSNint;  
        assign CSNint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? CSNbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[11] : (ATPint === 1'b0 ) ? CSNsys : 1'bx ; 
        assign IGint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? IGbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[14] : (ATPint === 1'b0 ) ? IGbuf : 1'bx;

        
        assign DEint = (LSint === 1'bx || (LSint === 1'b0 && HSint === 1'bx) || ^RMint !== 1'b0 || ^WMint !== 1'b0 ) ? 1'bx : 1'b0;
        
     
     and (TBISTint, ATPint, TBISTsys);
     and (SEint, ATPint, SEsys);
     and (TBYPASSint, ATPint, TBYPASSsys);
     and (TSE,TBYPASSint,!SEsys);
     and (MEMEN,INITNint,!CSNint,!SLEEPint,!TBYPASSint,!SEint,!IGint,!DEint,!STDBYint );
     and (MEMEN_dft,INITNint, !SLEEPint, ATPint,!STDBYint);

 `ifdef functional
/*****************assertions added to optimize dynamic power consumption**********/

//psl a_M: assert always ({( RW_assertions_en);(MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1))  } |-> (stable(Msys))) @(posedge CK); 

//psl a_WEN: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(WENsys))) @(posedge CK); 

//psl a_A: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(Asys))) @(posedge CK); 

//psl a_D: assert always ({( RW_assertions_en);((MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1)) && TBYPASSint === 1'b0)  } |-> (stable(Dsys))) @(posedge CK); 

/**********************************************************************************************/
`endif       

     

         
reg vddmp,vddmo, vddma, vddsmp, vddsma, gndsm, gndm,  vddmpi ; 
 
initial 
begin

        vddmp = 1'b1 ; 
        vddmo = 1'b1 ;
        vddma = 1'b1 ;
        
        vddsmp = 1'b1 ;
        
        
         gndm = 1'b0 ;
          
end

        
         assign gndmint = (reg_mem_block === 0) ? gndm : 1'b1;
         
         
         
         
         assign vddmpint = vddmp;
         assign vddmoint = vddmo;
         assign vddmaint = vddma;
         
          
        
         

        //CPF Changes

        
                
        initial
        begin : cpfvddmp 
           vddmpreg = vddmpint;
        end

        always @(vddmpint) begin
           vddmpreg = vddmpint;
        end
        
        initial
        begin : cpfvddmo 
           vddmoreg = vddmoint;
        end

        always @(vddmoint) begin
           vddmoreg = vddmoint;
        end
        
        initial
        begin : cpfvddma 
           vddmareg = vddmaint;
        end

        always @(vddmaint) begin
           vddmareg = vddmaint;
        end

        
        
 
        initial
        begin : cpfgndm 
           gndmreg = gndmint;
        end

        always @(gndmint) begin
           gndmreg = gndmint;
        end

        
        



 `ifdef functional
  `else
  initial begin
    if (debug_level < 1) begin
     $display ("%m  INFORMATION");
     $display ("***************************************");
     $display ("The Model is Operating in TIMING MODE");
     $display ("Please make sure that SDF is properly annotated otherwise dummy values will be used");
     $display ("%s", message_status);
     $display ("***************************************");
    end
  end

//////////////////////////
 //REG DECLARATIONS
   //======================

   reg [Bits-1 : 0] TimingViol_data;
   reg  [Bits-1 : 0] TimingViol_mask;
   reg [Bits-1 : 0] TimingViol_data_last, TimingViol_mask_last;
	reg TimingViol_data_0;
	reg TimingViol_data_1;
	reg TimingViol_data_2;
	reg TimingViol_data_3;
	reg TimingViol_data_4;
	reg TimingViol_data_5;
	reg TimingViol_data_6;
	reg TimingViol_data_7;
	reg TimingViol_data_8;
	reg TimingViol_data_9;
	reg TimingViol_data_10;
	reg TimingViol_data_11;
	reg TimingViol_data_12;
	reg TimingViol_data_13;
	reg TimingViol_data_14;
	reg TimingViol_data_15;
	reg TimingViol_data_16;
	reg TimingViol_data_17;
	reg TimingViol_data_18;
	reg TimingViol_data_19;
	reg TimingViol_data_20;
	reg TimingViol_data_21;
 reg TimingViol_mask_0;
 reg TimingViol_mask_1;
 reg TimingViol_mask_2;
 reg TimingViol_mask_3;
 reg TimingViol_mask_4;
 reg TimingViol_mask_5;
 reg TimingViol_mask_6;
 reg TimingViol_mask_7;
 reg TimingViol_mask_8;
 reg TimingViol_mask_9;
 reg TimingViol_mask_10;
 reg TimingViol_mask_11;
 reg TimingViol_mask_12;
 reg TimingViol_mask_13;
 reg TimingViol_mask_14;
 reg TimingViol_mask_15;
 reg TimingViol_mask_16;
 reg TimingViol_mask_17;
 reg TimingViol_mask_18;
 reg TimingViol_mask_19;
 reg TimingViol_mask_20;
 reg TimingViol_mask_21;

   reg TimingViol_addr;
   reg TimingViol_CSN, TimingViol_WEN, TimingViol_tbypass;
   reg TimingViol_tckh, TimingViol_tckl, TimingViol_tcycle;
   reg TimingViol_tckh_se, TimingViol_tckl_se, TimingViol_tcycle_se;
   reg TimingViol_sctrli,TimingViol_sdli,TimingViol_sdri,TimingViol_se;
   reg TimingViol_smli,TimingViol_smri;
   reg TimingViol_sctrli_flag,TimingViol_sdli_flag,TimingViol_sdri_flag;
   reg TimingViol_smli_flag,TimingViol_smri_flag;
   reg TimingViol_initnl;
   reg TimingViol_initn;
   reg TimingViol_ls;
   reg TimingViol_hs;
   reg TimingViol_sleep;
   reg TimingViol_stdby;
   reg TimingViol_rm;
   reg TimingViol_wm;
   reg TimingViol_tbist,TimingViol_ig,TimingViol_atp,TimingViol_TED,TimingViol_TOD,TimingViol_TEM,TimingViol_TOM;
   reg TimingViolRRAE,TimingViolRRA;

   wire CSTBYPASSN,cond_sdf_tas,cond_sdf_tds,cond_sdf_tms,cond_sdf_tws,cond_sdf_tbas,cond_sdf_tbps,cond_sdf_tbws,cond_sdf_tbdes,cond_sdf_tbdos,cond_sdf_tbmes,cond_sdf_tbmos;
   wire SETB_EN,CSIG_EN,MEM_ACT,EN_ADM,CS_EN,CS_ADM,cond_sdf_tps,IG_EN,IG_ADM,cond_sdf_tigs,cond_sdf_taa,cond_sdf_taa_ls1,cond_sdf_taa_hs1,cond_tseq_tm;
   wire cond_sdf_tcycle,cond_sdf_tcycle_ls1,cond_sdf_tcycle_hs1,cond_sdf_tcycle_se,cond_sdf_tckl_se,cond_sdf_tsctrlis,cond_sdf_tsdlis,cond_sdf_tsdris,cond_sdf_tsmlis,cond_sdf_tsmris;
   wire cond_sdf_tckh_se,cond_sdf_taa_sctrlo_se,cond_sdf_taa_sdlo_se,cond_sdf_taa_sdro_se,cond_sdf_taa_smlo_se,cond_sdf_taa_smro_se,cond_sdf_tckl,cond_sdf_tckh;
   wire cond_sdf_ttms,cond_sdf_tbists,INITNandnotSLEEPandATPandnotSE,cond_sdf_taa_sctrlo,cond_sdf_taa_sdlo,cond_sdf_taa_sdro,cond_sdf_taa_smlo,cond_sdf_taa_smro;
   wire cond_sdf_taa_tm,cond_sdf_taa_tm_ls1, cond_sdf_taa_tm_hs1,cond_sdf_taa_tckq_tm,cond_sdf_taa_tseq_tm;

   wire CSWETBYPASSN;
   wire cond_sdf_tstdbys,cond_sdf_tsls,sleep_en,atp_csn_en;
   wire cond_sdf_tlss,cond_sdf_thss,cond_sdf_trms,cond_sdf_twms; 
   wire cond_sdf_tses,cond_sdf_tinitns;
   wire tby_se_en;
   wire rra_en;
   wire tbist_atp_en;
   wire rrae_en;
   wire tbist_rrae_en;
   wire cond_sdf_trraes;
   wire cond_sdf_ttrraes;
   wire cond_sdf_taa_trramatch;
   wire cond_sdf_ttrraematch;
   wire cond_sdf_tamatch;
   wire cond_sdf_ttamatch;
   wire cond_sdf_tatpmatch;
   wire cond_sdf_ttbistmatch;



 and (CSWEMTBYPASS[0], !Mreg[0], CSWETBYPASSN);
 and (CSWEMTBYPASS[1], !Mreg[1], CSWETBYPASSN);
 and (CSWEMTBYPASS[2], !Mreg[2], CSWETBYPASSN);
 and (CSWEMTBYPASS[3], !Mreg[3], CSWETBYPASSN);
 and (CSWEMTBYPASS[4], !Mreg[4], CSWETBYPASSN);
 and (CSWEMTBYPASS[5], !Mreg[5], CSWETBYPASSN);
 and (CSWEMTBYPASS[6], !Mreg[6], CSWETBYPASSN);
 and (CSWEMTBYPASS[7], !Mreg[7], CSWETBYPASSN);
 and (CSWEMTBYPASS[8], !Mreg[8], CSWETBYPASSN);
 and (CSWEMTBYPASS[9], !Mreg[9], CSWETBYPASSN);
 and (CSWEMTBYPASS[10], !Mreg[10], CSWETBYPASSN);
 and (CSWEMTBYPASS[11], !Mreg[11], CSWETBYPASSN);
 and (CSWEMTBYPASS[12], !Mreg[12], CSWETBYPASSN);
 and (CSWEMTBYPASS[13], !Mreg[13], CSWETBYPASSN);
 and (CSWEMTBYPASS[14], !Mreg[14], CSWETBYPASSN);
 and (CSWEMTBYPASS[15], !Mreg[15], CSWETBYPASSN);
 and (CSWEMTBYPASS[16], !Mreg[16], CSWETBYPASSN);
 and (CSWEMTBYPASS[17], !Mreg[17], CSWETBYPASSN);
 and (CSWEMTBYPASS[18], !Mreg[18], CSWETBYPASSN);
 and (CSWEMTBYPASS[19], !Mreg[19], CSWETBYPASSN);
 and (CSWEMTBYPASS[20], !Mreg[20], CSWETBYPASSN);
 and (CSWEMTBYPASS[21], !Mreg[21], CSWETBYPASSN);

and (atp_csn_en,!ATPint,!CSNint,!IGint);
or (sleep_en,atp_csn_en,ATPint);
or (SETB_EN,SEint,TBISTint);
and (ATP_SETB_EN,ATPint,SETB_EN); 
or (CSIG_EN,IGint,CSNint);
and (MEM_ACT,!ATPint,CSIG_EN);
or (EN_ADM,MEM_ACT,ATP_SETB_EN);
and (CS_EN,!ATPint,IGint);
or (CS_ADM,CS_EN,ATP_SETB_EN);
and (atp_ig_csn_en,!ATPint,!CSNint,!IGint);
and (atp_se_en,!SEsys,ATPint);
or (cycle_en,atp_ig_csn_en,atp_se_en);
and (atp_ig_csn_en_reg,!ATPreg,!CSNreg,!IGreg);
and (atp_se_en_reg,!SE_reg,ATPreg);
or (cycle_en_reg,atp_ig_csn_en,atp_se_en);
and (INITNandnotSLEEPandATPandnotSE,cond_gac,!SEsys,ATPint);
and (csn_ig_en,!IGint,!CSNint);
and (atp_tby_ls_en,atp_se_en,cond_ls_tby_en);
and (IG_EN,!ATPint,!CSNint);
or (IG_ADM,IG_EN,atp_se_en);
and (CSWETBYPASSN, !WENreg, 1'b1);



assign cond_sdf_tsls=((sleep_en && INITNint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tstdbys=((sleep_en && INITNint && !SLEEPint) !==0) ? 1:0;
assign cond_sdf_atps=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_gac=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tas=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tds=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tms=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tws=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tps=((cond_gac && !CS_ADM) !==0) ? 1:0;
assign cond_sdf_tcycle=((cond_gac && cycle_en && !LSint && !HSint) !==0) ? 1:0;  
assign cond_sdf_tcycle_ls1=((cond_gac && cycle_en && LSint) !==0) ? 1:0;
assign cond_sdf_tcycle_hs1=((cond_gac && cycle_en && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_tckh=((cond_gac && cycle_en_reg) !==0) ? 1:0;
assign cond_sdf_tckl=((cond_gac && cycle_en) !==0) ? 1:0;
assign cond_sdf_tcycle_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckl_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsctrlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckh_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_ttms=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_tbists=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_tckq_tm=((cond_gac && SE_reg && ATPreg && TBYPASSsys) !==0) ? 1:0;
assign cond_ls_en=((atp_ig_csn_en || atp_tby_ls_en) !==0) ? 1:0;
assign cond_sdf_tlss=((cond_ls_en && cond_gac) !==0) ? 1:0;
assign cond_sdf_thss=((cond_ls_en && cond_gac && !LSint) !==0) ? 1:0;
assign cond_sdf_trms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_twms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_tses=((cond_gac && ATPint) !==0) ? 1:0;
assign cond_sdf_tbas=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbps=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbws=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tigs=((cond_gac && IG_ADM) !==0) ? 1:0;
assign cond_sdf_taa=((MEMEN_reg && WENreg && !LSint && !HSint) !==0) ? 1:0; 
// assign cond_sdf_taa_tbypass_q = ((MEMEN_reg && ATPint && TBYPASSint) !== 1'b0) ? 1'b1 : 1'b0;
assign cond_sdf_taa_ls1=((MEMEN_reg && WENreg && LSint) !==0) ? 1:0; 
assign cond_sdf_taa_hs1=((MEMEN_reg && WENreg && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && !HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_ls1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && LSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_hs1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tseq_tm=((cond_gac && TBYPASSint) !==0) ? 1:0;
assign cond_sdf_tinitns =(( sleep_en && !STDBYint && !SLEEPint) !==0) ? 1:0;
assign cond_ls_tby_en=((TBYPASSsys || csn_ig_en) !==0) ? 1:0;



//specify block begins

specify
    specparam
    
         PATHPULSE$CK$Q = 0,
         PATHPULSE$CK$SCTRLO = 0,

         PATHPULSE$CK$SDLO = 0,
         PATHPULSE$CK$SDRO = 0,
        
         PATHPULSE$SE$Q = 0,
         
//         PATHPULSE$TBYPASS$Q = 0,


        
         
        
         tsls = `setup_time,
         tslh = `hold_time ,
         tstdbys = `setup_time,
         tstdbyh = `hold_time , 
	 

         
         tcycle = `cycle_time,
         
         
         tckh = `pulse_width_time,
         tckl = `pulse_width_time,
         tcycle_se = `cycle_time,
         tckh_se = `pulse_width_time,
         tckl_se = `pulse_width_time,
         
         ttms = `setup_time,
         ttmh = `hold_time ,
         tps = `setup_time,
         tph = `hold_time ,
         tws = `setup_time,
         twh = `hold_time ,
         tds = `setup_time,
         tdh = `hold_time , 
         tas = `setup_time,
         tah = `hold_time ,
         tses= `setup_time,
         tseh= `hold_time ,
         tsctrlis=`setup_time,
         tsctrlih=`hold_time ,
         tsdlis=`setup_time,
         tsdlih=`hold_time ,
         tsdris=`setup_time,
         tsdrih=`hold_time , 
         tbists=`setup_time,
         tbisth=`hold_time ,
         tbps=`setup_time,
         tbph=`hold_time ,
         tbws=`setup_time,
         tbwh=`hold_time ,
         tbdes=`setup_time,
         tbdeh=`hold_time ,
         tbdos=`setup_time,
         tbdoh=`hold_time ,
         
         tbas=`setup_time,
         tbah=`hold_time ,
         tinitnl=`initin_low_pulse,
         tinitns=`setup_time,
         tinitnh=`hold_time ,
         tatps=`setup_time,
         tatph=`hold_time ,
         tigs=`setup_time,
         tigh=`hold_time ,
         
         
         trms=`setup_time,
         trmh=`hold_time ,
         twms=`setup_time,
         twmh=`hold_time , 

/*************************************************************************************************/
           // taa_tbypass_q = `access_time,
           // th_tbypass_q  = `retain_time,
            taa =`access_time,
            th = `retain_time,

 


            taa_tm =`access_time,
            th_tm = `retain_time,

            
            taa_tseq_tm =`access_time,
            th_tseq_tm = `retain_time,
            taa_tckq_tm   = `access_time,
            th_tckq_tm    = `retain_time,
            taa_sctrlo=`access_time,
            th_sctrlo= `retain_time,
            taa_sdlo=`access_time,
            th_sdlo= `retain_time,
            taa_sdro=`access_time,
            th_sdro= `retain_time,
            
         
            taa_sctrlo_se=`access_time,
            th_sctrlo_se= `retain_time
,
            taa_sdlo_se=`access_time,
            th_sdlo_se= `retain_time,
            taa_sdro_se=`access_time,
            th_sdro_se= `retain_time
         ;  


        /*---------------------- Timing Checks ---------------------*/

	$setup(posedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[6], tah, TimingViol_addr);

	$setup(posedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(posedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(posedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(posedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(posedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(posedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(posedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(posedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(posedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(posedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(posedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(posedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(posedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(posedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(posedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(posedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(posedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(posedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(posedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(posedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(posedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(posedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$setup(negedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(negedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(negedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(negedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(negedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(negedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(negedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(negedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(negedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(negedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(negedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(negedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(negedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(negedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(negedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(negedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(negedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(negedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(negedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(negedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(negedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(negedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[21], tdh, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[21], tdh, TimingViol_data_21);

        



        $setup(posedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $setup(negedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, posedge WEN, twh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, negedge WEN, twh, TimingViol_WEN); 
        $setup(posedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$setup(negedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, posedge CSN, tph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, negedge CSN, tph, TimingViol_CSN);
        $period(posedge CK &&& cond_sdf_tcycle, tcycle, TimingViol_tcycle);  

        
        $width(posedge CK  &&& cond_sdf_tckh, tckh, 0, TimingViol_tckh);
        $width(negedge CK  &&& cond_sdf_tckl, tckl, 0, TimingViol_tckl);
        $period(posedge CK &&& cond_sdf_tcycle_se, tcycle_se, TimingViol_tcycle_se);
        $width(posedge CK  &&& cond_sdf_tckh_se, tckh_se, 0, TimingViol_tckh_se);
        $width(negedge CK  &&& cond_sdf_tckl_se, tckl_se, 0, TimingViol_tckl_se);

        
        $setup(posedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $setup(negedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $hold(posedge CK &&& cond_sdf_ttms, posedge TBYPASS, ttmh, TimingViol_tbypass); 
        $hold(posedge CK &&& cond_sdf_ttms, negedge TBYPASS, ttmh, TimingViol_tbypass); 
 



        
        $setup(posedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $setup(negedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $hold(posedge CK &&& cond_sdf_tsls, posedge SLEEP, tslh, TimingViol_sleep);        
        $hold(posedge CK &&& cond_sdf_tsls, negedge SLEEP, tslh, TimingViol_sleep);

        $setup(posedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $setup(negedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $hold(posedge CK &&& cond_sdf_tstdbys, posedge STDBY, tstdbyh, TimingViol_stdby);        
        $hold(posedge CK &&& cond_sdf_tstdbys, negedge STDBY, tstdbyh, TimingViol_stdby); 
        
        
        $setup (posedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
	$setup (negedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
        
        $hold (posedge CK &&& cond_sdf_tses, posedge SE ,tseh,TimingViol_se);
	$hold (posedge CK &&& cond_sdf_tses, negedge SE ,tseh,TimingViol_se);
        
        $setup(posedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis , tsctrlis, TimingViol_sctrli);
        $setup(negedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis, tsctrlis, TimingViol_sctrli);
        $hold(posedge CK &&& cond_sdf_tsctrlis , posedge SCTRLI, tsctrlih, TimingViol_sctrli);        
        $hold(posedge CK &&& cond_sdf_tsctrlis , negedge SCTRLI, tsctrlih, TimingViol_sctrli);

        $setup(posedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $setup(negedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $hold(posedge CK &&& cond_sdf_tsdlis, posedge SDLI, tsdlih, TimingViol_sdli);        
        $hold(posedge CK &&& cond_sdf_tsdlis, negedge SDLI, tsdlih, TimingViol_sdli);

        $setup(posedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $setup(negedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $hold(posedge CK &&& cond_sdf_tsdris, posedge SDRI, tsdrih, TimingViol_sdri);        
        $hold(posedge CK &&& cond_sdf_tsdris, negedge SDRI, tsdrih, TimingViol_sdri);
        
 
	
         
        $width(negedge INITN , tinitnl, 0, TimingViol_initnl);
        
        $setup(posedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        $setup(negedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        
        $hold (posedge CK &&& cond_sdf_tinitns,posedge INITN, tinitnh, TimingViol_initn);
        $hold (posedge CK &&& cond_sdf_tinitns,negedge INITN, tinitnh, TimingViol_initn);

        $setup(posedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $setup(negedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $hold(posedge CK &&& cond_sdf_atps, posedge ATP, tatph, TimingViol_atp);        
        $hold(posedge CK &&& cond_sdf_atps, negedge ATP, tatph, TimingViol_atp);
        
        $setup(posedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $setup(negedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $hold(posedge CK &&& cond_sdf_tigs, posedge IG, tigh, TimingViol_ig);        
        $hold(posedge CK &&& cond_sdf_tigs, negedge IG, tigh, TimingViol_ig);



         
$setup(posedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[2], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[2], trmh, TimingViol_rm); 

        
$setup(posedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(posedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[1], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[1], twmh, TimingViol_wm);
 
        
        $setup(posedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $setup(negedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $hold(posedge CK &&& cond_sdf_tbists, posedge TBIST, tbisth, TimingViol_tbist);        
        $hold(posedge CK &&& cond_sdf_tbists, negedge TBIST, tbisth, TimingViol_tbist);
        
        	$setup(posedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$setup(negedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[6], tbah, TimingViol_addr);
       	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[6], tbah, TimingViol_addr);

        $setup(posedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$setup(negedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, posedge TCSN, tbph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, negedge TCSN, tbph, TimingViol_CSN); 
       
        $setup(posedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $setup(negedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, posedge TWEN, tbwh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, negedge TWEN, tbwh, TimingViol_WEN);
       
       
        $setup(posedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $setup(negedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, posedge TED, tbdeh, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, negedge TED, tbdeh, TimingViol_TED);

        $setup(posedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $setup(negedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, posedge TOD, tbdoh, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, negedge TOD, tbdoh, TimingViol_TOD);

          


          

          /*-------------------- Propagation Delays ------------------*/
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa, taa, th, taa, th, taa);
                 

/* // //	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[0] +: OutReg_data[0])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[1] +: OutReg_data[1])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[2] +: OutReg_data[2])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[3] +: OutReg_data[3])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[4] +: OutReg_data[4])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[5] +: OutReg_data[5])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[6] +: OutReg_data[6])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[7] +: OutReg_data[7])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[8] +: OutReg_data[8])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[9] +: OutReg_data[9])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[10] +: OutReg_data[10])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[11] +: OutReg_data[11])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[12] +: OutReg_data[12])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[13] +: OutReg_data[13])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[14] +: OutReg_data[14])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[15] +: OutReg_data[15])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[16] +: OutReg_data[16])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[17] +: OutReg_data[17])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[18] +: OutReg_data[18])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[19] +: OutReg_data[19])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[20] +: OutReg_data[20])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[21] +: OutReg_data[21])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q); */ 








	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                





	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                 

	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[0] +: OutReg_data[0])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[1] +: OutReg_data[1])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[2] +: OutReg_data[2])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[3] +: OutReg_data[3])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[4] +: OutReg_data[4])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[5] +: OutReg_data[5])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[6] +: OutReg_data[6])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[7] +: OutReg_data[7])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[8] +: OutReg_data[8])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[9] +: OutReg_data[9])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[10] +: OutReg_data[10])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[11] +: OutReg_data[11])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[12] +: OutReg_data[12])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[13] +: OutReg_data[13])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[14] +: OutReg_data[14])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[15] +: OutReg_data[15])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[16] +: OutReg_data[16])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[17] +: OutReg_data[17])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[18] +: OutReg_data[18])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[19] +: OutReg_data[19])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[20] +: OutReg_data[20])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[21] +: OutReg_data[21])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                



if (cond_sdf_taa_sctrlo) 
        (posedge CK *> (SCTRLO :  SCTRLI)) = (taa_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo); 

if (cond_sdf_taa_sctrlo_se) 
        (negedge CK *> (SCTRLO : SCTRLI)) = (taa_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se); 
 

if (cond_sdf_taa_sdlo) 
        (posedge CK *> (SDLO :  SDLI)) = (taa_sdlo,taa_sdlo,th_sdlo,taa_sdlo,th_sdlo,taa_sdlo); 

if (cond_sdf_taa_sdlo_se) 
        (negedge CK *> (SDLO : SDLI)) = (taa_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se);

if (cond_sdf_taa_sdro) 
        (posedge CK *> (SDRO :  SDRI)) = (taa_sdro,taa_sdro,th_sdro,taa_sdro,th_sdro,taa_sdro); 

if (cond_sdf_taa_sdro_se) 
        (negedge CK *> (SDRO : SDRI)) = (taa_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se); 

  
     




endspecify //specify block ends






// conversion from registers to array elements for data setup violation notifiers

always @(TimingViol_data_0   or TimingViol_TED  )
begin
        TimingViol_data[0]=~TimingViol_data[0];   
end


always @(TimingViol_data_1   or TimingViol_TOD  )
begin
        TimingViol_data[1]=~TimingViol_data[1];   
end


always @(TimingViol_data_2   or TimingViol_TED  )
begin
        TimingViol_data[2]=~TimingViol_data[2];   
end


always @(TimingViol_data_3   or TimingViol_TOD  )
begin
        TimingViol_data[3]=~TimingViol_data[3];   
end


always @(TimingViol_data_4   or TimingViol_TED  )
begin
        TimingViol_data[4]=~TimingViol_data[4];   
end


always @(TimingViol_data_5   or TimingViol_TOD  )
begin
        TimingViol_data[5]=~TimingViol_data[5];   
end


always @(TimingViol_data_6   or TimingViol_TED  )
begin
        TimingViol_data[6]=~TimingViol_data[6];   
end


always @(TimingViol_data_7   or TimingViol_TOD  )
begin
        TimingViol_data[7]=~TimingViol_data[7];   
end


always @(TimingViol_data_8   or TimingViol_TED  )
begin
        TimingViol_data[8]=~TimingViol_data[8];   
end


always @(TimingViol_data_9   or TimingViol_TOD  )
begin
        TimingViol_data[9]=~TimingViol_data[9];   
end


always @(TimingViol_data_10   or TimingViol_TED  )
begin
        TimingViol_data[10]=~TimingViol_data[10];   
end


always @(TimingViol_data_11   or TimingViol_TOD  )
begin
        TimingViol_data[11]=~TimingViol_data[11];   
end


always @(TimingViol_data_12   or TimingViol_TED  )
begin
        TimingViol_data[12]=~TimingViol_data[12];   
end


always @(TimingViol_data_13   or TimingViol_TOD  )
begin
        TimingViol_data[13]=~TimingViol_data[13];   
end


always @(TimingViol_data_14   or TimingViol_TED  )
begin
        TimingViol_data[14]=~TimingViol_data[14];   
end


always @(TimingViol_data_15   or TimingViol_TOD  )
begin
        TimingViol_data[15]=~TimingViol_data[15];   
end


always @(TimingViol_data_16   or TimingViol_TED  )
begin
        TimingViol_data[16]=~TimingViol_data[16];   
end


always @(TimingViol_data_17   or TimingViol_TOD  )
begin
        TimingViol_data[17]=~TimingViol_data[17];   
end


always @(TimingViol_data_18   or TimingViol_TED  )
begin
        TimingViol_data[18]=~TimingViol_data[18];   
end


always @(TimingViol_data_19   or TimingViol_TOD  )
begin
        TimingViol_data[19]=~TimingViol_data[19];   
end


always @(TimingViol_data_20   or TimingViol_TED  )
begin
        TimingViol_data[20]=~TimingViol_data[20];   
end


always @(TimingViol_data_21   or TimingViol_TOD  )
begin
        TimingViol_data[21]=~TimingViol_data[21];   
end


`endif


// TASK DEFINITION DESCRIPTION
// ================================



task task_insert_faults_in_memory;
begin
   if (reg_ConfigFault)
   begin   
     for(i = 0;i< fcnt;i = i+ 1) begin
        if(mem_red_array_stuck_at[i] === "mem_array") begin
          if (array_stuck_at[i] === "sa0") begin
           `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data & stuck_at_0fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
          `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] & stuck_at_0fault[i];
          `endif
         end //if(array_stuck_at)
                                        
         if(array_stuck_at[i] === "sa1") begin
         `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data | stuck_at_1fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
         `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] | stuck_at_1fault[i]; 
         `endif
         end //if(array_stuck_at)
       end //if mem_red_array_stuck_at
    
    
     end    // end of for
   end  
end
endtask



task task_read_fault_file;
begin
/*  -----------Implemetation for config fault starts------*/
   msgcnt = X;
   t = 0;
   fault_repair_flag = {max_faults{1'b1}};
   repair_flag = {max_faults{1'b1}};
   if(reg_ConfigFault) 
   begin
      file_ptr = $fopen(reg_Fault_file_name , "r");
      if(file_ptr == 0)
      begin     
          if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: File cannot be opened ",$realtime);
      end        
      else                
      begin : read_fault_file
        t = 0;
        for (i = 0; i< max_faults; i= i + 1)
        begin
         
           stuck0 = {Bits{1'b1}};
           stuck1 = {Bits{1'b0}};
           fault_char1 = $fgetc (file_ptr);
           if (fault_char1 == 8'b11111111)
              disable read_fault_file;
           ret_val = $ungetc (fault_char1, file_ptr);
           ret_val = $fgets(tempStr, file_ptr);
           ret_val = $sscanf(tempStr, "%s %d %d %s",fault_array,fault_word, fault_bit, stuck_at) ;
           flag_error = 0; 
           if(ret_val !== 0)
           begin         
              if(ret_val == 3 || ret_val == 4)
              begin
                if(ret_val == 3)
                   stuck_at = "sa0";

                if(stuck_at !== "sa0" && stuck_at !== "sa1" && stuck_at !== "none")
                begin
                    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: Wrong value for stuck at in fault file ",$realtime);
                   flag_error = 1;
                end    
                      
                if(fault_word >= Words)
                begin
                   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Address out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                if(fault_bit >= Bits)
                begin  
                    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Faulty bit out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                
                        
                if(fault_array !== "mem_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array is not mem_array ",$realtime);
                  flag_error = 1;
                end

                if(fault_array === "red_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array can't be on redundancy array in non redundancy cut.",$realtime);
                  flag_error = 1;
                end

                
                

                if(flag_error == 0)
                //Correct Inputs
                begin
                   if(stuck_at === "none")
                   begin
                       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
                   end
                   else
                   //Adding the faults
                   begin
                      FailureLocn[t] = fault_word;
                      Failurebit[t]  = fault_bit ;
                      std_fault_word = fault_word;
                      fault_row_add[t] = std_fault_word[Addr-1:mux_bits];
                      mem_red_array_stuck_at[t] = fault_array;
                      fault_repair_flag[t] = 1'b0;
                      if (stuck_at === "sa0" )
                      begin
                         stuck0[fault_bit] = 1'b0;         
                         stuck_at_0fault[t] = stuck0;
                      end     
                      if (stuck_at === "sa1" )
                      begin
                         stuck1[fault_bit] = 1'b1;
                         stuck_at_1fault[t] = stuck1; 
                      end

                      array_stuck_at[t] = stuck_at;
                      t = t + 1;
                   end //if(stuck_at === "none")  
                end //if(flag_error == 0)
              end //if(ret_val == 2 || ret_val == 3 
              else
              //wrong number of arguments
              begin
                if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: WRONG VALUES ENTERED FOR FAULTY WORD OR FAULTY BIT OR STUCK_AT IN Fault_file_name ",$realtime); 
                flag_error = 1;
              end
           end //if(ret_val !== 0)
           else
           begin 
               if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
           end    
        end //for (i = 0; i< m
      end //begin: read_fault_file  
      $fclose (file_ptr);

      fcnt = t;
      
      //fault injection at time 0.
      task_insert_faults_in_memory;
  end // config_fault 
end
endtask


task WriteMemX;
begin

`ifdef slm
   $slm_ResetMemory(MemAddr, WordX);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = WordX;
   
`endif        
 task_insert_faults_in_memory;
end
endtask

task WriteMem0;
begin
`ifdef slm
   $slm_ResetMemory(MemAddr, Word0);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = Word0;
  
`endif 
   task_insert_faults_in_memory;
end
endtask


task WriteOutX;                
begin
   OutReg_data <= #0 WordX;
end
endtask


task Invalid_next_cycle_func;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_func = 1;
     `else 
       #0 next_cycle_corrupt_func = 0; 
     `endif  
   end 
end
endtask

task Invalid_next_cycle_dft;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_dft = 1;
     `else 
       #0 next_cycle_corrupt_dft = 0; 
     `endif  
  end
end
endtask

task Invalid_next_cycle_func_tim;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
   #0 next_cycle_corrupt_func <= 1;
  end 
end
endtask

task Invalid_next_cycle_dft_tim;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
  #0 next_cycle_corrupt_dft <= 1;
  end
end
endtask


task ScanOutX;                
begin
   
   dff_SCTRLO_SE.Q <= 1'bx;   
   dff_SDLO_SE.Q <= 1'bx; 
   dff_SDRO_SE.Q <= 1'bx; 
    
   
   SCTRLOint=X;
   SDLOint=X;
   SDROint=X;
    
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   SDLO_data<=1'bx;
   SDRO_data<=1'bx;
    
   `endif
end
endtask

task delScanOutX;                
begin
   delSCTRLO_data<=X;
   delSDLO_data<=X;
   delSDRO_data<=X;
    
end
endtask

task ScanChainX;                
begin
 scanreg_ctrl=1'bx; 
 scanreg_dl=1'bx; 
 scanreg_dr =1'bx; 
  
end
endtask

task mem_blocked;
begin
 
   WriteMemX;
   WriteOutX;
   ScanChainX;
   ScanOutX;//immediately;
   delScanOutX;//immediately
   `ifdef POWER_SEQUENCING_OFF
   `else
   reg_mem_block=1;
   `endif
   debug_level = 2'b11;
end
endtask

task corrupt_all;
begin
 
  WriteMemX;
  WriteOutX;
  ScanChainX;
  ScanOutX;
  delScanOutX;//immediately;
  OutReg_data = WordX; 
  delOutReg_data=WordX;
  
end
endtask

task WriteCycle;                  
input [Addr-1 : 0] Address;
reg [Bits-1:0] tempReg1;
reg [Bits-1:0] tempReg_slm;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;


reg repair_flag;

integer po,i,num,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;
begin

   tempReg1 = WordX;
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];

   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};
   
   if (ValidAddress === X )   begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
        WriteMemX;
        if (INITNint !== 0) begin
        `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
           #0 next_cycle_corrupt_func = 1;
       `else 
           #0 next_cycle_corrupt_func = 0; 
       `endif  
   end 

   end


   if (ValidAddress !== X && next_cycle_corrupt_func === 0  )
   begin
         if (red_en === 1 && ((Row_Add_cmp === repair_add) || (Row_Add_cmp === next_repair_add)) ) begin
             repair_flag = 1'b1;
             
             Bank_sel_integer = 0;
                     
             if (Row_Add_cmp === repair_add) begin
               Col_Add_integer  = Col_Add; 
             end
             else if (Row_Add_cmp === next_repair_add) begin
               Col_Add_integer  = Col_Add + mux; 
             end  
             RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
        end  

        if(repair_flag === 0 && ValidAddress === 1) begin
           `ifdef slm
              $slm_ReadMemoryS(MemAddr, Address, tempReg_slm);
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = Mem[Address];
            `endif
          end  
        else if(repair_flag === 1) begin
           `ifdef slm
//              $slm_ReadMemoryS(RedMemAddr, RedMem_address, tempReg_slm);
          
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = RedMem[RedMem_address];
            `endif
        end
        
        for (num=0;num<Bits;num=num+1) begin
             po=num;        
             if ( Dint [num] !== tempReg1 [po]) begin
                if (Mint[num] === 1'b0)
                   tempReg1[po] = Dint[num];
                else if (Mint[num] === 1'bX)
                   tempReg1[po] = 1'bx;
             end                
        end //for (num=0
            
         if(repair_flag === 0 ) begin    
            if(ValidAddress === 1) begin  
              `ifdef slm
                  tempReg_slm=tempReg1; 
                  $slm_WriteMemory(MemAddr, Address, tempReg_slm);
              `else
                   Mem[Address] = tempReg1;
              `endif
            end
            else begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address Out Of Range. ",$realtime);
            end        
         end
         else if (repair_flag === 1 ) begin
            `ifdef slm
                tempReg_slm=tempReg1; 
//                $slm_WriteMemory(RedMemAddr, RedMem_address, tempReg_slm);
            `else
                RedMem[RedMem_address] = tempReg1;
            `endif
         end
   end //if (ValidAddress !== X
   task_insert_faults_in_memory;
end
endtask 

task ReadCycle;
input [Addr-1 : 0] Address;

reg [Bits-1:0] MemData_tmp;
reg [Bits-1:0] MemData;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;

reg repair_flag;

integer a,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;

begin
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];
   
   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};

   

   if (ValidAddress !== X && next_cycle_corrupt_func === 0 ) begin   
       if(red_en === 1 && ( Row_Add_cmp === repair_add ||  Row_Add_cmp === next_repair_add )) begin
              repair_flag = 1;
              
              Bank_sel_integer = 0;
               
              if(Row_Add_cmp === repair_add) begin
                Col_Add_integer = Col_Add;
              end
              else if (Row_Add_cmp === next_repair_add) begin
                Col_Add_integer = Col_Add + mux; 
              end
              RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
       end

      if(repair_flag === 0) begin
          if(ValidAddress === 1) begin 
           `ifdef slm
              $slm_ReadMemory(MemAddr, Address, MemData);
           `else
              MemData = Mem[Address];
           `endif
          end
          else begin
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Address Out Of Range. Output Corrupted ",$realtime);
             MemData = WordX;
          end
     end
      else if(repair_flag === 1) begin
        `ifdef slm
//           $slm_ReadMemory(RedMemAddr, RedMem_address, MemData);
        `else
           MemData = RedMem[RedMem_address];
        `endif
      end
   end //if (ValidAddress)  
   
   if(ValidAddress === X)
   begin
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Illegal Value on Address Bus. Memory and Output Corrupted ",$realtime); 
         Invalid_next_cycle_func;
   end 
   
  if(ValidAddress !== X && next_cycle_corrupt_func === 0 )
   begin
   for (a = 0; a < Bits; a = a + 1)
   begin
      if (MemData[a] !== OutReg_data[a])
         OutReg_data[a] = WordX[a];
   end//for (a = 0; a <  
         OutReg_data <= MemData;
   end     
end
endtask



// SCAN CHAINS
supply0 gnd;
buf (A_int[0], Aint[0]);
buf (A_int[1], Aint[1]);
buf (A_int[2], Aint[2]);
buf (A_int[3], Aint[3]);
buf (A_int[4], Aint[4]);
buf (A_int[5], Aint[5]);
buf (A_int[6], Aint[6]);                  //used for capturing
buf (A_int[7], gnd);
buf (A_int[8], gnd);
buf (A_int[9], gnd);
buf (A_int[10], gnd);
buf (A_int[11], gnd);
buf (A_int[12], gnd);
buf (A_int[13], gnd);
buf (A_int[14], gnd);   //used for capturing

buf (WEN_int, WENint);
buf (CSN_int, CSNint);
buf (IG_int, IGint);


// Scan flops



// CONTROL SCAN CHAIN
     ST_SPREG_LOLEAK_128x22m2_Tl_SCFF cntrl_scff_0 (.D(1'b0), .TI(SCTRLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[0]), .OUTX(scanreg_ctrl));

      
 ST_SPREG_LOLEAK_128x22m2_Tl_SCFF cntrl_scff_1 (.D(A_int[2]), .TI(scanreg_ctrl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[1]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m2_Tl_SCFF cntrl_scff_2 (.D(A_int[4]), .TI(scanreg_ctrl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[2]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m2_Tl_SCFF cntrl_scff_3 (.D(A_int[7]), .TI(scanreg_ctrl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[3]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m2_Tl_SCFF cntrl_scff_4 (.D(A_int[1]), .TI(scanreg_ctrl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[4]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m2_Tl_SCFF cntrl_scff_5 (.D(A_int[9]), .TI(scanreg_ctrl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[5]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m2_Tl_SCFF cntrl_scff_6 (.D(A_int[8]), .TI(scanreg_ctrl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[6]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m2_Tl_SCFF cntrl_scff_7 (.D(1'b0), .TI(scanreg_ctrl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[7]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m2_Tl_SCFF cntrl_scff_8 (.D(A_int[0]), .TI(scanreg_ctrl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[8]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m2_Tl_SCFF cntrl_scff_9 (.D(A_int[3]), .TI(scanreg_ctrl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[9]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m2_Tl_SCFF cntrl_scff_10 (.D(A_int[5]), .TI(scanreg_ctrl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[10]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m2_Tl_SCFF cntrl_scff_11 (.D(CSN_int), .TI(scanreg_ctrl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[11]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m2_Tl_SCFF cntrl_scff_12 (.D(A_int[6]), .TI(scanreg_ctrl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[12]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m2_Tl_SCFF cntrl_scff_13 (.D(WEN_int), .TI(scanreg_ctrl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[13]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m2_Tl_SCFF cntrl_scff_14 (.D(scanreg_ctrl_wire[14]), .TI(scanreg_ctrl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[14]), .OUTX(scanreg_ctrl));  

reg LP_CK_gate;

// Lock Up Latch
wire SCTRLO_temp;
 ST_SPREG_LOLEAK_128x22m2_Tl_lock_up_latch  dff_SCTRLO_SE (Latch_open, scanreg_ctrl_wire[14], SCTRLO_temp);

always @(SCTRLO_temp) begin
     SCTRLOint= SCTRLO_temp;
 `ifdef functional
 `else
 if (SCTRLOint !== SCTRLO_data) begin 
  if (SCTRLOint !==X)
   SCTRLO_data=1'bx;
   SCTRLO_data <= SCTRLOint;
 end 
 `endif
end  


// LEFT DATA SCAN CHAIN
     ST_SPREG_LOLEAK_128x22m2_Tl_SCFF ldata_scff_0 (.D(Dint[11]), .TI(SDLI), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[0]), .OUTX(scanreg_dl));
      
   
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF ldata_scff_1 (.D(Dint[10]), .TI(scanreg_dl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[1]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF ldata_scff_2 (.D(Dint[9]), .TI(scanreg_dl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[2]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF ldata_scff_3 (.D(Dint[8]), .TI(scanreg_dl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[3]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF ldata_scff_4 (.D(Dint[7]), .TI(scanreg_dl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[4]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF ldata_scff_5 (.D(Dint[6]), .TI(scanreg_dl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[5]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF ldata_scff_6 (.D(Dint[5]), .TI(scanreg_dl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[6]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF ldata_scff_7 (.D(Dint[4]), .TI(scanreg_dl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[7]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF ldata_scff_8 (.D(Dint[3]), .TI(scanreg_dl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[8]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF ldata_scff_9 (.D(Dint[2]), .TI(scanreg_dl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[9]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF ldata_scff_10 (.D(Dint[1]), .TI(scanreg_dl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[10]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF ldata_scff_11 (.D(Dint[0]), .TI(scanreg_dl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[11]), .OUTX(scanreg_dl));



// Lock Up Latch
wire SDLO_temp;
 ST_SPREG_LOLEAK_128x22m2_Tl_lock_up_latch  dff_SDLO_SE (Latch_open, scanreg_dl_wire[11], SDLO_temp);

always @(SDLO_temp) begin
     SDLOint= SDLO_temp;
 `ifdef functional
 `else
 if (SDLOint !== SDLO_data) begin 
  if (SDLOint !==X)
   SDLO_data=1'bx;
   SDLO_data <= SDLOint;
 end 
 `endif
end  






// RIGHT DATA SCAN CHAIN

     ST_SPREG_LOLEAK_128x22m2_Tl_SCFF rdata_scff_0 (.D(Dint[21]), .TI(SDRI), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[0]), .OUTX(scanreg_dr));
     
 
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF rdata_scff_1 (.D(Dint[20]), .TI(scanreg_dr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[1]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF rdata_scff_2 (.D(Dint[19]), .TI(scanreg_dr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[2]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF rdata_scff_3 (.D(Dint[18]), .TI(scanreg_dr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[3]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF rdata_scff_4 (.D(Dint[17]), .TI(scanreg_dr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[4]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF rdata_scff_5 (.D(Dint[16]), .TI(scanreg_dr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[5]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF rdata_scff_6 (.D(Dint[15]), .TI(scanreg_dr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[6]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF rdata_scff_7 (.D(Dint[14]), .TI(scanreg_dr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[7]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF rdata_scff_8 (.D(Dint[13]), .TI(scanreg_dr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[8]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m2_Tl_SCFF rdata_scff_9 (.D(Dint[12]), .TI(scanreg_dr_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[9]), .OUTX(scanreg_dr)); 


// Lock Up Latch
wire SDRO_temp;
 ST_SPREG_LOLEAK_128x22m2_Tl_lock_up_latch  dff_SDRO_SE (Latch_open, scanreg_dr_wire[9], SDRO_temp);


always @(SDRO_temp) begin
     SDROint= SDRO_temp;
 `ifdef functional
 `else
 if (SDROint !== SDRO_data) begin 
  if (SDROint !==X)
   SDRO_data=1'bx;
   SDRO_data <= SDROint;
 end 
 `endif
end






//


 //////// CAPTURE TASK //////
task scan_acquire;
begin
   if (supply_ok === 1) begin 
      if ( SEsys === 0 && ((LP_CK_gate === 0 && TBYPASSsys !== 1'bx)|| TBYPASSsys===0)) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
         
         Latch_open=1;
         

      end //if ( SEint === 0
   end//if(supply_ok 
end
endtask

task scan_shift;
begin
 if (supply_ok === 1) begin
   if (STDBYint === 0 && SLEEPint === 0) begin
      if (CKint_dft === X && INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0) begin
         ScanChainX;
         ScanOutX;
      end
      else if (CKint_dft === 1 && lastCK_dft === 0 ) begin
          //// SHIFT
        if (SEsys === 1) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
           
        //// SHIFT Ends
        end //if (SEsys === 1
        else if (SEsys === X) begin
            ScanChainX;
            ScanOutX;
            delScanOutX;
        end//if (SEint ==X
      
      end///if (CKint === 
    
      else if (CKint_dft === 0 && lastCK_dft === 1 ) begin
        Latch_open=1;
      end
    end  //if (STDByint === 0 && SLEEPint === 0
 end//if(supply_ok
end
endtask






// BEHAVIOURAL MODULE DESCRIPTION
// ================================

initial
begin
  // Define format for timing value
  $timeformat (-9, 3, " ns", 0);
  `ifdef slm
  $slm_RegisterMemory(MemAddr, Words, Bits);
  `endif   
   reg_mem_block=0;
   flag_mem_block=0;
  `ifdef functional
  `else
   TimingViol_data=0;
   TimingViol_mask=0;
   `endif
   decoding_start=0;
  
   //Parameter Assignment
   
   reg_Fault_file_name = Fault_file_name; 
   reg_ConfigFault     = ConfigFault;
   reg_MEM_INITIALIZE  = MEM_INITIALIZE;
   reg_BinaryInit      = BinaryInit;
   reg_InitFileName    = InitFileName;
   reg_Initn_reset_value = Initn_reset_value;
   reg_File_load_time    = File_load_time;

   time_fall_sleep=0;
   time_fall_PSWLARGEMP=0;
   time_fall_PSWLARGEMP_0=0;
   time_fall_PSWLARGEMA=0;
   time_fall_PSWLARGEMA_0=0;
   time_fall_PSWSMALLMP=0;
   time_fall_PSWSMALLMA=0;

   vddmp_rise_time=0;
   vddmp_fall_time=0;
   vddsmp_rise_time=0;
   vddsmp_fall_time=0;
   vddma_rise_time=0;
   vddma_fall_time=0;
   vddsma_rise_time=0;
   vddsma_fall_time=0;
   vddm_fall_time=0;  
   vddm_rise_time=0;  
   vddsm_fall_time=0; 
   vddsm_rise_time=0;

   next_cycle_corrupt_func=0;
   next_cycle_corrupt_dft=0;
   init_pulse_done = 0;
   power_up_done = 0;
   file_loaded=1;
   debug_level= 2'b01;
   message_status = "ONLY WARNINGS/ERRORS are Switched ON.For INFO also use debug_level=2'b00";
  `ifdef  NO_WARNING_MODE
     debug_level = 2'b11;
     message_status = "All Warning/Errors/Info Messages are Switched OFF";
  `endif  
  `ifdef  ONLY_ERROR_MODE
     debug_level = 2'b10;
     message_status = "All Warning/Info Messages are Switched OFF.Errors are switched on";
  `endif 
  `ifdef  ALL_MSG_MODE
     debug_level = 2'b00;
     message_status = "All Messages are Switched ON";
  `endif 
  
  `ifdef slm
     operating_mode = "SLM";
   `else
      `ifdef functional
         operating_mode = "FUNCTIONAL";
       `else
         operating_mode = "TIMING";
      `endif
   `endif   
  
  if (debug_level < 1) begin
  $display ("%m INFORMATION ");
  $display ("***************************************");
  $display ("The Model is Operating in %s MODE", operating_mode);
  $display ("%s", message_status);
  if(reg_ConfigFault)
  $display ("Configurable Fault Functionality is ON");   
  else
  $display ("Configurable Fault Functionality is OFF");   
  $display("Fault File used by the model Fault_File_Name=%s" ,reg_Fault_file_name);
  $display("Values of Config_fault used in model=%d" ,reg_ConfigFault);
  $display("Values of Mem_INITALIZE used in model=%d" ,reg_MEM_INITIALIZE);
  $display("Values of BinaryInit used in model=%d" ,reg_BinaryInit);
  $display("Values of InitFileName used in model=%s" ,reg_InitFileName);
  $display("Values of Initn_reset_value used in model=%d" ,reg_Initn_reset_value);
  $display("Values of File_load_time used in model=%t" ,reg_File_load_time);

  $display ("***************************************");
  end
     
  task_read_fault_file; 
   if(!INITNint) begin
    if(supply_ok ) begin 
      init_pulse_done = 1;
      power_up_done = 1;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif 
    end 
   end 
        
   lastCK_func = CKint_func;
   lastCK_dft = CKint_dft;

 `ifdef MEM_CONTENTS_SLEEP
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","w");
   $fclose(ptr);
 `endif 

   
end  // initial block ends



//+++++++++++++++++++++++++++++++ CONFIG FAULT IMPLEMETATION ENDS+++++++++++++++++++++++++++++++//
        




//INITN block starts
//================================
always @(INITNint  or supply_ok )
begin
 if (INITNint === 1'b0) begin
   if(supply_ok) begin
     init_pulse_done = 1;
     power_up_done = 1;
     lastCK_func=CKint_func;
     lastCK_dft=CKint_dft;
     next_cycle_corrupt_func = 0;
     next_cycle_corrupt_dft = 0;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif     
   end 
 end        

 if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && INITNint !== 1)
   begin
     ScanOutX;
     ScanChainX;
     delScanOutX;
   end  
         
 if (init_pulse_done === 0 && INITNint !== 0) begin
     if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) INFO: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
 end
 
end//always @(INITNint)


// Clock Generation 
//wire gated_clock;
//wire clock_gate_en;
//ST_SPREG_LOLEAK_128x22m2_Tl_lock_up_latch CK_SE_latch (!CK , SE, SE_latch_CK);
//and (clock_gate_en, ATP, TBYPASS, !SE_latch_CK);

//ST_SPREG_LOLEAK_128x22m2_Tl_lock_up_latch LP_latch (!CK , scanreg_ctrl_wire[14], LP_latch_CK);
//and (gated_clock,CK,!LP_latch_CK);
//assign CK_new= clock_gate_en ===0 ? CK : (clock_gate_en ===1 ? gated_clock: (CK===0) ? 0 :1'bx);


// Clock Generation Ends


// Functional CK block starts
//======================================
always @(CKint_func)
begin
   lastCK_func=CKreg_func;  
   CKreg_func=CKint_func;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
        if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
      if (CKreg_func === 1'bX || (CKreg_func === 1'b1 && lastCK_func === 1'bx)) begin
        if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
         
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
         Invalid_next_cycle_func;
        end
      end
      else if (CKreg_func === 1'b1 && lastCK_func === 1'b0 ) begin
        time_CK_func_rise=$realtime;
        MEMEN_prev = MEMEN_reg;
        MEMEN_reg = MEMEN;
        CSNreg = CSNint;
        IGreg = IGint;
        DEreg = DEint;
        SE_reg = SEsys;
        TBYPASS_reg = TBYPASSsys;
        ATPreg = ATPint;
        INITNreg = INITNint;
        SLEEPreg = SLEEPint;
        STDBYreg = STDBYint;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 

    `ifdef functional
    `else
        Mem_last=Mem[Aint];
    `endif 
        if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.INITN pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SLEEP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.STANDBY pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg === X && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.chip select  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg === X && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.IG pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg === X && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.Debug pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg === X && (SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.ATP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg === X && TBYPASS_reg !== 1) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SE pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg !== 1 && TBYPASS_reg === X) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.TBYPASS pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end

        else if ((INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0))) && WENint === X) begin
            // Uncertain write cycle
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: write enable going to X  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end 
        else if (next_cycle_corrupt_func === 1) begin
          next_cycle_corrupt_func = X;
        end
        else if (next_cycle_corrupt_func === 1'bx) begin
          next_cycle_corrupt_func = 0;
        end 
        
//        if (next_cycle_corrupt_func === 0 ) begin 
         
          /*---------------------- File initialization -----------------*/
          
          if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0)) && flag_mem_block === 1'b0) begin
                 Areg=Aint;
                 Dreg=Dint;
                 Mreg=Mint;
                 WENreg=WENint;     
             if (reg_MEM_INITIALIZE === 1'b1 && $realtime >= reg_File_load_time && file_loaded ) begin   
                `ifdef slm
                  if (reg_BinaryInit)
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_BIN");
                  else
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_HEX");
   
                `else
                  if (reg_BinaryInit)
                     $readmemb(reg_InitFileName, Mem, 0, Words-1);
                  else
                     $readmemh(reg_InitFileName, Mem, 0, Words-1);
                `endif
                 file_loaded = 0;
             end
   
             if (^Aint === X)
               ValidAddress = X;
             else if (Aint < Words)
               ValidAddress = 1;
             else    
               ValidAddress = 0;
   
             if(red_en === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Redundancy Enable is Invalid. Either RRAE is X or TRRAE is X",$realtime);
                ValidAddress = X; 
           end
           else if(red_en === 1'b1 && ^repair_add === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Repair Address is invalid.RRA is X",$realtime);
                ValidAddress = X;
           end
             
             if (ValidAddress)
               `ifdef slm
                   $slm_ReadMemoryS(MemAddr, Aint, Mem_temp);
               `else
                    Mem_temp = Mem[Aint];
               `endif
             else
                Mem_temp = WordX;  
          
     /*---------------------- Normal Read and Write -----------------*/
     
             if (WENint === 1) begin
               ReadCycle(Aint);
             end
       
             else if (WENint === 0) begin
               WriteCycle(Aint);
             end 
                
          
          end //  if (MEMEN === 1'b1 
       
//        end  // if (next_cycle_corrupt_func === 0
      
      end // if (CKint = 1   
   end // if (init_pulse_done === 1           
 end 
end // always @(CKint_func)
        
always @(MEMEN)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) && CKint_func === 1'bx) begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.clock pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
    Invalid_next_cycle_func;
  end
 end 
end

// DFT CK block starts
//======================================
always @(CKint_dft) 
begin
   lastCK_dft=CKreg_dft;
   CKreg_dft=CKint_dft;
   
   Latch_open=0;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
     if (CKreg_dft === 1'bX || (CKreg_dft === 1'b1 && lastCK_dft === 1'bx)) begin
       if (INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0 ) begin
        
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: DFT clock  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime); 
         Invalid_next_cycle_dft;
         if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
           WriteOutX;
         end
       end
     end 

     if(CKint_dft === 0 && lastCK_dft === 1) begin
      if(ATPreg === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
       if(SE_reg === 1'b1 && SEsys === 1'b0) begin
        if(TBYPASSint === 1'b1) begin   
            
            
    OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9],
scanreg_dl_wire[10], scanreg_dl_wire[scanlen_l-1]}; 
 
         for (i = 0; i < Bits; i = i + 1)
         begin
          if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
         end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
        end 
       end
      end
     end 
     
     else if (CKreg_dft === 1'b1 && lastCK_dft === 1'b0 ) begin
       SE_reg = SEsys;
       TBYPASS_reg = TBYPASSsys;
       ATPreg = ATPint;
       INITNreg = INITNint;
       SLEEPreg = SLEEPint;
       STDBYreg = STDBYint;
       MEMEN_dft_prev = MEMEN_dft_reg;
       MEMEN_dft_reg = MEMEN_dft;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 
       if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ) begin 
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
 //     else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys === X && TBYPASSsys !== 1) begin
///           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
//           Invalid_next_cycle_dft;
//        end       
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys === X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
        end 
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys !== 0 && LP_CK_gate===X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: LP FLOP Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           ScanChainX;
           ScanOutX;   
          if( TBYPASSint !== 0 && SEint !== 1) begin
            WriteOutX;
          end
          next_cycle_corrupt_dft=0;
        end        
       else if (next_cycle_corrupt_dft === 1'b1) begin 
         next_cycle_corrupt_dft = X;
       end 
       else if (next_cycle_corrupt_dft === 1'bx) begin
         next_cycle_corrupt_dft = 0;
       end
       
       if (next_cycle_corrupt_dft === 0 ) begin
         
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1 && flag_mem_block === 1'b0) begin
           
           if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0  && LP_CK_gate===0) begin
              OutReg_data_tbypass = Dint;
              for (i = 0; i < Bits; i = i + 1)
              begin
               if (OutReg_data_tbypass[i] !== OutReg_data[i])
                 OutReg_data[i] = WordX[i];
              end//for (i = 0; i < */ 
              OutReg_data <= OutReg_data_tbypass;
           end
           
             scan_acquire;
         end //MEMEN_dft == 1        
       end // if ( next_cycle_corrupt_dft
       
     end // if (CKint_dft === 1'b1
      //  if (next_cycle_corrupt_dft === 0 ) begin 
       if (SE_reg !== 0) begin
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1  && flag_mem_block === 1'b0) begin
           next_cycle_corrupt_dft = 0;
           if ( next_cycle_corrupt_func === 1) begin
	    next_cycle_corrupt_func = 0 ;
	   end	
           scan_shift;
         end
       end
     //end // if ( next_cycle_corrupt_dft    
     if ((!(TBYPASSsys!==0 && SEsys!==1 && LP_CK_gate!==0 ) && next_cycle_corrupt_dft === 0) || CKint_dft !==1) begin          
       CK_sc=INITNreg & !STDBYreg & !SLEEPreg & ATPreg & CKreg_dft ;
     end     
   end // if (init_pulse_done 
 end // if (supply_ok 
end // always @(CKint_dft)

always @(MEMEN_dft)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) && CKint_dft === 1'bx)  begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.MEMEN_dft and clock should not be X at this time instant. ScanChains and ScanOuts Corrupted ",$realtime); 
    Invalid_next_cycle_dft;
    
    if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
      WriteOutX;
    end
  end
  if ( MEMEN_dft !== 0 && TBYPASSsys !== 0 && SEsys !== 1) begin
     WriteOutX;
     OutReg_data = WordX; 
     delOutReg_data=WordX;
 end 
end
end //always @(MEMEN_dft

always @(TBYPASSsys or ATPint)
begin
   if(supply_ok === 1'b1) begin 
    if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0 && INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1) begin
      if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
    end  
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint === X && SEsys !== 1) ) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end 
end //always @(TBYPASSint





always @(SEsys)
begin
 if(supply_ok === 1'b1) begin 
  if(CKint_dft === 0 && ATPint === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
    if(SE_reg === 1'b1 && SEsys === 1'b0) begin
      if(TBYPASSsys === 1'b1) begin
          
          
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9],
scanreg_dl_wire[10], scanreg_dl_wire[scanlen_l-1]};  


        for (i = 0; i < Bits; i = i + 1)
        begin
         if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
        end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
      end
    end
  end
  if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0) begin
      if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
  end 
  else if ((TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint === X && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end   
end

//assign output data
`ifdef functional        

   
always @(SDLOint)
#0.001 delSDLO_data<=SDLOint;

always @(SDROint)
#0.001 delSDRO_data<=SDROint;

 
always @(SCTRLOint)
#0.001 delSCTRLO_data<=SCTRLOint;


always @(OutReg_data)
   #0.001 delOutReg_data = OutReg_data;
`else
`endif

/***************************** Embeded switch functionality starts here ***********************************/





always @(STDBYint)
begin
  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0 && STDBYint !== 1'b0)
    begin
      ScanOutX;
      ScanChainX;
     delScanOutX;     
    end
  end
end



always @(SLEEPint)
begin


  if (SLEEPint !== 1'b1) begin
    time_fall_sleep = $realtime;
  end

  if (power_up_done === 0)
    begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
    end
  else begin
    if (SLEEPint === 1'b1 && lastSLEEP === 1'b0 ) begin 
      
    end
    else if (SLEEPint !== 1'b1 && lastSLEEP === 1'b1 && full_shutdown !== 1) begin 
      
      if (supply_ok !== 1 && ($realtime > 0)) begin
         if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID LOW_POWER) ERROR: ISOLATION signal removed from the memory but array and periphery supply is not completely switched on.Very High Current would be drawn by the memory. All further operations on memory are blocked",$realtime);
          WriteMemX;
          WriteOutX;
          ScanChainX;
          OutReg_data = WordX; 
          delOutReg_data=WordX;
          ScanOutX;//immediately;
          delScanOutX;//immediately;
          init_pulse_done = 0;
          power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            debug_level = 2'b11;
          `endif
          
      end        
      
       
    end   
    else if (SLEEPint === X && lastSLEEP === 1'b0 && full_shutdown !== 1'b1) begin 
     
    end 
  end  


  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && SLEEPint !== 0)
    begin
      ScanOutX;
      ScanChainX;
        delScanOutX;      
    end
  end

// if (init_pulse_done === 0)
//   begin
//     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
//   end
//
// else if ( SLEEPint !== 1 && (supply_ok !==1) ) begin
//    
//    WriteOutX;
//    OutReg_data = WordX; 
//    delOutReg_data=WordX;
//    ScanOutX;//immediately;
//    delScanOutX;//immediately;
//    ScanChainX;
//    WriteMemX;
//    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies with sleep/Power down signal being low.This scenario can lead to high dc currents and some reliability issues Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
// end

 print_sleep;    
 lastSLEEP=SLEEPint;
end

/********************************** Embeded switch functionality ends here *******************************/

task print_sleep;
begin
  if (SLEEPint === 1'b0) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been deasserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end  
  else if (SLEEPint === 1'b1) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been asserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_ACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif

  end        
  else begin
      if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) ERROR: SLEEP pin is at an invalid state.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INVALID in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end        
end
endtask





 

//// C28SOI non flip compiler power functionality 
always @(gndmreg )
begin
 if (power_up_done === 1 && $realtime > 0) begin    
    if(gndmreg !== 1'b0 ) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or gndsm is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
        corrupt_all;
        init_pulse_done = 0;
        power_up_done = 0;
     `ifdef NO_BLOCK_MEM
     `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of ground pins.Ground must be maintained at 0 Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime);
        debug_level = 2'b11;
     `endif   

    end   
 end

end




always @(vddmareg )
begin

if (vddmareg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddma(Array Supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 
    end
   end   
   else if (SLEEPint === 1) begin
    WriteMemX;
   end

end

if ((vddmareg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1 ) && $realtime > 0) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddm or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         corrupt_all;
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif

end


end

always @(vddmpreg )
begin
 if (vddmpreg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or vddsmp is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmp(Periphery Supply)/vddsmp(Substrate power supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 

    end
   end   
   else if (SLEEPint === 1) begin
    WriteOutX;
    ScanChainX;
    ScanOutX;
    delScanOutX;//immediately;
    OutReg_data = WordX; 
    delOutReg_data=WordX;
   end
 end

if( (vddmpreg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1'b1 )  && $realtime > 0) begin
         corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif
end
 
 
end


always @(vddmoreg)
begin
  if (power_up_done === 1 && $realtime > 0) begin   
      if (vddmoreg !== 1'b1)  begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin
           corrupt_all;
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
         end //if (vddmareg === 1'b1 

      else if (vddmareg === 1'b0 && vddmpreg === 1'b0   && SLEEPint === 1'b1 &&  $realtime > 0)
        begin 
            if((debug_level < 2) && ($realtime > 0)) $display("%m - %t WARNING: Illegal Value on power pin(s). Memory and Output Corrupted ", $realtime);
 
           corrupt_all;
        end //else if (vddmareg === 1'b 
     end   // if (vddmoreg !== 1'b1)
     else if (vddmoreg === 1'b1 && $realtime > 0 ) begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin     
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           corrupt_all;
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
        end        
     end // else if (vddmoreg === 1'b1
  end 
end // always @(vddmoreg)












always @(gndmreg) begin
 if (gndmreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 0. ",$realtime);
 end
 else if (gndmreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 1. ",$realtime);
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to invalid state. ",$realtime);
 end
end




 
always @(vddmareg) begin
 if (vddmareg === 0) begin 
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 0. ",$realtime);
  vddma_fall_time = $realtime;
 end
 else if (vddmareg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 1. ",$realtime);
  vddma_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to invalid state. ",$realtime);
  vddma_fall_time = $realtime;
 end 

 

end

always @(vddmpreg) begin
 if (vddmpreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 0. ",$realtime);
  vddmp_fall_time = $realtime;
 end
 else if (vddmpreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 1. ",$realtime);
  vddmp_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to invalid state. ",$realtime);
  vddmp_fall_time = $realtime;
 end

 
 
end



// end of C28SOI power functionality 
 


assign supply_ok          =  (vddmareg === 1'b1 && vddmpreg  === 1'b1  && gndmreg === 1'b0 && vddmoreg === 1'b1 ) ? 1'b1 : 1'b0;
assign core_supply_ok     =  (vddmoreg === 1'b1 && vddmareg === 1'b1 && gndmreg === 1'b0 ) ? 1'b1 : 1'b0;
assign peri_supply_ok     =  (vddmoreg === 1'b1 && vddmpreg === 1'b1 && gndmreg === 1'b0  ) ? 1'b1 : 1'b0;

assign full_shutdown = (vddmpreg === 1'b0 && vddmareg === 1'b0   ) ? 1'b1 : 1'b0 ;




`ifdef functional
`else


task WriteLocMskX_bwise;
   input [Addr-1 : 0] Address;
   input [Bits-1 : 0] Mask;

reg [Bits+Red_extrabit:0] tempReg1;
integer num1; 
begin
   tempReg1 = WordX;
   if (^Address !== X )
   begin
      tempReg1 = Mem[Address];
             
      for (j = 0;j< Bits; j=j+1) begin
         num1=j;
        if (Mask[j] === 1'bx)
            tempReg1[num1] = 1'bx;
      end
      Mem[Address] = tempReg1;
      task_insert_faults_in_memory;
   end//if (^Address !== X
   else begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      WriteMemX;
   end   
end
endtask


/****************Actions taken on timing violations*****************/

 always @(TimingViol_data)
// tds or tdh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  for (l = 0; l < Bits; l = l + 1) begin   
    if (CSWEMTBYPASS[l] !== 0) begin
     if((TimingViol_data[l] !== TimingViol_data_last[l])) begin


         Mreg[l] = 1'bx;
     end    
     WriteLocMskX_bwise(Areg,Mreg);
    end   
   end 
  end
    if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin
     scanreg_dl =1'bx; 
     scanreg_dr =1'bx; 
     SDLOint=X;
     SDROint=X;
     `ifdef functional
     `else
     SDLO_data<=1'bx;
     SDRO_data<=1'bx;
     `endif
    end
     TimingViol_data_last = TimingViol_data; 
end





always @(TimingViol_addr)
// tas or tah
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
      scanreg_ctrl=1'bx; 
      SCTRLOint=X;
      `ifdef functional
      `else
      SCTRLO_data<=1'bx;
      `endif
  end
end


always @(TimingViol_WEN)
//tws or twh
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WEN pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end 

always @(TimingViol_CSN )
// tps or tph 
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;

   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CSN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end

always @(TimingViol_tcycle )
//tcycle
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
   if (MEMEN !== 0 && MEMEN_prev !== 0) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckl )
// tckl 
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckh) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end


always @(TimingViol_tcycle_se )
//tcycle_se
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckl_se  )
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckh_se) begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tbist) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
   end
   if (TBYPASSint !== 1'b0) begin 
    WriteOutX;
   end 
   if (INITNreg !==0 && STDBYreg !== 1 && TBYPASS_reg !== 1 && SLEEPreg !== 1 && SE_reg !== 1 && IGreg !== 1 && DEreg !== 1) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBIST pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end






always @(TimingViol_tbypass)
//ttmck
begin
#0  
  WriteOutX;
  if (INITNreg !== 0 && SLEEPreg !== 1 && SE_reg !== 1 && STDBYreg !== 1 &&  DEreg !== 1) begin
   Invalid_next_cycle_dft_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
end



always @(TimingViol_sleep)
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_stdby)
begin
#0
  if (CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin 
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (ATPreg !== 0) begin 
   Invalid_next_cycle_dft_tim;
  end
end






always @(TimingViol_se) begin
#0
   if (TBYPASS_reg !== 0) begin 
    WriteOutX;
   end 
  if (TBYPASS_reg === 0) begin
     WriteOutX;
     WriteMemX;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE timing violation  Memory State Machine is corrupted. Output Corrupted ",$realtime); 
  end 
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
  end
end

always @(TimingViol_sctrli) begin
  scanreg_ctrl=1'bx; 
end


always @(TimingViol_sdli) begin
 scanreg_dl=1'bx; 
end

always @(TimingViol_sdri) begin
   scanreg_dr=1'bx;
end

 

always @(TimingViol_initnl) begin
init_pulse_done=0;
WriteOutX;
OutReg_data = WordX; 
delOutReg_data=WordX;
ScanOutX;
delScanOutX;
ScanChainX;
WriteMemX;
end

always @(TimingViol_initn) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end

always @(TimingViol_ig) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && INITNreg !== 0 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: IG pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   ScanChainX;
   ScanOutX;
   delScanOutX;       
  end
end

always @(TimingViol_atp) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin  
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_rm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^WMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: RM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
   end
end
 
always @(TimingViol_wm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^RMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);        
   end
end 


`endif


endmodule




module ST_SPREG_LOLEAK_128x22m2_Tl_lock_up_latch (EN,D,Q);
input EN,D;
output reg Q;

  always @ (EN or D) begin
    if (EN === 1) begin
       Q = D;
    end
    else if ((EN === 1'bz || EN === 1'bx  )&& D !== Q) begin
        Q=1'bx;
    end    
  end
endmodule

module ST_SPREG_LOLEAK_128x22m2_Tl_SCFF (D,TI,TE,CP,Q,OUTX);
input D,TI,TE,CP;
input OUTX;
output reg Q;
wire Dint;
assign Dint= (TE===1)?TI:(TE===0)?D:1'bx;

always @(posedge CP)
        begin
          if(Dint === 1'bZ || CP ===1'bx || OUTX === 1'bx)
          begin
                  Q = 1'bx;
          end
          else
          begin
                  Q = Dint;
          end        
        end
always @(posedge OUTX)
Q = 1'bx;
endmodule



`undef setup_time
`undef hold_time
`undef access_time
`undef retain_time
`undef cycle_time
`undef pulse_width_time
`undef initin_low_pulse


`delay_mode_path
`endcelldefine
`nosuppress_faults






/****************************************************************
--  Description         : Verilog Model 
--  ModelVersion        : 1.2
--  Date                : Apr, 2013
--  Changes Made by	: PS
--  Revision History    : 
 
****************************************************************/


/******************** START OF HEADER****************************
   This Header Gives Information about the parameters & options present in the Model
   
   words = 1024
   bits  = 19
   mux   = 8 
   
   
   
   write_mask = no 
   
   margin_control = yes 
   
   
   Dft = Yes  

    ------------------------------------------------------------------------------------
     Signal Name             | Description       |             Port Mode        | Active When
                             |                   |          r    |  w   | rw    |
   ------------------------------------------------------------------------------------

    D 	        Data in                     na     x      na       -  
    IG    Input Gate Enable           x      x      na       High     
    ATP            ATPG Enable                 x      x      na       High     
    INITN                 INITN pin                   x      x      na       Low
    
    
     
    Q 	        Data out	            x      na     na       -
    A              Address                     x      x      na       high and low
    
    CK                Clock	                    x      x      na       posedge
    CSN          Chip Enable                 x      x      na       low
    
    RM         Read Margins                 x      x      na       High 
    SCTRLI         Scan Input (Control)
    SCTRLO        Scan Output (Control)
    SDLI         Scan Input (Data-Left)
    SDLO        Scan Output (Data-Left)
    SDRI         Scan Input (Data-Right)
    SDRO        Scan Output (Data-Right)
    SE          Scan Enable pin 
    STDBY              Standby pin                 x      x      na       High
    
    SLEEP                        Sleep pin                   x      x      na        High 
    
     
     
    TBIST          Bist Enable Pin 
    
    TBYPASS                      Memory Bypass                na     na     na        High
    
    TED        Bist Even Data pin
    TOD         Bist Odd Data Pin
     
    TA         Bist Read Address
    TCSN     Bist Read Chip Select
    
    TWEN    Bist Write Enable 
    WEN         Write Enable                na     x      na       Low 
    
    WM        Write Margins Code          x      x      na       -
     

******************** END OF HEADER ****************************/


//********************************************//
// ST_SPREG_LOLEAK_1024x19m8_Tl Verilog Model                 //  
//********************************************//




`ifdef slm
        `define functional
`endif

`celldefine
`suppress_faults
  `ifdef functional
   `delay_mode_unit
  `else
   `delay_mode_path
  `endif

`define setup_time 0.0
`define hold_time 0.0
`define access_time 1.0
`define retain_time 0.9
`define cycle_time 0.0
`define pulse_width_time 0.0
`define initin_low_pulse 0.0



 






`timescale 1ns / 1ps


module ST_SPREG_LOLEAK_1024x19m8_Tl (A,ATP,CK,CSN,D ,IG,INITN , Q ,RM    ,SCTRLI,SCTRLO,SDLI,SDLO,SDRI,SDRO,SE,SLEEP   , STDBY  ,TA,TBIST   ,TBYPASS ,TCSN,TED ,TOD   ,TWEN ,WEN,WM  );

 parameter
  Words = 1024,
  Bits = 19,
  Addr = 10,
  mux = 8,
  repair_address_width = 7,
  write_margin_size = 2, 
  read_margin_size = 3; 

 //  INPUT OUTPUT PORTS DECLARATION DONE SEPARATELY FOR SPREG and ROM
 // ========================


        output [Bits-1 : 0] Q;
         
        output SCTRLO;
        input SE,SCTRLI;
        
        input [Addr-1 : 0] A;
        
        input [read_margin_size-1 : 0] RM;
        
         
        input CK,CSN,INITN,IG,ATP; 
        
        
        input [Addr-1 :0 ] TA;
input TBIST,TCSN ;
        
        input STDBY;
        
        input SLEEP; 
        
         
        
        
         
        output SDLO;
        output SDRO;
        
        
        
        
        input [Bits-1 : 0] D ;
	
          
         
        
        input [write_margin_size-1 : 0] WM;
        
        
        input TBYPASS;
        
        input WEN;
        
        
         
        input SDLI,SDRI  ; 
        
        
        
        //Bist inputs
        // ===========
        input TWEN,TED,TOD; 
        
        
        
        

        






    parameter
        Fault_file_name = "ST_SPREG_LOLEAK_1024x19m8_Tl_faults.txt",
        `ifdef ConfigFault
        ConfigFault = 1,
        `else
        ConfigFault = 0,
        `endif
        max_faults = 1026,
        
        MEM_INITIALIZE  = 1'b0,
        BinaryInit = 1'b0, 
        InitFileName = "ST_SPREG_LOLEAK_1024x19m8_Tl.cde",
        Debug_mode = "all_warning_mode",
        File_load_time=0,
        Initn_reset_value={19{1'b0}},
        InstancePath = "ST_SPREG_LOLEAK_1024x19m8_Tl";
    
    parameter
        
        bank = 1, 
        mux_bits=3,
        Red_extrabit=0,
        bank_bits = 0,
        RedWords = mux * 2 * bank,
        max_address_bits = 15 ,
        Rows = Words/mux;

  
    parameter 

     

        
           scanchains=3,    
          
        
        scanlen_ctrl=15,
        
        

      

        
        scanlen_r=(Bits)/2,
        
        scanlen_l=(Bits+1)/2 ; 
      
      

    parameter
        
        `ifdef functional  
            RW_assertions_en = 0,
        `endif
        WordX = {Bits{1'bx}},
        AddrX = {Addr{1'bx}},
        Word0 = {Bits{1'b0}},
        X = 1'bx;
   



//  WIRE DECLARATION RELATED TO POWER PINS
//  ======================================
	
        wire supply_ok, full_shutdown;
        
        wire core_supply_ok;
        wire peri_supply_ok;

        wire gndmint, gndsmint;
         
        
        wire vddmpint;
        wire vddmoint;
        wire vddmaint;
        wire vddsmpint;  
        wire vddsmaint;  
        
        

//  WIRE DECLARATION 
//  ==================
        wire [Bits-1 : 0] CSWEMTBYPASS;
        wire [Bits-1 : 0] Dint, Dsys;
        wire [Bits-1 : 0] Mint; 
        wire [19-1:0] Msys;
	wire [Addr-1 : 0] Aint;
        wire [Addr-1 : 0] Asys;

       


        wire [max_address_bits-1 : 0] A_int; 
                
	wire CKint_dft;
	wire CKint_func;
	wire CSNint;
        wire MEMEN;
        wire MEMEN_dft;
        wire TSE;

	wire WENint;
	wire WENsys;
        wire SLEEPint;
        wire STDBYint;
        wire SEint;
        wire SEsys;
        wire SCTRLIint;
        wire SDLIint;
        wire SDRIint;
        
        wire INITNint;
        wire TBYPASSint;
        wire TBYPASSsys;
        wire LSint; 
        wire HSint; 
        wire ATPint;
        wire DEint;
        
        wire [Addr-1 : 0] TAint;
        wire TBISTint;
        wire TBISTsys;
        wire TCSNint;
        wire TEDint;
        wire TODint;
        wire TEMint;
        wire TOMint;
        wire [Bits-1 : 0] TMint;
        wire [Bits-1 : 0] TDint;
        wire TWENint;
        wire IGint;
        wire IGbuf;
        wire CSNbuf;
        wire WENbuf;
        wire [read_margin_size-1:0] RMint;
        wire [write_margin_size-1:0] WMint;

        //Wires for scan chains
        //  ====================     
        wire [scanlen_ctrl -1:0]scanreg_ctrl_wire;
        wire [scanlen_l -1:0]  scanreg_dl_wire; 
        wire [scanlen_r -1:0]  scanreg_dr_wire; 
   
        wire [scanlen_l -1:0]  scanreg_ml_wire; 
        wire [scanlen_r -1:0]  scanreg_mr_wire; 


        wire [repair_address_width -1 : 0] RRAint;
        wire RRAEint;
        wire TRRAEint;    
        wire red_en;
        wire [repair_address_width -1 : 0] repair_add, next_repair_add;


//  REG DECLARATION
//  ====================     
        reg MEMEN_reg;
        reg MEMEN_prev;
        reg reg_mem_block;
        reg flag_mem_block;
        reg SCTRLIint_temp;
        reg SDLIint_temp;
        reg SDRIint_temp;
        reg SMLIint_temp;
        reg SMRIint_temp;

        //  REG DECLARATION
        //  ====================
        reg SCTRLOint;
        
        reg SDLOint,SDROint;
         
        
        reg next_cycle_corrupt_func;
        reg next_cycle_corrupt_dft;
        reg [Bits-1 : 0] delOutReg_data;//delayed Output Register
        reg [Bits-1 : 0] OutReg_data;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_tbypass;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_scan;   // Data Output registe
        reg [Bits-1 : 0] OutReg_rado_retained;   // register for retaining rado data when SLEEP --> 1
        reg delSCTRLO_data,SCTRLO_data;      // delayed Output Register
        reg delSDLO_data,SDLO_data;      // delayed Output Register
        reg delSDRO_data,SDRO_data;      // delayed Output Register
        
        
        // SCAN CHAINS register
        reg scanreg_ctrl; 
        reg scanreg_dl; 
        reg scanreg_dr; 
        
        
        reg CK_sc;
        reg Latch_open=0;
        reg lastCK_dft,CKreg_dft;
        reg lastCK_func,CKreg_func;
        reg lastSLEEP;
        reg lastPSWLARGEMP,lastPSWLARGEMA,lastPSWSMALLMP,lastPSWSMALLMA;
        reg CSNreg;
        reg init_pulse_done; //if == 1 then it implies that initb low pulse has been applied
        reg power_up_done; //if == 1 then it implies that power up has been done
        `ifdef slm
        `else
	      
             reg [Bits-1 : 0] Mem [Words-1 : 0];
             reg [Bits-1 : 0] RedMem [RedWords-1 : 0];
 
        `endif
        
	reg [Bits-1 :0] Mem_temp;
        reg [Bits-1 :0] Mem_slm; 
	reg ValidAddress;
	reg ValidDebugCode;
        reg decoding_start;
        reg file_loaded;
        reg [Bits-1 :0] Dreg;
        reg [Bits-1 :0] Mreg;
        reg WENreg;
        reg [Addr-1 :0] Areg;
        reg SE_reg;
        reg TBYPASS_reg;
        reg INITNreg;
        reg IGreg;
        reg DEreg;
        reg SLEEPreg;
        reg STDBYreg;
        reg ATPreg;
        reg MEMEN_dft_reg;
        reg MEMEN_dft_prev;
        reg RRMATCHreg;
        reg RRMATCHreg_last;//changes_made
        reg RRMATCHreg_glitch;
        reg [repair_address_width -1 : 0] repair_add_last;
        reg RRAEint_last;
        reg [Addr-mux_bits-1:0] row_add_temp;
        reg [Addr-mux_bits-bank_bits-1:0] row_add_cmp_temp;

       
        //parameter registers
        reg [2047:0] reg_Fault_file_name;
        reg reg_ConfigFault;
        reg reg_MEM_INITIALIZE;
        reg reg_BinaryInit;
        reg [2047:0] reg_InitFileName;
        reg [Bits -1 :0] reg_Initn_reset_value;
        time reg_File_load_time;

        //Power Supply Registers        
        reg vddmireg;
        reg vddmreg;
        reg vddsmreg;
        reg gndmreg;
        reg gndsmreg;   
        reg vddmpreg;
        reg vddmpireg;
        reg vddmareg;
        reg vddsmpreg;
        reg vddsmareg;
        reg vddmoreg;
        time vddmp_rise_time;
        time vddmp_fall_time;
        time vddsmp_rise_time;
        time vddsmp_fall_time;
        time vddma_rise_time;
        time vddma_fall_time;
        time vddsma_rise_time;
        time vddsma_fall_time;
        reg reg_check_rise;
        reg reg_check_fall;
        reg reg_check_rise_vddma;
        reg reg_check_fall_vddsma;
        reg  reg_check_rise_vddm, reg_check_fall_vddsm ;
        time vddm_fall_time,  vddm_rise_time,  vddsm_fall_time, vddsm_rise_time ;
  /* This register is used to force all warning messages 
  ** OFF during run time.
  ** It is a 2 bit register.
  ** USAGE :
  ** debug_level_off = 2'b00 -> ALL MESSAGES(INFO/WARNINGS/ERRORS) will be DISPLAYED 
  ** debug_level = 2'b01     -> ONLY WARNINGS/ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b10     -> ONLY ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b11     -> NO MESSAGES will be DISPLAYED.
  */ 
        reg [1:0] debug_level;
        reg [8*10: 0] operating_mode;
        reg [8*44: 0] message_status;

        integer i, k, j, l,m,q,w,r,s,num1,redcnt,n,num2,FirstHalf,Bfaileff,memcnt,ptr;
        integer decoder[Bits-1:0];
        `ifdef slm
           integer MemAddr;
        `endif


        //************************************************************
        //****** CONFIG FAULT IMPLEMENTATION VARIABLES*************** 
        //************************************************************ 

        integer file_ptr, ret_val;
        integer fault_word;
        integer fault_bit;
        integer fcnt, Fault_in_memory,faultnum,stop_loop,count;
        integer t;  
        integer FailureLocn [max_faults -1 :0];
        integer Failurebit [max_faults -1 :0];
        reg [100 : 0] stuck_at;
        reg [100 : 0] fault_array;
        reg [200 : 0] tempStr;
        reg [7:0] fault_char;
        reg [7:0] fault_char1; // 8 Bit File Pointer
        reg [Addr -1 : 0] std_fault_word;
        reg [Addr -1 : mux_bits] fault_row_add [max_faults -1 :0];
        reg [max_faults -1 :0] fault_repair_flag;
        reg [max_faults -1 :0] dont_insert_fault;
        reg [max_faults -1 :0] repair_flag;
        reg [100 : 0] array_stuck_at[max_faults -1 : 0] ;
        reg [100 : 0] mem_red_array_stuck_at[max_faults -1 : 0] ; 
        reg msgcnt;
        
       
        reg [Bits - 1: 0] stuck_at_0fault [max_faults -1 : 0];
        reg [Bits - 1: 0] stuck_at_1fault [max_faults -1 : 0];
        reg [Bits -1 : 0] stuck0;
        reg [Bits -1 : 0] stuck1;

        reg [Bits+Red_extrabit :0] Mem_last;
        

        `ifdef slm
        reg [Bits -1 : 0] slm_temp_data;
        `endif
        
        real time_CK_func_rise , time_RADCK_rise;
        real time_fall_sleep,time_fall_PSWLARGEMP,time_fall_PSWLARGEMP_0,time_fall_PSWLARGEMA,time_fall_PSWLARGEMA_0,time_fall_PSWSMALLMP,time_fall_PSWSMALLMA;
        integer flag_error;
        
//BUFFER INSTANTIATION
//=========================
       `ifdef functional
       
         buf (SCTRLO,delSCTRLO_data); 
         buf bufq [Bits-1:0] (Q,delOutReg_data);
      `else
       
         buf (SCTRLO,SCTRLO_data);
         buf bufq [Bits-1:0] (Q,OutReg_data);
      `endif
      
  
        buf (SEsys,SE);
	buf (SCTRLIint, SCTRLI);
   

	buf (CKint_func, CK);
	buf (CKint_dft, CK);
        buf bufaddr [Addr-1:0] (Asys,A);
        buf (INITNint,INITN);
        
        buf (LSint,1'b0); 
        buf (IGbuf,IG);
        buf (ATPint,ATP);

        buf bufTaddr [Addr-1 : 0] (TAint,TA);
        buf (TBISTsys,TBIST);
        buf (TCSNint,TCSN);

        buf (CSNsys,CSN);
        buf (STDBYint,STDBY );   
        
        buf (SLEEPint,SLEEP ); 

        buf bufrm [read_margin_size-1:0] (RMint, RM); 

        
        

        assign RRAEint = 1'b0;
        assign TRRAEint = 1'b0;
        assign repair_add = 0;
        assign next_repair_add = 0;
        assign red_en = 1'b0; 
        
        
        
        
        
        
        
        buf (PSWLARGEMPint,1'b0);
        buf (PSWSMALLMPint,1'b0); 
        buf (PSWLARGEMAint,1'b0);
        buf (PSWSMALLMAint,1'b0);   

      `ifdef functional
       
       
         buf (SDLO,delSDLO_data);
         buf (SDRO,delSDRO_data);
        
      `else
       
         buf (SDLO,SDLO_data);
         buf (SDRO,SDRO_data);
         
      `endif
       
         
       
        buf bufdata [Bits-1:0] (Dsys,D);
        
        
        assign Msys=19'b0; 
	

        
        buf (TBYPASSsys, TBYPASS);
        


        buf (WENsys,WEN);
	 
	buf (SDLIint, SDLI);
	buf (SDRIint, SDRI);
	 
        
        buf (HSint,1'b0); 

        
        buf (TEDint,TED);
        buf (TODint,TOD);
         
        buf (TWENint,TWEN);
        
        
        buf bufwm [write_margin_size-1:0] (WMint, WM); 
        



//      assign scanreg_ctrl_wire={scanreg_ctrl[scanlen_ctrl - 2:0],SCTRLIint};
//      assign scanreg_dl_wire={scanreg_dl[scanlen_l - 2:0],SDLIint};
//      assign scanreg_dr_wire={scanreg_dr[scanlen_r - 2:0],SDRIint};
      
        
      assign Aint   = (TBISTint === 1'b0 ) ? Asys : (TBISTint === 1'bx ) ? {Addr{1'bx}} : TAint;  

        
//        assign A_int = Aint;
	
        
                
        assign Dint[0] = (TBISTint === 1'b0) ? Dsys[0] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[1] = (TBISTint === 1'b0) ? Dsys[1] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[2] = (TBISTint === 1'b0) ? Dsys[2] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[3] = (TBISTint === 1'b0) ? Dsys[3] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[4] = (TBISTint === 1'b0) ? Dsys[4] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[5] = (TBISTint === 1'b0) ? Dsys[5] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[6] = (TBISTint === 1'b0) ? Dsys[6] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[7] = (TBISTint === 1'b0) ? Dsys[7] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[8] = (TBISTint === 1'b0) ? Dsys[8] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[9] = (TBISTint === 1'b0) ? Dsys[9] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[10] = (TBISTint === 1'b0) ? Dsys[10] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[11] = (TBISTint === 1'b0) ? Dsys[11] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[12] = (TBISTint === 1'b0) ? Dsys[12] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[13] = (TBISTint === 1'b0) ? Dsys[13] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[14] = (TBISTint === 1'b0) ? Dsys[14] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[15] = (TBISTint === 1'b0) ? Dsys[15] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[16] = (TBISTint === 1'b0) ? Dsys[16] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[17] = (TBISTint === 1'b0) ? Dsys[17] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[18] = (TBISTint === 1'b0) ? Dsys[18] : (TBISTint === 1'b1) ? TEDint : 1'bx;          
	 
        assign Mint = 19'b0;
         

        assign WENbuf = (TBISTint === 1'b0 ) ? WENsys : (TBISTint === 1'bx ) ? 1'bx : TWENint;  
        assign WENint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? WENbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[13] : (ATPint === 1'b0 ) ? WENsys : 1'bx ; 
        
        assign CSNbuf = (TBISTint === 1'b0 ) ? CSNsys : (TBISTint === 1'bx ) ? 1'bx : TCSNint;  
        assign CSNint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? CSNbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[11] : (ATPint === 1'b0 ) ? CSNsys : 1'bx ; 
        assign IGint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? IGbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[14] : (ATPint === 1'b0 ) ? IGbuf : 1'bx;

        
        assign DEint = (LSint === 1'bx || (LSint === 1'b0 && HSint === 1'bx) || ^RMint !== 1'b0 || ^WMint !== 1'b0 ) ? 1'bx : 1'b0;
        
     
     and (TBISTint, ATPint, TBISTsys);
     and (SEint, ATPint, SEsys);
     and (TBYPASSint, ATPint, TBYPASSsys);
     and (TSE,TBYPASSint,!SEsys);
     and (MEMEN,INITNint,!CSNint,!SLEEPint,!TBYPASSint,!SEint,!IGint,!DEint,!STDBYint );
     and (MEMEN_dft,INITNint, !SLEEPint, ATPint,!STDBYint);

 `ifdef functional
/*****************assertions added to optimize dynamic power consumption**********/

//psl a_M: assert always ({( RW_assertions_en);(MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1))  } |-> (stable(Msys))) @(posedge CK); 

//psl a_WEN: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(WENsys))) @(posedge CK); 

//psl a_A: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(Asys))) @(posedge CK); 

//psl a_D: assert always ({( RW_assertions_en);((MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1)) && TBYPASSint === 1'b0)  } |-> (stable(Dsys))) @(posedge CK); 

/**********************************************************************************************/
`endif       

     

         
reg vddmp,vddmo, vddma, vddsmp, vddsma, gndsm, gndm,  vddmpi ; 
 
initial 
begin

        vddmp = 1'b1 ; 
        vddmo = 1'b1 ;
        vddma = 1'b1 ;
        
        vddsmp = 1'b1 ;
        
        
         gndm = 1'b0 ;
          
end

        
         assign gndmint = (reg_mem_block === 0) ? gndm : 1'b1;
         
         
         
         
         assign vddmpint = vddmp;
         assign vddmoint = vddmo;
         assign vddmaint = vddma;
         
          
        
         

        //CPF Changes

        
                
        initial
        begin : cpfvddmp 
           vddmpreg = vddmpint;
        end

        always @(vddmpint) begin
           vddmpreg = vddmpint;
        end
        
        initial
        begin : cpfvddmo 
           vddmoreg = vddmoint;
        end

        always @(vddmoint) begin
           vddmoreg = vddmoint;
        end
        
        initial
        begin : cpfvddma 
           vddmareg = vddmaint;
        end

        always @(vddmaint) begin
           vddmareg = vddmaint;
        end

        
        
 
        initial
        begin : cpfgndm 
           gndmreg = gndmint;
        end

        always @(gndmint) begin
           gndmreg = gndmint;
        end

        
        



 `ifdef functional
  `else
  initial begin
    if (debug_level < 1) begin
     $display ("%m  INFORMATION");
     $display ("***************************************");
     $display ("The Model is Operating in TIMING MODE");
     $display ("Please make sure that SDF is properly annotated otherwise dummy values will be used");
     $display ("%s", message_status);
     $display ("***************************************");
    end
  end

//////////////////////////
 //REG DECLARATIONS
   //======================

   reg [Bits-1 : 0] TimingViol_data;
   reg  [Bits-1 : 0] TimingViol_mask;
   reg [Bits-1 : 0] TimingViol_data_last, TimingViol_mask_last;
	reg TimingViol_data_0;
	reg TimingViol_data_1;
	reg TimingViol_data_2;
	reg TimingViol_data_3;
	reg TimingViol_data_4;
	reg TimingViol_data_5;
	reg TimingViol_data_6;
	reg TimingViol_data_7;
	reg TimingViol_data_8;
	reg TimingViol_data_9;
	reg TimingViol_data_10;
	reg TimingViol_data_11;
	reg TimingViol_data_12;
	reg TimingViol_data_13;
	reg TimingViol_data_14;
	reg TimingViol_data_15;
	reg TimingViol_data_16;
	reg TimingViol_data_17;
	reg TimingViol_data_18;
 reg TimingViol_mask_0;
 reg TimingViol_mask_1;
 reg TimingViol_mask_2;
 reg TimingViol_mask_3;
 reg TimingViol_mask_4;
 reg TimingViol_mask_5;
 reg TimingViol_mask_6;
 reg TimingViol_mask_7;
 reg TimingViol_mask_8;
 reg TimingViol_mask_9;
 reg TimingViol_mask_10;
 reg TimingViol_mask_11;
 reg TimingViol_mask_12;
 reg TimingViol_mask_13;
 reg TimingViol_mask_14;
 reg TimingViol_mask_15;
 reg TimingViol_mask_16;
 reg TimingViol_mask_17;
 reg TimingViol_mask_18;

   reg TimingViol_addr;
   reg TimingViol_CSN, TimingViol_WEN, TimingViol_tbypass;
   reg TimingViol_tckh, TimingViol_tckl, TimingViol_tcycle;
   reg TimingViol_tckh_se, TimingViol_tckl_se, TimingViol_tcycle_se;
   reg TimingViol_sctrli,TimingViol_sdli,TimingViol_sdri,TimingViol_se;
   reg TimingViol_smli,TimingViol_smri;
   reg TimingViol_sctrli_flag,TimingViol_sdli_flag,TimingViol_sdri_flag;
   reg TimingViol_smli_flag,TimingViol_smri_flag;
   reg TimingViol_initnl;
   reg TimingViol_initn;
   reg TimingViol_ls;
   reg TimingViol_hs;
   reg TimingViol_sleep;
   reg TimingViol_stdby;
   reg TimingViol_rm;
   reg TimingViol_wm;
   reg TimingViol_tbist,TimingViol_ig,TimingViol_atp,TimingViol_TED,TimingViol_TOD,TimingViol_TEM,TimingViol_TOM;
   reg TimingViolRRAE,TimingViolRRA;

   wire CSTBYPASSN,cond_sdf_tas,cond_sdf_tds,cond_sdf_tms,cond_sdf_tws,cond_sdf_tbas,cond_sdf_tbps,cond_sdf_tbws,cond_sdf_tbdes,cond_sdf_tbdos,cond_sdf_tbmes,cond_sdf_tbmos;
   wire SETB_EN,CSIG_EN,MEM_ACT,EN_ADM,CS_EN,CS_ADM,cond_sdf_tps,IG_EN,IG_ADM,cond_sdf_tigs,cond_sdf_taa,cond_sdf_taa_ls1,cond_sdf_taa_hs1,cond_tseq_tm;
   wire cond_sdf_tcycle,cond_sdf_tcycle_ls1,cond_sdf_tcycle_hs1,cond_sdf_tcycle_se,cond_sdf_tckl_se,cond_sdf_tsctrlis,cond_sdf_tsdlis,cond_sdf_tsdris,cond_sdf_tsmlis,cond_sdf_tsmris;
   wire cond_sdf_tckh_se,cond_sdf_taa_sctrlo_se,cond_sdf_taa_sdlo_se,cond_sdf_taa_sdro_se,cond_sdf_taa_smlo_se,cond_sdf_taa_smro_se,cond_sdf_tckl,cond_sdf_tckh;
   wire cond_sdf_ttms,cond_sdf_tbists,INITNandnotSLEEPandATPandnotSE,cond_sdf_taa_sctrlo,cond_sdf_taa_sdlo,cond_sdf_taa_sdro,cond_sdf_taa_smlo,cond_sdf_taa_smro;
   wire cond_sdf_taa_tm,cond_sdf_taa_tm_ls1, cond_sdf_taa_tm_hs1,cond_sdf_taa_tckq_tm,cond_sdf_taa_tseq_tm;

   wire CSWETBYPASSN;
   wire cond_sdf_tstdbys,cond_sdf_tsls,sleep_en,atp_csn_en;
   wire cond_sdf_tlss,cond_sdf_thss,cond_sdf_trms,cond_sdf_twms; 
   wire cond_sdf_tses,cond_sdf_tinitns;
   wire tby_se_en;
   wire rra_en;
   wire tbist_atp_en;
   wire rrae_en;
   wire tbist_rrae_en;
   wire cond_sdf_trraes;
   wire cond_sdf_ttrraes;
   wire cond_sdf_taa_trramatch;
   wire cond_sdf_ttrraematch;
   wire cond_sdf_tamatch;
   wire cond_sdf_ttamatch;
   wire cond_sdf_tatpmatch;
   wire cond_sdf_ttbistmatch;



 and (CSWEMTBYPASS[0], !Mreg[0], CSWETBYPASSN);
 and (CSWEMTBYPASS[1], !Mreg[1], CSWETBYPASSN);
 and (CSWEMTBYPASS[2], !Mreg[2], CSWETBYPASSN);
 and (CSWEMTBYPASS[3], !Mreg[3], CSWETBYPASSN);
 and (CSWEMTBYPASS[4], !Mreg[4], CSWETBYPASSN);
 and (CSWEMTBYPASS[5], !Mreg[5], CSWETBYPASSN);
 and (CSWEMTBYPASS[6], !Mreg[6], CSWETBYPASSN);
 and (CSWEMTBYPASS[7], !Mreg[7], CSWETBYPASSN);
 and (CSWEMTBYPASS[8], !Mreg[8], CSWETBYPASSN);
 and (CSWEMTBYPASS[9], !Mreg[9], CSWETBYPASSN);
 and (CSWEMTBYPASS[10], !Mreg[10], CSWETBYPASSN);
 and (CSWEMTBYPASS[11], !Mreg[11], CSWETBYPASSN);
 and (CSWEMTBYPASS[12], !Mreg[12], CSWETBYPASSN);
 and (CSWEMTBYPASS[13], !Mreg[13], CSWETBYPASSN);
 and (CSWEMTBYPASS[14], !Mreg[14], CSWETBYPASSN);
 and (CSWEMTBYPASS[15], !Mreg[15], CSWETBYPASSN);
 and (CSWEMTBYPASS[16], !Mreg[16], CSWETBYPASSN);
 and (CSWEMTBYPASS[17], !Mreg[17], CSWETBYPASSN);
 and (CSWEMTBYPASS[18], !Mreg[18], CSWETBYPASSN);

and (atp_csn_en,!ATPint,!CSNint,!IGint);
or (sleep_en,atp_csn_en,ATPint);
or (SETB_EN,SEint,TBISTint);
and (ATP_SETB_EN,ATPint,SETB_EN); 
or (CSIG_EN,IGint,CSNint);
and (MEM_ACT,!ATPint,CSIG_EN);
or (EN_ADM,MEM_ACT,ATP_SETB_EN);
and (CS_EN,!ATPint,IGint);
or (CS_ADM,CS_EN,ATP_SETB_EN);
and (atp_ig_csn_en,!ATPint,!CSNint,!IGint);
and (atp_se_en,!SEsys,ATPint);
or (cycle_en,atp_ig_csn_en,atp_se_en);
and (atp_ig_csn_en_reg,!ATPreg,!CSNreg,!IGreg);
and (atp_se_en_reg,!SE_reg,ATPreg);
or (cycle_en_reg,atp_ig_csn_en,atp_se_en);
and (INITNandnotSLEEPandATPandnotSE,cond_gac,!SEsys,ATPint);
and (csn_ig_en,!IGint,!CSNint);
and (atp_tby_ls_en,atp_se_en,cond_ls_tby_en);
and (IG_EN,!ATPint,!CSNint);
or (IG_ADM,IG_EN,atp_se_en);
and (CSWETBYPASSN, !WENreg, 1'b1);



assign cond_sdf_tsls=((sleep_en && INITNint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tstdbys=((sleep_en && INITNint && !SLEEPint) !==0) ? 1:0;
assign cond_sdf_atps=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_gac=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tas=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tds=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tms=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tws=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tps=((cond_gac && !CS_ADM) !==0) ? 1:0;
assign cond_sdf_tcycle=((cond_gac && cycle_en && !LSint && !HSint) !==0) ? 1:0;  
assign cond_sdf_tcycle_ls1=((cond_gac && cycle_en && LSint) !==0) ? 1:0;
assign cond_sdf_tcycle_hs1=((cond_gac && cycle_en && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_tckh=((cond_gac && cycle_en_reg) !==0) ? 1:0;
assign cond_sdf_tckl=((cond_gac && cycle_en) !==0) ? 1:0;
assign cond_sdf_tcycle_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckl_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsctrlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckh_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_ttms=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_tbists=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_tckq_tm=((cond_gac && SE_reg && ATPreg && TBYPASSsys) !==0) ? 1:0;
assign cond_ls_en=((atp_ig_csn_en || atp_tby_ls_en) !==0) ? 1:0;
assign cond_sdf_tlss=((cond_ls_en && cond_gac) !==0) ? 1:0;
assign cond_sdf_thss=((cond_ls_en && cond_gac && !LSint) !==0) ? 1:0;
assign cond_sdf_trms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_twms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_tses=((cond_gac && ATPint) !==0) ? 1:0;
assign cond_sdf_tbas=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbps=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbws=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tigs=((cond_gac && IG_ADM) !==0) ? 1:0;
assign cond_sdf_taa=((MEMEN_reg && WENreg && !LSint && !HSint) !==0) ? 1:0; 
// assign cond_sdf_taa_tbypass_q = ((MEMEN_reg && ATPint && TBYPASSint) !== 1'b0) ? 1'b1 : 1'b0;
assign cond_sdf_taa_ls1=((MEMEN_reg && WENreg && LSint) !==0) ? 1:0; 
assign cond_sdf_taa_hs1=((MEMEN_reg && WENreg && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && !HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_ls1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && LSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_hs1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tseq_tm=((cond_gac && TBYPASSint) !==0) ? 1:0;
assign cond_sdf_tinitns =(( sleep_en && !STDBYint && !SLEEPint) !==0) ? 1:0;
assign cond_ls_tby_en=((TBYPASSsys || csn_ig_en) !==0) ? 1:0;



//specify block begins

specify
    specparam
    
         PATHPULSE$CK$Q = 0,
         PATHPULSE$CK$SCTRLO = 0,

         PATHPULSE$CK$SDLO = 0,
         PATHPULSE$CK$SDRO = 0,
        
         PATHPULSE$SE$Q = 0,
         
//         PATHPULSE$TBYPASS$Q = 0,


        
         
        
         tsls = `setup_time,
         tslh = `hold_time ,
         tstdbys = `setup_time,
         tstdbyh = `hold_time , 
	 

         
         tcycle = `cycle_time,
         
         
         tckh = `pulse_width_time,
         tckl = `pulse_width_time,
         tcycle_se = `cycle_time,
         tckh_se = `pulse_width_time,
         tckl_se = `pulse_width_time,
         
         ttms = `setup_time,
         ttmh = `hold_time ,
         tps = `setup_time,
         tph = `hold_time ,
         tws = `setup_time,
         twh = `hold_time ,
         tds = `setup_time,
         tdh = `hold_time , 
         tas = `setup_time,
         tah = `hold_time ,
         tses= `setup_time,
         tseh= `hold_time ,
         tsctrlis=`setup_time,
         tsctrlih=`hold_time ,
         tsdlis=`setup_time,
         tsdlih=`hold_time ,
         tsdris=`setup_time,
         tsdrih=`hold_time , 
         tbists=`setup_time,
         tbisth=`hold_time ,
         tbps=`setup_time,
         tbph=`hold_time ,
         tbws=`setup_time,
         tbwh=`hold_time ,
         tbdes=`setup_time,
         tbdeh=`hold_time ,
         tbdos=`setup_time,
         tbdoh=`hold_time ,
         
         tbas=`setup_time,
         tbah=`hold_time ,
         tinitnl=`initin_low_pulse,
         tinitns=`setup_time,
         tinitnh=`hold_time ,
         tatps=`setup_time,
         tatph=`hold_time ,
         tigs=`setup_time,
         tigh=`hold_time ,
         
         
         trms=`setup_time,
         trmh=`hold_time ,
         twms=`setup_time,
         twmh=`hold_time , 

/*************************************************************************************************/
           // taa_tbypass_q = `access_time,
           // th_tbypass_q  = `retain_time,
            taa =`access_time,
            th = `retain_time,

 


            taa_tm =`access_time,
            th_tm = `retain_time,

            
            taa_tseq_tm =`access_time,
            th_tseq_tm = `retain_time,
            taa_tckq_tm   = `access_time,
            th_tckq_tm    = `retain_time,
            taa_sctrlo=`access_time,
            th_sctrlo= `retain_time,
            taa_sdlo=`access_time,
            th_sdlo= `retain_time,
            taa_sdro=`access_time,
            th_sdro= `retain_time,
            
         
            taa_sctrlo_se=`access_time,
            th_sctrlo_se= `retain_time
,
            taa_sdlo_se=`access_time,
            th_sdlo_se= `retain_time,
            taa_sdro_se=`access_time,
            th_sdro_se= `retain_time
         ;  


        /*---------------------- Timing Checks ---------------------*/

	$setup(posedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[7], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[8], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[9], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[7], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[8], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[9], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[7], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[8], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[9], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[7], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[8], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[9], tah, TimingViol_addr);

	$setup(posedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(posedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(posedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(posedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(posedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(posedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(posedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(posedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(posedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(posedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(posedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(posedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(posedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(posedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(posedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(posedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(posedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(posedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(posedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(negedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(negedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(negedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(negedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(negedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(negedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(negedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(negedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(negedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(negedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(negedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(negedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(negedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(negedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(negedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(negedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(negedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(negedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(negedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[18], tdh, TimingViol_data_18);

        



        $setup(posedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $setup(negedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, posedge WEN, twh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, negedge WEN, twh, TimingViol_WEN); 
        $setup(posedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$setup(negedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, posedge CSN, tph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, negedge CSN, tph, TimingViol_CSN);
        $period(posedge CK &&& cond_sdf_tcycle, tcycle, TimingViol_tcycle);  

        
        $width(posedge CK  &&& cond_sdf_tckh, tckh, 0, TimingViol_tckh);
        $width(negedge CK  &&& cond_sdf_tckl, tckl, 0, TimingViol_tckl);
        $period(posedge CK &&& cond_sdf_tcycle_se, tcycle_se, TimingViol_tcycle_se);
        $width(posedge CK  &&& cond_sdf_tckh_se, tckh_se, 0, TimingViol_tckh_se);
        $width(negedge CK  &&& cond_sdf_tckl_se, tckl_se, 0, TimingViol_tckl_se);

        
        $setup(posedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $setup(negedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $hold(posedge CK &&& cond_sdf_ttms, posedge TBYPASS, ttmh, TimingViol_tbypass); 
        $hold(posedge CK &&& cond_sdf_ttms, negedge TBYPASS, ttmh, TimingViol_tbypass); 
 



        
        $setup(posedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $setup(negedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $hold(posedge CK &&& cond_sdf_tsls, posedge SLEEP, tslh, TimingViol_sleep);        
        $hold(posedge CK &&& cond_sdf_tsls, negedge SLEEP, tslh, TimingViol_sleep);

        $setup(posedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $setup(negedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $hold(posedge CK &&& cond_sdf_tstdbys, posedge STDBY, tstdbyh, TimingViol_stdby);        
        $hold(posedge CK &&& cond_sdf_tstdbys, negedge STDBY, tstdbyh, TimingViol_stdby); 
        
        
        $setup (posedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
	$setup (negedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
        
        $hold (posedge CK &&& cond_sdf_tses, posedge SE ,tseh,TimingViol_se);
	$hold (posedge CK &&& cond_sdf_tses, negedge SE ,tseh,TimingViol_se);
        
        $setup(posedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis , tsctrlis, TimingViol_sctrli);
        $setup(negedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis, tsctrlis, TimingViol_sctrli);
        $hold(posedge CK &&& cond_sdf_tsctrlis , posedge SCTRLI, tsctrlih, TimingViol_sctrli);        
        $hold(posedge CK &&& cond_sdf_tsctrlis , negedge SCTRLI, tsctrlih, TimingViol_sctrli);

        $setup(posedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $setup(negedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $hold(posedge CK &&& cond_sdf_tsdlis, posedge SDLI, tsdlih, TimingViol_sdli);        
        $hold(posedge CK &&& cond_sdf_tsdlis, negedge SDLI, tsdlih, TimingViol_sdli);

        $setup(posedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $setup(negedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $hold(posedge CK &&& cond_sdf_tsdris, posedge SDRI, tsdrih, TimingViol_sdri);        
        $hold(posedge CK &&& cond_sdf_tsdris, negedge SDRI, tsdrih, TimingViol_sdri);
        
 
	
         
        $width(negedge INITN , tinitnl, 0, TimingViol_initnl);
        
        $setup(posedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        $setup(negedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        
        $hold (posedge CK &&& cond_sdf_tinitns,posedge INITN, tinitnh, TimingViol_initn);
        $hold (posedge CK &&& cond_sdf_tinitns,negedge INITN, tinitnh, TimingViol_initn);

        $setup(posedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $setup(negedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $hold(posedge CK &&& cond_sdf_atps, posedge ATP, tatph, TimingViol_atp);        
        $hold(posedge CK &&& cond_sdf_atps, negedge ATP, tatph, TimingViol_atp);
        
        $setup(posedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $setup(negedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $hold(posedge CK &&& cond_sdf_tigs, posedge IG, tigh, TimingViol_ig);        
        $hold(posedge CK &&& cond_sdf_tigs, negedge IG, tigh, TimingViol_ig);



         
$setup(posedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[2], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[2], trmh, TimingViol_rm); 

        
$setup(posedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(posedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[1], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[1], twmh, TimingViol_wm);
 
        
        $setup(posedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $setup(negedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $hold(posedge CK &&& cond_sdf_tbists, posedge TBIST, tbisth, TimingViol_tbist);        
        $hold(posedge CK &&& cond_sdf_tbists, negedge TBIST, tbisth, TimingViol_tbist);
        
        	$setup(posedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[7], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[8], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[9], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$setup(negedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[7], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[8], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[9], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[6], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[7], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[8], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[9], tbah, TimingViol_addr);
       	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[6], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[7], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[8], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[9], tbah, TimingViol_addr);

        $setup(posedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$setup(negedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, posedge TCSN, tbph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, negedge TCSN, tbph, TimingViol_CSN); 
       
        $setup(posedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $setup(negedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, posedge TWEN, tbwh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, negedge TWEN, tbwh, TimingViol_WEN);
       
       
        $setup(posedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $setup(negedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, posedge TED, tbdeh, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, negedge TED, tbdeh, TimingViol_TED);

        $setup(posedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $setup(negedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, posedge TOD, tbdoh, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, negedge TOD, tbdoh, TimingViol_TOD);

          


          

          /*-------------------- Propagation Delays ------------------*/
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa, taa, th, taa, th, taa);
                 

/* // //	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[0] +: OutReg_data[0])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[1] +: OutReg_data[1])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[2] +: OutReg_data[2])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[3] +: OutReg_data[3])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[4] +: OutReg_data[4])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[5] +: OutReg_data[5])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[6] +: OutReg_data[6])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[7] +: OutReg_data[7])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[8] +: OutReg_data[8])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[9] +: OutReg_data[9])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[10] +: OutReg_data[10])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[11] +: OutReg_data[11])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[12] +: OutReg_data[12])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[13] +: OutReg_data[13])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[14] +: OutReg_data[14])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[15] +: OutReg_data[15])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[16] +: OutReg_data[16])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[17] +: OutReg_data[17])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[18] +: OutReg_data[18])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q); */ 








	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                





	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                 

	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[0] +: OutReg_data[0])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[1] +: OutReg_data[1])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[2] +: OutReg_data[2])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[3] +: OutReg_data[3])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[4] +: OutReg_data[4])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[5] +: OutReg_data[5])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[6] +: OutReg_data[6])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[7] +: OutReg_data[7])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[8] +: OutReg_data[8])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[9] +: OutReg_data[9])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[10] +: OutReg_data[10])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[11] +: OutReg_data[11])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[12] +: OutReg_data[12])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[13] +: OutReg_data[13])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[14] +: OutReg_data[14])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[15] +: OutReg_data[15])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[16] +: OutReg_data[16])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[17] +: OutReg_data[17])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[18] +: OutReg_data[18])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                



if (cond_sdf_taa_sctrlo) 
        (posedge CK *> (SCTRLO :  SCTRLI)) = (taa_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo); 

if (cond_sdf_taa_sctrlo_se) 
        (negedge CK *> (SCTRLO : SCTRLI)) = (taa_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se); 
 

if (cond_sdf_taa_sdlo) 
        (posedge CK *> (SDLO :  SDLI)) = (taa_sdlo,taa_sdlo,th_sdlo,taa_sdlo,th_sdlo,taa_sdlo); 

if (cond_sdf_taa_sdlo_se) 
        (negedge CK *> (SDLO : SDLI)) = (taa_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se);

if (cond_sdf_taa_sdro) 
        (posedge CK *> (SDRO :  SDRI)) = (taa_sdro,taa_sdro,th_sdro,taa_sdro,th_sdro,taa_sdro); 

if (cond_sdf_taa_sdro_se) 
        (negedge CK *> (SDRO : SDRI)) = (taa_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se); 

  
     




endspecify //specify block ends






// conversion from registers to array elements for data setup violation notifiers

always @(TimingViol_data_0   or TimingViol_TED  )
begin
        TimingViol_data[0]=~TimingViol_data[0];   
end


always @(TimingViol_data_1   or TimingViol_TOD  )
begin
        TimingViol_data[1]=~TimingViol_data[1];   
end


always @(TimingViol_data_2   or TimingViol_TED  )
begin
        TimingViol_data[2]=~TimingViol_data[2];   
end


always @(TimingViol_data_3   or TimingViol_TOD  )
begin
        TimingViol_data[3]=~TimingViol_data[3];   
end


always @(TimingViol_data_4   or TimingViol_TED  )
begin
        TimingViol_data[4]=~TimingViol_data[4];   
end


always @(TimingViol_data_5   or TimingViol_TOD  )
begin
        TimingViol_data[5]=~TimingViol_data[5];   
end


always @(TimingViol_data_6   or TimingViol_TED  )
begin
        TimingViol_data[6]=~TimingViol_data[6];   
end


always @(TimingViol_data_7   or TimingViol_TOD  )
begin
        TimingViol_data[7]=~TimingViol_data[7];   
end


always @(TimingViol_data_8   or TimingViol_TED  )
begin
        TimingViol_data[8]=~TimingViol_data[8];   
end


always @(TimingViol_data_9   or TimingViol_TOD  )
begin
        TimingViol_data[9]=~TimingViol_data[9];   
end


always @(TimingViol_data_10   or TimingViol_TED  )
begin
        TimingViol_data[10]=~TimingViol_data[10];   
end


always @(TimingViol_data_11   or TimingViol_TOD  )
begin
        TimingViol_data[11]=~TimingViol_data[11];   
end


always @(TimingViol_data_12   or TimingViol_TED  )
begin
        TimingViol_data[12]=~TimingViol_data[12];   
end


always @(TimingViol_data_13   or TimingViol_TOD  )
begin
        TimingViol_data[13]=~TimingViol_data[13];   
end


always @(TimingViol_data_14   or TimingViol_TED  )
begin
        TimingViol_data[14]=~TimingViol_data[14];   
end


always @(TimingViol_data_15   or TimingViol_TOD  )
begin
        TimingViol_data[15]=~TimingViol_data[15];   
end


always @(TimingViol_data_16   or TimingViol_TED  )
begin
        TimingViol_data[16]=~TimingViol_data[16];   
end


always @(TimingViol_data_17   or TimingViol_TOD  )
begin
        TimingViol_data[17]=~TimingViol_data[17];   
end


always @(TimingViol_data_18   or TimingViol_TED  )
begin
        TimingViol_data[18]=~TimingViol_data[18];   
end


`endif


// TASK DEFINITION DESCRIPTION
// ================================



task task_insert_faults_in_memory;
begin
   if (reg_ConfigFault)
   begin   
     for(i = 0;i< fcnt;i = i+ 1) begin
        if(mem_red_array_stuck_at[i] === "mem_array") begin
          if (array_stuck_at[i] === "sa0") begin
           `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data & stuck_at_0fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
          `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] & stuck_at_0fault[i];
          `endif
         end //if(array_stuck_at)
                                        
         if(array_stuck_at[i] === "sa1") begin
         `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data | stuck_at_1fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
         `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] | stuck_at_1fault[i]; 
         `endif
         end //if(array_stuck_at)
       end //if mem_red_array_stuck_at
    
    
     end    // end of for
   end  
end
endtask



task task_read_fault_file;
begin
/*  -----------Implemetation for config fault starts------*/
   msgcnt = X;
   t = 0;
   fault_repair_flag = {max_faults{1'b1}};
   repair_flag = {max_faults{1'b1}};
   if(reg_ConfigFault) 
   begin
      file_ptr = $fopen(reg_Fault_file_name , "r");
      if(file_ptr == 0)
      begin     
          if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: File cannot be opened ",$realtime);
      end        
      else                
      begin : read_fault_file
        t = 0;
        for (i = 0; i< max_faults; i= i + 1)
        begin
         
           stuck0 = {Bits{1'b1}};
           stuck1 = {Bits{1'b0}};
           fault_char1 = $fgetc (file_ptr);
           if (fault_char1 == 8'b11111111)
              disable read_fault_file;
           ret_val = $ungetc (fault_char1, file_ptr);
           ret_val = $fgets(tempStr, file_ptr);
           ret_val = $sscanf(tempStr, "%s %d %d %s",fault_array,fault_word, fault_bit, stuck_at) ;
           flag_error = 0; 
           if(ret_val !== 0)
           begin         
              if(ret_val == 3 || ret_val == 4)
              begin
                if(ret_val == 3)
                   stuck_at = "sa0";

                if(stuck_at !== "sa0" && stuck_at !== "sa1" && stuck_at !== "none")
                begin
                    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: Wrong value for stuck at in fault file ",$realtime);
                   flag_error = 1;
                end    
                      
                if(fault_word >= Words)
                begin
                   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Address out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                if(fault_bit >= Bits)
                begin  
                    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Faulty bit out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                
                        
                if(fault_array !== "mem_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array is not mem_array ",$realtime);
                  flag_error = 1;
                end

                if(fault_array === "red_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array can't be on redundancy array in non redundancy cut.",$realtime);
                  flag_error = 1;
                end

                
                

                if(flag_error == 0)
                //Correct Inputs
                begin
                   if(stuck_at === "none")
                   begin
                       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
                   end
                   else
                   //Adding the faults
                   begin
                      FailureLocn[t] = fault_word;
                      Failurebit[t]  = fault_bit ;
                      std_fault_word = fault_word;
                      fault_row_add[t] = std_fault_word[Addr-1:mux_bits];
                      mem_red_array_stuck_at[t] = fault_array;
                      fault_repair_flag[t] = 1'b0;
                      if (stuck_at === "sa0" )
                      begin
                         stuck0[fault_bit] = 1'b0;         
                         stuck_at_0fault[t] = stuck0;
                      end     
                      if (stuck_at === "sa1" )
                      begin
                         stuck1[fault_bit] = 1'b1;
                         stuck_at_1fault[t] = stuck1; 
                      end

                      array_stuck_at[t] = stuck_at;
                      t = t + 1;
                   end //if(stuck_at === "none")  
                end //if(flag_error == 0)
              end //if(ret_val == 2 || ret_val == 3 
              else
              //wrong number of arguments
              begin
                if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: WRONG VALUES ENTERED FOR FAULTY WORD OR FAULTY BIT OR STUCK_AT IN Fault_file_name ",$realtime); 
                flag_error = 1;
              end
           end //if(ret_val !== 0)
           else
           begin 
               if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
           end    
        end //for (i = 0; i< m
      end //begin: read_fault_file  
      $fclose (file_ptr);

      fcnt = t;
      
      //fault injection at time 0.
      task_insert_faults_in_memory;
  end // config_fault 
end
endtask


task WriteMemX;
begin

`ifdef slm
   $slm_ResetMemory(MemAddr, WordX);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = WordX;
   
`endif        
 task_insert_faults_in_memory;
end
endtask

task WriteMem0;
begin
`ifdef slm
   $slm_ResetMemory(MemAddr, Word0);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = Word0;
  
`endif 
   task_insert_faults_in_memory;
end
endtask


task WriteOutX;                
begin
   OutReg_data <= #0 WordX;
end
endtask


task Invalid_next_cycle_func;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_func = 1;
     `else 
       #0 next_cycle_corrupt_func = 0; 
     `endif  
   end 
end
endtask

task Invalid_next_cycle_dft;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_dft = 1;
     `else 
       #0 next_cycle_corrupt_dft = 0; 
     `endif  
  end
end
endtask

task Invalid_next_cycle_func_tim;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
   #0 next_cycle_corrupt_func <= 1;
  end 
end
endtask

task Invalid_next_cycle_dft_tim;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
  #0 next_cycle_corrupt_dft <= 1;
  end
end
endtask


task ScanOutX;                
begin
   
   dff_SCTRLO_SE.Q <= 1'bx;   
   dff_SDLO_SE.Q <= 1'bx; 
   dff_SDRO_SE.Q <= 1'bx; 
    
   
   SCTRLOint=X;
   SDLOint=X;
   SDROint=X;
    
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   SDLO_data<=1'bx;
   SDRO_data<=1'bx;
    
   `endif
end
endtask

task delScanOutX;                
begin
   delSCTRLO_data<=X;
   delSDLO_data<=X;
   delSDRO_data<=X;
    
end
endtask

task ScanChainX;                
begin
 scanreg_ctrl=1'bx; 
 scanreg_dl=1'bx; 
 scanreg_dr =1'bx; 
  
end
endtask

task mem_blocked;
begin
 
   WriteMemX;
   WriteOutX;
   ScanChainX;
   ScanOutX;//immediately;
   delScanOutX;//immediately
   `ifdef POWER_SEQUENCING_OFF
   `else
   reg_mem_block=1;
   `endif
   debug_level = 2'b11;
end
endtask

task corrupt_all;
begin
 
  WriteMemX;
  WriteOutX;
  ScanChainX;
  ScanOutX;
  delScanOutX;//immediately;
  OutReg_data = WordX; 
  delOutReg_data=WordX;
  
end
endtask

task WriteCycle;                  
input [Addr-1 : 0] Address;
reg [Bits-1:0] tempReg1;
reg [Bits-1:0] tempReg_slm;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;


reg repair_flag;

integer po,i,num,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;
begin

   tempReg1 = WordX;
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];

   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};
   
   if (ValidAddress === X )   begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
        WriteMemX;
        if (INITNint !== 0) begin
        `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
           #0 next_cycle_corrupt_func = 1;
       `else 
           #0 next_cycle_corrupt_func = 0; 
       `endif  
   end 

   end


   if (ValidAddress !== X && next_cycle_corrupt_func === 0  )
   begin
         if (red_en === 1 && ((Row_Add_cmp === repair_add) || (Row_Add_cmp === next_repair_add)) ) begin
             repair_flag = 1'b1;
             
             Bank_sel_integer = 0;
                     
             if (Row_Add_cmp === repair_add) begin
               Col_Add_integer  = Col_Add; 
             end
             else if (Row_Add_cmp === next_repair_add) begin
               Col_Add_integer  = Col_Add + mux; 
             end  
             RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
        end  

        if(repair_flag === 0 && ValidAddress === 1) begin
           `ifdef slm
              $slm_ReadMemoryS(MemAddr, Address, tempReg_slm);
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = Mem[Address];
            `endif
          end  
        else if(repair_flag === 1) begin
           `ifdef slm
//              $slm_ReadMemoryS(RedMemAddr, RedMem_address, tempReg_slm);
          
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = RedMem[RedMem_address];
            `endif
        end
        
        for (num=0;num<Bits;num=num+1) begin
             po=num;        
             if ( Dint [num] !== tempReg1 [po]) begin
                if (Mint[num] === 1'b0)
                   tempReg1[po] = Dint[num];
                else if (Mint[num] === 1'bX)
                   tempReg1[po] = 1'bx;
             end                
        end //for (num=0
            
         if(repair_flag === 0 ) begin    
            if(ValidAddress === 1) begin  
              `ifdef slm
                  tempReg_slm=tempReg1; 
                  $slm_WriteMemory(MemAddr, Address, tempReg_slm);
              `else
                   Mem[Address] = tempReg1;
              `endif
            end
            else begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address Out Of Range. ",$realtime);
            end        
         end
         else if (repair_flag === 1 ) begin
            `ifdef slm
                tempReg_slm=tempReg1; 
//                $slm_WriteMemory(RedMemAddr, RedMem_address, tempReg_slm);
            `else
                RedMem[RedMem_address] = tempReg1;
            `endif
         end
   end //if (ValidAddress !== X
   task_insert_faults_in_memory;
end
endtask 

task ReadCycle;
input [Addr-1 : 0] Address;

reg [Bits-1:0] MemData_tmp;
reg [Bits-1:0] MemData;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;

reg repair_flag;

integer a,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;

begin
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];
   
   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};

   

   if (ValidAddress !== X && next_cycle_corrupt_func === 0 ) begin   
       if(red_en === 1 && ( Row_Add_cmp === repair_add ||  Row_Add_cmp === next_repair_add )) begin
              repair_flag = 1;
              
              Bank_sel_integer = 0;
               
              if(Row_Add_cmp === repair_add) begin
                Col_Add_integer = Col_Add;
              end
              else if (Row_Add_cmp === next_repair_add) begin
                Col_Add_integer = Col_Add + mux; 
              end
              RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
       end

      if(repair_flag === 0) begin
          if(ValidAddress === 1) begin 
           `ifdef slm
              $slm_ReadMemory(MemAddr, Address, MemData);
           `else
              MemData = Mem[Address];
           `endif
          end
          else begin
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Address Out Of Range. Output Corrupted ",$realtime);
             MemData = WordX;
          end
     end
      else if(repair_flag === 1) begin
        `ifdef slm
//           $slm_ReadMemory(RedMemAddr, RedMem_address, MemData);
        `else
           MemData = RedMem[RedMem_address];
        `endif
      end
   end //if (ValidAddress)  
   
   if(ValidAddress === X)
   begin
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Illegal Value on Address Bus. Memory and Output Corrupted ",$realtime); 
         Invalid_next_cycle_func;
   end 
   
  if(ValidAddress !== X && next_cycle_corrupt_func === 0 )
   begin
   for (a = 0; a < Bits; a = a + 1)
   begin
      if (MemData[a] !== OutReg_data[a])
         OutReg_data[a] = WordX[a];
   end//for (a = 0; a <  
         OutReg_data <= MemData;
   end     
end
endtask



// SCAN CHAINS
supply0 gnd;
buf (A_int[0], Aint[0]);
buf (A_int[1], Aint[1]);
buf (A_int[2], Aint[2]);
buf (A_int[3], Aint[3]);
buf (A_int[4], Aint[4]);
buf (A_int[5], Aint[5]);
buf (A_int[6], Aint[6]);
buf (A_int[7], Aint[7]);
buf (A_int[8], Aint[8]);
buf (A_int[9], Aint[9]);                  //used for capturing
buf (A_int[10], gnd);
buf (A_int[11], gnd);
buf (A_int[12], gnd);
buf (A_int[13], gnd);
buf (A_int[14], gnd);   //used for capturing

buf (WEN_int, WENint);
buf (CSN_int, CSNint);
buf (IG_int, IGint);


// Scan flops



// CONTROL SCAN CHAIN
     ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF cntrl_scff_0 (.D(A_int[2]), .TI(SCTRLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[0]), .OUTX(scanreg_ctrl));

      
 ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF cntrl_scff_1 (.D(A_int[4]), .TI(scanreg_ctrl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[1]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF cntrl_scff_2 (.D(A_int[6]), .TI(scanreg_ctrl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[2]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF cntrl_scff_3 (.D(A_int[9]), .TI(scanreg_ctrl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[3]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF cntrl_scff_4 (.D(A_int[3]), .TI(scanreg_ctrl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[4]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF cntrl_scff_5 (.D(A_int[11]), .TI(scanreg_ctrl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[5]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF cntrl_scff_6 (.D(A_int[10]), .TI(scanreg_ctrl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[6]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF cntrl_scff_7 (.D(A_int[1]), .TI(scanreg_ctrl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[7]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF cntrl_scff_8 (.D(A_int[0]), .TI(scanreg_ctrl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[8]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF cntrl_scff_9 (.D(A_int[5]), .TI(scanreg_ctrl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[9]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF cntrl_scff_10 (.D(A_int[7]), .TI(scanreg_ctrl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[10]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF cntrl_scff_11 (.D(CSN_int), .TI(scanreg_ctrl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[11]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF cntrl_scff_12 (.D(A_int[8]), .TI(scanreg_ctrl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[12]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF cntrl_scff_13 (.D(WEN_int), .TI(scanreg_ctrl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[13]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF cntrl_scff_14 (.D(scanreg_ctrl_wire[14]), .TI(scanreg_ctrl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[14]), .OUTX(scanreg_ctrl));  

reg LP_CK_gate;

// Lock Up Latch
wire SCTRLO_temp;
 ST_SPREG_LOLEAK_1024x19m8_Tl_lock_up_latch  dff_SCTRLO_SE (Latch_open, scanreg_ctrl_wire[14], SCTRLO_temp);

always @(SCTRLO_temp) begin
     SCTRLOint= SCTRLO_temp;
 `ifdef functional
 `else
 if (SCTRLOint !== SCTRLO_data) begin 
  if (SCTRLOint !==X)
   SCTRLO_data=1'bx;
   SCTRLO_data <= SCTRLOint;
 end 
 `endif
end  


// LEFT DATA SCAN CHAIN
     ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF ldata_scff_0 (.D(Dint[9]), .TI(SDLI), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[0]), .OUTX(scanreg_dl));
      
   
 
        ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF ldata_scff_1 (.D(Dint[8]), .TI(scanreg_dl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[1]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF ldata_scff_2 (.D(Dint[7]), .TI(scanreg_dl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[2]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF ldata_scff_3 (.D(Dint[6]), .TI(scanreg_dl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[3]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF ldata_scff_4 (.D(Dint[5]), .TI(scanreg_dl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[4]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF ldata_scff_5 (.D(Dint[4]), .TI(scanreg_dl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[5]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF ldata_scff_6 (.D(Dint[3]), .TI(scanreg_dl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[6]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF ldata_scff_7 (.D(Dint[2]), .TI(scanreg_dl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[7]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF ldata_scff_8 (.D(Dint[1]), .TI(scanreg_dl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[8]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF ldata_scff_9 (.D(Dint[0]), .TI(scanreg_dl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[9]), .OUTX(scanreg_dl));



// Lock Up Latch
wire SDLO_temp;
 ST_SPREG_LOLEAK_1024x19m8_Tl_lock_up_latch  dff_SDLO_SE (Latch_open, scanreg_dl_wire[9], SDLO_temp);

always @(SDLO_temp) begin
     SDLOint= SDLO_temp;
 `ifdef functional
 `else
 if (SDLOint !== SDLO_data) begin 
  if (SDLOint !==X)
   SDLO_data=1'bx;
   SDLO_data <= SDLOint;
 end 
 `endif
end  






// RIGHT DATA SCAN CHAIN

     ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF rdata_scff_0 (.D(Dint[18]), .TI(SDRI), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[0]), .OUTX(scanreg_dr));
     
 
 
        ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF rdata_scff_1 (.D(Dint[17]), .TI(scanreg_dr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[1]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF rdata_scff_2 (.D(Dint[16]), .TI(scanreg_dr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[2]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF rdata_scff_3 (.D(Dint[15]), .TI(scanreg_dr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[3]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF rdata_scff_4 (.D(Dint[14]), .TI(scanreg_dr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[4]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF rdata_scff_5 (.D(Dint[13]), .TI(scanreg_dr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[5]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF rdata_scff_6 (.D(Dint[12]), .TI(scanreg_dr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[6]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF rdata_scff_7 (.D(Dint[11]), .TI(scanreg_dr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[7]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF rdata_scff_8 (.D(Dint[10]), .TI(scanreg_dr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[8]), .OUTX(scanreg_dr)); 


// Lock Up Latch
wire SDRO_temp;
 ST_SPREG_LOLEAK_1024x19m8_Tl_lock_up_latch  dff_SDRO_SE (Latch_open, scanreg_dr_wire[8], SDRO_temp);


always @(SDRO_temp) begin
     SDROint= SDRO_temp;
 `ifdef functional
 `else
 if (SDROint !== SDRO_data) begin 
  if (SDROint !==X)
   SDRO_data=1'bx;
   SDRO_data <= SDROint;
 end 
 `endif
end






//


 //////// CAPTURE TASK //////
task scan_acquire;
begin
   if (supply_ok === 1) begin 
      if ( SEsys === 0 && ((LP_CK_gate === 0 && TBYPASSsys !== 1'bx)|| TBYPASSsys===0)) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
         
         Latch_open=1;
         

      end //if ( SEint === 0
   end//if(supply_ok 
end
endtask

task scan_shift;
begin
 if (supply_ok === 1) begin
   if (STDBYint === 0 && SLEEPint === 0) begin
      if (CKint_dft === X && INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0) begin
         ScanChainX;
         ScanOutX;
      end
      else if (CKint_dft === 1 && lastCK_dft === 0 ) begin
          //// SHIFT
        if (SEsys === 1) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
           
        //// SHIFT Ends
        end //if (SEsys === 1
        else if (SEsys === X) begin
            ScanChainX;
            ScanOutX;
            delScanOutX;
        end//if (SEint ==X
      
      end///if (CKint === 
    
      else if (CKint_dft === 0 && lastCK_dft === 1 ) begin
        Latch_open=1;
      end
    end  //if (STDByint === 0 && SLEEPint === 0
 end//if(supply_ok
end
endtask






// BEHAVIOURAL MODULE DESCRIPTION
// ================================

initial
begin
  // Define format for timing value
  $timeformat (-9, 3, " ns", 0);
  `ifdef slm
  $slm_RegisterMemory(MemAddr, Words, Bits);
  `endif   
   reg_mem_block=0;
   flag_mem_block=0;
  `ifdef functional
  `else
   TimingViol_data=0;
   TimingViol_mask=0;
   `endif
   decoding_start=0;
  
   //Parameter Assignment
   
   reg_Fault_file_name = Fault_file_name; 
   reg_ConfigFault     = ConfigFault;
   reg_MEM_INITIALIZE  = MEM_INITIALIZE;
   reg_BinaryInit      = BinaryInit;
   reg_InitFileName    = InitFileName;
   reg_Initn_reset_value = Initn_reset_value;
   reg_File_load_time    = File_load_time;

   time_fall_sleep=0;
   time_fall_PSWLARGEMP=0;
   time_fall_PSWLARGEMP_0=0;
   time_fall_PSWLARGEMA=0;
   time_fall_PSWLARGEMA_0=0;
   time_fall_PSWSMALLMP=0;
   time_fall_PSWSMALLMA=0;

   vddmp_rise_time=0;
   vddmp_fall_time=0;
   vddsmp_rise_time=0;
   vddsmp_fall_time=0;
   vddma_rise_time=0;
   vddma_fall_time=0;
   vddsma_rise_time=0;
   vddsma_fall_time=0;
   vddm_fall_time=0;  
   vddm_rise_time=0;  
   vddsm_fall_time=0; 
   vddsm_rise_time=0;

   next_cycle_corrupt_func=0;
   next_cycle_corrupt_dft=0;
   init_pulse_done = 0;
   power_up_done = 0;
   file_loaded=1;
   debug_level= 2'b01;
   message_status = "ONLY WARNINGS/ERRORS are Switched ON.For INFO also use debug_level=2'b00";
  `ifdef  NO_WARNING_MODE
     debug_level = 2'b11;
     message_status = "All Warning/Errors/Info Messages are Switched OFF";
  `endif  
  `ifdef  ONLY_ERROR_MODE
     debug_level = 2'b10;
     message_status = "All Warning/Info Messages are Switched OFF.Errors are switched on";
  `endif 
  `ifdef  ALL_MSG_MODE
     debug_level = 2'b00;
     message_status = "All Messages are Switched ON";
  `endif 
  
  `ifdef slm
     operating_mode = "SLM";
   `else
      `ifdef functional
         operating_mode = "FUNCTIONAL";
       `else
         operating_mode = "TIMING";
      `endif
   `endif   
  
  if (debug_level < 1) begin
  $display ("%m INFORMATION ");
  $display ("***************************************");
  $display ("The Model is Operating in %s MODE", operating_mode);
  $display ("%s", message_status);
  if(reg_ConfigFault)
  $display ("Configurable Fault Functionality is ON");   
  else
  $display ("Configurable Fault Functionality is OFF");   
  $display("Fault File used by the model Fault_File_Name=%s" ,reg_Fault_file_name);
  $display("Values of Config_fault used in model=%d" ,reg_ConfigFault);
  $display("Values of Mem_INITALIZE used in model=%d" ,reg_MEM_INITIALIZE);
  $display("Values of BinaryInit used in model=%d" ,reg_BinaryInit);
  $display("Values of InitFileName used in model=%s" ,reg_InitFileName);
  $display("Values of Initn_reset_value used in model=%d" ,reg_Initn_reset_value);
  $display("Values of File_load_time used in model=%t" ,reg_File_load_time);

  $display ("***************************************");
  end
     
  task_read_fault_file; 
   if(!INITNint) begin
    if(supply_ok ) begin 
      init_pulse_done = 1;
      power_up_done = 1;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif 
    end 
   end 
        
   lastCK_func = CKint_func;
   lastCK_dft = CKint_dft;

 `ifdef MEM_CONTENTS_SLEEP
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","w");
   $fclose(ptr);
 `endif 

   
end  // initial block ends



//+++++++++++++++++++++++++++++++ CONFIG FAULT IMPLEMETATION ENDS+++++++++++++++++++++++++++++++//
        




//INITN block starts
//================================
always @(INITNint  or supply_ok )
begin
 if (INITNint === 1'b0) begin
   if(supply_ok) begin
     init_pulse_done = 1;
     power_up_done = 1;
     lastCK_func=CKint_func;
     lastCK_dft=CKint_dft;
     next_cycle_corrupt_func = 0;
     next_cycle_corrupt_dft = 0;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif     
   end 
 end        

 if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && INITNint !== 1)
   begin
     ScanOutX;
     ScanChainX;
     delScanOutX;
   end  
         
 if (init_pulse_done === 0 && INITNint !== 0) begin
     if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) INFO: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
 end
 
end//always @(INITNint)


// Clock Generation 
//wire gated_clock;
//wire clock_gate_en;
//ST_SPREG_LOLEAK_1024x19m8_Tl_lock_up_latch CK_SE_latch (!CK , SE, SE_latch_CK);
//and (clock_gate_en, ATP, TBYPASS, !SE_latch_CK);

//ST_SPREG_LOLEAK_1024x19m8_Tl_lock_up_latch LP_latch (!CK , scanreg_ctrl_wire[14], LP_latch_CK);
//and (gated_clock,CK,!LP_latch_CK);
//assign CK_new= clock_gate_en ===0 ? CK : (clock_gate_en ===1 ? gated_clock: (CK===0) ? 0 :1'bx);


// Clock Generation Ends


// Functional CK block starts
//======================================
always @(CKint_func)
begin
   lastCK_func=CKreg_func;  
   CKreg_func=CKint_func;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
        if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
      if (CKreg_func === 1'bX || (CKreg_func === 1'b1 && lastCK_func === 1'bx)) begin
        if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
         
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
         Invalid_next_cycle_func;
        end
      end
      else if (CKreg_func === 1'b1 && lastCK_func === 1'b0 ) begin
        time_CK_func_rise=$realtime;
        MEMEN_prev = MEMEN_reg;
        MEMEN_reg = MEMEN;
        CSNreg = CSNint;
        IGreg = IGint;
        DEreg = DEint;
        SE_reg = SEsys;
        TBYPASS_reg = TBYPASSsys;
        ATPreg = ATPint;
        INITNreg = INITNint;
        SLEEPreg = SLEEPint;
        STDBYreg = STDBYint;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 

    `ifdef functional
    `else
        Mem_last=Mem[Aint];
    `endif 
        if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.INITN pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SLEEP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.STANDBY pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg === X && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.chip select  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg === X && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.IG pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg === X && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.Debug pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg === X && (SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.ATP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg === X && TBYPASS_reg !== 1) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SE pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg !== 1 && TBYPASS_reg === X) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.TBYPASS pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end

        else if ((INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0))) && WENint === X) begin
            // Uncertain write cycle
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: write enable going to X  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end 
        else if (next_cycle_corrupt_func === 1) begin
          next_cycle_corrupt_func = X;
        end
        else if (next_cycle_corrupt_func === 1'bx) begin
          next_cycle_corrupt_func = 0;
        end 
        
//        if (next_cycle_corrupt_func === 0 ) begin 
         
          /*---------------------- File initialization -----------------*/
          
          if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0)) && flag_mem_block === 1'b0) begin
                 Areg=Aint;
                 Dreg=Dint;
                 Mreg=Mint;
                 WENreg=WENint;     
             if (reg_MEM_INITIALIZE === 1'b1 && $realtime >= reg_File_load_time && file_loaded ) begin   
                `ifdef slm
                  if (reg_BinaryInit)
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_BIN");
                  else
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_HEX");
   
                `else
                  if (reg_BinaryInit)
                     $readmemb(reg_InitFileName, Mem, 0, Words-1);
                  else
                     $readmemh(reg_InitFileName, Mem, 0, Words-1);
                `endif
                 file_loaded = 0;
             end
   
             if (^Aint === X)
               ValidAddress = X;
             else if (Aint < Words)
               ValidAddress = 1;
             else    
               ValidAddress = 0;
   
             if(red_en === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Redundancy Enable is Invalid. Either RRAE is X or TRRAE is X",$realtime);
                ValidAddress = X; 
           end
           else if(red_en === 1'b1 && ^repair_add === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Repair Address is invalid.RRA is X",$realtime);
                ValidAddress = X;
           end
             
             if (ValidAddress)
               `ifdef slm
                   $slm_ReadMemoryS(MemAddr, Aint, Mem_temp);
               `else
                    Mem_temp = Mem[Aint];
               `endif
             else
                Mem_temp = WordX;  
          
     /*---------------------- Normal Read and Write -----------------*/
     
             if (WENint === 1) begin
               ReadCycle(Aint);
             end
       
             else if (WENint === 0) begin
               WriteCycle(Aint);
             end 
                
          
          end //  if (MEMEN === 1'b1 
       
//        end  // if (next_cycle_corrupt_func === 0
      
      end // if (CKint = 1   
   end // if (init_pulse_done === 1           
 end 
end // always @(CKint_func)
        
always @(MEMEN)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) && CKint_func === 1'bx) begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.clock pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
    Invalid_next_cycle_func;
  end
 end 
end

// DFT CK block starts
//======================================
always @(CKint_dft) 
begin
   lastCK_dft=CKreg_dft;
   CKreg_dft=CKint_dft;
   
   Latch_open=0;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
     if (CKreg_dft === 1'bX || (CKreg_dft === 1'b1 && lastCK_dft === 1'bx)) begin
       if (INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0 ) begin
        
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: DFT clock  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime); 
         Invalid_next_cycle_dft;
         if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
           WriteOutX;
         end
       end
     end 

     if(CKint_dft === 0 && lastCK_dft === 1) begin
      if(ATPreg === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
       if(SE_reg === 1'b1 && SEsys === 1'b0) begin
        if(TBYPASSint === 1'b1) begin   
    
       
       
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8], scanreg_dl_wire[scanlen_l-1]}; 
       


         for (i = 0; i < Bits; i = i + 1)
         begin
          if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
         end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
        end 
       end
      end
     end 
     
     else if (CKreg_dft === 1'b1 && lastCK_dft === 1'b0 ) begin
       SE_reg = SEsys;
       TBYPASS_reg = TBYPASSsys;
       ATPreg = ATPint;
       INITNreg = INITNint;
       SLEEPreg = SLEEPint;
       STDBYreg = STDBYint;
       MEMEN_dft_prev = MEMEN_dft_reg;
       MEMEN_dft_reg = MEMEN_dft;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 
       if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ) begin 
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
 //     else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys === X && TBYPASSsys !== 1) begin
///           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
//           Invalid_next_cycle_dft;
//        end       
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys === X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
        end 
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys !== 0 && LP_CK_gate===X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: LP FLOP Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           ScanChainX;
           ScanOutX;   
          if( TBYPASSint !== 0 && SEint !== 1) begin
            WriteOutX;
          end
          next_cycle_corrupt_dft=0;
        end        
       else if (next_cycle_corrupt_dft === 1'b1) begin 
         next_cycle_corrupt_dft = X;
       end 
       else if (next_cycle_corrupt_dft === 1'bx) begin
         next_cycle_corrupt_dft = 0;
       end
       
       if (next_cycle_corrupt_dft === 0 ) begin
         
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1 && flag_mem_block === 1'b0) begin
           
           if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0  && LP_CK_gate===0) begin
              OutReg_data_tbypass = Dint;
              for (i = 0; i < Bits; i = i + 1)
              begin
               if (OutReg_data_tbypass[i] !== OutReg_data[i])
                 OutReg_data[i] = WordX[i];
              end//for (i = 0; i < */ 
              OutReg_data <= OutReg_data_tbypass;
           end
           
             scan_acquire;
         end //MEMEN_dft == 1        
       end // if ( next_cycle_corrupt_dft
       
     end // if (CKint_dft === 1'b1
      //  if (next_cycle_corrupt_dft === 0 ) begin 
       if (SE_reg !== 0) begin
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1  && flag_mem_block === 1'b0) begin
           next_cycle_corrupt_dft = 0;
           if ( next_cycle_corrupt_func === 1) begin
	    next_cycle_corrupt_func = 0 ;
	   end	
           scan_shift;
         end
       end
     //end // if ( next_cycle_corrupt_dft    
     if ((!(TBYPASSsys!==0 && SEsys!==1 && LP_CK_gate!==0 ) && next_cycle_corrupt_dft === 0) || CKint_dft !==1) begin          
       CK_sc=INITNreg & !STDBYreg & !SLEEPreg & ATPreg & CKreg_dft ;
     end     
   end // if (init_pulse_done 
 end // if (supply_ok 
end // always @(CKint_dft)

always @(MEMEN_dft)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) && CKint_dft === 1'bx)  begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.MEMEN_dft and clock should not be X at this time instant. ScanChains and ScanOuts Corrupted ",$realtime); 
    Invalid_next_cycle_dft;
    
    if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
      WriteOutX;
    end
  end
  if ( MEMEN_dft !== 0 && TBYPASSsys !== 0 && SEsys !== 1) begin
     WriteOutX;
     OutReg_data = WordX; 
     delOutReg_data=WordX;
 end 
end
end //always @(MEMEN_dft

always @(TBYPASSsys or ATPint)
begin
   if(supply_ok === 1'b1) begin 
    if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0 && INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1) begin
      if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
    end  
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint === X && SEsys !== 1) ) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end 
end //always @(TBYPASSint





always @(SEsys)
begin
 if(supply_ok === 1'b1) begin 
  if(CKint_dft === 0 && ATPint === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
    if(SE_reg === 1'b1 && SEsys === 1'b0) begin
      if(TBYPASSsys === 1'b1) begin
  
     
         
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8], scanreg_dl_wire[scanlen_l-1]};
           
      


        for (i = 0; i < Bits; i = i + 1)
        begin
         if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
        end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
      end
    end
  end
  if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0) begin
      if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
  end 
  else if ((TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint === X && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end   
end

//assign output data
`ifdef functional        

   
always @(SDLOint)
#0.001 delSDLO_data<=SDLOint;

always @(SDROint)
#0.001 delSDRO_data<=SDROint;

 
always @(SCTRLOint)
#0.001 delSCTRLO_data<=SCTRLOint;


always @(OutReg_data)
   #0.001 delOutReg_data = OutReg_data;
`else
`endif

/***************************** Embeded switch functionality starts here ***********************************/





always @(STDBYint)
begin
  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0 && STDBYint !== 1'b0)
    begin
      ScanOutX;
      ScanChainX;
     delScanOutX;     
    end
  end
end



always @(SLEEPint)
begin


  if (SLEEPint !== 1'b1) begin
    time_fall_sleep = $realtime;
  end

  if (power_up_done === 0)
    begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
    end
  else begin
    if (SLEEPint === 1'b1 && lastSLEEP === 1'b0 ) begin 
      
    end
    else if (SLEEPint !== 1'b1 && lastSLEEP === 1'b1 && full_shutdown !== 1) begin 
      
      if (supply_ok !== 1 && ($realtime > 0)) begin
         if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID LOW_POWER) ERROR: ISOLATION signal removed from the memory but array and periphery supply is not completely switched on.Very High Current would be drawn by the memory. All further operations on memory are blocked",$realtime);
          WriteMemX;
          WriteOutX;
          ScanChainX;
          OutReg_data = WordX; 
          delOutReg_data=WordX;
          ScanOutX;//immediately;
          delScanOutX;//immediately;
          init_pulse_done = 0;
          power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            debug_level = 2'b11;
          `endif
          
      end        
      
       
    end   
    else if (SLEEPint === X && lastSLEEP === 1'b0 && full_shutdown !== 1'b1) begin 
     
    end 
  end  


  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && SLEEPint !== 0)
    begin
      ScanOutX;
      ScanChainX;
        delScanOutX;      
    end
  end

// if (init_pulse_done === 0)
//   begin
//     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
//   end
//
// else if ( SLEEPint !== 1 && (supply_ok !==1) ) begin
//    
//    WriteOutX;
//    OutReg_data = WordX; 
//    delOutReg_data=WordX;
//    ScanOutX;//immediately;
//    delScanOutX;//immediately;
//    ScanChainX;
//    WriteMemX;
//    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies with sleep/Power down signal being low.This scenario can lead to high dc currents and some reliability issues Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
// end

 print_sleep;    
 lastSLEEP=SLEEPint;
end

/********************************** Embeded switch functionality ends here *******************************/

task print_sleep;
begin
  if (SLEEPint === 1'b0) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been deasserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end  
  else if (SLEEPint === 1'b1) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been asserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_ACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif

  end        
  else begin
      if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) ERROR: SLEEP pin is at an invalid state.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INVALID in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end        
end
endtask





 

//// C28SOI non flip compiler power functionality 
always @(gndmreg )
begin
 if (power_up_done === 1 && $realtime > 0) begin    
    if(gndmreg !== 1'b0 ) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or gndsm is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
        corrupt_all;
        init_pulse_done = 0;
        power_up_done = 0;
     `ifdef NO_BLOCK_MEM
     `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of ground pins.Ground must be maintained at 0 Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime);
        debug_level = 2'b11;
     `endif   

    end   
 end

end




always @(vddmareg )
begin

if (vddmareg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddma(Array Supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 
    end
   end   
   else if (SLEEPint === 1) begin
    WriteMemX;
   end

end

if ((vddmareg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1 ) && $realtime > 0) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddm or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         corrupt_all;
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif

end


end

always @(vddmpreg )
begin
 if (vddmpreg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or vddsmp is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmp(Periphery Supply)/vddsmp(Substrate power supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 

    end
   end   
   else if (SLEEPint === 1) begin
    WriteOutX;
    ScanChainX;
    ScanOutX;
    delScanOutX;//immediately;
    OutReg_data = WordX; 
    delOutReg_data=WordX;
   end
 end

if( (vddmpreg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1'b1 )  && $realtime > 0) begin
         corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif
end
 
 
end


always @(vddmoreg)
begin
  if (power_up_done === 1 && $realtime > 0) begin   
      if (vddmoreg !== 1'b1)  begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin
           corrupt_all;
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
         end //if (vddmareg === 1'b1 

      else if (vddmareg === 1'b0 && vddmpreg === 1'b0   && SLEEPint === 1'b1 &&  $realtime > 0)
        begin 
            if((debug_level < 2) && ($realtime > 0)) $display("%m - %t WARNING: Illegal Value on power pin(s). Memory and Output Corrupted ", $realtime);
 
           corrupt_all;
        end //else if (vddmareg === 1'b 
     end   // if (vddmoreg !== 1'b1)
     else if (vddmoreg === 1'b1 && $realtime > 0 ) begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin     
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           corrupt_all;
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
        end        
     end // else if (vddmoreg === 1'b1
  end 
end // always @(vddmoreg)












always @(gndmreg) begin
 if (gndmreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 0. ",$realtime);
 end
 else if (gndmreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 1. ",$realtime);
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to invalid state. ",$realtime);
 end
end




 
always @(vddmareg) begin
 if (vddmareg === 0) begin 
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 0. ",$realtime);
  vddma_fall_time = $realtime;
 end
 else if (vddmareg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 1. ",$realtime);
  vddma_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to invalid state. ",$realtime);
  vddma_fall_time = $realtime;
 end 

 

end

always @(vddmpreg) begin
 if (vddmpreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 0. ",$realtime);
  vddmp_fall_time = $realtime;
 end
 else if (vddmpreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 1. ",$realtime);
  vddmp_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to invalid state. ",$realtime);
  vddmp_fall_time = $realtime;
 end

 
 
end



// end of C28SOI power functionality 
 


assign supply_ok          =  (vddmareg === 1'b1 && vddmpreg  === 1'b1  && gndmreg === 1'b0 && vddmoreg === 1'b1 ) ? 1'b1 : 1'b0;
assign core_supply_ok     =  (vddmoreg === 1'b1 && vddmareg === 1'b1 && gndmreg === 1'b0 ) ? 1'b1 : 1'b0;
assign peri_supply_ok     =  (vddmoreg === 1'b1 && vddmpreg === 1'b1 && gndmreg === 1'b0  ) ? 1'b1 : 1'b0;

assign full_shutdown = (vddmpreg === 1'b0 && vddmareg === 1'b0   ) ? 1'b1 : 1'b0 ;




`ifdef functional
`else


task WriteLocMskX_bwise;
   input [Addr-1 : 0] Address;
   input [Bits-1 : 0] Mask;

reg [Bits+Red_extrabit:0] tempReg1;
integer num1; 
begin
   tempReg1 = WordX;
   if (^Address !== X )
   begin
      tempReg1 = Mem[Address];
             
      for (j = 0;j< Bits; j=j+1) begin
         num1=j;
        if (Mask[j] === 1'bx)
            tempReg1[num1] = 1'bx;
      end
      Mem[Address] = tempReg1;
      task_insert_faults_in_memory;
   end//if (^Address !== X
   else begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      WriteMemX;
   end   
end
endtask


/****************Actions taken on timing violations*****************/

 always @(TimingViol_data)
// tds or tdh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  for (l = 0; l < Bits; l = l + 1) begin   
    if (CSWEMTBYPASS[l] !== 0) begin
     if((TimingViol_data[l] !== TimingViol_data_last[l])) begin


         Mreg[l] = 1'bx;
     end    
     WriteLocMskX_bwise(Areg,Mreg);
    end   
   end 
  end
    if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin
     scanreg_dl =1'bx; 
     scanreg_dr =1'bx; 
     SDLOint=X;
     SDROint=X;
     `ifdef functional
     `else
     SDLO_data<=1'bx;
     SDRO_data<=1'bx;
     `endif
    end
     TimingViol_data_last = TimingViol_data; 
end





always @(TimingViol_addr)
// tas or tah
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
      scanreg_ctrl=1'bx; 
      SCTRLOint=X;
      `ifdef functional
      `else
      SCTRLO_data<=1'bx;
      `endif
  end
end


always @(TimingViol_WEN)
//tws or twh
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WEN pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end 

always @(TimingViol_CSN )
// tps or tph 
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;

   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CSN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end

always @(TimingViol_tcycle )
//tcycle
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
   if (MEMEN !== 0 && MEMEN_prev !== 0) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckl )
// tckl 
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckh) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end


always @(TimingViol_tcycle_se )
//tcycle_se
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckl_se  )
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckh_se) begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tbist) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
   end
   if (TBYPASSint !== 1'b0) begin 
    WriteOutX;
   end 
   if (INITNreg !==0 && STDBYreg !== 1 && TBYPASS_reg !== 1 && SLEEPreg !== 1 && SE_reg !== 1 && IGreg !== 1 && DEreg !== 1) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBIST pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end






always @(TimingViol_tbypass)
//ttmck
begin
#0  
  WriteOutX;
  if (INITNreg !== 0 && SLEEPreg !== 1 && SE_reg !== 1 && STDBYreg !== 1 &&  DEreg !== 1) begin
   Invalid_next_cycle_dft_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
end



always @(TimingViol_sleep)
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_stdby)
begin
#0
  if (CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin 
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (ATPreg !== 0) begin 
   Invalid_next_cycle_dft_tim;
  end
end






always @(TimingViol_se) begin
#0
   if (TBYPASS_reg !== 0) begin 
    WriteOutX;
   end 
  if (TBYPASS_reg === 0) begin
     WriteOutX;
     WriteMemX;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE timing violation  Memory State Machine is corrupted. Output Corrupted ",$realtime); 
  end 
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
  end
end

always @(TimingViol_sctrli) begin
  scanreg_ctrl=1'bx; 
end


always @(TimingViol_sdli) begin
 scanreg_dl=1'bx; 
end

always @(TimingViol_sdri) begin
   scanreg_dr=1'bx;
end

 

always @(TimingViol_initnl) begin
init_pulse_done=0;
WriteOutX;
OutReg_data = WordX; 
delOutReg_data=WordX;
ScanOutX;
delScanOutX;
ScanChainX;
WriteMemX;
end

always @(TimingViol_initn) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end

always @(TimingViol_ig) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && INITNreg !== 0 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: IG pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   ScanChainX;
   ScanOutX;
   delScanOutX;       
  end
end

always @(TimingViol_atp) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin  
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_rm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^WMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: RM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
   end
end
 
always @(TimingViol_wm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^RMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);        
   end
end 


`endif


endmodule




module ST_SPREG_LOLEAK_1024x19m8_Tl_lock_up_latch (EN,D,Q);
input EN,D;
output reg Q;

  always @ (EN or D) begin
    if (EN === 1) begin
       Q = D;
    end
    else if ((EN === 1'bz || EN === 1'bx  )&& D !== Q) begin
        Q=1'bx;
    end    
  end
endmodule

module ST_SPREG_LOLEAK_1024x19m8_Tl_SCFF (D,TI,TE,CP,Q,OUTX);
input D,TI,TE,CP;
input OUTX;
output reg Q;
wire Dint;
assign Dint= (TE===1)?TI:(TE===0)?D:1'bx;

always @(posedge CP)
        begin
          if(Dint === 1'bZ || CP ===1'bx || OUTX === 1'bx)
          begin
                  Q = 1'bx;
          end
          else
          begin
                  Q = Dint;
          end        
        end
always @(posedge OUTX)
Q = 1'bx;
endmodule



`undef setup_time
`undef hold_time
`undef access_time
`undef retain_time
`undef cycle_time
`undef pulse_width_time
`undef initin_low_pulse


`delay_mode_path
`endcelldefine
`nosuppress_faults






/****************************************************************
--  Description         : Verilog Model 
--  ModelVersion        : 1.2
--  Date                : Apr, 2013
--  Changes Made by	: PS
--  Revision History    : 
 
****************************************************************/


/******************** START OF HEADER****************************
   This Header Gives Information about the parameters & options present in the Model
   
   words = 64
   bits  = 23
   mux   = 2 
   
   
   
   write_mask = no 
   
   margin_control = yes 
   
   
   Dft = Yes  

    ------------------------------------------------------------------------------------
     Signal Name             | Description       |             Port Mode        | Active When
                             |                   |          r    |  w   | rw    |
   ------------------------------------------------------------------------------------

    D 	        Data in                     na     x      na       -  
    IG    Input Gate Enable           x      x      na       High     
    ATP            ATPG Enable                 x      x      na       High     
    INITN                 INITN pin                   x      x      na       Low
    
    
     
    Q 	        Data out	            x      na     na       -
    A              Address                     x      x      na       high and low
    
    CK                Clock	                    x      x      na       posedge
    CSN          Chip Enable                 x      x      na       low
    
    RM         Read Margins                 x      x      na       High 
    SCTRLI         Scan Input (Control)
    SCTRLO        Scan Output (Control)
    SDLI         Scan Input (Data-Left)
    SDLO        Scan Output (Data-Left)
    SDRI         Scan Input (Data-Right)
    SDRO        Scan Output (Data-Right)
    SE          Scan Enable pin 
    STDBY              Standby pin                 x      x      na       High
    
    SLEEP                        Sleep pin                   x      x      na        High 
    
     
     
    TBIST          Bist Enable Pin 
    
    TBYPASS                      Memory Bypass                na     na     na        High
    
    TED        Bist Even Data pin
    TOD         Bist Odd Data Pin
     
    TA         Bist Read Address
    TCSN     Bist Read Chip Select
    
    TWEN    Bist Write Enable 
    WEN         Write Enable                na     x      na       Low 
    
    WM        Write Margins Code          x      x      na       -
     

******************** END OF HEADER ****************************/


//********************************************//
// ST_SPREG_LOLEAK_64x23m2_Tl Verilog Model                 //  
//********************************************//




`ifdef slm
        `define functional
`endif

`celldefine
`suppress_faults
  `ifdef functional
   `delay_mode_unit
  `else
   `delay_mode_path
  `endif

`define setup_time 0.0
`define hold_time 0.0
`define access_time 1.0
`define retain_time 0.9
`define cycle_time 0.0
`define pulse_width_time 0.0
`define initin_low_pulse 0.0



 






`timescale 1ns / 1ps


module ST_SPREG_LOLEAK_64x23m2_Tl (A,ATP,CK,CSN,D ,IG,INITN , Q ,RM    ,SCTRLI,SCTRLO,SDLI,SDLO,SDRI,SDRO,SE,SLEEP   , STDBY  ,TA,TBIST   ,TBYPASS ,TCSN,TED ,TOD   ,TWEN ,WEN,WM  );

 parameter
  Words = 64,
  Bits = 23,
  Addr = 6,
  mux = 2,
  repair_address_width = 5,
  write_margin_size = 2, 
  read_margin_size = 3; 

 //  INPUT OUTPUT PORTS DECLARATION DONE SEPARATELY FOR SPREG and ROM
 // ========================


        output [Bits-1 : 0] Q;
         
        output SCTRLO;
        input SE,SCTRLI;
        
        input [Addr-1 : 0] A;
        
        input [read_margin_size-1 : 0] RM;
        
         
        input CK,CSN,INITN,IG,ATP; 
        
        
        input [Addr-1 :0 ] TA;
input TBIST,TCSN ;
        
        input STDBY;
        
        input SLEEP; 
        
         
        
        
         
        output SDLO;
        output SDRO;
        
        
        
        
        input [Bits-1 : 0] D ;
	
          
         
        
        input [write_margin_size-1 : 0] WM;
        
        
        input TBYPASS;
        
        input WEN;
        
        
         
        input SDLI,SDRI  ; 
        
        
        
        //Bist inputs
        // ===========
        input TWEN,TED,TOD; 
        
        
        
        

        






    parameter
        Fault_file_name = "ST_SPREG_LOLEAK_64x23m2_Tl_faults.txt",
        `ifdef ConfigFault
        ConfigFault = 1,
        `else
        ConfigFault = 0,
        `endif
        max_faults = 66,
        
        MEM_INITIALIZE  = 1'b0,
        BinaryInit = 1'b0, 
        InitFileName = "ST_SPREG_LOLEAK_64x23m2_Tl.cde",
        Debug_mode = "all_warning_mode",
        File_load_time=0,
        Initn_reset_value={23{1'b0}},
        InstancePath = "ST_SPREG_LOLEAK_64x23m2_Tl";
    
    parameter
        
        bank = 1, 
        mux_bits=1,
        Red_extrabit=0,
        bank_bits = 0,
        RedWords = mux * 2 * bank,
        max_address_bits = 15 ,
        Rows = Words/mux;

  
    parameter 

     

        
           scanchains=3,    
          
        
        scanlen_ctrl=15,
        
        

      

        
        
        scanlen_r=(2*((Bits+1)/4)),
        
        scanlen_l=((Bits+1)-(2*((Bits+1)/4)))   ; 
      
      

    parameter
        
        `ifdef functional  
            RW_assertions_en = 0,
        `endif
        WordX = {Bits{1'bx}},
        AddrX = {Addr{1'bx}},
        Word0 = {Bits{1'b0}},
        X = 1'bx;
   



//  WIRE DECLARATION RELATED TO POWER PINS
//  ======================================
	
        wire supply_ok, full_shutdown;
        
        wire core_supply_ok;
        wire peri_supply_ok;

        wire gndmint, gndsmint;
         
        
        wire vddmpint;
        wire vddmoint;
        wire vddmaint;
        wire vddsmpint;  
        wire vddsmaint;  
        
        

//  WIRE DECLARATION 
//  ==================
        wire [Bits-1 : 0] CSWEMTBYPASS;
        wire [Bits-1 : 0] Dint, Dsys;
        wire [Bits-1 : 0] Mint; 
        wire [23-1:0] Msys;
	wire [Addr-1 : 0] Aint;
        wire [Addr-1 : 0] Asys;

       


        wire [max_address_bits-1 : 0] A_int; 
                
	wire CKint_dft;
	wire CKint_func;
	wire CSNint;
        wire MEMEN;
        wire MEMEN_dft;
        wire TSE;

	wire WENint;
	wire WENsys;
        wire SLEEPint;
        wire STDBYint;
        wire SEint;
        wire SEsys;
        wire SCTRLIint;
        wire SDLIint;
        wire SDRIint;
        
        wire INITNint;
        wire TBYPASSint;
        wire TBYPASSsys;
        wire LSint; 
        wire HSint; 
        wire ATPint;
        wire DEint;
        
        wire [Addr-1 : 0] TAint;
        wire TBISTint;
        wire TBISTsys;
        wire TCSNint;
        wire TEDint;
        wire TODint;
        wire TEMint;
        wire TOMint;
        wire [Bits-1 : 0] TMint;
        wire [Bits-1 : 0] TDint;
        wire TWENint;
        wire IGint;
        wire IGbuf;
        wire CSNbuf;
        wire WENbuf;
        wire [read_margin_size-1:0] RMint;
        wire [write_margin_size-1:0] WMint;

        //Wires for scan chains
        //  ====================     
        wire [scanlen_ctrl -1:0]scanreg_ctrl_wire;
        wire [scanlen_l -1:0]  scanreg_dl_wire; 
        wire [scanlen_r -1:0]  scanreg_dr_wire; 
   
        wire [scanlen_l -1:0]  scanreg_ml_wire; 
        wire [scanlen_r -1:0]  scanreg_mr_wire; 


        wire [repair_address_width -1 : 0] RRAint;
        wire RRAEint;
        wire TRRAEint;    
        wire red_en;
        wire [repair_address_width -1 : 0] repair_add, next_repair_add;


//  REG DECLARATION
//  ====================     
        reg MEMEN_reg;
        reg MEMEN_prev;
        reg reg_mem_block;
        reg flag_mem_block;
        reg SCTRLIint_temp;
        reg SDLIint_temp;
        reg SDRIint_temp;
        reg SMLIint_temp;
        reg SMRIint_temp;

        //  REG DECLARATION
        //  ====================
        reg SCTRLOint;
        
        reg SDLOint,SDROint;
         
        
        reg next_cycle_corrupt_func;
        reg next_cycle_corrupt_dft;
        reg [Bits-1 : 0] delOutReg_data;//delayed Output Register
        reg [Bits-1 : 0] OutReg_data;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_tbypass;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_scan;   // Data Output registe
        reg [Bits-1 : 0] OutReg_rado_retained;   // register for retaining rado data when SLEEP --> 1
        reg delSCTRLO_data,SCTRLO_data;      // delayed Output Register
        reg delSDLO_data,SDLO_data;      // delayed Output Register
        reg delSDRO_data,SDRO_data;      // delayed Output Register
        
        
        // SCAN CHAINS register
        reg scanreg_ctrl; 
        reg scanreg_dl; 
        reg scanreg_dr; 
        
        
        reg CK_sc;
        reg Latch_open=0;
        reg lastCK_dft,CKreg_dft;
        reg lastCK_func,CKreg_func;
        reg lastSLEEP;
        reg lastPSWLARGEMP,lastPSWLARGEMA,lastPSWSMALLMP,lastPSWSMALLMA;
        reg CSNreg;
        reg init_pulse_done; //if == 1 then it implies that initb low pulse has been applied
        reg power_up_done; //if == 1 then it implies that power up has been done
        `ifdef slm
        `else
	      
             reg [Bits-1 : 0] Mem [Words-1 : 0];
             reg [Bits-1 : 0] RedMem [RedWords-1 : 0];
 
        `endif
        
	reg [Bits-1 :0] Mem_temp;
        reg [Bits-1 :0] Mem_slm; 
	reg ValidAddress;
	reg ValidDebugCode;
        reg decoding_start;
        reg file_loaded;
        reg [Bits-1 :0] Dreg;
        reg [Bits-1 :0] Mreg;
        reg WENreg;
        reg [Addr-1 :0] Areg;
        reg SE_reg;
        reg TBYPASS_reg;
        reg INITNreg;
        reg IGreg;
        reg DEreg;
        reg SLEEPreg;
        reg STDBYreg;
        reg ATPreg;
        reg MEMEN_dft_reg;
        reg MEMEN_dft_prev;
        reg RRMATCHreg;
        reg RRMATCHreg_last;//changes_made
        reg RRMATCHreg_glitch;
        reg [repair_address_width -1 : 0] repair_add_last;
        reg RRAEint_last;
        reg [Addr-mux_bits-1:0] row_add_temp;
        reg [Addr-mux_bits-bank_bits-1:0] row_add_cmp_temp;

       
        //parameter registers
        reg [2047:0] reg_Fault_file_name;
        reg reg_ConfigFault;
        reg reg_MEM_INITIALIZE;
        reg reg_BinaryInit;
        reg [2047:0] reg_InitFileName;
        reg [Bits -1 :0] reg_Initn_reset_value;
        time reg_File_load_time;

        //Power Supply Registers        
        reg vddmireg;
        reg vddmreg;
        reg vddsmreg;
        reg gndmreg;
        reg gndsmreg;   
        reg vddmpreg;
        reg vddmpireg;
        reg vddmareg;
        reg vddsmpreg;
        reg vddsmareg;
        reg vddmoreg;
        time vddmp_rise_time;
        time vddmp_fall_time;
        time vddsmp_rise_time;
        time vddsmp_fall_time;
        time vddma_rise_time;
        time vddma_fall_time;
        time vddsma_rise_time;
        time vddsma_fall_time;
        reg reg_check_rise;
        reg reg_check_fall;
        reg reg_check_rise_vddma;
        reg reg_check_fall_vddsma;
        reg  reg_check_rise_vddm, reg_check_fall_vddsm ;
        time vddm_fall_time,  vddm_rise_time,  vddsm_fall_time, vddsm_rise_time ;
  /* This register is used to force all warning messages 
  ** OFF during run time.
  ** It is a 2 bit register.
  ** USAGE :
  ** debug_level_off = 2'b00 -> ALL MESSAGES(INFO/WARNINGS/ERRORS) will be DISPLAYED 
  ** debug_level = 2'b01     -> ONLY WARNINGS/ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b10     -> ONLY ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b11     -> NO MESSAGES will be DISPLAYED.
  */ 
        reg [1:0] debug_level;
        reg [8*10: 0] operating_mode;
        reg [8*44: 0] message_status;

        integer i, k, j, l,m,q,w,r,s,num1,redcnt,n,num2,FirstHalf,Bfaileff,memcnt,ptr;
        integer decoder[Bits-1:0];
        `ifdef slm
           integer MemAddr;
        `endif


        //************************************************************
        //****** CONFIG FAULT IMPLEMENTATION VARIABLES*************** 
        //************************************************************ 

        integer file_ptr, ret_val;
        integer fault_word;
        integer fault_bit;
        integer fcnt, Fault_in_memory,faultnum,stop_loop,count;
        integer t;  
        integer FailureLocn [max_faults -1 :0];
        integer Failurebit [max_faults -1 :0];
        reg [100 : 0] stuck_at;
        reg [100 : 0] fault_array;
        reg [200 : 0] tempStr;
        reg [7:0] fault_char;
        reg [7:0] fault_char1; // 8 Bit File Pointer
        reg [Addr -1 : 0] std_fault_word;
        reg [Addr -1 : mux_bits] fault_row_add [max_faults -1 :0];
        reg [max_faults -1 :0] fault_repair_flag;
        reg [max_faults -1 :0] dont_insert_fault;
        reg [max_faults -1 :0] repair_flag;
        reg [100 : 0] array_stuck_at[max_faults -1 : 0] ;
        reg [100 : 0] mem_red_array_stuck_at[max_faults -1 : 0] ; 
        reg msgcnt;
        
       
        reg [Bits - 1: 0] stuck_at_0fault [max_faults -1 : 0];
        reg [Bits - 1: 0] stuck_at_1fault [max_faults -1 : 0];
        reg [Bits -1 : 0] stuck0;
        reg [Bits -1 : 0] stuck1;

        reg [Bits+Red_extrabit :0] Mem_last;
        

        `ifdef slm
        reg [Bits -1 : 0] slm_temp_data;
        `endif
        
        real time_CK_func_rise , time_RADCK_rise;
        real time_fall_sleep,time_fall_PSWLARGEMP,time_fall_PSWLARGEMP_0,time_fall_PSWLARGEMA,time_fall_PSWLARGEMA_0,time_fall_PSWSMALLMP,time_fall_PSWSMALLMA;
        integer flag_error;
        
//BUFFER INSTANTIATION
//=========================
       `ifdef functional
       
         buf (SCTRLO,delSCTRLO_data); 
         buf bufq [Bits-1:0] (Q,delOutReg_data);
      `else
       
         buf (SCTRLO,SCTRLO_data);
         buf bufq [Bits-1:0] (Q,OutReg_data);
      `endif
      
  
        buf (SEsys,SE);
	buf (SCTRLIint, SCTRLI);
   

	buf (CKint_func, CK);
	buf (CKint_dft, CK);
        buf bufaddr [Addr-1:0] (Asys,A);
        buf (INITNint,INITN);
        
        buf (LSint,1'b0); 
        buf (IGbuf,IG);
        buf (ATPint,ATP);

        buf bufTaddr [Addr-1 : 0] (TAint,TA);
        buf (TBISTsys,TBIST);
        buf (TCSNint,TCSN);

        buf (CSNsys,CSN);
        buf (STDBYint,STDBY );   
        
        buf (SLEEPint,SLEEP ); 

        buf bufrm [read_margin_size-1:0] (RMint, RM); 

        
        

        assign RRAEint = 1'b0;
        assign TRRAEint = 1'b0;
        assign repair_add = 0;
        assign next_repair_add = 0;
        assign red_en = 1'b0; 
        
        
        
        
        
        
        
        buf (PSWLARGEMPint,1'b0);
        buf (PSWSMALLMPint,1'b0); 
        buf (PSWLARGEMAint,1'b0);
        buf (PSWSMALLMAint,1'b0);   

      `ifdef functional
       
       
         buf (SDLO,delSDLO_data);
         buf (SDRO,delSDRO_data);
        
      `else
       
         buf (SDLO,SDLO_data);
         buf (SDRO,SDRO_data);
         
      `endif
       
         
       
        buf bufdata [Bits-1:0] (Dsys,D);
        
        
        assign Msys=23'b0; 
	

        
        buf (TBYPASSsys, TBYPASS);
        


        buf (WENsys,WEN);
	 
	buf (SDLIint, SDLI);
	buf (SDRIint, SDRI);
	 
        
        buf (HSint,1'b0); 

        
        buf (TEDint,TED);
        buf (TODint,TOD);
         
        buf (TWENint,TWEN);
        
        
        buf bufwm [write_margin_size-1:0] (WMint, WM); 
        



//      assign scanreg_ctrl_wire={scanreg_ctrl[scanlen_ctrl - 2:0],SCTRLIint};
//      assign scanreg_dl_wire={scanreg_dl[scanlen_l - 2:0],SDLIint};
//      assign scanreg_dr_wire={scanreg_dr[scanlen_r - 2:0],SDRIint};
      
        
      assign Aint   = (TBISTint === 1'b0 ) ? Asys : (TBISTint === 1'bx ) ? {Addr{1'bx}} : TAint;  

        
//        assign A_int = Aint;
	
        
                
        assign Dint[0] = (TBISTint === 1'b0) ? Dsys[0] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[1] = (TBISTint === 1'b0) ? Dsys[1] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[2] = (TBISTint === 1'b0) ? Dsys[2] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[3] = (TBISTint === 1'b0) ? Dsys[3] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[4] = (TBISTint === 1'b0) ? Dsys[4] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[5] = (TBISTint === 1'b0) ? Dsys[5] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[6] = (TBISTint === 1'b0) ? Dsys[6] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[7] = (TBISTint === 1'b0) ? Dsys[7] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[8] = (TBISTint === 1'b0) ? Dsys[8] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[9] = (TBISTint === 1'b0) ? Dsys[9] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[10] = (TBISTint === 1'b0) ? Dsys[10] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[11] = (TBISTint === 1'b0) ? Dsys[11] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[12] = (TBISTint === 1'b0) ? Dsys[12] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[13] = (TBISTint === 1'b0) ? Dsys[13] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[14] = (TBISTint === 1'b0) ? Dsys[14] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[15] = (TBISTint === 1'b0) ? Dsys[15] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[16] = (TBISTint === 1'b0) ? Dsys[16] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[17] = (TBISTint === 1'b0) ? Dsys[17] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[18] = (TBISTint === 1'b0) ? Dsys[18] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[19] = (TBISTint === 1'b0) ? Dsys[19] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[20] = (TBISTint === 1'b0) ? Dsys[20] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[21] = (TBISTint === 1'b0) ? Dsys[21] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[22] = (TBISTint === 1'b0) ? Dsys[22] : (TBISTint === 1'b1) ? TEDint : 1'bx;          
	 
        assign Mint = 23'b0;
         

        assign WENbuf = (TBISTint === 1'b0 ) ? WENsys : (TBISTint === 1'bx ) ? 1'bx : TWENint;  
        assign WENint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? WENbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[13] : (ATPint === 1'b0 ) ? WENsys : 1'bx ; 
        
        assign CSNbuf = (TBISTint === 1'b0 ) ? CSNsys : (TBISTint === 1'bx ) ? 1'bx : TCSNint;  
        assign CSNint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? CSNbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[11] : (ATPint === 1'b0 ) ? CSNsys : 1'bx ; 
        assign IGint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? IGbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[14] : (ATPint === 1'b0 ) ? IGbuf : 1'bx;

        
        assign DEint = (LSint === 1'bx || (LSint === 1'b0 && HSint === 1'bx) || ^RMint !== 1'b0 || ^WMint !== 1'b0 ) ? 1'bx : 1'b0;
        
     
     and (TBISTint, ATPint, TBISTsys);
     and (SEint, ATPint, SEsys);
     and (TBYPASSint, ATPint, TBYPASSsys);
     and (TSE,TBYPASSint,!SEsys);
     and (MEMEN,INITNint,!CSNint,!SLEEPint,!TBYPASSint,!SEint,!IGint,!DEint,!STDBYint );
     and (MEMEN_dft,INITNint, !SLEEPint, ATPint,!STDBYint);

 `ifdef functional
/*****************assertions added to optimize dynamic power consumption**********/

//psl a_M: assert always ({( RW_assertions_en);(MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1))  } |-> (stable(Msys))) @(posedge CK); 

//psl a_WEN: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(WENsys))) @(posedge CK); 

//psl a_A: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(Asys))) @(posedge CK); 

//psl a_D: assert always ({( RW_assertions_en);((MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1)) && TBYPASSint === 1'b0)  } |-> (stable(Dsys))) @(posedge CK); 

/**********************************************************************************************/
`endif       

     

         
reg vddmp,vddmo, vddma, vddsmp, vddsma, gndsm, gndm,  vddmpi ; 
 
initial 
begin

        vddmp = 1'b1 ; 
        vddmo = 1'b1 ;
        vddma = 1'b1 ;
        
        vddsmp = 1'b1 ;
        
        
         gndm = 1'b0 ;
          
end

        
         assign gndmint = (reg_mem_block === 0) ? gndm : 1'b1;
         
         
         
         
         assign vddmpint = vddmp;
         assign vddmoint = vddmo;
         assign vddmaint = vddma;
         
          
        
         

        //CPF Changes

        
                
        initial
        begin : cpfvddmp 
           vddmpreg = vddmpint;
        end

        always @(vddmpint) begin
           vddmpreg = vddmpint;
        end
        
        initial
        begin : cpfvddmo 
           vddmoreg = vddmoint;
        end

        always @(vddmoint) begin
           vddmoreg = vddmoint;
        end
        
        initial
        begin : cpfvddma 
           vddmareg = vddmaint;
        end

        always @(vddmaint) begin
           vddmareg = vddmaint;
        end

        
        
 
        initial
        begin : cpfgndm 
           gndmreg = gndmint;
        end

        always @(gndmint) begin
           gndmreg = gndmint;
        end

        
        



 `ifdef functional
  `else
  initial begin
    if (debug_level < 1) begin
     $display ("%m  INFORMATION");
     $display ("***************************************");
     $display ("The Model is Operating in TIMING MODE");
     $display ("Please make sure that SDF is properly annotated otherwise dummy values will be used");
     $display ("%s", message_status);
     $display ("***************************************");
    end
  end

//////////////////////////
 //REG DECLARATIONS
   //======================

   reg [Bits-1 : 0] TimingViol_data;
   reg  [Bits-1 : 0] TimingViol_mask;
   reg [Bits-1 : 0] TimingViol_data_last, TimingViol_mask_last;
	reg TimingViol_data_0;
	reg TimingViol_data_1;
	reg TimingViol_data_2;
	reg TimingViol_data_3;
	reg TimingViol_data_4;
	reg TimingViol_data_5;
	reg TimingViol_data_6;
	reg TimingViol_data_7;
	reg TimingViol_data_8;
	reg TimingViol_data_9;
	reg TimingViol_data_10;
	reg TimingViol_data_11;
	reg TimingViol_data_12;
	reg TimingViol_data_13;
	reg TimingViol_data_14;
	reg TimingViol_data_15;
	reg TimingViol_data_16;
	reg TimingViol_data_17;
	reg TimingViol_data_18;
	reg TimingViol_data_19;
	reg TimingViol_data_20;
	reg TimingViol_data_21;
	reg TimingViol_data_22;
 reg TimingViol_mask_0;
 reg TimingViol_mask_1;
 reg TimingViol_mask_2;
 reg TimingViol_mask_3;
 reg TimingViol_mask_4;
 reg TimingViol_mask_5;
 reg TimingViol_mask_6;
 reg TimingViol_mask_7;
 reg TimingViol_mask_8;
 reg TimingViol_mask_9;
 reg TimingViol_mask_10;
 reg TimingViol_mask_11;
 reg TimingViol_mask_12;
 reg TimingViol_mask_13;
 reg TimingViol_mask_14;
 reg TimingViol_mask_15;
 reg TimingViol_mask_16;
 reg TimingViol_mask_17;
 reg TimingViol_mask_18;
 reg TimingViol_mask_19;
 reg TimingViol_mask_20;
 reg TimingViol_mask_21;
 reg TimingViol_mask_22;

   reg TimingViol_addr;
   reg TimingViol_CSN, TimingViol_WEN, TimingViol_tbypass;
   reg TimingViol_tckh, TimingViol_tckl, TimingViol_tcycle;
   reg TimingViol_tckh_se, TimingViol_tckl_se, TimingViol_tcycle_se;
   reg TimingViol_sctrli,TimingViol_sdli,TimingViol_sdri,TimingViol_se;
   reg TimingViol_smli,TimingViol_smri;
   reg TimingViol_sctrli_flag,TimingViol_sdli_flag,TimingViol_sdri_flag;
   reg TimingViol_smli_flag,TimingViol_smri_flag;
   reg TimingViol_initnl;
   reg TimingViol_initn;
   reg TimingViol_ls;
   reg TimingViol_hs;
   reg TimingViol_sleep;
   reg TimingViol_stdby;
   reg TimingViol_rm;
   reg TimingViol_wm;
   reg TimingViol_tbist,TimingViol_ig,TimingViol_atp,TimingViol_TED,TimingViol_TOD,TimingViol_TEM,TimingViol_TOM;
   reg TimingViolRRAE,TimingViolRRA;

   wire CSTBYPASSN,cond_sdf_tas,cond_sdf_tds,cond_sdf_tms,cond_sdf_tws,cond_sdf_tbas,cond_sdf_tbps,cond_sdf_tbws,cond_sdf_tbdes,cond_sdf_tbdos,cond_sdf_tbmes,cond_sdf_tbmos;
   wire SETB_EN,CSIG_EN,MEM_ACT,EN_ADM,CS_EN,CS_ADM,cond_sdf_tps,IG_EN,IG_ADM,cond_sdf_tigs,cond_sdf_taa,cond_sdf_taa_ls1,cond_sdf_taa_hs1,cond_tseq_tm;
   wire cond_sdf_tcycle,cond_sdf_tcycle_ls1,cond_sdf_tcycle_hs1,cond_sdf_tcycle_se,cond_sdf_tckl_se,cond_sdf_tsctrlis,cond_sdf_tsdlis,cond_sdf_tsdris,cond_sdf_tsmlis,cond_sdf_tsmris;
   wire cond_sdf_tckh_se,cond_sdf_taa_sctrlo_se,cond_sdf_taa_sdlo_se,cond_sdf_taa_sdro_se,cond_sdf_taa_smlo_se,cond_sdf_taa_smro_se,cond_sdf_tckl,cond_sdf_tckh;
   wire cond_sdf_ttms,cond_sdf_tbists,INITNandnotSLEEPandATPandnotSE,cond_sdf_taa_sctrlo,cond_sdf_taa_sdlo,cond_sdf_taa_sdro,cond_sdf_taa_smlo,cond_sdf_taa_smro;
   wire cond_sdf_taa_tm,cond_sdf_taa_tm_ls1, cond_sdf_taa_tm_hs1,cond_sdf_taa_tckq_tm,cond_sdf_taa_tseq_tm;

   wire CSWETBYPASSN;
   wire cond_sdf_tstdbys,cond_sdf_tsls,sleep_en,atp_csn_en;
   wire cond_sdf_tlss,cond_sdf_thss,cond_sdf_trms,cond_sdf_twms; 
   wire cond_sdf_tses,cond_sdf_tinitns;
   wire tby_se_en;
   wire rra_en;
   wire tbist_atp_en;
   wire rrae_en;
   wire tbist_rrae_en;
   wire cond_sdf_trraes;
   wire cond_sdf_ttrraes;
   wire cond_sdf_taa_trramatch;
   wire cond_sdf_ttrraematch;
   wire cond_sdf_tamatch;
   wire cond_sdf_ttamatch;
   wire cond_sdf_tatpmatch;
   wire cond_sdf_ttbistmatch;



 and (CSWEMTBYPASS[0], !Mreg[0], CSWETBYPASSN);
 and (CSWEMTBYPASS[1], !Mreg[1], CSWETBYPASSN);
 and (CSWEMTBYPASS[2], !Mreg[2], CSWETBYPASSN);
 and (CSWEMTBYPASS[3], !Mreg[3], CSWETBYPASSN);
 and (CSWEMTBYPASS[4], !Mreg[4], CSWETBYPASSN);
 and (CSWEMTBYPASS[5], !Mreg[5], CSWETBYPASSN);
 and (CSWEMTBYPASS[6], !Mreg[6], CSWETBYPASSN);
 and (CSWEMTBYPASS[7], !Mreg[7], CSWETBYPASSN);
 and (CSWEMTBYPASS[8], !Mreg[8], CSWETBYPASSN);
 and (CSWEMTBYPASS[9], !Mreg[9], CSWETBYPASSN);
 and (CSWEMTBYPASS[10], !Mreg[10], CSWETBYPASSN);
 and (CSWEMTBYPASS[11], !Mreg[11], CSWETBYPASSN);
 and (CSWEMTBYPASS[12], !Mreg[12], CSWETBYPASSN);
 and (CSWEMTBYPASS[13], !Mreg[13], CSWETBYPASSN);
 and (CSWEMTBYPASS[14], !Mreg[14], CSWETBYPASSN);
 and (CSWEMTBYPASS[15], !Mreg[15], CSWETBYPASSN);
 and (CSWEMTBYPASS[16], !Mreg[16], CSWETBYPASSN);
 and (CSWEMTBYPASS[17], !Mreg[17], CSWETBYPASSN);
 and (CSWEMTBYPASS[18], !Mreg[18], CSWETBYPASSN);
 and (CSWEMTBYPASS[19], !Mreg[19], CSWETBYPASSN);
 and (CSWEMTBYPASS[20], !Mreg[20], CSWETBYPASSN);
 and (CSWEMTBYPASS[21], !Mreg[21], CSWETBYPASSN);
 and (CSWEMTBYPASS[22], !Mreg[22], CSWETBYPASSN);

and (atp_csn_en,!ATPint,!CSNint,!IGint);
or (sleep_en,atp_csn_en,ATPint);
or (SETB_EN,SEint,TBISTint);
and (ATP_SETB_EN,ATPint,SETB_EN); 
or (CSIG_EN,IGint,CSNint);
and (MEM_ACT,!ATPint,CSIG_EN);
or (EN_ADM,MEM_ACT,ATP_SETB_EN);
and (CS_EN,!ATPint,IGint);
or (CS_ADM,CS_EN,ATP_SETB_EN);
and (atp_ig_csn_en,!ATPint,!CSNint,!IGint);
and (atp_se_en,!SEsys,ATPint);
or (cycle_en,atp_ig_csn_en,atp_se_en);
and (atp_ig_csn_en_reg,!ATPreg,!CSNreg,!IGreg);
and (atp_se_en_reg,!SE_reg,ATPreg);
or (cycle_en_reg,atp_ig_csn_en,atp_se_en);
and (INITNandnotSLEEPandATPandnotSE,cond_gac,!SEsys,ATPint);
and (csn_ig_en,!IGint,!CSNint);
and (atp_tby_ls_en,atp_se_en,cond_ls_tby_en);
and (IG_EN,!ATPint,!CSNint);
or (IG_ADM,IG_EN,atp_se_en);
and (CSWETBYPASSN, !WENreg, 1'b1);



assign cond_sdf_tsls=((sleep_en && INITNint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tstdbys=((sleep_en && INITNint && !SLEEPint) !==0) ? 1:0;
assign cond_sdf_atps=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_gac=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tas=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tds=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tms=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tws=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tps=((cond_gac && !CS_ADM) !==0) ? 1:0;
assign cond_sdf_tcycle=((cond_gac && cycle_en && !LSint && !HSint) !==0) ? 1:0;  
assign cond_sdf_tcycle_ls1=((cond_gac && cycle_en && LSint) !==0) ? 1:0;
assign cond_sdf_tcycle_hs1=((cond_gac && cycle_en && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_tckh=((cond_gac && cycle_en_reg) !==0) ? 1:0;
assign cond_sdf_tckl=((cond_gac && cycle_en) !==0) ? 1:0;
assign cond_sdf_tcycle_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckl_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsctrlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckh_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_ttms=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_tbists=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_tckq_tm=((cond_gac && SE_reg && ATPreg && TBYPASSsys) !==0) ? 1:0;
assign cond_ls_en=((atp_ig_csn_en || atp_tby_ls_en) !==0) ? 1:0;
assign cond_sdf_tlss=((cond_ls_en && cond_gac) !==0) ? 1:0;
assign cond_sdf_thss=((cond_ls_en && cond_gac && !LSint) !==0) ? 1:0;
assign cond_sdf_trms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_twms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_tses=((cond_gac && ATPint) !==0) ? 1:0;
assign cond_sdf_tbas=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbps=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbws=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tigs=((cond_gac && IG_ADM) !==0) ? 1:0;
assign cond_sdf_taa=((MEMEN_reg && WENreg && !LSint && !HSint) !==0) ? 1:0; 
// assign cond_sdf_taa_tbypass_q = ((MEMEN_reg && ATPint && TBYPASSint) !== 1'b0) ? 1'b1 : 1'b0;
assign cond_sdf_taa_ls1=((MEMEN_reg && WENreg && LSint) !==0) ? 1:0; 
assign cond_sdf_taa_hs1=((MEMEN_reg && WENreg && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && !HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_ls1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && LSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_hs1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tseq_tm=((cond_gac && TBYPASSint) !==0) ? 1:0;
assign cond_sdf_tinitns =(( sleep_en && !STDBYint && !SLEEPint) !==0) ? 1:0;
assign cond_ls_tby_en=((TBYPASSsys || csn_ig_en) !==0) ? 1:0;



//specify block begins

specify
    specparam
    
         PATHPULSE$CK$Q = 0,
         PATHPULSE$CK$SCTRLO = 0,

         PATHPULSE$CK$SDLO = 0,
         PATHPULSE$CK$SDRO = 0,
        
         PATHPULSE$SE$Q = 0,
         
//         PATHPULSE$TBYPASS$Q = 0,


        
         
        
         tsls = `setup_time,
         tslh = `hold_time ,
         tstdbys = `setup_time,
         tstdbyh = `hold_time , 
	 

         
         tcycle = `cycle_time,
         
         
         tckh = `pulse_width_time,
         tckl = `pulse_width_time,
         tcycle_se = `cycle_time,
         tckh_se = `pulse_width_time,
         tckl_se = `pulse_width_time,
         
         ttms = `setup_time,
         ttmh = `hold_time ,
         tps = `setup_time,
         tph = `hold_time ,
         tws = `setup_time,
         twh = `hold_time ,
         tds = `setup_time,
         tdh = `hold_time , 
         tas = `setup_time,
         tah = `hold_time ,
         tses= `setup_time,
         tseh= `hold_time ,
         tsctrlis=`setup_time,
         tsctrlih=`hold_time ,
         tsdlis=`setup_time,
         tsdlih=`hold_time ,
         tsdris=`setup_time,
         tsdrih=`hold_time , 
         tbists=`setup_time,
         tbisth=`hold_time ,
         tbps=`setup_time,
         tbph=`hold_time ,
         tbws=`setup_time,
         tbwh=`hold_time ,
         tbdes=`setup_time,
         tbdeh=`hold_time ,
         tbdos=`setup_time,
         tbdoh=`hold_time ,
         
         tbas=`setup_time,
         tbah=`hold_time ,
         tinitnl=`initin_low_pulse,
         tinitns=`setup_time,
         tinitnh=`hold_time ,
         tatps=`setup_time,
         tatph=`hold_time ,
         tigs=`setup_time,
         tigh=`hold_time ,
         
         
         trms=`setup_time,
         trmh=`hold_time ,
         twms=`setup_time,
         twmh=`hold_time , 

/*************************************************************************************************/
           // taa_tbypass_q = `access_time,
           // th_tbypass_q  = `retain_time,
            taa =`access_time,
            th = `retain_time,

 


            taa_tm =`access_time,
            th_tm = `retain_time,

            
            taa_tseq_tm =`access_time,
            th_tseq_tm = `retain_time,
            taa_tckq_tm   = `access_time,
            th_tckq_tm    = `retain_time,
            taa_sctrlo=`access_time,
            th_sctrlo= `retain_time,
            taa_sdlo=`access_time,
            th_sdlo= `retain_time,
            taa_sdro=`access_time,
            th_sdro= `retain_time,
            
         
            taa_sctrlo_se=`access_time,
            th_sctrlo_se= `retain_time
,
            taa_sdlo_se=`access_time,
            th_sdlo_se= `retain_time,
            taa_sdro_se=`access_time,
            th_sdro_se= `retain_time
         ;  


        /*---------------------- Timing Checks ---------------------*/

	$setup(posedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[5], tah, TimingViol_addr);

	$setup(posedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(posedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(posedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(posedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(posedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(posedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(posedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(posedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(posedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(posedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(posedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(posedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(posedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(posedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(posedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(posedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(posedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(posedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(posedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(posedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(posedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(posedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$setup(posedge D[22], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_22);
	$setup(negedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(negedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(negedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(negedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(negedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(negedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(negedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(negedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(negedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(negedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(negedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(negedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(negedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(negedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(negedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(negedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(negedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(negedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(negedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(negedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(negedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(negedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$setup(negedge D[22], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_22);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[21], tdh, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[22], tdh, TimingViol_data_22);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[21], tdh, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[22], tdh, TimingViol_data_22);

        



        $setup(posedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $setup(negedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, posedge WEN, twh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, negedge WEN, twh, TimingViol_WEN); 
        $setup(posedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$setup(negedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, posedge CSN, tph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, negedge CSN, tph, TimingViol_CSN);
        $period(posedge CK &&& cond_sdf_tcycle, tcycle, TimingViol_tcycle);  

        
        $width(posedge CK  &&& cond_sdf_tckh, tckh, 0, TimingViol_tckh);
        $width(negedge CK  &&& cond_sdf_tckl, tckl, 0, TimingViol_tckl);
        $period(posedge CK &&& cond_sdf_tcycle_se, tcycle_se, TimingViol_tcycle_se);
        $width(posedge CK  &&& cond_sdf_tckh_se, tckh_se, 0, TimingViol_tckh_se);
        $width(negedge CK  &&& cond_sdf_tckl_se, tckl_se, 0, TimingViol_tckl_se);

        
        $setup(posedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $setup(negedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $hold(posedge CK &&& cond_sdf_ttms, posedge TBYPASS, ttmh, TimingViol_tbypass); 
        $hold(posedge CK &&& cond_sdf_ttms, negedge TBYPASS, ttmh, TimingViol_tbypass); 
 



        
        $setup(posedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $setup(negedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $hold(posedge CK &&& cond_sdf_tsls, posedge SLEEP, tslh, TimingViol_sleep);        
        $hold(posedge CK &&& cond_sdf_tsls, negedge SLEEP, tslh, TimingViol_sleep);

        $setup(posedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $setup(negedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $hold(posedge CK &&& cond_sdf_tstdbys, posedge STDBY, tstdbyh, TimingViol_stdby);        
        $hold(posedge CK &&& cond_sdf_tstdbys, negedge STDBY, tstdbyh, TimingViol_stdby); 
        
        
        $setup (posedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
	$setup (negedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
        
        $hold (posedge CK &&& cond_sdf_tses, posedge SE ,tseh,TimingViol_se);
	$hold (posedge CK &&& cond_sdf_tses, negedge SE ,tseh,TimingViol_se);
        
        $setup(posedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis , tsctrlis, TimingViol_sctrli);
        $setup(negedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis, tsctrlis, TimingViol_sctrli);
        $hold(posedge CK &&& cond_sdf_tsctrlis , posedge SCTRLI, tsctrlih, TimingViol_sctrli);        
        $hold(posedge CK &&& cond_sdf_tsctrlis , negedge SCTRLI, tsctrlih, TimingViol_sctrli);

        $setup(posedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $setup(negedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $hold(posedge CK &&& cond_sdf_tsdlis, posedge SDLI, tsdlih, TimingViol_sdli);        
        $hold(posedge CK &&& cond_sdf_tsdlis, negedge SDLI, tsdlih, TimingViol_sdli);

        $setup(posedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $setup(negedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $hold(posedge CK &&& cond_sdf_tsdris, posedge SDRI, tsdrih, TimingViol_sdri);        
        $hold(posedge CK &&& cond_sdf_tsdris, negedge SDRI, tsdrih, TimingViol_sdri);
        
 
	
         
        $width(negedge INITN , tinitnl, 0, TimingViol_initnl);
        
        $setup(posedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        $setup(negedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        
        $hold (posedge CK &&& cond_sdf_tinitns,posedge INITN, tinitnh, TimingViol_initn);
        $hold (posedge CK &&& cond_sdf_tinitns,negedge INITN, tinitnh, TimingViol_initn);

        $setup(posedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $setup(negedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $hold(posedge CK &&& cond_sdf_atps, posedge ATP, tatph, TimingViol_atp);        
        $hold(posedge CK &&& cond_sdf_atps, negedge ATP, tatph, TimingViol_atp);
        
        $setup(posedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $setup(negedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $hold(posedge CK &&& cond_sdf_tigs, posedge IG, tigh, TimingViol_ig);        
        $hold(posedge CK &&& cond_sdf_tigs, negedge IG, tigh, TimingViol_ig);



         
$setup(posedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[2], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[2], trmh, TimingViol_rm); 

        
$setup(posedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(posedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[1], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[1], twmh, TimingViol_wm);
 
        
        $setup(posedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $setup(negedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $hold(posedge CK &&& cond_sdf_tbists, posedge TBIST, tbisth, TimingViol_tbist);        
        $hold(posedge CK &&& cond_sdf_tbists, negedge TBIST, tbisth, TimingViol_tbist);
        
        	$setup(posedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$setup(negedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[5], tbah, TimingViol_addr);
       	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[5], tbah, TimingViol_addr);

        $setup(posedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$setup(negedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, posedge TCSN, tbph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, negedge TCSN, tbph, TimingViol_CSN); 
       
        $setup(posedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $setup(negedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, posedge TWEN, tbwh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, negedge TWEN, tbwh, TimingViol_WEN);
       
       
        $setup(posedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $setup(negedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, posedge TED, tbdeh, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, negedge TED, tbdeh, TimingViol_TED);

        $setup(posedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $setup(negedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, posedge TOD, tbdoh, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, negedge TOD, tbdoh, TimingViol_TOD);

          


          

          /*-------------------- Propagation Delays ------------------*/
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[22] +: OutReg_data[22])) = (taa, taa, th, taa, th, taa);
                 

/* // //	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[0] +: OutReg_data[0])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[1] +: OutReg_data[1])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[2] +: OutReg_data[2])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[3] +: OutReg_data[3])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[4] +: OutReg_data[4])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[5] +: OutReg_data[5])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[6] +: OutReg_data[6])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[7] +: OutReg_data[7])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[8] +: OutReg_data[8])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[9] +: OutReg_data[9])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[10] +: OutReg_data[10])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[11] +: OutReg_data[11])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[12] +: OutReg_data[12])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[13] +: OutReg_data[13])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[14] +: OutReg_data[14])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[15] +: OutReg_data[15])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[16] +: OutReg_data[16])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[17] +: OutReg_data[17])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[18] +: OutReg_data[18])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[19] +: OutReg_data[19])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[20] +: OutReg_data[20])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[21] +: OutReg_data[21])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[22] +: OutReg_data[22])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q); */ 








	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[22] +: OutReg_data[22])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                





	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[22] +: OutReg_data[22])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[22] +: OutReg_data[22])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                 

	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[0] +: OutReg_data[0])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[1] +: OutReg_data[1])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[2] +: OutReg_data[2])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[3] +: OutReg_data[3])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[4] +: OutReg_data[4])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[5] +: OutReg_data[5])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[6] +: OutReg_data[6])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[7] +: OutReg_data[7])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[8] +: OutReg_data[8])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[9] +: OutReg_data[9])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[10] +: OutReg_data[10])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[11] +: OutReg_data[11])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[12] +: OutReg_data[12])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[13] +: OutReg_data[13])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[14] +: OutReg_data[14])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[15] +: OutReg_data[15])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[16] +: OutReg_data[16])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[17] +: OutReg_data[17])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[18] +: OutReg_data[18])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[19] +: OutReg_data[19])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[20] +: OutReg_data[20])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[21] +: OutReg_data[21])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[22] +: OutReg_data[22])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                



if (cond_sdf_taa_sctrlo) 
        (posedge CK *> (SCTRLO :  SCTRLI)) = (taa_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo); 

if (cond_sdf_taa_sctrlo_se) 
        (negedge CK *> (SCTRLO : SCTRLI)) = (taa_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se); 
 

if (cond_sdf_taa_sdlo) 
        (posedge CK *> (SDLO :  SDLI)) = (taa_sdlo,taa_sdlo,th_sdlo,taa_sdlo,th_sdlo,taa_sdlo); 

if (cond_sdf_taa_sdlo_se) 
        (negedge CK *> (SDLO : SDLI)) = (taa_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se);

if (cond_sdf_taa_sdro) 
        (posedge CK *> (SDRO :  SDRI)) = (taa_sdro,taa_sdro,th_sdro,taa_sdro,th_sdro,taa_sdro); 

if (cond_sdf_taa_sdro_se) 
        (negedge CK *> (SDRO : SDRI)) = (taa_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se); 

  
     




endspecify //specify block ends






// conversion from registers to array elements for data setup violation notifiers

always @(TimingViol_data_0   or TimingViol_TED  )
begin
        TimingViol_data[0]=~TimingViol_data[0];   
end


always @(TimingViol_data_1   or TimingViol_TOD  )
begin
        TimingViol_data[1]=~TimingViol_data[1];   
end


always @(TimingViol_data_2   or TimingViol_TED  )
begin
        TimingViol_data[2]=~TimingViol_data[2];   
end


always @(TimingViol_data_3   or TimingViol_TOD  )
begin
        TimingViol_data[3]=~TimingViol_data[3];   
end


always @(TimingViol_data_4   or TimingViol_TED  )
begin
        TimingViol_data[4]=~TimingViol_data[4];   
end


always @(TimingViol_data_5   or TimingViol_TOD  )
begin
        TimingViol_data[5]=~TimingViol_data[5];   
end


always @(TimingViol_data_6   or TimingViol_TED  )
begin
        TimingViol_data[6]=~TimingViol_data[6];   
end


always @(TimingViol_data_7   or TimingViol_TOD  )
begin
        TimingViol_data[7]=~TimingViol_data[7];   
end


always @(TimingViol_data_8   or TimingViol_TED  )
begin
        TimingViol_data[8]=~TimingViol_data[8];   
end


always @(TimingViol_data_9   or TimingViol_TOD  )
begin
        TimingViol_data[9]=~TimingViol_data[9];   
end


always @(TimingViol_data_10   or TimingViol_TED  )
begin
        TimingViol_data[10]=~TimingViol_data[10];   
end


always @(TimingViol_data_11   or TimingViol_TOD  )
begin
        TimingViol_data[11]=~TimingViol_data[11];   
end


always @(TimingViol_data_12   or TimingViol_TED  )
begin
        TimingViol_data[12]=~TimingViol_data[12];   
end


always @(TimingViol_data_13   or TimingViol_TOD  )
begin
        TimingViol_data[13]=~TimingViol_data[13];   
end


always @(TimingViol_data_14   or TimingViol_TED  )
begin
        TimingViol_data[14]=~TimingViol_data[14];   
end


always @(TimingViol_data_15   or TimingViol_TOD  )
begin
        TimingViol_data[15]=~TimingViol_data[15];   
end


always @(TimingViol_data_16   or TimingViol_TED  )
begin
        TimingViol_data[16]=~TimingViol_data[16];   
end


always @(TimingViol_data_17   or TimingViol_TOD  )
begin
        TimingViol_data[17]=~TimingViol_data[17];   
end


always @(TimingViol_data_18   or TimingViol_TED  )
begin
        TimingViol_data[18]=~TimingViol_data[18];   
end


always @(TimingViol_data_19   or TimingViol_TOD  )
begin
        TimingViol_data[19]=~TimingViol_data[19];   
end


always @(TimingViol_data_20   or TimingViol_TED  )
begin
        TimingViol_data[20]=~TimingViol_data[20];   
end


always @(TimingViol_data_21   or TimingViol_TOD  )
begin
        TimingViol_data[21]=~TimingViol_data[21];   
end


always @(TimingViol_data_22   or TimingViol_TED  )
begin
        TimingViol_data[22]=~TimingViol_data[22];   
end


`endif


// TASK DEFINITION DESCRIPTION
// ================================



task task_insert_faults_in_memory;
begin
   if (reg_ConfigFault)
   begin   
     for(i = 0;i< fcnt;i = i+ 1) begin
        if(mem_red_array_stuck_at[i] === "mem_array") begin
          if (array_stuck_at[i] === "sa0") begin
           `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data & stuck_at_0fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
          `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] & stuck_at_0fault[i];
          `endif
         end //if(array_stuck_at)
                                        
         if(array_stuck_at[i] === "sa1") begin
         `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data | stuck_at_1fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
         `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] | stuck_at_1fault[i]; 
         `endif
         end //if(array_stuck_at)
       end //if mem_red_array_stuck_at
    
    
     end    // end of for
   end  
end
endtask



task task_read_fault_file;
begin
/*  -----------Implemetation for config fault starts------*/
   msgcnt = X;
   t = 0;
   fault_repair_flag = {max_faults{1'b1}};
   repair_flag = {max_faults{1'b1}};
   if(reg_ConfigFault) 
   begin
      file_ptr = $fopen(reg_Fault_file_name , "r");
      if(file_ptr == 0)
      begin     
          if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: File cannot be opened ",$realtime);
      end        
      else                
      begin : read_fault_file
        t = 0;
        for (i = 0; i< max_faults; i= i + 1)
        begin
         
           stuck0 = {Bits{1'b1}};
           stuck1 = {Bits{1'b0}};
           fault_char1 = $fgetc (file_ptr);
           if (fault_char1 == 8'b11111111)
              disable read_fault_file;
           ret_val = $ungetc (fault_char1, file_ptr);
           ret_val = $fgets(tempStr, file_ptr);
           ret_val = $sscanf(tempStr, "%s %d %d %s",fault_array,fault_word, fault_bit, stuck_at) ;
           flag_error = 0; 
           if(ret_val !== 0)
           begin         
              if(ret_val == 3 || ret_val == 4)
              begin
                if(ret_val == 3)
                   stuck_at = "sa0";

                if(stuck_at !== "sa0" && stuck_at !== "sa1" && stuck_at !== "none")
                begin
                    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: Wrong value for stuck at in fault file ",$realtime);
                   flag_error = 1;
                end    
                      
                if(fault_word >= Words)
                begin
                   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Address out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                if(fault_bit >= Bits)
                begin  
                    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Faulty bit out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                
                        
                if(fault_array !== "mem_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array is not mem_array ",$realtime);
                  flag_error = 1;
                end

                if(fault_array === "red_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array can't be on redundancy array in non redundancy cut.",$realtime);
                  flag_error = 1;
                end

                
                

                if(flag_error == 0)
                //Correct Inputs
                begin
                   if(stuck_at === "none")
                   begin
                       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
                   end
                   else
                   //Adding the faults
                   begin
                      FailureLocn[t] = fault_word;
                      Failurebit[t]  = fault_bit ;
                      std_fault_word = fault_word;
                      fault_row_add[t] = std_fault_word[Addr-1:mux_bits];
                      mem_red_array_stuck_at[t] = fault_array;
                      fault_repair_flag[t] = 1'b0;
                      if (stuck_at === "sa0" )
                      begin
                         stuck0[fault_bit] = 1'b0;         
                         stuck_at_0fault[t] = stuck0;
                      end     
                      if (stuck_at === "sa1" )
                      begin
                         stuck1[fault_bit] = 1'b1;
                         stuck_at_1fault[t] = stuck1; 
                      end

                      array_stuck_at[t] = stuck_at;
                      t = t + 1;
                   end //if(stuck_at === "none")  
                end //if(flag_error == 0)
              end //if(ret_val == 2 || ret_val == 3 
              else
              //wrong number of arguments
              begin
                if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: WRONG VALUES ENTERED FOR FAULTY WORD OR FAULTY BIT OR STUCK_AT IN Fault_file_name ",$realtime); 
                flag_error = 1;
              end
           end //if(ret_val !== 0)
           else
           begin 
               if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
           end    
        end //for (i = 0; i< m
      end //begin: read_fault_file  
      $fclose (file_ptr);

      fcnt = t;
      
      //fault injection at time 0.
      task_insert_faults_in_memory;
  end // config_fault 
end
endtask


task WriteMemX;
begin

`ifdef slm
   $slm_ResetMemory(MemAddr, WordX);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = WordX;
   
`endif        
 task_insert_faults_in_memory;
end
endtask

task WriteMem0;
begin
`ifdef slm
   $slm_ResetMemory(MemAddr, Word0);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = Word0;
  
`endif 
   task_insert_faults_in_memory;
end
endtask


task WriteOutX;                
begin
   OutReg_data <= #0 WordX;
end
endtask


task Invalid_next_cycle_func;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_func = 1;
     `else 
       #0 next_cycle_corrupt_func = 0; 
     `endif  
   end 
end
endtask

task Invalid_next_cycle_dft;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_dft = 1;
     `else 
       #0 next_cycle_corrupt_dft = 0; 
     `endif  
  end
end
endtask

task Invalid_next_cycle_func_tim;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
   #0 next_cycle_corrupt_func <= 1;
  end 
end
endtask

task Invalid_next_cycle_dft_tim;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
  #0 next_cycle_corrupt_dft <= 1;
  end
end
endtask


task ScanOutX;                
begin
   
   dff_SCTRLO_SE.Q <= 1'bx;   
   dff_SDLO_SE.Q <= 1'bx; 
   dff_SDRO_SE.Q <= 1'bx; 
    
   
   SCTRLOint=X;
   SDLOint=X;
   SDROint=X;
    
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   SDLO_data<=1'bx;
   SDRO_data<=1'bx;
    
   `endif
end
endtask

task delScanOutX;                
begin
   delSCTRLO_data<=X;
   delSDLO_data<=X;
   delSDRO_data<=X;
    
end
endtask

task ScanChainX;                
begin
 scanreg_ctrl=1'bx; 
 scanreg_dl=1'bx; 
 scanreg_dr =1'bx; 
  
end
endtask

task mem_blocked;
begin
 
   WriteMemX;
   WriteOutX;
   ScanChainX;
   ScanOutX;//immediately;
   delScanOutX;//immediately
   `ifdef POWER_SEQUENCING_OFF
   `else
   reg_mem_block=1;
   `endif
   debug_level = 2'b11;
end
endtask

task corrupt_all;
begin
 
  WriteMemX;
  WriteOutX;
  ScanChainX;
  ScanOutX;
  delScanOutX;//immediately;
  OutReg_data = WordX; 
  delOutReg_data=WordX;
  
end
endtask

task WriteCycle;                  
input [Addr-1 : 0] Address;
reg [Bits-1:0] tempReg1;
reg [Bits-1:0] tempReg_slm;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;


reg repair_flag;

integer po,i,num,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;
begin

   tempReg1 = WordX;
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];

   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};
   
   if (ValidAddress === X )   begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
        WriteMemX;
        if (INITNint !== 0) begin
        `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
           #0 next_cycle_corrupt_func = 1;
       `else 
           #0 next_cycle_corrupt_func = 0; 
       `endif  
   end 

   end


   if (ValidAddress !== X && next_cycle_corrupt_func === 0  )
   begin
         if (red_en === 1 && ((Row_Add_cmp === repair_add) || (Row_Add_cmp === next_repair_add)) ) begin
             repair_flag = 1'b1;
             
             Bank_sel_integer = 0;
                     
             if (Row_Add_cmp === repair_add) begin
               Col_Add_integer  = Col_Add; 
             end
             else if (Row_Add_cmp === next_repair_add) begin
               Col_Add_integer  = Col_Add + mux; 
             end  
             RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
        end  

        if(repair_flag === 0 && ValidAddress === 1) begin
           `ifdef slm
              $slm_ReadMemoryS(MemAddr, Address, tempReg_slm);
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = Mem[Address];
            `endif
          end  
        else if(repair_flag === 1) begin
           `ifdef slm
//              $slm_ReadMemoryS(RedMemAddr, RedMem_address, tempReg_slm);
          
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = RedMem[RedMem_address];
            `endif
        end
        
        for (num=0;num<Bits;num=num+1) begin
             po=num;        
             if ( Dint [num] !== tempReg1 [po]) begin
                if (Mint[num] === 1'b0)
                   tempReg1[po] = Dint[num];
                else if (Mint[num] === 1'bX)
                   tempReg1[po] = 1'bx;
             end                
        end //for (num=0
            
         if(repair_flag === 0 ) begin    
            if(ValidAddress === 1) begin  
              `ifdef slm
                  tempReg_slm=tempReg1; 
                  $slm_WriteMemory(MemAddr, Address, tempReg_slm);
              `else
                   Mem[Address] = tempReg1;
              `endif
            end
            else begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address Out Of Range. ",$realtime);
            end        
         end
         else if (repair_flag === 1 ) begin
            `ifdef slm
                tempReg_slm=tempReg1; 
//                $slm_WriteMemory(RedMemAddr, RedMem_address, tempReg_slm);
            `else
                RedMem[RedMem_address] = tempReg1;
            `endif
         end
   end //if (ValidAddress !== X
   task_insert_faults_in_memory;
end
endtask 

task ReadCycle;
input [Addr-1 : 0] Address;

reg [Bits-1:0] MemData_tmp;
reg [Bits-1:0] MemData;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;

reg repair_flag;

integer a,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;

begin
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];
   
   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};

   

   if (ValidAddress !== X && next_cycle_corrupt_func === 0 ) begin   
       if(red_en === 1 && ( Row_Add_cmp === repair_add ||  Row_Add_cmp === next_repair_add )) begin
              repair_flag = 1;
              
              Bank_sel_integer = 0;
               
              if(Row_Add_cmp === repair_add) begin
                Col_Add_integer = Col_Add;
              end
              else if (Row_Add_cmp === next_repair_add) begin
                Col_Add_integer = Col_Add + mux; 
              end
              RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
       end

      if(repair_flag === 0) begin
          if(ValidAddress === 1) begin 
           `ifdef slm
              $slm_ReadMemory(MemAddr, Address, MemData);
           `else
              MemData = Mem[Address];
           `endif
          end
          else begin
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Address Out Of Range. Output Corrupted ",$realtime);
             MemData = WordX;
          end
     end
      else if(repair_flag === 1) begin
        `ifdef slm
//           $slm_ReadMemory(RedMemAddr, RedMem_address, MemData);
        `else
           MemData = RedMem[RedMem_address];
        `endif
      end
   end //if (ValidAddress)  
   
   if(ValidAddress === X)
   begin
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Illegal Value on Address Bus. Memory and Output Corrupted ",$realtime); 
         Invalid_next_cycle_func;
   end 
   
  if(ValidAddress !== X && next_cycle_corrupt_func === 0 )
   begin
   for (a = 0; a < Bits; a = a + 1)
   begin
      if (MemData[a] !== OutReg_data[a])
         OutReg_data[a] = WordX[a];
   end//for (a = 0; a <  
         OutReg_data <= MemData;
   end     
end
endtask



// SCAN CHAINS
supply0 gnd;
buf (A_int[0], Aint[0]);
buf (A_int[1], Aint[1]);
buf (A_int[2], Aint[2]);
buf (A_int[3], Aint[3]);
buf (A_int[4], Aint[4]);
buf (A_int[5], Aint[5]);                  //used for capturing
buf (A_int[6], gnd);
buf (A_int[7], gnd);
buf (A_int[8], gnd);
buf (A_int[9], gnd);
buf (A_int[10], gnd);
buf (A_int[11], gnd);
buf (A_int[12], gnd);
buf (A_int[13], gnd);
buf (A_int[14], gnd);   //used for capturing

buf (WEN_int, WENint);
buf (CSN_int, CSNint);
buf (IG_int, IGint);


// Scan flops



// CONTROL SCAN CHAIN
     ST_SPREG_LOLEAK_64x23m2_Tl_SCFF cntrl_scff_0 (.D(1'b0), .TI(SCTRLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[0]), .OUTX(scanreg_ctrl));

      
 ST_SPREG_LOLEAK_64x23m2_Tl_SCFF cntrl_scff_1 (.D(A_int[2]), .TI(scanreg_ctrl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[1]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m2_Tl_SCFF cntrl_scff_2 (.D(A_int[4]), .TI(scanreg_ctrl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[2]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m2_Tl_SCFF cntrl_scff_3 (.D(A_int[7]), .TI(scanreg_ctrl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[3]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m2_Tl_SCFF cntrl_scff_4 (.D(A_int[1]), .TI(scanreg_ctrl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[4]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m2_Tl_SCFF cntrl_scff_5 (.D(A_int[9]), .TI(scanreg_ctrl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[5]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m2_Tl_SCFF cntrl_scff_6 (.D(A_int[8]), .TI(scanreg_ctrl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[6]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m2_Tl_SCFF cntrl_scff_7 (.D(1'b0), .TI(scanreg_ctrl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[7]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m2_Tl_SCFF cntrl_scff_8 (.D(A_int[0]), .TI(scanreg_ctrl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[8]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m2_Tl_SCFF cntrl_scff_9 (.D(A_int[3]), .TI(scanreg_ctrl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[9]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m2_Tl_SCFF cntrl_scff_10 (.D(A_int[5]), .TI(scanreg_ctrl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[10]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m2_Tl_SCFF cntrl_scff_11 (.D(CSN_int), .TI(scanreg_ctrl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[11]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m2_Tl_SCFF cntrl_scff_12 (.D(A_int[6]), .TI(scanreg_ctrl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[12]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m2_Tl_SCFF cntrl_scff_13 (.D(WEN_int), .TI(scanreg_ctrl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[13]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m2_Tl_SCFF cntrl_scff_14 (.D(scanreg_ctrl_wire[14]), .TI(scanreg_ctrl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[14]), .OUTX(scanreg_ctrl));  

reg LP_CK_gate;

// Lock Up Latch
wire SCTRLO_temp;
 ST_SPREG_LOLEAK_64x23m2_Tl_lock_up_latch  dff_SCTRLO_SE (Latch_open, scanreg_ctrl_wire[14], SCTRLO_temp);

always @(SCTRLO_temp) begin
     SCTRLOint= SCTRLO_temp;
 `ifdef functional
 `else
 if (SCTRLOint !== SCTRLO_data) begin 
  if (SCTRLOint !==X)
   SCTRLO_data=1'bx;
   SCTRLO_data <= SCTRLOint;
 end 
 `endif
end  


// LEFT DATA SCAN CHAIN
     ST_SPREG_LOLEAK_64x23m2_Tl_SCFF ldata_scff_0 (.D(Dint[11]), .TI(SDLI), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[0]), .OUTX(scanreg_dl));
      
   
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF ldata_scff_1 (.D(Dint[10]), .TI(scanreg_dl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[1]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF ldata_scff_2 (.D(Dint[9]), .TI(scanreg_dl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[2]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF ldata_scff_3 (.D(Dint[8]), .TI(scanreg_dl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[3]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF ldata_scff_4 (.D(Dint[7]), .TI(scanreg_dl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[4]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF ldata_scff_5 (.D(Dint[6]), .TI(scanreg_dl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[5]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF ldata_scff_6 (.D(Dint[5]), .TI(scanreg_dl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[6]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF ldata_scff_7 (.D(Dint[4]), .TI(scanreg_dl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[7]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF ldata_scff_8 (.D(Dint[3]), .TI(scanreg_dl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[8]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF ldata_scff_9 (.D(Dint[2]), .TI(scanreg_dl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[9]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF ldata_scff_10 (.D(Dint[1]), .TI(scanreg_dl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[10]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF ldata_scff_11 (.D(Dint[0]), .TI(scanreg_dl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[11]), .OUTX(scanreg_dl));



// Lock Up Latch
wire SDLO_temp;
 ST_SPREG_LOLEAK_64x23m2_Tl_lock_up_latch  dff_SDLO_SE (Latch_open, scanreg_dl_wire[11], SDLO_temp);

always @(SDLO_temp) begin
     SDLOint= SDLO_temp;
 `ifdef functional
 `else
 if (SDLOint !== SDLO_data) begin 
  if (SDLOint !==X)
   SDLO_data=1'bx;
   SDLO_data <= SDLOint;
 end 
 `endif
end  






// RIGHT DATA SCAN CHAIN

     ST_SPREG_LOLEAK_64x23m2_Tl_SCFF rdata_scff_0 (.D(1'b0), .TI(SDRI), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[0]), .OUTX(scanreg_dr));
     
 
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF rdata_scff_1 (.D(Dint[22]), .TI(scanreg_dr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[1]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF rdata_scff_2 (.D(Dint[21]), .TI(scanreg_dr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[2]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF rdata_scff_3 (.D(Dint[20]), .TI(scanreg_dr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[3]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF rdata_scff_4 (.D(Dint[19]), .TI(scanreg_dr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[4]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF rdata_scff_5 (.D(Dint[18]), .TI(scanreg_dr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[5]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF rdata_scff_6 (.D(Dint[17]), .TI(scanreg_dr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[6]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF rdata_scff_7 (.D(Dint[16]), .TI(scanreg_dr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[7]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF rdata_scff_8 (.D(Dint[15]), .TI(scanreg_dr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[8]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF rdata_scff_9 (.D(Dint[14]), .TI(scanreg_dr_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[9]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF rdata_scff_10 (.D(Dint[13]), .TI(scanreg_dr_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[10]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m2_Tl_SCFF rdata_scff_11 (.D(Dint[12]), .TI(scanreg_dr_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[11]), .OUTX(scanreg_dr)); 


// Lock Up Latch
wire SDRO_temp;
 ST_SPREG_LOLEAK_64x23m2_Tl_lock_up_latch  dff_SDRO_SE (Latch_open, scanreg_dr_wire[11], SDRO_temp);


always @(SDRO_temp) begin
     SDROint= SDRO_temp;
 `ifdef functional
 `else
 if (SDROint !== SDRO_data) begin 
  if (SDROint !==X)
   SDRO_data=1'bx;
   SDRO_data <= SDROint;
 end 
 `endif
end






//


 //////// CAPTURE TASK //////
task scan_acquire;
begin
   if (supply_ok === 1) begin 
      if ( SEsys === 0 && ((LP_CK_gate === 0 && TBYPASSsys !== 1'bx)|| TBYPASSsys===0)) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
         
         Latch_open=1;
         

      end //if ( SEint === 0
   end//if(supply_ok 
end
endtask

task scan_shift;
begin
 if (supply_ok === 1) begin
   if (STDBYint === 0 && SLEEPint === 0) begin
      if (CKint_dft === X && INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0) begin
         ScanChainX;
         ScanOutX;
      end
      else if (CKint_dft === 1 && lastCK_dft === 0 ) begin
          //// SHIFT
        if (SEsys === 1) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
           
        //// SHIFT Ends
        end //if (SEsys === 1
        else if (SEsys === X) begin
            ScanChainX;
            ScanOutX;
            delScanOutX;
        end//if (SEint ==X
      
      end///if (CKint === 
    
      else if (CKint_dft === 0 && lastCK_dft === 1 ) begin
        Latch_open=1;
      end
    end  //if (STDByint === 0 && SLEEPint === 0
 end//if(supply_ok
end
endtask






// BEHAVIOURAL MODULE DESCRIPTION
// ================================

initial
begin
  // Define format for timing value
  $timeformat (-9, 3, " ns", 0);
  `ifdef slm
  $slm_RegisterMemory(MemAddr, Words, Bits);
  `endif   
   reg_mem_block=0;
   flag_mem_block=0;
  `ifdef functional
  `else
   TimingViol_data=0;
   TimingViol_mask=0;
   `endif
   decoding_start=0;
  
   //Parameter Assignment
   
   reg_Fault_file_name = Fault_file_name; 
   reg_ConfigFault     = ConfigFault;
   reg_MEM_INITIALIZE  = MEM_INITIALIZE;
   reg_BinaryInit      = BinaryInit;
   reg_InitFileName    = InitFileName;
   reg_Initn_reset_value = Initn_reset_value;
   reg_File_load_time    = File_load_time;

   time_fall_sleep=0;
   time_fall_PSWLARGEMP=0;
   time_fall_PSWLARGEMP_0=0;
   time_fall_PSWLARGEMA=0;
   time_fall_PSWLARGEMA_0=0;
   time_fall_PSWSMALLMP=0;
   time_fall_PSWSMALLMA=0;

   vddmp_rise_time=0;
   vddmp_fall_time=0;
   vddsmp_rise_time=0;
   vddsmp_fall_time=0;
   vddma_rise_time=0;
   vddma_fall_time=0;
   vddsma_rise_time=0;
   vddsma_fall_time=0;
   vddm_fall_time=0;  
   vddm_rise_time=0;  
   vddsm_fall_time=0; 
   vddsm_rise_time=0;

   next_cycle_corrupt_func=0;
   next_cycle_corrupt_dft=0;
   init_pulse_done = 0;
   power_up_done = 0;
   file_loaded=1;
   debug_level= 2'b01;
   message_status = "ONLY WARNINGS/ERRORS are Switched ON.For INFO also use debug_level=2'b00";
  `ifdef  NO_WARNING_MODE
     debug_level = 2'b11;
     message_status = "All Warning/Errors/Info Messages are Switched OFF";
  `endif  
  `ifdef  ONLY_ERROR_MODE
     debug_level = 2'b10;
     message_status = "All Warning/Info Messages are Switched OFF.Errors are switched on";
  `endif 
  `ifdef  ALL_MSG_MODE
     debug_level = 2'b00;
     message_status = "All Messages are Switched ON";
  `endif 
  
  `ifdef slm
     operating_mode = "SLM";
   `else
      `ifdef functional
         operating_mode = "FUNCTIONAL";
       `else
         operating_mode = "TIMING";
      `endif
   `endif   
  
  if (debug_level < 1) begin
  $display ("%m INFORMATION ");
  $display ("***************************************");
  $display ("The Model is Operating in %s MODE", operating_mode);
  $display ("%s", message_status);
  if(reg_ConfigFault)
  $display ("Configurable Fault Functionality is ON");   
  else
  $display ("Configurable Fault Functionality is OFF");   
  $display("Fault File used by the model Fault_File_Name=%s" ,reg_Fault_file_name);
  $display("Values of Config_fault used in model=%d" ,reg_ConfigFault);
  $display("Values of Mem_INITALIZE used in model=%d" ,reg_MEM_INITIALIZE);
  $display("Values of BinaryInit used in model=%d" ,reg_BinaryInit);
  $display("Values of InitFileName used in model=%s" ,reg_InitFileName);
  $display("Values of Initn_reset_value used in model=%d" ,reg_Initn_reset_value);
  $display("Values of File_load_time used in model=%t" ,reg_File_load_time);

  $display ("***************************************");
  end
     
  task_read_fault_file; 
   if(!INITNint) begin
    if(supply_ok ) begin 
      init_pulse_done = 1;
      power_up_done = 1;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif 
    end 
   end 
        
   lastCK_func = CKint_func;
   lastCK_dft = CKint_dft;

 `ifdef MEM_CONTENTS_SLEEP
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","w");
   $fclose(ptr);
 `endif 

   
end  // initial block ends



//+++++++++++++++++++++++++++++++ CONFIG FAULT IMPLEMETATION ENDS+++++++++++++++++++++++++++++++//
        




//INITN block starts
//================================
always @(INITNint  or supply_ok )
begin
 if (INITNint === 1'b0) begin
   if(supply_ok) begin
     init_pulse_done = 1;
     power_up_done = 1;
     lastCK_func=CKint_func;
     lastCK_dft=CKint_dft;
     next_cycle_corrupt_func = 0;
     next_cycle_corrupt_dft = 0;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif     
   end 
 end        

 if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && INITNint !== 1)
   begin
     ScanOutX;
     ScanChainX;
     delScanOutX;
   end  
         
 if (init_pulse_done === 0 && INITNint !== 0) begin
     if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) INFO: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
 end
 
end//always @(INITNint)


// Clock Generation 
//wire gated_clock;
//wire clock_gate_en;
//ST_SPREG_LOLEAK_64x23m2_Tl_lock_up_latch CK_SE_latch (!CK , SE, SE_latch_CK);
//and (clock_gate_en, ATP, TBYPASS, !SE_latch_CK);

//ST_SPREG_LOLEAK_64x23m2_Tl_lock_up_latch LP_latch (!CK , scanreg_ctrl_wire[14], LP_latch_CK);
//and (gated_clock,CK,!LP_latch_CK);
//assign CK_new= clock_gate_en ===0 ? CK : (clock_gate_en ===1 ? gated_clock: (CK===0) ? 0 :1'bx);


// Clock Generation Ends


// Functional CK block starts
//======================================
always @(CKint_func)
begin
   lastCK_func=CKreg_func;  
   CKreg_func=CKint_func;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
        if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
      if (CKreg_func === 1'bX || (CKreg_func === 1'b1 && lastCK_func === 1'bx)) begin
        if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
         
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
         Invalid_next_cycle_func;
        end
      end
      else if (CKreg_func === 1'b1 && lastCK_func === 1'b0 ) begin
        time_CK_func_rise=$realtime;
        MEMEN_prev = MEMEN_reg;
        MEMEN_reg = MEMEN;
        CSNreg = CSNint;
        IGreg = IGint;
        DEreg = DEint;
        SE_reg = SEsys;
        TBYPASS_reg = TBYPASSsys;
        ATPreg = ATPint;
        INITNreg = INITNint;
        SLEEPreg = SLEEPint;
        STDBYreg = STDBYint;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 

    `ifdef functional
    `else
        Mem_last=Mem[Aint];
    `endif 
        if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.INITN pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SLEEP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.STANDBY pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg === X && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.chip select  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg === X && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.IG pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg === X && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.Debug pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg === X && (SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.ATP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg === X && TBYPASS_reg !== 1) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SE pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg !== 1 && TBYPASS_reg === X) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.TBYPASS pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end

        else if ((INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0))) && WENint === X) begin
            // Uncertain write cycle
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: write enable going to X  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end 
        else if (next_cycle_corrupt_func === 1) begin
          next_cycle_corrupt_func = X;
        end
        else if (next_cycle_corrupt_func === 1'bx) begin
          next_cycle_corrupt_func = 0;
        end 
        
//        if (next_cycle_corrupt_func === 0 ) begin 
         
          /*---------------------- File initialization -----------------*/
          
          if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0)) && flag_mem_block === 1'b0) begin
                 Areg=Aint;
                 Dreg=Dint;
                 Mreg=Mint;
                 WENreg=WENint;     
             if (reg_MEM_INITIALIZE === 1'b1 && $realtime >= reg_File_load_time && file_loaded ) begin   
                `ifdef slm
                  if (reg_BinaryInit)
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_BIN");
                  else
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_HEX");
   
                `else
                  if (reg_BinaryInit)
                     $readmemb(reg_InitFileName, Mem, 0, Words-1);
                  else
                     $readmemh(reg_InitFileName, Mem, 0, Words-1);
                `endif
                 file_loaded = 0;
             end
   
             if (^Aint === X)
               ValidAddress = X;
             else if (Aint < Words)
               ValidAddress = 1;
             else    
               ValidAddress = 0;
   
             if(red_en === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Redundancy Enable is Invalid. Either RRAE is X or TRRAE is X",$realtime);
                ValidAddress = X; 
           end
           else if(red_en === 1'b1 && ^repair_add === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Repair Address is invalid.RRA is X",$realtime);
                ValidAddress = X;
           end
             
             if (ValidAddress)
               `ifdef slm
                   $slm_ReadMemoryS(MemAddr, Aint, Mem_temp);
               `else
                    Mem_temp = Mem[Aint];
               `endif
             else
                Mem_temp = WordX;  
          
     /*---------------------- Normal Read and Write -----------------*/
     
             if (WENint === 1) begin
               ReadCycle(Aint);
             end
       
             else if (WENint === 0) begin
               WriteCycle(Aint);
             end 
                
          
          end //  if (MEMEN === 1'b1 
       
//        end  // if (next_cycle_corrupt_func === 0
      
      end // if (CKint = 1   
   end // if (init_pulse_done === 1           
 end 
end // always @(CKint_func)
        
always @(MEMEN)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) && CKint_func === 1'bx) begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.clock pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
    Invalid_next_cycle_func;
  end
 end 
end

// DFT CK block starts
//======================================
always @(CKint_dft) 
begin
   lastCK_dft=CKreg_dft;
   CKreg_dft=CKint_dft;
   
   Latch_open=0;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
     if (CKreg_dft === 1'bX || (CKreg_dft === 1'b1 && lastCK_dft === 1'bx)) begin
       if (INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0 ) begin
        
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: DFT clock  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime); 
         Invalid_next_cycle_dft;
         if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
           WriteOutX;
         end
       end
     end 

     if(CKint_dft === 0 && lastCK_dft === 1) begin
      if(ATPreg === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
       if(SE_reg === 1'b1 && SEsys === 1'b0) begin
        if(TBYPASSint === 1'b1) begin   
            
    
    OutReg_data_scan = { scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],
scanreg_dr_wire[10],
scanreg_dr_wire[11],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9],
scanreg_dl_wire[10], scanreg_dl_wire[scanlen_l-1]}; 
 
         for (i = 0; i < Bits; i = i + 1)
         begin
          if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
         end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
        end 
       end
      end
     end 
     
     else if (CKreg_dft === 1'b1 && lastCK_dft === 1'b0 ) begin
       SE_reg = SEsys;
       TBYPASS_reg = TBYPASSsys;
       ATPreg = ATPint;
       INITNreg = INITNint;
       SLEEPreg = SLEEPint;
       STDBYreg = STDBYint;
       MEMEN_dft_prev = MEMEN_dft_reg;
       MEMEN_dft_reg = MEMEN_dft;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 
       if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ) begin 
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
 //     else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys === X && TBYPASSsys !== 1) begin
///           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
//           Invalid_next_cycle_dft;
//        end       
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys === X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
        end 
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys !== 0 && LP_CK_gate===X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: LP FLOP Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           ScanChainX;
           ScanOutX;   
          if( TBYPASSint !== 0 && SEint !== 1) begin
            WriteOutX;
          end
          next_cycle_corrupt_dft=0;
        end        
       else if (next_cycle_corrupt_dft === 1'b1) begin 
         next_cycle_corrupt_dft = X;
       end 
       else if (next_cycle_corrupt_dft === 1'bx) begin
         next_cycle_corrupt_dft = 0;
       end
       
       if (next_cycle_corrupt_dft === 0 ) begin
         
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1 && flag_mem_block === 1'b0) begin
           
           if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0  && LP_CK_gate===0) begin
              OutReg_data_tbypass = Dint;
              for (i = 0; i < Bits; i = i + 1)
              begin
               if (OutReg_data_tbypass[i] !== OutReg_data[i])
                 OutReg_data[i] = WordX[i];
              end//for (i = 0; i < */ 
              OutReg_data <= OutReg_data_tbypass;
           end
           
             scan_acquire;
         end //MEMEN_dft == 1        
       end // if ( next_cycle_corrupt_dft
       
     end // if (CKint_dft === 1'b1
      //  if (next_cycle_corrupt_dft === 0 ) begin 
       if (SE_reg !== 0) begin
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1  && flag_mem_block === 1'b0) begin
           next_cycle_corrupt_dft = 0;
           if ( next_cycle_corrupt_func === 1) begin
	    next_cycle_corrupt_func = 0 ;
	   end	
           scan_shift;
         end
       end
     //end // if ( next_cycle_corrupt_dft    
     if ((!(TBYPASSsys!==0 && SEsys!==1 && LP_CK_gate!==0 ) && next_cycle_corrupt_dft === 0) || CKint_dft !==1) begin          
       CK_sc=INITNreg & !STDBYreg & !SLEEPreg & ATPreg & CKreg_dft ;
     end     
   end // if (init_pulse_done 
 end // if (supply_ok 
end // always @(CKint_dft)

always @(MEMEN_dft)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) && CKint_dft === 1'bx)  begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.MEMEN_dft and clock should not be X at this time instant. ScanChains and ScanOuts Corrupted ",$realtime); 
    Invalid_next_cycle_dft;
    
    if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
      WriteOutX;
    end
  end
  if ( MEMEN_dft !== 0 && TBYPASSsys !== 0 && SEsys !== 1) begin
     WriteOutX;
     OutReg_data = WordX; 
     delOutReg_data=WordX;
 end 
end
end //always @(MEMEN_dft

always @(TBYPASSsys or ATPint)
begin
   if(supply_ok === 1'b1) begin 
    if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0 && INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1) begin
      if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
    end  
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint === X && SEsys !== 1) ) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end 
end //always @(TBYPASSint





always @(SEsys)
begin
 if(supply_ok === 1'b1) begin 
  if(CKint_dft === 0 && ATPint === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
    if(SE_reg === 1'b1 && SEsys === 1'b0) begin
      if(TBYPASSsys === 1'b1) begin
          
  
        OutReg_data_scan = { scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],
scanreg_dr_wire[10],
scanreg_dr_wire[11],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9],
scanreg_dl_wire[10], scanreg_dl_wire[scanlen_l-1]};  


        for (i = 0; i < Bits; i = i + 1)
        begin
         if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
        end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
      end
    end
  end
  if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0) begin
      if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
  end 
  else if ((TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint === X && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end   
end

//assign output data
`ifdef functional        

   
always @(SDLOint)
#0.001 delSDLO_data<=SDLOint;

always @(SDROint)
#0.001 delSDRO_data<=SDROint;

 
always @(SCTRLOint)
#0.001 delSCTRLO_data<=SCTRLOint;


always @(OutReg_data)
   #0.001 delOutReg_data = OutReg_data;
`else
`endif

/***************************** Embeded switch functionality starts here ***********************************/





always @(STDBYint)
begin
  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0 && STDBYint !== 1'b0)
    begin
      ScanOutX;
      ScanChainX;
     delScanOutX;     
    end
  end
end



always @(SLEEPint)
begin


  if (SLEEPint !== 1'b1) begin
    time_fall_sleep = $realtime;
  end

  if (power_up_done === 0)
    begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
    end
  else begin
    if (SLEEPint === 1'b1 && lastSLEEP === 1'b0 ) begin 
      
    end
    else if (SLEEPint !== 1'b1 && lastSLEEP === 1'b1 && full_shutdown !== 1) begin 
      
      if (supply_ok !== 1 && ($realtime > 0)) begin
         if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID LOW_POWER) ERROR: ISOLATION signal removed from the memory but array and periphery supply is not completely switched on.Very High Current would be drawn by the memory. All further operations on memory are blocked",$realtime);
          WriteMemX;
          WriteOutX;
          ScanChainX;
          OutReg_data = WordX; 
          delOutReg_data=WordX;
          ScanOutX;//immediately;
          delScanOutX;//immediately;
          init_pulse_done = 0;
          power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            debug_level = 2'b11;
          `endif
          
      end        
      
       
    end   
    else if (SLEEPint === X && lastSLEEP === 1'b0 && full_shutdown !== 1'b1) begin 
     
    end 
  end  


  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && SLEEPint !== 0)
    begin
      ScanOutX;
      ScanChainX;
        delScanOutX;      
    end
  end

// if (init_pulse_done === 0)
//   begin
//     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
//   end
//
// else if ( SLEEPint !== 1 && (supply_ok !==1) ) begin
//    
//    WriteOutX;
//    OutReg_data = WordX; 
//    delOutReg_data=WordX;
//    ScanOutX;//immediately;
//    delScanOutX;//immediately;
//    ScanChainX;
//    WriteMemX;
//    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies with sleep/Power down signal being low.This scenario can lead to high dc currents and some reliability issues Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
// end

 print_sleep;    
 lastSLEEP=SLEEPint;
end

/********************************** Embeded switch functionality ends here *******************************/

task print_sleep;
begin
  if (SLEEPint === 1'b0) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been deasserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end  
  else if (SLEEPint === 1'b1) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been asserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_ACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif

  end        
  else begin
      if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) ERROR: SLEEP pin is at an invalid state.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INVALID in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end        
end
endtask





 

//// C28SOI non flip compiler power functionality 
always @(gndmreg )
begin
 if (power_up_done === 1 && $realtime > 0) begin    
    if(gndmreg !== 1'b0 ) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or gndsm is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
        corrupt_all;
        init_pulse_done = 0;
        power_up_done = 0;
     `ifdef NO_BLOCK_MEM
     `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of ground pins.Ground must be maintained at 0 Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime);
        debug_level = 2'b11;
     `endif   

    end   
 end

end




always @(vddmareg )
begin

if (vddmareg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddma(Array Supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 
    end
   end   
   else if (SLEEPint === 1) begin
    WriteMemX;
   end

end

if ((vddmareg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1 ) && $realtime > 0) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddm or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         corrupt_all;
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif

end


end

always @(vddmpreg )
begin
 if (vddmpreg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or vddsmp is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmp(Periphery Supply)/vddsmp(Substrate power supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 

    end
   end   
   else if (SLEEPint === 1) begin
    WriteOutX;
    ScanChainX;
    ScanOutX;
    delScanOutX;//immediately;
    OutReg_data = WordX; 
    delOutReg_data=WordX;
   end
 end

if( (vddmpreg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1'b1 )  && $realtime > 0) begin
         corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif
end
 
 
end


always @(vddmoreg)
begin
  if (power_up_done === 1 && $realtime > 0) begin   
      if (vddmoreg !== 1'b1)  begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin
           corrupt_all;
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
         end //if (vddmareg === 1'b1 

      else if (vddmareg === 1'b0 && vddmpreg === 1'b0   && SLEEPint === 1'b1 &&  $realtime > 0)
        begin 
            if((debug_level < 2) && ($realtime > 0)) $display("%m - %t WARNING: Illegal Value on power pin(s). Memory and Output Corrupted ", $realtime);
 
           corrupt_all;
        end //else if (vddmareg === 1'b 
     end   // if (vddmoreg !== 1'b1)
     else if (vddmoreg === 1'b1 && $realtime > 0 ) begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin     
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           corrupt_all;
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
        end        
     end // else if (vddmoreg === 1'b1
  end 
end // always @(vddmoreg)












always @(gndmreg) begin
 if (gndmreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 0. ",$realtime);
 end
 else if (gndmreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 1. ",$realtime);
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to invalid state. ",$realtime);
 end
end




 
always @(vddmareg) begin
 if (vddmareg === 0) begin 
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 0. ",$realtime);
  vddma_fall_time = $realtime;
 end
 else if (vddmareg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 1. ",$realtime);
  vddma_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to invalid state. ",$realtime);
  vddma_fall_time = $realtime;
 end 

 

end

always @(vddmpreg) begin
 if (vddmpreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 0. ",$realtime);
  vddmp_fall_time = $realtime;
 end
 else if (vddmpreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 1. ",$realtime);
  vddmp_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to invalid state. ",$realtime);
  vddmp_fall_time = $realtime;
 end

 
 
end



// end of C28SOI power functionality 
 


assign supply_ok          =  (vddmareg === 1'b1 && vddmpreg  === 1'b1  && gndmreg === 1'b0 && vddmoreg === 1'b1 ) ? 1'b1 : 1'b0;
assign core_supply_ok     =  (vddmoreg === 1'b1 && vddmareg === 1'b1 && gndmreg === 1'b0 ) ? 1'b1 : 1'b0;
assign peri_supply_ok     =  (vddmoreg === 1'b1 && vddmpreg === 1'b1 && gndmreg === 1'b0  ) ? 1'b1 : 1'b0;

assign full_shutdown = (vddmpreg === 1'b0 && vddmareg === 1'b0   ) ? 1'b1 : 1'b0 ;




`ifdef functional
`else


task WriteLocMskX_bwise;
   input [Addr-1 : 0] Address;
   input [Bits-1 : 0] Mask;

reg [Bits+Red_extrabit:0] tempReg1;
integer num1; 
begin
   tempReg1 = WordX;
   if (^Address !== X )
   begin
      tempReg1 = Mem[Address];
             
      for (j = 0;j< Bits; j=j+1) begin
         num1=j;
        if (Mask[j] === 1'bx)
            tempReg1[num1] = 1'bx;
      end
      Mem[Address] = tempReg1;
      task_insert_faults_in_memory;
   end//if (^Address !== X
   else begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      WriteMemX;
   end   
end
endtask


/****************Actions taken on timing violations*****************/

 always @(TimingViol_data)
// tds or tdh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  for (l = 0; l < Bits; l = l + 1) begin   
    if (CSWEMTBYPASS[l] !== 0) begin
     if((TimingViol_data[l] !== TimingViol_data_last[l])) begin


         Mreg[l] = 1'bx;
     end    
     WriteLocMskX_bwise(Areg,Mreg);
    end   
   end 
  end
    if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin
     scanreg_dl =1'bx; 
     scanreg_dr =1'bx; 
     SDLOint=X;
     SDROint=X;
     `ifdef functional
     `else
     SDLO_data<=1'bx;
     SDRO_data<=1'bx;
     `endif
    end
     TimingViol_data_last = TimingViol_data; 
end





always @(TimingViol_addr)
// tas or tah
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
      scanreg_ctrl=1'bx; 
      SCTRLOint=X;
      `ifdef functional
      `else
      SCTRLO_data<=1'bx;
      `endif
  end
end


always @(TimingViol_WEN)
//tws or twh
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WEN pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end 

always @(TimingViol_CSN )
// tps or tph 
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;

   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CSN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end

always @(TimingViol_tcycle )
//tcycle
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
   if (MEMEN !== 0 && MEMEN_prev !== 0) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckl )
// tckl 
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckh) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end


always @(TimingViol_tcycle_se )
//tcycle_se
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckl_se  )
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckh_se) begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tbist) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
   end
   if (TBYPASSint !== 1'b0) begin 
    WriteOutX;
   end 
   if (INITNreg !==0 && STDBYreg !== 1 && TBYPASS_reg !== 1 && SLEEPreg !== 1 && SE_reg !== 1 && IGreg !== 1 && DEreg !== 1) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBIST pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end






always @(TimingViol_tbypass)
//ttmck
begin
#0  
  WriteOutX;
  if (INITNreg !== 0 && SLEEPreg !== 1 && SE_reg !== 1 && STDBYreg !== 1 &&  DEreg !== 1) begin
   Invalid_next_cycle_dft_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
end



always @(TimingViol_sleep)
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_stdby)
begin
#0
  if (CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin 
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (ATPreg !== 0) begin 
   Invalid_next_cycle_dft_tim;
  end
end






always @(TimingViol_se) begin
#0
   if (TBYPASS_reg !== 0) begin 
    WriteOutX;
   end 
  if (TBYPASS_reg === 0) begin
     WriteOutX;
     WriteMemX;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE timing violation  Memory State Machine is corrupted. Output Corrupted ",$realtime); 
  end 
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
  end
end

always @(TimingViol_sctrli) begin
  scanreg_ctrl=1'bx; 
end


always @(TimingViol_sdli) begin
 scanreg_dl=1'bx; 
end

always @(TimingViol_sdri) begin
   scanreg_dr=1'bx;
end

 

always @(TimingViol_initnl) begin
init_pulse_done=0;
WriteOutX;
OutReg_data = WordX; 
delOutReg_data=WordX;
ScanOutX;
delScanOutX;
ScanChainX;
WriteMemX;
end

always @(TimingViol_initn) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end

always @(TimingViol_ig) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && INITNreg !== 0 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: IG pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   ScanChainX;
   ScanOutX;
   delScanOutX;       
  end
end

always @(TimingViol_atp) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin  
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_rm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^WMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: RM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
   end
end
 
always @(TimingViol_wm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^RMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);        
   end
end 


`endif


endmodule




module ST_SPREG_LOLEAK_64x23m2_Tl_lock_up_latch (EN,D,Q);
input EN,D;
output reg Q;

  always @ (EN or D) begin
    if (EN === 1) begin
       Q = D;
    end
    else if ((EN === 1'bz || EN === 1'bx  )&& D !== Q) begin
        Q=1'bx;
    end    
  end
endmodule

module ST_SPREG_LOLEAK_64x23m2_Tl_SCFF (D,TI,TE,CP,Q,OUTX);
input D,TI,TE,CP;
input OUTX;
output reg Q;
wire Dint;
assign Dint= (TE===1)?TI:(TE===0)?D:1'bx;

always @(posedge CP)
        begin
          if(Dint === 1'bZ || CP ===1'bx || OUTX === 1'bx)
          begin
                  Q = 1'bx;
          end
          else
          begin
                  Q = Dint;
          end        
        end
always @(posedge OUTX)
Q = 1'bx;
endmodule



`undef setup_time
`undef hold_time
`undef access_time
`undef retain_time
`undef cycle_time
`undef pulse_width_time
`undef initin_low_pulse


`delay_mode_path
`endcelldefine
`nosuppress_faults






/****************************************************************
--  Description         : Verilog Model 
--  ModelVersion        : 1.2
--  Date                : Apr, 2013
--  Changes Made by	: PS
--  Revision History    : 
 
****************************************************************/


/******************** START OF HEADER****************************
   This Header Gives Information about the parameters & options present in the Model
   
   words = 256
   bits  = 21
   mux   = 2 
   
   
   
   write_mask = no 
   
   margin_control = yes 
   
   
   Dft = Yes  

    ------------------------------------------------------------------------------------
     Signal Name             | Description       |             Port Mode        | Active When
                             |                   |          r    |  w   | rw    |
   ------------------------------------------------------------------------------------

    D 	        Data in                     na     x      na       -  
    IG    Input Gate Enable           x      x      na       High     
    ATP            ATPG Enable                 x      x      na       High     
    INITN                 INITN pin                   x      x      na       Low
    
    
     
    Q 	        Data out	            x      na     na       -
    A              Address                     x      x      na       high and low
    
    CK                Clock	                    x      x      na       posedge
    CSN          Chip Enable                 x      x      na       low
    
    RM         Read Margins                 x      x      na       High 
    SCTRLI         Scan Input (Control)
    SCTRLO        Scan Output (Control)
    SDLI         Scan Input (Data-Left)
    SDLO        Scan Output (Data-Left)
    SDRI         Scan Input (Data-Right)
    SDRO        Scan Output (Data-Right)
    SE          Scan Enable pin 
    STDBY              Standby pin                 x      x      na       High
    
    SLEEP                        Sleep pin                   x      x      na        High 
    
     
     
    TBIST          Bist Enable Pin 
    
    TBYPASS                      Memory Bypass                na     na     na        High
    
    TED        Bist Even Data pin
    TOD         Bist Odd Data Pin
     
    TA         Bist Read Address
    TCSN     Bist Read Chip Select
    
    TWEN    Bist Write Enable 
    WEN         Write Enable                na     x      na       Low 
    
    WM        Write Margins Code          x      x      na       -
     

******************** END OF HEADER ****************************/


//********************************************//
// ST_SPREG_LOLEAK_256x21m2_Tl Verilog Model                 //  
//********************************************//




`ifdef slm
        `define functional
`endif

`celldefine
`suppress_faults
  `ifdef functional
   `delay_mode_unit
  `else
   `delay_mode_path
  `endif

`define setup_time 0.0
`define hold_time 0.0
`define access_time 1.0
`define retain_time 0.9
`define cycle_time 0.0
`define pulse_width_time 0.0
`define initin_low_pulse 0.0



 






`timescale 1ns / 1ps


module ST_SPREG_LOLEAK_256x21m2_Tl (A,ATP,CK,CSN,D ,IG,INITN , Q ,RM    ,SCTRLI,SCTRLO,SDLI,SDLO,SDRI,SDRO,SE,SLEEP   , STDBY  ,TA,TBIST   ,TBYPASS ,TCSN,TED ,TOD   ,TWEN ,WEN,WM  );

 parameter
  Words = 256,
  Bits = 21,
  Addr = 8,
  mux = 2,
  repair_address_width = 7,
  write_margin_size = 2, 
  read_margin_size = 3; 

 //  INPUT OUTPUT PORTS DECLARATION DONE SEPARATELY FOR SPREG and ROM
 // ========================


        output [Bits-1 : 0] Q;
         
        output SCTRLO;
        input SE,SCTRLI;
        
        input [Addr-1 : 0] A;
        
        input [read_margin_size-1 : 0] RM;
        
         
        input CK,CSN,INITN,IG,ATP; 
        
        
        input [Addr-1 :0 ] TA;
input TBIST,TCSN ;
        
        input STDBY;
        
        input SLEEP; 
        
         
        
        
         
        output SDLO;
        output SDRO;
        
        
        
        
        input [Bits-1 : 0] D ;
	
          
         
        
        input [write_margin_size-1 : 0] WM;
        
        
        input TBYPASS;
        
        input WEN;
        
        
         
        input SDLI,SDRI  ; 
        
        
        
        //Bist inputs
        // ===========
        input TWEN,TED,TOD; 
        
        
        
        

        






    parameter
        Fault_file_name = "ST_SPREG_LOLEAK_256x21m2_Tl_faults.txt",
        `ifdef ConfigFault
        ConfigFault = 1,
        `else
        ConfigFault = 0,
        `endif
        max_faults = 258,
        
        MEM_INITIALIZE  = 1'b0,
        BinaryInit = 1'b0, 
        InitFileName = "ST_SPREG_LOLEAK_256x21m2_Tl.cde",
        Debug_mode = "all_warning_mode",
        File_load_time=0,
        Initn_reset_value={21{1'b0}},
        InstancePath = "ST_SPREG_LOLEAK_256x21m2_Tl";
    
    parameter
        
        bank = 1, 
        mux_bits=1,
        Red_extrabit=0,
        bank_bits = 0,
        RedWords = mux * 2 * bank,
        max_address_bits = 15 ,
        Rows = Words/mux;

  
    parameter 

     

        
           scanchains=3,    
          
        
        scanlen_ctrl=15,
        
        

      

        
        
        scanlen_r=(2*((Bits+1)/4)),
        
        scanlen_l=((Bits+1)-(2*((Bits+1)/4)))   ; 
      
      

    parameter
        
        `ifdef functional  
            RW_assertions_en = 0,
        `endif
        WordX = {Bits{1'bx}},
        AddrX = {Addr{1'bx}},
        Word0 = {Bits{1'b0}},
        X = 1'bx;
   



//  WIRE DECLARATION RELATED TO POWER PINS
//  ======================================
	
        wire supply_ok, full_shutdown;
        
        wire core_supply_ok;
        wire peri_supply_ok;

        wire gndmint, gndsmint;
         
        
        wire vddmpint;
        wire vddmoint;
        wire vddmaint;
        wire vddsmpint;  
        wire vddsmaint;  
        
        

//  WIRE DECLARATION 
//  ==================
        wire [Bits-1 : 0] CSWEMTBYPASS;
        wire [Bits-1 : 0] Dint, Dsys;
        wire [Bits-1 : 0] Mint; 
        wire [21-1:0] Msys;
	wire [Addr-1 : 0] Aint;
        wire [Addr-1 : 0] Asys;

       


        wire [max_address_bits-1 : 0] A_int; 
                
	wire CKint_dft;
	wire CKint_func;
	wire CSNint;
        wire MEMEN;
        wire MEMEN_dft;
        wire TSE;

	wire WENint;
	wire WENsys;
        wire SLEEPint;
        wire STDBYint;
        wire SEint;
        wire SEsys;
        wire SCTRLIint;
        wire SDLIint;
        wire SDRIint;
        
        wire INITNint;
        wire TBYPASSint;
        wire TBYPASSsys;
        wire LSint; 
        wire HSint; 
        wire ATPint;
        wire DEint;
        
        wire [Addr-1 : 0] TAint;
        wire TBISTint;
        wire TBISTsys;
        wire TCSNint;
        wire TEDint;
        wire TODint;
        wire TEMint;
        wire TOMint;
        wire [Bits-1 : 0] TMint;
        wire [Bits-1 : 0] TDint;
        wire TWENint;
        wire IGint;
        wire IGbuf;
        wire CSNbuf;
        wire WENbuf;
        wire [read_margin_size-1:0] RMint;
        wire [write_margin_size-1:0] WMint;

        //Wires for scan chains
        //  ====================     
        wire [scanlen_ctrl -1:0]scanreg_ctrl_wire;
        wire [scanlen_l -1:0]  scanreg_dl_wire; 
        wire [scanlen_r -1:0]  scanreg_dr_wire; 
   
        wire [scanlen_l -1:0]  scanreg_ml_wire; 
        wire [scanlen_r -1:0]  scanreg_mr_wire; 


        wire [repair_address_width -1 : 0] RRAint;
        wire RRAEint;
        wire TRRAEint;    
        wire red_en;
        wire [repair_address_width -1 : 0] repair_add, next_repair_add;


//  REG DECLARATION
//  ====================     
        reg MEMEN_reg;
        reg MEMEN_prev;
        reg reg_mem_block;
        reg flag_mem_block;
        reg SCTRLIint_temp;
        reg SDLIint_temp;
        reg SDRIint_temp;
        reg SMLIint_temp;
        reg SMRIint_temp;

        //  REG DECLARATION
        //  ====================
        reg SCTRLOint;
        
        reg SDLOint,SDROint;
         
        
        reg next_cycle_corrupt_func;
        reg next_cycle_corrupt_dft;
        reg [Bits-1 : 0] delOutReg_data;//delayed Output Register
        reg [Bits-1 : 0] OutReg_data;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_tbypass;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_scan;   // Data Output registe
        reg [Bits-1 : 0] OutReg_rado_retained;   // register for retaining rado data when SLEEP --> 1
        reg delSCTRLO_data,SCTRLO_data;      // delayed Output Register
        reg delSDLO_data,SDLO_data;      // delayed Output Register
        reg delSDRO_data,SDRO_data;      // delayed Output Register
        
        
        // SCAN CHAINS register
        reg scanreg_ctrl; 
        reg scanreg_dl; 
        reg scanreg_dr; 
        
        
        reg CK_sc;
        reg Latch_open=0;
        reg lastCK_dft,CKreg_dft;
        reg lastCK_func,CKreg_func;
        reg lastSLEEP;
        reg lastPSWLARGEMP,lastPSWLARGEMA,lastPSWSMALLMP,lastPSWSMALLMA;
        reg CSNreg;
        reg init_pulse_done; //if == 1 then it implies that initb low pulse has been applied
        reg power_up_done; //if == 1 then it implies that power up has been done
        `ifdef slm
        `else
	      
             reg [Bits-1 : 0] Mem [Words-1 : 0];
             reg [Bits-1 : 0] RedMem [RedWords-1 : 0];
 
        `endif
        
	reg [Bits-1 :0] Mem_temp;
        reg [Bits-1 :0] Mem_slm; 
	reg ValidAddress;
	reg ValidDebugCode;
        reg decoding_start;
        reg file_loaded;
        reg [Bits-1 :0] Dreg;
        reg [Bits-1 :0] Mreg;
        reg WENreg;
        reg [Addr-1 :0] Areg;
        reg SE_reg;
        reg TBYPASS_reg;
        reg INITNreg;
        reg IGreg;
        reg DEreg;
        reg SLEEPreg;
        reg STDBYreg;
        reg ATPreg;
        reg MEMEN_dft_reg;
        reg MEMEN_dft_prev;
        reg RRMATCHreg;
        reg RRMATCHreg_last;//changes_made
        reg RRMATCHreg_glitch;
        reg [repair_address_width -1 : 0] repair_add_last;
        reg RRAEint_last;
        reg [Addr-mux_bits-1:0] row_add_temp;
        reg [Addr-mux_bits-bank_bits-1:0] row_add_cmp_temp;

       
        //parameter registers
        reg [2047:0] reg_Fault_file_name;
        reg reg_ConfigFault;
        reg reg_MEM_INITIALIZE;
        reg reg_BinaryInit;
        reg [2047:0] reg_InitFileName;
        reg [Bits -1 :0] reg_Initn_reset_value;
        time reg_File_load_time;

        //Power Supply Registers        
        reg vddmireg;
        reg vddmreg;
        reg vddsmreg;
        reg gndmreg;
        reg gndsmreg;   
        reg vddmpreg;
        reg vddmpireg;
        reg vddmareg;
        reg vddsmpreg;
        reg vddsmareg;
        reg vddmoreg;
        time vddmp_rise_time;
        time vddmp_fall_time;
        time vddsmp_rise_time;
        time vddsmp_fall_time;
        time vddma_rise_time;
        time vddma_fall_time;
        time vddsma_rise_time;
        time vddsma_fall_time;
        reg reg_check_rise;
        reg reg_check_fall;
        reg reg_check_rise_vddma;
        reg reg_check_fall_vddsma;
        reg  reg_check_rise_vddm, reg_check_fall_vddsm ;
        time vddm_fall_time,  vddm_rise_time,  vddsm_fall_time, vddsm_rise_time ;
  /* This register is used to force all warning messages 
  ** OFF during run time.
  ** It is a 2 bit register.
  ** USAGE :
  ** debug_level_off = 2'b00 -> ALL MESSAGES(INFO/WARNINGS/ERRORS) will be DISPLAYED 
  ** debug_level = 2'b01     -> ONLY WARNINGS/ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b10     -> ONLY ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b11     -> NO MESSAGES will be DISPLAYED.
  */ 
        reg [1:0] debug_level;
        reg [8*10: 0] operating_mode;
        reg [8*44: 0] message_status;

        integer i, k, j, l,m,q,w,r,s,num1,redcnt,n,num2,FirstHalf,Bfaileff,memcnt,ptr;
        integer decoder[Bits-1:0];
        `ifdef slm
           integer MemAddr;
        `endif


        //************************************************************
        //****** CONFIG FAULT IMPLEMENTATION VARIABLES*************** 
        //************************************************************ 

        integer file_ptr, ret_val;
        integer fault_word;
        integer fault_bit;
        integer fcnt, Fault_in_memory,faultnum,stop_loop,count;
        integer t;  
        integer FailureLocn [max_faults -1 :0];
        integer Failurebit [max_faults -1 :0];
        reg [100 : 0] stuck_at;
        reg [100 : 0] fault_array;
        reg [200 : 0] tempStr;
        reg [7:0] fault_char;
        reg [7:0] fault_char1; // 8 Bit File Pointer
        reg [Addr -1 : 0] std_fault_word;
        reg [Addr -1 : mux_bits] fault_row_add [max_faults -1 :0];
        reg [max_faults -1 :0] fault_repair_flag;
        reg [max_faults -1 :0] dont_insert_fault;
        reg [max_faults -1 :0] repair_flag;
        reg [100 : 0] array_stuck_at[max_faults -1 : 0] ;
        reg [100 : 0] mem_red_array_stuck_at[max_faults -1 : 0] ; 
        reg msgcnt;
        
       
        reg [Bits - 1: 0] stuck_at_0fault [max_faults -1 : 0];
        reg [Bits - 1: 0] stuck_at_1fault [max_faults -1 : 0];
        reg [Bits -1 : 0] stuck0;
        reg [Bits -1 : 0] stuck1;

        reg [Bits+Red_extrabit :0] Mem_last;
        

        `ifdef slm
        reg [Bits -1 : 0] slm_temp_data;
        `endif
        
        real time_CK_func_rise , time_RADCK_rise;
        real time_fall_sleep,time_fall_PSWLARGEMP,time_fall_PSWLARGEMP_0,time_fall_PSWLARGEMA,time_fall_PSWLARGEMA_0,time_fall_PSWSMALLMP,time_fall_PSWSMALLMA;
        integer flag_error;
        
//BUFFER INSTANTIATION
//=========================
       `ifdef functional
       
         buf (SCTRLO,delSCTRLO_data); 
         buf bufq [Bits-1:0] (Q,delOutReg_data);
      `else
       
         buf (SCTRLO,SCTRLO_data);
         buf bufq [Bits-1:0] (Q,OutReg_data);
      `endif
      
  
        buf (SEsys,SE);
	buf (SCTRLIint, SCTRLI);
   

	buf (CKint_func, CK);
	buf (CKint_dft, CK);
        buf bufaddr [Addr-1:0] (Asys,A);
        buf (INITNint,INITN);
        
        buf (LSint,1'b0); 
        buf (IGbuf,IG);
        buf (ATPint,ATP);

        buf bufTaddr [Addr-1 : 0] (TAint,TA);
        buf (TBISTsys,TBIST);
        buf (TCSNint,TCSN);

        buf (CSNsys,CSN);
        buf (STDBYint,STDBY );   
        
        buf (SLEEPint,SLEEP ); 

        buf bufrm [read_margin_size-1:0] (RMint, RM); 

        
        

        assign RRAEint = 1'b0;
        assign TRRAEint = 1'b0;
        assign repair_add = 0;
        assign next_repair_add = 0;
        assign red_en = 1'b0; 
        
        
        
        
        
        
        
        buf (PSWLARGEMPint,1'b0);
        buf (PSWSMALLMPint,1'b0); 
        buf (PSWLARGEMAint,1'b0);
        buf (PSWSMALLMAint,1'b0);   

      `ifdef functional
       
       
         buf (SDLO,delSDLO_data);
         buf (SDRO,delSDRO_data);
        
      `else
       
         buf (SDLO,SDLO_data);
         buf (SDRO,SDRO_data);
         
      `endif
       
         
       
        buf bufdata [Bits-1:0] (Dsys,D);
        
        
        assign Msys=21'b0; 
	

        
        buf (TBYPASSsys, TBYPASS);
        


        buf (WENsys,WEN);
	 
	buf (SDLIint, SDLI);
	buf (SDRIint, SDRI);
	 
        
        buf (HSint,1'b0); 

        
        buf (TEDint,TED);
        buf (TODint,TOD);
         
        buf (TWENint,TWEN);
        
        
        buf bufwm [write_margin_size-1:0] (WMint, WM); 
        



//      assign scanreg_ctrl_wire={scanreg_ctrl[scanlen_ctrl - 2:0],SCTRLIint};
//      assign scanreg_dl_wire={scanreg_dl[scanlen_l - 2:0],SDLIint};
//      assign scanreg_dr_wire={scanreg_dr[scanlen_r - 2:0],SDRIint};
      
        
      assign Aint   = (TBISTint === 1'b0 ) ? Asys : (TBISTint === 1'bx ) ? {Addr{1'bx}} : TAint;  

        
//        assign A_int = Aint;
	
        
                
        assign Dint[0] = (TBISTint === 1'b0) ? Dsys[0] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[1] = (TBISTint === 1'b0) ? Dsys[1] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[2] = (TBISTint === 1'b0) ? Dsys[2] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[3] = (TBISTint === 1'b0) ? Dsys[3] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[4] = (TBISTint === 1'b0) ? Dsys[4] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[5] = (TBISTint === 1'b0) ? Dsys[5] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[6] = (TBISTint === 1'b0) ? Dsys[6] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[7] = (TBISTint === 1'b0) ? Dsys[7] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[8] = (TBISTint === 1'b0) ? Dsys[8] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[9] = (TBISTint === 1'b0) ? Dsys[9] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[10] = (TBISTint === 1'b0) ? Dsys[10] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[11] = (TBISTint === 1'b0) ? Dsys[11] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[12] = (TBISTint === 1'b0) ? Dsys[12] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[13] = (TBISTint === 1'b0) ? Dsys[13] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[14] = (TBISTint === 1'b0) ? Dsys[14] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[15] = (TBISTint === 1'b0) ? Dsys[15] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[16] = (TBISTint === 1'b0) ? Dsys[16] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[17] = (TBISTint === 1'b0) ? Dsys[17] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[18] = (TBISTint === 1'b0) ? Dsys[18] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[19] = (TBISTint === 1'b0) ? Dsys[19] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[20] = (TBISTint === 1'b0) ? Dsys[20] : (TBISTint === 1'b1) ? TEDint : 1'bx;          
	 
        assign Mint = 21'b0;
         

        assign WENbuf = (TBISTint === 1'b0 ) ? WENsys : (TBISTint === 1'bx ) ? 1'bx : TWENint;  
        assign WENint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? WENbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[13] : (ATPint === 1'b0 ) ? WENsys : 1'bx ; 
        
        assign CSNbuf = (TBISTint === 1'b0 ) ? CSNsys : (TBISTint === 1'bx ) ? 1'bx : TCSNint;  
        assign CSNint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? CSNbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[11] : (ATPint === 1'b0 ) ? CSNsys : 1'bx ; 
        assign IGint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? IGbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[14] : (ATPint === 1'b0 ) ? IGbuf : 1'bx;

        
        assign DEint = (LSint === 1'bx || (LSint === 1'b0 && HSint === 1'bx) || ^RMint !== 1'b0 || ^WMint !== 1'b0 ) ? 1'bx : 1'b0;
        
     
     and (TBISTint, ATPint, TBISTsys);
     and (SEint, ATPint, SEsys);
     and (TBYPASSint, ATPint, TBYPASSsys);
     and (TSE,TBYPASSint,!SEsys);
     and (MEMEN,INITNint,!CSNint,!SLEEPint,!TBYPASSint,!SEint,!IGint,!DEint,!STDBYint );
     and (MEMEN_dft,INITNint, !SLEEPint, ATPint,!STDBYint);

 `ifdef functional
/*****************assertions added to optimize dynamic power consumption**********/

//psl a_M: assert always ({( RW_assertions_en);(MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1))  } |-> (stable(Msys))) @(posedge CK); 

//psl a_WEN: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(WENsys))) @(posedge CK); 

//psl a_A: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(Asys))) @(posedge CK); 

//psl a_D: assert always ({( RW_assertions_en);((MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1)) && TBYPASSint === 1'b0)  } |-> (stable(Dsys))) @(posedge CK); 

/**********************************************************************************************/
`endif       

     

         
reg vddmp,vddmo, vddma, vddsmp, vddsma, gndsm, gndm,  vddmpi ; 
 
initial 
begin

        vddmp = 1'b1 ; 
        vddmo = 1'b1 ;
        vddma = 1'b1 ;
        
        vddsmp = 1'b1 ;
        
        
         gndm = 1'b0 ;
          
end

        
         assign gndmint = (reg_mem_block === 0) ? gndm : 1'b1;
         
         
         
         
         assign vddmpint = vddmp;
         assign vddmoint = vddmo;
         assign vddmaint = vddma;
         
          
        
         

        //CPF Changes

        
                
        initial
        begin : cpfvddmp 
           vddmpreg = vddmpint;
        end

        always @(vddmpint) begin
           vddmpreg = vddmpint;
        end
        
        initial
        begin : cpfvddmo 
           vddmoreg = vddmoint;
        end

        always @(vddmoint) begin
           vddmoreg = vddmoint;
        end
        
        initial
        begin : cpfvddma 
           vddmareg = vddmaint;
        end

        always @(vddmaint) begin
           vddmareg = vddmaint;
        end

        
        
 
        initial
        begin : cpfgndm 
           gndmreg = gndmint;
        end

        always @(gndmint) begin
           gndmreg = gndmint;
        end

        
        



 `ifdef functional
  `else
  initial begin
    if (debug_level < 1) begin
     $display ("%m  INFORMATION");
     $display ("***************************************");
     $display ("The Model is Operating in TIMING MODE");
     $display ("Please make sure that SDF is properly annotated otherwise dummy values will be used");
     $display ("%s", message_status);
     $display ("***************************************");
    end
  end

//////////////////////////
 //REG DECLARATIONS
   //======================

   reg [Bits-1 : 0] TimingViol_data;
   reg  [Bits-1 : 0] TimingViol_mask;
   reg [Bits-1 : 0] TimingViol_data_last, TimingViol_mask_last;
	reg TimingViol_data_0;
	reg TimingViol_data_1;
	reg TimingViol_data_2;
	reg TimingViol_data_3;
	reg TimingViol_data_4;
	reg TimingViol_data_5;
	reg TimingViol_data_6;
	reg TimingViol_data_7;
	reg TimingViol_data_8;
	reg TimingViol_data_9;
	reg TimingViol_data_10;
	reg TimingViol_data_11;
	reg TimingViol_data_12;
	reg TimingViol_data_13;
	reg TimingViol_data_14;
	reg TimingViol_data_15;
	reg TimingViol_data_16;
	reg TimingViol_data_17;
	reg TimingViol_data_18;
	reg TimingViol_data_19;
	reg TimingViol_data_20;
 reg TimingViol_mask_0;
 reg TimingViol_mask_1;
 reg TimingViol_mask_2;
 reg TimingViol_mask_3;
 reg TimingViol_mask_4;
 reg TimingViol_mask_5;
 reg TimingViol_mask_6;
 reg TimingViol_mask_7;
 reg TimingViol_mask_8;
 reg TimingViol_mask_9;
 reg TimingViol_mask_10;
 reg TimingViol_mask_11;
 reg TimingViol_mask_12;
 reg TimingViol_mask_13;
 reg TimingViol_mask_14;
 reg TimingViol_mask_15;
 reg TimingViol_mask_16;
 reg TimingViol_mask_17;
 reg TimingViol_mask_18;
 reg TimingViol_mask_19;
 reg TimingViol_mask_20;

   reg TimingViol_addr;
   reg TimingViol_CSN, TimingViol_WEN, TimingViol_tbypass;
   reg TimingViol_tckh, TimingViol_tckl, TimingViol_tcycle;
   reg TimingViol_tckh_se, TimingViol_tckl_se, TimingViol_tcycle_se;
   reg TimingViol_sctrli,TimingViol_sdli,TimingViol_sdri,TimingViol_se;
   reg TimingViol_smli,TimingViol_smri;
   reg TimingViol_sctrli_flag,TimingViol_sdli_flag,TimingViol_sdri_flag;
   reg TimingViol_smli_flag,TimingViol_smri_flag;
   reg TimingViol_initnl;
   reg TimingViol_initn;
   reg TimingViol_ls;
   reg TimingViol_hs;
   reg TimingViol_sleep;
   reg TimingViol_stdby;
   reg TimingViol_rm;
   reg TimingViol_wm;
   reg TimingViol_tbist,TimingViol_ig,TimingViol_atp,TimingViol_TED,TimingViol_TOD,TimingViol_TEM,TimingViol_TOM;
   reg TimingViolRRAE,TimingViolRRA;

   wire CSTBYPASSN,cond_sdf_tas,cond_sdf_tds,cond_sdf_tms,cond_sdf_tws,cond_sdf_tbas,cond_sdf_tbps,cond_sdf_tbws,cond_sdf_tbdes,cond_sdf_tbdos,cond_sdf_tbmes,cond_sdf_tbmos;
   wire SETB_EN,CSIG_EN,MEM_ACT,EN_ADM,CS_EN,CS_ADM,cond_sdf_tps,IG_EN,IG_ADM,cond_sdf_tigs,cond_sdf_taa,cond_sdf_taa_ls1,cond_sdf_taa_hs1,cond_tseq_tm;
   wire cond_sdf_tcycle,cond_sdf_tcycle_ls1,cond_sdf_tcycle_hs1,cond_sdf_tcycle_se,cond_sdf_tckl_se,cond_sdf_tsctrlis,cond_sdf_tsdlis,cond_sdf_tsdris,cond_sdf_tsmlis,cond_sdf_tsmris;
   wire cond_sdf_tckh_se,cond_sdf_taa_sctrlo_se,cond_sdf_taa_sdlo_se,cond_sdf_taa_sdro_se,cond_sdf_taa_smlo_se,cond_sdf_taa_smro_se,cond_sdf_tckl,cond_sdf_tckh;
   wire cond_sdf_ttms,cond_sdf_tbists,INITNandnotSLEEPandATPandnotSE,cond_sdf_taa_sctrlo,cond_sdf_taa_sdlo,cond_sdf_taa_sdro,cond_sdf_taa_smlo,cond_sdf_taa_smro;
   wire cond_sdf_taa_tm,cond_sdf_taa_tm_ls1, cond_sdf_taa_tm_hs1,cond_sdf_taa_tckq_tm,cond_sdf_taa_tseq_tm;

   wire CSWETBYPASSN;
   wire cond_sdf_tstdbys,cond_sdf_tsls,sleep_en,atp_csn_en;
   wire cond_sdf_tlss,cond_sdf_thss,cond_sdf_trms,cond_sdf_twms; 
   wire cond_sdf_tses,cond_sdf_tinitns;
   wire tby_se_en;
   wire rra_en;
   wire tbist_atp_en;
   wire rrae_en;
   wire tbist_rrae_en;
   wire cond_sdf_trraes;
   wire cond_sdf_ttrraes;
   wire cond_sdf_taa_trramatch;
   wire cond_sdf_ttrraematch;
   wire cond_sdf_tamatch;
   wire cond_sdf_ttamatch;
   wire cond_sdf_tatpmatch;
   wire cond_sdf_ttbistmatch;



 and (CSWEMTBYPASS[0], !Mreg[0], CSWETBYPASSN);
 and (CSWEMTBYPASS[1], !Mreg[1], CSWETBYPASSN);
 and (CSWEMTBYPASS[2], !Mreg[2], CSWETBYPASSN);
 and (CSWEMTBYPASS[3], !Mreg[3], CSWETBYPASSN);
 and (CSWEMTBYPASS[4], !Mreg[4], CSWETBYPASSN);
 and (CSWEMTBYPASS[5], !Mreg[5], CSWETBYPASSN);
 and (CSWEMTBYPASS[6], !Mreg[6], CSWETBYPASSN);
 and (CSWEMTBYPASS[7], !Mreg[7], CSWETBYPASSN);
 and (CSWEMTBYPASS[8], !Mreg[8], CSWETBYPASSN);
 and (CSWEMTBYPASS[9], !Mreg[9], CSWETBYPASSN);
 and (CSWEMTBYPASS[10], !Mreg[10], CSWETBYPASSN);
 and (CSWEMTBYPASS[11], !Mreg[11], CSWETBYPASSN);
 and (CSWEMTBYPASS[12], !Mreg[12], CSWETBYPASSN);
 and (CSWEMTBYPASS[13], !Mreg[13], CSWETBYPASSN);
 and (CSWEMTBYPASS[14], !Mreg[14], CSWETBYPASSN);
 and (CSWEMTBYPASS[15], !Mreg[15], CSWETBYPASSN);
 and (CSWEMTBYPASS[16], !Mreg[16], CSWETBYPASSN);
 and (CSWEMTBYPASS[17], !Mreg[17], CSWETBYPASSN);
 and (CSWEMTBYPASS[18], !Mreg[18], CSWETBYPASSN);
 and (CSWEMTBYPASS[19], !Mreg[19], CSWETBYPASSN);
 and (CSWEMTBYPASS[20], !Mreg[20], CSWETBYPASSN);

and (atp_csn_en,!ATPint,!CSNint,!IGint);
or (sleep_en,atp_csn_en,ATPint);
or (SETB_EN,SEint,TBISTint);
and (ATP_SETB_EN,ATPint,SETB_EN); 
or (CSIG_EN,IGint,CSNint);
and (MEM_ACT,!ATPint,CSIG_EN);
or (EN_ADM,MEM_ACT,ATP_SETB_EN);
and (CS_EN,!ATPint,IGint);
or (CS_ADM,CS_EN,ATP_SETB_EN);
and (atp_ig_csn_en,!ATPint,!CSNint,!IGint);
and (atp_se_en,!SEsys,ATPint);
or (cycle_en,atp_ig_csn_en,atp_se_en);
and (atp_ig_csn_en_reg,!ATPreg,!CSNreg,!IGreg);
and (atp_se_en_reg,!SE_reg,ATPreg);
or (cycle_en_reg,atp_ig_csn_en,atp_se_en);
and (INITNandnotSLEEPandATPandnotSE,cond_gac,!SEsys,ATPint);
and (csn_ig_en,!IGint,!CSNint);
and (atp_tby_ls_en,atp_se_en,cond_ls_tby_en);
and (IG_EN,!ATPint,!CSNint);
or (IG_ADM,IG_EN,atp_se_en);
and (CSWETBYPASSN, !WENreg, 1'b1);



assign cond_sdf_tsls=((sleep_en && INITNint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tstdbys=((sleep_en && INITNint && !SLEEPint) !==0) ? 1:0;
assign cond_sdf_atps=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_gac=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tas=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tds=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tms=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tws=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tps=((cond_gac && !CS_ADM) !==0) ? 1:0;
assign cond_sdf_tcycle=((cond_gac && cycle_en && !LSint && !HSint) !==0) ? 1:0;  
assign cond_sdf_tcycle_ls1=((cond_gac && cycle_en && LSint) !==0) ? 1:0;
assign cond_sdf_tcycle_hs1=((cond_gac && cycle_en && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_tckh=((cond_gac && cycle_en_reg) !==0) ? 1:0;
assign cond_sdf_tckl=((cond_gac && cycle_en) !==0) ? 1:0;
assign cond_sdf_tcycle_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckl_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsctrlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckh_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_ttms=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_tbists=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_tckq_tm=((cond_gac && SE_reg && ATPreg && TBYPASSsys) !==0) ? 1:0;
assign cond_ls_en=((atp_ig_csn_en || atp_tby_ls_en) !==0) ? 1:0;
assign cond_sdf_tlss=((cond_ls_en && cond_gac) !==0) ? 1:0;
assign cond_sdf_thss=((cond_ls_en && cond_gac && !LSint) !==0) ? 1:0;
assign cond_sdf_trms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_twms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_tses=((cond_gac && ATPint) !==0) ? 1:0;
assign cond_sdf_tbas=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbps=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbws=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tigs=((cond_gac && IG_ADM) !==0) ? 1:0;
assign cond_sdf_taa=((MEMEN_reg && WENreg && !LSint && !HSint) !==0) ? 1:0; 
// assign cond_sdf_taa_tbypass_q = ((MEMEN_reg && ATPint && TBYPASSint) !== 1'b0) ? 1'b1 : 1'b0;
assign cond_sdf_taa_ls1=((MEMEN_reg && WENreg && LSint) !==0) ? 1:0; 
assign cond_sdf_taa_hs1=((MEMEN_reg && WENreg && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && !HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_ls1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && LSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_hs1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tseq_tm=((cond_gac && TBYPASSint) !==0) ? 1:0;
assign cond_sdf_tinitns =(( sleep_en && !STDBYint && !SLEEPint) !==0) ? 1:0;
assign cond_ls_tby_en=((TBYPASSsys || csn_ig_en) !==0) ? 1:0;



//specify block begins

specify
    specparam
    
         PATHPULSE$CK$Q = 0,
         PATHPULSE$CK$SCTRLO = 0,

         PATHPULSE$CK$SDLO = 0,
         PATHPULSE$CK$SDRO = 0,
        
         PATHPULSE$SE$Q = 0,
         
//         PATHPULSE$TBYPASS$Q = 0,


        
         
        
         tsls = `setup_time,
         tslh = `hold_time ,
         tstdbys = `setup_time,
         tstdbyh = `hold_time , 
	 

         
         tcycle = `cycle_time,
         
         
         tckh = `pulse_width_time,
         tckl = `pulse_width_time,
         tcycle_se = `cycle_time,
         tckh_se = `pulse_width_time,
         tckl_se = `pulse_width_time,
         
         ttms = `setup_time,
         ttmh = `hold_time ,
         tps = `setup_time,
         tph = `hold_time ,
         tws = `setup_time,
         twh = `hold_time ,
         tds = `setup_time,
         tdh = `hold_time , 
         tas = `setup_time,
         tah = `hold_time ,
         tses= `setup_time,
         tseh= `hold_time ,
         tsctrlis=`setup_time,
         tsctrlih=`hold_time ,
         tsdlis=`setup_time,
         tsdlih=`hold_time ,
         tsdris=`setup_time,
         tsdrih=`hold_time , 
         tbists=`setup_time,
         tbisth=`hold_time ,
         tbps=`setup_time,
         tbph=`hold_time ,
         tbws=`setup_time,
         tbwh=`hold_time ,
         tbdes=`setup_time,
         tbdeh=`hold_time ,
         tbdos=`setup_time,
         tbdoh=`hold_time ,
         
         tbas=`setup_time,
         tbah=`hold_time ,
         tinitnl=`initin_low_pulse,
         tinitns=`setup_time,
         tinitnh=`hold_time ,
         tatps=`setup_time,
         tatph=`hold_time ,
         tigs=`setup_time,
         tigh=`hold_time ,
         
         
         trms=`setup_time,
         trmh=`hold_time ,
         twms=`setup_time,
         twmh=`hold_time , 

/*************************************************************************************************/
           // taa_tbypass_q = `access_time,
           // th_tbypass_q  = `retain_time,
            taa =`access_time,
            th = `retain_time,

 


            taa_tm =`access_time,
            th_tm = `retain_time,

            
            taa_tseq_tm =`access_time,
            th_tseq_tm = `retain_time,
            taa_tckq_tm   = `access_time,
            th_tckq_tm    = `retain_time,
            taa_sctrlo=`access_time,
            th_sctrlo= `retain_time,
            taa_sdlo=`access_time,
            th_sdlo= `retain_time,
            taa_sdro=`access_time,
            th_sdro= `retain_time,
            
         
            taa_sctrlo_se=`access_time,
            th_sctrlo_se= `retain_time
,
            taa_sdlo_se=`access_time,
            th_sdlo_se= `retain_time,
            taa_sdro_se=`access_time,
            th_sdro_se= `retain_time
         ;  


        /*---------------------- Timing Checks ---------------------*/

	$setup(posedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[7], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[7], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[7], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[7], tah, TimingViol_addr);

	$setup(posedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(posedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(posedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(posedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(posedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(posedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(posedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(posedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(posedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(posedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(posedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(posedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(posedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(posedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(posedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(posedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(posedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(posedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(posedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(posedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(posedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(negedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(negedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(negedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(negedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(negedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(negedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(negedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(negedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(negedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(negedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(negedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(negedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(negedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(negedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(negedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(negedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(negedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(negedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(negedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(negedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(negedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[20], tdh, TimingViol_data_20);

        



        $setup(posedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $setup(negedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, posedge WEN, twh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, negedge WEN, twh, TimingViol_WEN); 
        $setup(posedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$setup(negedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, posedge CSN, tph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, negedge CSN, tph, TimingViol_CSN);
        $period(posedge CK &&& cond_sdf_tcycle, tcycle, TimingViol_tcycle);  

        
        $width(posedge CK  &&& cond_sdf_tckh, tckh, 0, TimingViol_tckh);
        $width(negedge CK  &&& cond_sdf_tckl, tckl, 0, TimingViol_tckl);
        $period(posedge CK &&& cond_sdf_tcycle_se, tcycle_se, TimingViol_tcycle_se);
        $width(posedge CK  &&& cond_sdf_tckh_se, tckh_se, 0, TimingViol_tckh_se);
        $width(negedge CK  &&& cond_sdf_tckl_se, tckl_se, 0, TimingViol_tckl_se);

        
        $setup(posedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $setup(negedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $hold(posedge CK &&& cond_sdf_ttms, posedge TBYPASS, ttmh, TimingViol_tbypass); 
        $hold(posedge CK &&& cond_sdf_ttms, negedge TBYPASS, ttmh, TimingViol_tbypass); 
 



        
        $setup(posedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $setup(negedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $hold(posedge CK &&& cond_sdf_tsls, posedge SLEEP, tslh, TimingViol_sleep);        
        $hold(posedge CK &&& cond_sdf_tsls, negedge SLEEP, tslh, TimingViol_sleep);

        $setup(posedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $setup(negedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $hold(posedge CK &&& cond_sdf_tstdbys, posedge STDBY, tstdbyh, TimingViol_stdby);        
        $hold(posedge CK &&& cond_sdf_tstdbys, negedge STDBY, tstdbyh, TimingViol_stdby); 
        
        
        $setup (posedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
	$setup (negedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
        
        $hold (posedge CK &&& cond_sdf_tses, posedge SE ,tseh,TimingViol_se);
	$hold (posedge CK &&& cond_sdf_tses, negedge SE ,tseh,TimingViol_se);
        
        $setup(posedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis , tsctrlis, TimingViol_sctrli);
        $setup(negedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis, tsctrlis, TimingViol_sctrli);
        $hold(posedge CK &&& cond_sdf_tsctrlis , posedge SCTRLI, tsctrlih, TimingViol_sctrli);        
        $hold(posedge CK &&& cond_sdf_tsctrlis , negedge SCTRLI, tsctrlih, TimingViol_sctrli);

        $setup(posedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $setup(negedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $hold(posedge CK &&& cond_sdf_tsdlis, posedge SDLI, tsdlih, TimingViol_sdli);        
        $hold(posedge CK &&& cond_sdf_tsdlis, negedge SDLI, tsdlih, TimingViol_sdli);

        $setup(posedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $setup(negedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $hold(posedge CK &&& cond_sdf_tsdris, posedge SDRI, tsdrih, TimingViol_sdri);        
        $hold(posedge CK &&& cond_sdf_tsdris, negedge SDRI, tsdrih, TimingViol_sdri);
        
 
	
         
        $width(negedge INITN , tinitnl, 0, TimingViol_initnl);
        
        $setup(posedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        $setup(negedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        
        $hold (posedge CK &&& cond_sdf_tinitns,posedge INITN, tinitnh, TimingViol_initn);
        $hold (posedge CK &&& cond_sdf_tinitns,negedge INITN, tinitnh, TimingViol_initn);

        $setup(posedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $setup(negedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $hold(posedge CK &&& cond_sdf_atps, posedge ATP, tatph, TimingViol_atp);        
        $hold(posedge CK &&& cond_sdf_atps, negedge ATP, tatph, TimingViol_atp);
        
        $setup(posedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $setup(negedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $hold(posedge CK &&& cond_sdf_tigs, posedge IG, tigh, TimingViol_ig);        
        $hold(posedge CK &&& cond_sdf_tigs, negedge IG, tigh, TimingViol_ig);



         
$setup(posedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[2], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[2], trmh, TimingViol_rm); 

        
$setup(posedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(posedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[1], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[1], twmh, TimingViol_wm);
 
        
        $setup(posedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $setup(negedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $hold(posedge CK &&& cond_sdf_tbists, posedge TBIST, tbisth, TimingViol_tbist);        
        $hold(posedge CK &&& cond_sdf_tbists, negedge TBIST, tbisth, TimingViol_tbist);
        
        	$setup(posedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[7], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$setup(negedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[7], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[6], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[7], tbah, TimingViol_addr);
       	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[6], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[7], tbah, TimingViol_addr);

        $setup(posedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$setup(negedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, posedge TCSN, tbph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, negedge TCSN, tbph, TimingViol_CSN); 
       
        $setup(posedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $setup(negedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, posedge TWEN, tbwh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, negedge TWEN, tbwh, TimingViol_WEN);
       
       
        $setup(posedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $setup(negedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, posedge TED, tbdeh, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, negedge TED, tbdeh, TimingViol_TED);

        $setup(posedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $setup(negedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, posedge TOD, tbdoh, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, negedge TOD, tbdoh, TimingViol_TOD);

          


          

          /*-------------------- Propagation Delays ------------------*/
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa, taa, th, taa, th, taa);
                 

/* // //	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[0] +: OutReg_data[0])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[1] +: OutReg_data[1])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[2] +: OutReg_data[2])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[3] +: OutReg_data[3])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[4] +: OutReg_data[4])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[5] +: OutReg_data[5])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[6] +: OutReg_data[6])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[7] +: OutReg_data[7])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[8] +: OutReg_data[8])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[9] +: OutReg_data[9])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[10] +: OutReg_data[10])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[11] +: OutReg_data[11])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[12] +: OutReg_data[12])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[13] +: OutReg_data[13])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[14] +: OutReg_data[14])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[15] +: OutReg_data[15])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[16] +: OutReg_data[16])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[17] +: OutReg_data[17])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[18] +: OutReg_data[18])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[19] +: OutReg_data[19])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[20] +: OutReg_data[20])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q); */ 








	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                





	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                 

	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[0] +: OutReg_data[0])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[1] +: OutReg_data[1])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[2] +: OutReg_data[2])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[3] +: OutReg_data[3])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[4] +: OutReg_data[4])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[5] +: OutReg_data[5])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[6] +: OutReg_data[6])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[7] +: OutReg_data[7])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[8] +: OutReg_data[8])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[9] +: OutReg_data[9])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[10] +: OutReg_data[10])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[11] +: OutReg_data[11])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[12] +: OutReg_data[12])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[13] +: OutReg_data[13])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[14] +: OutReg_data[14])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[15] +: OutReg_data[15])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[16] +: OutReg_data[16])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[17] +: OutReg_data[17])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[18] +: OutReg_data[18])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[19] +: OutReg_data[19])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[20] +: OutReg_data[20])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                



if (cond_sdf_taa_sctrlo) 
        (posedge CK *> (SCTRLO :  SCTRLI)) = (taa_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo); 

if (cond_sdf_taa_sctrlo_se) 
        (negedge CK *> (SCTRLO : SCTRLI)) = (taa_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se); 
 

if (cond_sdf_taa_sdlo) 
        (posedge CK *> (SDLO :  SDLI)) = (taa_sdlo,taa_sdlo,th_sdlo,taa_sdlo,th_sdlo,taa_sdlo); 

if (cond_sdf_taa_sdlo_se) 
        (negedge CK *> (SDLO : SDLI)) = (taa_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se);

if (cond_sdf_taa_sdro) 
        (posedge CK *> (SDRO :  SDRI)) = (taa_sdro,taa_sdro,th_sdro,taa_sdro,th_sdro,taa_sdro); 

if (cond_sdf_taa_sdro_se) 
        (negedge CK *> (SDRO : SDRI)) = (taa_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se); 

  
     




endspecify //specify block ends






// conversion from registers to array elements for data setup violation notifiers

always @(TimingViol_data_0   or TimingViol_TED  )
begin
        TimingViol_data[0]=~TimingViol_data[0];   
end


always @(TimingViol_data_1   or TimingViol_TOD  )
begin
        TimingViol_data[1]=~TimingViol_data[1];   
end


always @(TimingViol_data_2   or TimingViol_TED  )
begin
        TimingViol_data[2]=~TimingViol_data[2];   
end


always @(TimingViol_data_3   or TimingViol_TOD  )
begin
        TimingViol_data[3]=~TimingViol_data[3];   
end


always @(TimingViol_data_4   or TimingViol_TED  )
begin
        TimingViol_data[4]=~TimingViol_data[4];   
end


always @(TimingViol_data_5   or TimingViol_TOD  )
begin
        TimingViol_data[5]=~TimingViol_data[5];   
end


always @(TimingViol_data_6   or TimingViol_TED  )
begin
        TimingViol_data[6]=~TimingViol_data[6];   
end


always @(TimingViol_data_7   or TimingViol_TOD  )
begin
        TimingViol_data[7]=~TimingViol_data[7];   
end


always @(TimingViol_data_8   or TimingViol_TED  )
begin
        TimingViol_data[8]=~TimingViol_data[8];   
end


always @(TimingViol_data_9   or TimingViol_TOD  )
begin
        TimingViol_data[9]=~TimingViol_data[9];   
end


always @(TimingViol_data_10   or TimingViol_TED  )
begin
        TimingViol_data[10]=~TimingViol_data[10];   
end


always @(TimingViol_data_11   or TimingViol_TOD  )
begin
        TimingViol_data[11]=~TimingViol_data[11];   
end


always @(TimingViol_data_12   or TimingViol_TED  )
begin
        TimingViol_data[12]=~TimingViol_data[12];   
end


always @(TimingViol_data_13   or TimingViol_TOD  )
begin
        TimingViol_data[13]=~TimingViol_data[13];   
end


always @(TimingViol_data_14   or TimingViol_TED  )
begin
        TimingViol_data[14]=~TimingViol_data[14];   
end


always @(TimingViol_data_15   or TimingViol_TOD  )
begin
        TimingViol_data[15]=~TimingViol_data[15];   
end


always @(TimingViol_data_16   or TimingViol_TED  )
begin
        TimingViol_data[16]=~TimingViol_data[16];   
end


always @(TimingViol_data_17   or TimingViol_TOD  )
begin
        TimingViol_data[17]=~TimingViol_data[17];   
end


always @(TimingViol_data_18   or TimingViol_TED  )
begin
        TimingViol_data[18]=~TimingViol_data[18];   
end


always @(TimingViol_data_19   or TimingViol_TOD  )
begin
        TimingViol_data[19]=~TimingViol_data[19];   
end


always @(TimingViol_data_20   or TimingViol_TED  )
begin
        TimingViol_data[20]=~TimingViol_data[20];   
end


`endif


// TASK DEFINITION DESCRIPTION
// ================================



task task_insert_faults_in_memory;
begin
   if (reg_ConfigFault)
   begin   
     for(i = 0;i< fcnt;i = i+ 1) begin
        if(mem_red_array_stuck_at[i] === "mem_array") begin
          if (array_stuck_at[i] === "sa0") begin
           `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data & stuck_at_0fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
          `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] & stuck_at_0fault[i];
          `endif
         end //if(array_stuck_at)
                                        
         if(array_stuck_at[i] === "sa1") begin
         `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data | stuck_at_1fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
         `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] | stuck_at_1fault[i]; 
         `endif
         end //if(array_stuck_at)
       end //if mem_red_array_stuck_at
    
    
     end    // end of for
   end  
end
endtask



task task_read_fault_file;
begin
/*  -----------Implemetation for config fault starts------*/
   msgcnt = X;
   t = 0;
   fault_repair_flag = {max_faults{1'b1}};
   repair_flag = {max_faults{1'b1}};
   if(reg_ConfigFault) 
   begin
      file_ptr = $fopen(reg_Fault_file_name , "r");
      if(file_ptr == 0)
      begin     
          if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: File cannot be opened ",$realtime);
      end        
      else                
      begin : read_fault_file
        t = 0;
        for (i = 0; i< max_faults; i= i + 1)
        begin
         
           stuck0 = {Bits{1'b1}};
           stuck1 = {Bits{1'b0}};
           fault_char1 = $fgetc (file_ptr);
           if (fault_char1 == 8'b11111111)
              disable read_fault_file;
           ret_val = $ungetc (fault_char1, file_ptr);
           ret_val = $fgets(tempStr, file_ptr);
           ret_val = $sscanf(tempStr, "%s %d %d %s",fault_array,fault_word, fault_bit, stuck_at) ;
           flag_error = 0; 
           if(ret_val !== 0)
           begin         
              if(ret_val == 3 || ret_val == 4)
              begin
                if(ret_val == 3)
                   stuck_at = "sa0";

                if(stuck_at !== "sa0" && stuck_at !== "sa1" && stuck_at !== "none")
                begin
                    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: Wrong value for stuck at in fault file ",$realtime);
                   flag_error = 1;
                end    
                      
                if(fault_word >= Words)
                begin
                   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Address out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                if(fault_bit >= Bits)
                begin  
                    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Faulty bit out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                
                        
                if(fault_array !== "mem_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array is not mem_array ",$realtime);
                  flag_error = 1;
                end

                if(fault_array === "red_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array can't be on redundancy array in non redundancy cut.",$realtime);
                  flag_error = 1;
                end

                
                

                if(flag_error == 0)
                //Correct Inputs
                begin
                   if(stuck_at === "none")
                   begin
                       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
                   end
                   else
                   //Adding the faults
                   begin
                      FailureLocn[t] = fault_word;
                      Failurebit[t]  = fault_bit ;
                      std_fault_word = fault_word;
                      fault_row_add[t] = std_fault_word[Addr-1:mux_bits];
                      mem_red_array_stuck_at[t] = fault_array;
                      fault_repair_flag[t] = 1'b0;
                      if (stuck_at === "sa0" )
                      begin
                         stuck0[fault_bit] = 1'b0;         
                         stuck_at_0fault[t] = stuck0;
                      end     
                      if (stuck_at === "sa1" )
                      begin
                         stuck1[fault_bit] = 1'b1;
                         stuck_at_1fault[t] = stuck1; 
                      end

                      array_stuck_at[t] = stuck_at;
                      t = t + 1;
                   end //if(stuck_at === "none")  
                end //if(flag_error == 0)
              end //if(ret_val == 2 || ret_val == 3 
              else
              //wrong number of arguments
              begin
                if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: WRONG VALUES ENTERED FOR FAULTY WORD OR FAULTY BIT OR STUCK_AT IN Fault_file_name ",$realtime); 
                flag_error = 1;
              end
           end //if(ret_val !== 0)
           else
           begin 
               if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
           end    
        end //for (i = 0; i< m
      end //begin: read_fault_file  
      $fclose (file_ptr);

      fcnt = t;
      
      //fault injection at time 0.
      task_insert_faults_in_memory;
  end // config_fault 
end
endtask


task WriteMemX;
begin

`ifdef slm
   $slm_ResetMemory(MemAddr, WordX);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = WordX;
   
`endif        
 task_insert_faults_in_memory;
end
endtask

task WriteMem0;
begin
`ifdef slm
   $slm_ResetMemory(MemAddr, Word0);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = Word0;
  
`endif 
   task_insert_faults_in_memory;
end
endtask


task WriteOutX;                
begin
   OutReg_data <= #0 WordX;
end
endtask


task Invalid_next_cycle_func;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_func = 1;
     `else 
       #0 next_cycle_corrupt_func = 0; 
     `endif  
   end 
end
endtask

task Invalid_next_cycle_dft;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_dft = 1;
     `else 
       #0 next_cycle_corrupt_dft = 0; 
     `endif  
  end
end
endtask

task Invalid_next_cycle_func_tim;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
   #0 next_cycle_corrupt_func <= 1;
  end 
end
endtask

task Invalid_next_cycle_dft_tim;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
  #0 next_cycle_corrupt_dft <= 1;
  end
end
endtask


task ScanOutX;                
begin
   
   dff_SCTRLO_SE.Q <= 1'bx;   
   dff_SDLO_SE.Q <= 1'bx; 
   dff_SDRO_SE.Q <= 1'bx; 
    
   
   SCTRLOint=X;
   SDLOint=X;
   SDROint=X;
    
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   SDLO_data<=1'bx;
   SDRO_data<=1'bx;
    
   `endif
end
endtask

task delScanOutX;                
begin
   delSCTRLO_data<=X;
   delSDLO_data<=X;
   delSDRO_data<=X;
    
end
endtask

task ScanChainX;                
begin
 scanreg_ctrl=1'bx; 
 scanreg_dl=1'bx; 
 scanreg_dr =1'bx; 
  
end
endtask

task mem_blocked;
begin
 
   WriteMemX;
   WriteOutX;
   ScanChainX;
   ScanOutX;//immediately;
   delScanOutX;//immediately
   `ifdef POWER_SEQUENCING_OFF
   `else
   reg_mem_block=1;
   `endif
   debug_level = 2'b11;
end
endtask

task corrupt_all;
begin
 
  WriteMemX;
  WriteOutX;
  ScanChainX;
  ScanOutX;
  delScanOutX;//immediately;
  OutReg_data = WordX; 
  delOutReg_data=WordX;
  
end
endtask

task WriteCycle;                  
input [Addr-1 : 0] Address;
reg [Bits-1:0] tempReg1;
reg [Bits-1:0] tempReg_slm;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;


reg repair_flag;

integer po,i,num,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;
begin

   tempReg1 = WordX;
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];

   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};
   
   if (ValidAddress === X )   begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
        WriteMemX;
        if (INITNint !== 0) begin
        `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
           #0 next_cycle_corrupt_func = 1;
       `else 
           #0 next_cycle_corrupt_func = 0; 
       `endif  
   end 

   end


   if (ValidAddress !== X && next_cycle_corrupt_func === 0  )
   begin
         if (red_en === 1 && ((Row_Add_cmp === repair_add) || (Row_Add_cmp === next_repair_add)) ) begin
             repair_flag = 1'b1;
             
             Bank_sel_integer = 0;
                     
             if (Row_Add_cmp === repair_add) begin
               Col_Add_integer  = Col_Add; 
             end
             else if (Row_Add_cmp === next_repair_add) begin
               Col_Add_integer  = Col_Add + mux; 
             end  
             RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
        end  

        if(repair_flag === 0 && ValidAddress === 1) begin
           `ifdef slm
              $slm_ReadMemoryS(MemAddr, Address, tempReg_slm);
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = Mem[Address];
            `endif
          end  
        else if(repair_flag === 1) begin
           `ifdef slm
//              $slm_ReadMemoryS(RedMemAddr, RedMem_address, tempReg_slm);
          
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = RedMem[RedMem_address];
            `endif
        end
        
        for (num=0;num<Bits;num=num+1) begin
             po=num;        
             if ( Dint [num] !== tempReg1 [po]) begin
                if (Mint[num] === 1'b0)
                   tempReg1[po] = Dint[num];
                else if (Mint[num] === 1'bX)
                   tempReg1[po] = 1'bx;
             end                
        end //for (num=0
            
         if(repair_flag === 0 ) begin    
            if(ValidAddress === 1) begin  
              `ifdef slm
                  tempReg_slm=tempReg1; 
                  $slm_WriteMemory(MemAddr, Address, tempReg_slm);
              `else
                   Mem[Address] = tempReg1;
              `endif
            end
            else begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address Out Of Range. ",$realtime);
            end        
         end
         else if (repair_flag === 1 ) begin
            `ifdef slm
                tempReg_slm=tempReg1; 
//                $slm_WriteMemory(RedMemAddr, RedMem_address, tempReg_slm);
            `else
                RedMem[RedMem_address] = tempReg1;
            `endif
         end
   end //if (ValidAddress !== X
   task_insert_faults_in_memory;
end
endtask 

task ReadCycle;
input [Addr-1 : 0] Address;

reg [Bits-1:0] MemData_tmp;
reg [Bits-1:0] MemData;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;

reg repair_flag;

integer a,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;

begin
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];
   
   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};

   

   if (ValidAddress !== X && next_cycle_corrupt_func === 0 ) begin   
       if(red_en === 1 && ( Row_Add_cmp === repair_add ||  Row_Add_cmp === next_repair_add )) begin
              repair_flag = 1;
              
              Bank_sel_integer = 0;
               
              if(Row_Add_cmp === repair_add) begin
                Col_Add_integer = Col_Add;
              end
              else if (Row_Add_cmp === next_repair_add) begin
                Col_Add_integer = Col_Add + mux; 
              end
              RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
       end

      if(repair_flag === 0) begin
          if(ValidAddress === 1) begin 
           `ifdef slm
              $slm_ReadMemory(MemAddr, Address, MemData);
           `else
              MemData = Mem[Address];
           `endif
          end
          else begin
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Address Out Of Range. Output Corrupted ",$realtime);
             MemData = WordX;
          end
     end
      else if(repair_flag === 1) begin
        `ifdef slm
//           $slm_ReadMemory(RedMemAddr, RedMem_address, MemData);
        `else
           MemData = RedMem[RedMem_address];
        `endif
      end
   end //if (ValidAddress)  
   
   if(ValidAddress === X)
   begin
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Illegal Value on Address Bus. Memory and Output Corrupted ",$realtime); 
         Invalid_next_cycle_func;
   end 
   
  if(ValidAddress !== X && next_cycle_corrupt_func === 0 )
   begin
   for (a = 0; a < Bits; a = a + 1)
   begin
      if (MemData[a] !== OutReg_data[a])
         OutReg_data[a] = WordX[a];
   end//for (a = 0; a <  
         OutReg_data <= MemData;
   end     
end
endtask



// SCAN CHAINS
supply0 gnd;
buf (A_int[0], Aint[0]);
buf (A_int[1], Aint[1]);
buf (A_int[2], Aint[2]);
buf (A_int[3], Aint[3]);
buf (A_int[4], Aint[4]);
buf (A_int[5], Aint[5]);
buf (A_int[6], Aint[6]);
buf (A_int[7], Aint[7]);                  //used for capturing
buf (A_int[8], gnd);
buf (A_int[9], gnd);
buf (A_int[10], gnd);
buf (A_int[11], gnd);
buf (A_int[12], gnd);
buf (A_int[13], gnd);
buf (A_int[14], gnd);   //used for capturing

buf (WEN_int, WENint);
buf (CSN_int, CSNint);
buf (IG_int, IGint);


// Scan flops



// CONTROL SCAN CHAIN
     ST_SPREG_LOLEAK_256x21m2_Tl_SCFF cntrl_scff_0 (.D(1'b0), .TI(SCTRLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[0]), .OUTX(scanreg_ctrl));

      
 ST_SPREG_LOLEAK_256x21m2_Tl_SCFF cntrl_scff_1 (.D(A_int[2]), .TI(scanreg_ctrl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[1]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m2_Tl_SCFF cntrl_scff_2 (.D(A_int[4]), .TI(scanreg_ctrl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[2]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m2_Tl_SCFF cntrl_scff_3 (.D(A_int[7]), .TI(scanreg_ctrl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[3]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m2_Tl_SCFF cntrl_scff_4 (.D(A_int[1]), .TI(scanreg_ctrl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[4]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m2_Tl_SCFF cntrl_scff_5 (.D(A_int[9]), .TI(scanreg_ctrl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[5]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m2_Tl_SCFF cntrl_scff_6 (.D(A_int[8]), .TI(scanreg_ctrl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[6]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m2_Tl_SCFF cntrl_scff_7 (.D(1'b0), .TI(scanreg_ctrl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[7]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m2_Tl_SCFF cntrl_scff_8 (.D(A_int[0]), .TI(scanreg_ctrl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[8]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m2_Tl_SCFF cntrl_scff_9 (.D(A_int[3]), .TI(scanreg_ctrl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[9]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m2_Tl_SCFF cntrl_scff_10 (.D(A_int[5]), .TI(scanreg_ctrl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[10]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m2_Tl_SCFF cntrl_scff_11 (.D(CSN_int), .TI(scanreg_ctrl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[11]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m2_Tl_SCFF cntrl_scff_12 (.D(A_int[6]), .TI(scanreg_ctrl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[12]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m2_Tl_SCFF cntrl_scff_13 (.D(WEN_int), .TI(scanreg_ctrl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[13]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m2_Tl_SCFF cntrl_scff_14 (.D(scanreg_ctrl_wire[14]), .TI(scanreg_ctrl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[14]), .OUTX(scanreg_ctrl));  

reg LP_CK_gate;

// Lock Up Latch
wire SCTRLO_temp;
 ST_SPREG_LOLEAK_256x21m2_Tl_lock_up_latch  dff_SCTRLO_SE (Latch_open, scanreg_ctrl_wire[14], SCTRLO_temp);

always @(SCTRLO_temp) begin
     SCTRLOint= SCTRLO_temp;
 `ifdef functional
 `else
 if (SCTRLOint !== SCTRLO_data) begin 
  if (SCTRLOint !==X)
   SCTRLO_data=1'bx;
   SCTRLO_data <= SCTRLOint;
 end 
 `endif
end  


// LEFT DATA SCAN CHAIN
     ST_SPREG_LOLEAK_256x21m2_Tl_SCFF ldata_scff_0 (.D(Dint[11]), .TI(SDLI), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[0]), .OUTX(scanreg_dl));
      
   
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF ldata_scff_1 (.D(Dint[10]), .TI(scanreg_dl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[1]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF ldata_scff_2 (.D(Dint[9]), .TI(scanreg_dl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[2]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF ldata_scff_3 (.D(Dint[8]), .TI(scanreg_dl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[3]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF ldata_scff_4 (.D(Dint[7]), .TI(scanreg_dl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[4]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF ldata_scff_5 (.D(Dint[6]), .TI(scanreg_dl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[5]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF ldata_scff_6 (.D(Dint[5]), .TI(scanreg_dl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[6]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF ldata_scff_7 (.D(Dint[4]), .TI(scanreg_dl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[7]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF ldata_scff_8 (.D(Dint[3]), .TI(scanreg_dl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[8]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF ldata_scff_9 (.D(Dint[2]), .TI(scanreg_dl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[9]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF ldata_scff_10 (.D(Dint[1]), .TI(scanreg_dl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[10]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF ldata_scff_11 (.D(Dint[0]), .TI(scanreg_dl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[11]), .OUTX(scanreg_dl));



// Lock Up Latch
wire SDLO_temp;
 ST_SPREG_LOLEAK_256x21m2_Tl_lock_up_latch  dff_SDLO_SE (Latch_open, scanreg_dl_wire[11], SDLO_temp);

always @(SDLO_temp) begin
     SDLOint= SDLO_temp;
 `ifdef functional
 `else
 if (SDLOint !== SDLO_data) begin 
  if (SDLOint !==X)
   SDLO_data=1'bx;
   SDLO_data <= SDLOint;
 end 
 `endif
end  






// RIGHT DATA SCAN CHAIN

     ST_SPREG_LOLEAK_256x21m2_Tl_SCFF rdata_scff_0 (.D(1'b0), .TI(SDRI), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[0]), .OUTX(scanreg_dr));
     
 
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF rdata_scff_1 (.D(Dint[20]), .TI(scanreg_dr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[1]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF rdata_scff_2 (.D(Dint[19]), .TI(scanreg_dr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[2]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF rdata_scff_3 (.D(Dint[18]), .TI(scanreg_dr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[3]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF rdata_scff_4 (.D(Dint[17]), .TI(scanreg_dr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[4]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF rdata_scff_5 (.D(Dint[16]), .TI(scanreg_dr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[5]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF rdata_scff_6 (.D(Dint[15]), .TI(scanreg_dr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[6]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF rdata_scff_7 (.D(Dint[14]), .TI(scanreg_dr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[7]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF rdata_scff_8 (.D(Dint[13]), .TI(scanreg_dr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[8]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m2_Tl_SCFF rdata_scff_9 (.D(Dint[12]), .TI(scanreg_dr_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[9]), .OUTX(scanreg_dr)); 


// Lock Up Latch
wire SDRO_temp;
 ST_SPREG_LOLEAK_256x21m2_Tl_lock_up_latch  dff_SDRO_SE (Latch_open, scanreg_dr_wire[9], SDRO_temp);


always @(SDRO_temp) begin
     SDROint= SDRO_temp;
 `ifdef functional
 `else
 if (SDROint !== SDRO_data) begin 
  if (SDROint !==X)
   SDRO_data=1'bx;
   SDRO_data <= SDROint;
 end 
 `endif
end






//


 //////// CAPTURE TASK //////
task scan_acquire;
begin
   if (supply_ok === 1) begin 
      if ( SEsys === 0 && ((LP_CK_gate === 0 && TBYPASSsys !== 1'bx)|| TBYPASSsys===0)) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
         
         Latch_open=1;
         

      end //if ( SEint === 0
   end//if(supply_ok 
end
endtask

task scan_shift;
begin
 if (supply_ok === 1) begin
   if (STDBYint === 0 && SLEEPint === 0) begin
      if (CKint_dft === X && INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0) begin
         ScanChainX;
         ScanOutX;
      end
      else if (CKint_dft === 1 && lastCK_dft === 0 ) begin
          //// SHIFT
        if (SEsys === 1) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
           
        //// SHIFT Ends
        end //if (SEsys === 1
        else if (SEsys === X) begin
            ScanChainX;
            ScanOutX;
            delScanOutX;
        end//if (SEint ==X
      
      end///if (CKint === 
    
      else if (CKint_dft === 0 && lastCK_dft === 1 ) begin
        Latch_open=1;
      end
    end  //if (STDByint === 0 && SLEEPint === 0
 end//if(supply_ok
end
endtask






// BEHAVIOURAL MODULE DESCRIPTION
// ================================

initial
begin
  // Define format for timing value
  $timeformat (-9, 3, " ns", 0);
  `ifdef slm
  $slm_RegisterMemory(MemAddr, Words, Bits);
  `endif   
   reg_mem_block=0;
   flag_mem_block=0;
  `ifdef functional
  `else
   TimingViol_data=0;
   TimingViol_mask=0;
   `endif
   decoding_start=0;
  
   //Parameter Assignment
   
   reg_Fault_file_name = Fault_file_name; 
   reg_ConfigFault     = ConfigFault;
   reg_MEM_INITIALIZE  = MEM_INITIALIZE;
   reg_BinaryInit      = BinaryInit;
   reg_InitFileName    = InitFileName;
   reg_Initn_reset_value = Initn_reset_value;
   reg_File_load_time    = File_load_time;

   time_fall_sleep=0;
   time_fall_PSWLARGEMP=0;
   time_fall_PSWLARGEMP_0=0;
   time_fall_PSWLARGEMA=0;
   time_fall_PSWLARGEMA_0=0;
   time_fall_PSWSMALLMP=0;
   time_fall_PSWSMALLMA=0;

   vddmp_rise_time=0;
   vddmp_fall_time=0;
   vddsmp_rise_time=0;
   vddsmp_fall_time=0;
   vddma_rise_time=0;
   vddma_fall_time=0;
   vddsma_rise_time=0;
   vddsma_fall_time=0;
   vddm_fall_time=0;  
   vddm_rise_time=0;  
   vddsm_fall_time=0; 
   vddsm_rise_time=0;

   next_cycle_corrupt_func=0;
   next_cycle_corrupt_dft=0;
   init_pulse_done = 0;
   power_up_done = 0;
   file_loaded=1;
   debug_level= 2'b01;
   message_status = "ONLY WARNINGS/ERRORS are Switched ON.For INFO also use debug_level=2'b00";
  `ifdef  NO_WARNING_MODE
     debug_level = 2'b11;
     message_status = "All Warning/Errors/Info Messages are Switched OFF";
  `endif  
  `ifdef  ONLY_ERROR_MODE
     debug_level = 2'b10;
     message_status = "All Warning/Info Messages are Switched OFF.Errors are switched on";
  `endif 
  `ifdef  ALL_MSG_MODE
     debug_level = 2'b00;
     message_status = "All Messages are Switched ON";
  `endif 
  
  `ifdef slm
     operating_mode = "SLM";
   `else
      `ifdef functional
         operating_mode = "FUNCTIONAL";
       `else
         operating_mode = "TIMING";
      `endif
   `endif   
  
  if (debug_level < 1) begin
  $display ("%m INFORMATION ");
  $display ("***************************************");
  $display ("The Model is Operating in %s MODE", operating_mode);
  $display ("%s", message_status);
  if(reg_ConfigFault)
  $display ("Configurable Fault Functionality is ON");   
  else
  $display ("Configurable Fault Functionality is OFF");   
  $display("Fault File used by the model Fault_File_Name=%s" ,reg_Fault_file_name);
  $display("Values of Config_fault used in model=%d" ,reg_ConfigFault);
  $display("Values of Mem_INITALIZE used in model=%d" ,reg_MEM_INITIALIZE);
  $display("Values of BinaryInit used in model=%d" ,reg_BinaryInit);
  $display("Values of InitFileName used in model=%s" ,reg_InitFileName);
  $display("Values of Initn_reset_value used in model=%d" ,reg_Initn_reset_value);
  $display("Values of File_load_time used in model=%t" ,reg_File_load_time);

  $display ("***************************************");
  end
     
  task_read_fault_file; 
   if(!INITNint) begin
    if(supply_ok ) begin 
      init_pulse_done = 1;
      power_up_done = 1;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif 
    end 
   end 
        
   lastCK_func = CKint_func;
   lastCK_dft = CKint_dft;

 `ifdef MEM_CONTENTS_SLEEP
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","w");
   $fclose(ptr);
 `endif 

   
end  // initial block ends



//+++++++++++++++++++++++++++++++ CONFIG FAULT IMPLEMETATION ENDS+++++++++++++++++++++++++++++++//
        




//INITN block starts
//================================
always @(INITNint  or supply_ok )
begin
 if (INITNint === 1'b0) begin
   if(supply_ok) begin
     init_pulse_done = 1;
     power_up_done = 1;
     lastCK_func=CKint_func;
     lastCK_dft=CKint_dft;
     next_cycle_corrupt_func = 0;
     next_cycle_corrupt_dft = 0;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif     
   end 
 end        

 if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && INITNint !== 1)
   begin
     ScanOutX;
     ScanChainX;
     delScanOutX;
   end  
         
 if (init_pulse_done === 0 && INITNint !== 0) begin
     if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) INFO: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
 end
 
end//always @(INITNint)


// Clock Generation 
//wire gated_clock;
//wire clock_gate_en;
//ST_SPREG_LOLEAK_256x21m2_Tl_lock_up_latch CK_SE_latch (!CK , SE, SE_latch_CK);
//and (clock_gate_en, ATP, TBYPASS, !SE_latch_CK);

//ST_SPREG_LOLEAK_256x21m2_Tl_lock_up_latch LP_latch (!CK , scanreg_ctrl_wire[14], LP_latch_CK);
//and (gated_clock,CK,!LP_latch_CK);
//assign CK_new= clock_gate_en ===0 ? CK : (clock_gate_en ===1 ? gated_clock: (CK===0) ? 0 :1'bx);


// Clock Generation Ends


// Functional CK block starts
//======================================
always @(CKint_func)
begin
   lastCK_func=CKreg_func;  
   CKreg_func=CKint_func;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
        if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
      if (CKreg_func === 1'bX || (CKreg_func === 1'b1 && lastCK_func === 1'bx)) begin
        if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
         
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
         Invalid_next_cycle_func;
        end
      end
      else if (CKreg_func === 1'b1 && lastCK_func === 1'b0 ) begin
        time_CK_func_rise=$realtime;
        MEMEN_prev = MEMEN_reg;
        MEMEN_reg = MEMEN;
        CSNreg = CSNint;
        IGreg = IGint;
        DEreg = DEint;
        SE_reg = SEsys;
        TBYPASS_reg = TBYPASSsys;
        ATPreg = ATPint;
        INITNreg = INITNint;
        SLEEPreg = SLEEPint;
        STDBYreg = STDBYint;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 

    `ifdef functional
    `else
        Mem_last=Mem[Aint];
    `endif 
        if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.INITN pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SLEEP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.STANDBY pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg === X && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.chip select  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg === X && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.IG pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg === X && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.Debug pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg === X && (SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.ATP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg === X && TBYPASS_reg !== 1) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SE pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg !== 1 && TBYPASS_reg === X) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.TBYPASS pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end

        else if ((INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0))) && WENint === X) begin
            // Uncertain write cycle
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: write enable going to X  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end 
        else if (next_cycle_corrupt_func === 1) begin
          next_cycle_corrupt_func = X;
        end
        else if (next_cycle_corrupt_func === 1'bx) begin
          next_cycle_corrupt_func = 0;
        end 
        
//        if (next_cycle_corrupt_func === 0 ) begin 
         
          /*---------------------- File initialization -----------------*/
          
          if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0)) && flag_mem_block === 1'b0) begin
                 Areg=Aint;
                 Dreg=Dint;
                 Mreg=Mint;
                 WENreg=WENint;     
             if (reg_MEM_INITIALIZE === 1'b1 && $realtime >= reg_File_load_time && file_loaded ) begin   
                `ifdef slm
                  if (reg_BinaryInit)
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_BIN");
                  else
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_HEX");
   
                `else
                  if (reg_BinaryInit)
                     $readmemb(reg_InitFileName, Mem, 0, Words-1);
                  else
                     $readmemh(reg_InitFileName, Mem, 0, Words-1);
                `endif
                 file_loaded = 0;
             end
   
             if (^Aint === X)
               ValidAddress = X;
             else if (Aint < Words)
               ValidAddress = 1;
             else    
               ValidAddress = 0;
   
             if(red_en === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Redundancy Enable is Invalid. Either RRAE is X or TRRAE is X",$realtime);
                ValidAddress = X; 
           end
           else if(red_en === 1'b1 && ^repair_add === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Repair Address is invalid.RRA is X",$realtime);
                ValidAddress = X;
           end
             
             if (ValidAddress)
               `ifdef slm
                   $slm_ReadMemoryS(MemAddr, Aint, Mem_temp);
               `else
                    Mem_temp = Mem[Aint];
               `endif
             else
                Mem_temp = WordX;  
          
     /*---------------------- Normal Read and Write -----------------*/
     
             if (WENint === 1) begin
               ReadCycle(Aint);
             end
       
             else if (WENint === 0) begin
               WriteCycle(Aint);
             end 
                
          
          end //  if (MEMEN === 1'b1 
       
//        end  // if (next_cycle_corrupt_func === 0
      
      end // if (CKint = 1   
   end // if (init_pulse_done === 1           
 end 
end // always @(CKint_func)
        
always @(MEMEN)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) && CKint_func === 1'bx) begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.clock pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
    Invalid_next_cycle_func;
  end
 end 
end

// DFT CK block starts
//======================================
always @(CKint_dft) 
begin
   lastCK_dft=CKreg_dft;
   CKreg_dft=CKint_dft;
   
   Latch_open=0;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
     if (CKreg_dft === 1'bX || (CKreg_dft === 1'b1 && lastCK_dft === 1'bx)) begin
       if (INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0 ) begin
        
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: DFT clock  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime); 
         Invalid_next_cycle_dft;
         if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
           WriteOutX;
         end
       end
     end 

     if(CKint_dft === 0 && lastCK_dft === 1) begin
      if(ATPreg === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
       if(SE_reg === 1'b1 && SEsys === 1'b0) begin
        if(TBYPASSint === 1'b1) begin   
            
    
    OutReg_data_scan = { scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9],
scanreg_dl_wire[10], scanreg_dl_wire[scanlen_l-1]}; 
 
         for (i = 0; i < Bits; i = i + 1)
         begin
          if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
         end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
        end 
       end
      end
     end 
     
     else if (CKreg_dft === 1'b1 && lastCK_dft === 1'b0 ) begin
       SE_reg = SEsys;
       TBYPASS_reg = TBYPASSsys;
       ATPreg = ATPint;
       INITNreg = INITNint;
       SLEEPreg = SLEEPint;
       STDBYreg = STDBYint;
       MEMEN_dft_prev = MEMEN_dft_reg;
       MEMEN_dft_reg = MEMEN_dft;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 
       if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ) begin 
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
 //     else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys === X && TBYPASSsys !== 1) begin
///           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
//           Invalid_next_cycle_dft;
//        end       
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys === X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
        end 
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys !== 0 && LP_CK_gate===X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: LP FLOP Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           ScanChainX;
           ScanOutX;   
          if( TBYPASSint !== 0 && SEint !== 1) begin
            WriteOutX;
          end
          next_cycle_corrupt_dft=0;
        end        
       else if (next_cycle_corrupt_dft === 1'b1) begin 
         next_cycle_corrupt_dft = X;
       end 
       else if (next_cycle_corrupt_dft === 1'bx) begin
         next_cycle_corrupt_dft = 0;
       end
       
       if (next_cycle_corrupt_dft === 0 ) begin
         
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1 && flag_mem_block === 1'b0) begin
           
           if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0  && LP_CK_gate===0) begin
              OutReg_data_tbypass = Dint;
              for (i = 0; i < Bits; i = i + 1)
              begin
               if (OutReg_data_tbypass[i] !== OutReg_data[i])
                 OutReg_data[i] = WordX[i];
              end//for (i = 0; i < */ 
              OutReg_data <= OutReg_data_tbypass;
           end
           
             scan_acquire;
         end //MEMEN_dft == 1        
       end // if ( next_cycle_corrupt_dft
       
     end // if (CKint_dft === 1'b1
      //  if (next_cycle_corrupt_dft === 0 ) begin 
       if (SE_reg !== 0) begin
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1  && flag_mem_block === 1'b0) begin
           next_cycle_corrupt_dft = 0;
           if ( next_cycle_corrupt_func === 1) begin
	    next_cycle_corrupt_func = 0 ;
	   end	
           scan_shift;
         end
       end
     //end // if ( next_cycle_corrupt_dft    
     if ((!(TBYPASSsys!==0 && SEsys!==1 && LP_CK_gate!==0 ) && next_cycle_corrupt_dft === 0) || CKint_dft !==1) begin          
       CK_sc=INITNreg & !STDBYreg & !SLEEPreg & ATPreg & CKreg_dft ;
     end     
   end // if (init_pulse_done 
 end // if (supply_ok 
end // always @(CKint_dft)

always @(MEMEN_dft)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) && CKint_dft === 1'bx)  begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.MEMEN_dft and clock should not be X at this time instant. ScanChains and ScanOuts Corrupted ",$realtime); 
    Invalid_next_cycle_dft;
    
    if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
      WriteOutX;
    end
  end
  if ( MEMEN_dft !== 0 && TBYPASSsys !== 0 && SEsys !== 1) begin
     WriteOutX;
     OutReg_data = WordX; 
     delOutReg_data=WordX;
 end 
end
end //always @(MEMEN_dft

always @(TBYPASSsys or ATPint)
begin
   if(supply_ok === 1'b1) begin 
    if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0 && INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1) begin
      if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
    end  
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint === X && SEsys !== 1) ) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end 
end //always @(TBYPASSint





always @(SEsys)
begin
 if(supply_ok === 1'b1) begin 
  if(CKint_dft === 0 && ATPint === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
    if(SE_reg === 1'b1 && SEsys === 1'b0) begin
      if(TBYPASSsys === 1'b1) begin
          
  
        OutReg_data_scan = { scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9],
scanreg_dl_wire[10], scanreg_dl_wire[scanlen_l-1]};  


        for (i = 0; i < Bits; i = i + 1)
        begin
         if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
        end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
      end
    end
  end
  if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0) begin
      if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
  end 
  else if ((TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint === X && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end   
end

//assign output data
`ifdef functional        

   
always @(SDLOint)
#0.001 delSDLO_data<=SDLOint;

always @(SDROint)
#0.001 delSDRO_data<=SDROint;

 
always @(SCTRLOint)
#0.001 delSCTRLO_data<=SCTRLOint;


always @(OutReg_data)
   #0.001 delOutReg_data = OutReg_data;
`else
`endif

/***************************** Embeded switch functionality starts here ***********************************/





always @(STDBYint)
begin
  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0 && STDBYint !== 1'b0)
    begin
      ScanOutX;
      ScanChainX;
     delScanOutX;     
    end
  end
end



always @(SLEEPint)
begin


  if (SLEEPint !== 1'b1) begin
    time_fall_sleep = $realtime;
  end

  if (power_up_done === 0)
    begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
    end
  else begin
    if (SLEEPint === 1'b1 && lastSLEEP === 1'b0 ) begin 
      
    end
    else if (SLEEPint !== 1'b1 && lastSLEEP === 1'b1 && full_shutdown !== 1) begin 
      
      if (supply_ok !== 1 && ($realtime > 0)) begin
         if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID LOW_POWER) ERROR: ISOLATION signal removed from the memory but array and periphery supply is not completely switched on.Very High Current would be drawn by the memory. All further operations on memory are blocked",$realtime);
          WriteMemX;
          WriteOutX;
          ScanChainX;
          OutReg_data = WordX; 
          delOutReg_data=WordX;
          ScanOutX;//immediately;
          delScanOutX;//immediately;
          init_pulse_done = 0;
          power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            debug_level = 2'b11;
          `endif
          
      end        
      
       
    end   
    else if (SLEEPint === X && lastSLEEP === 1'b0 && full_shutdown !== 1'b1) begin 
     
    end 
  end  


  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && SLEEPint !== 0)
    begin
      ScanOutX;
      ScanChainX;
        delScanOutX;      
    end
  end

// if (init_pulse_done === 0)
//   begin
//     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
//   end
//
// else if ( SLEEPint !== 1 && (supply_ok !==1) ) begin
//    
//    WriteOutX;
//    OutReg_data = WordX; 
//    delOutReg_data=WordX;
//    ScanOutX;//immediately;
//    delScanOutX;//immediately;
//    ScanChainX;
//    WriteMemX;
//    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies with sleep/Power down signal being low.This scenario can lead to high dc currents and some reliability issues Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
// end

 print_sleep;    
 lastSLEEP=SLEEPint;
end

/********************************** Embeded switch functionality ends here *******************************/

task print_sleep;
begin
  if (SLEEPint === 1'b0) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been deasserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end  
  else if (SLEEPint === 1'b1) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been asserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_ACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif

  end        
  else begin
      if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) ERROR: SLEEP pin is at an invalid state.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INVALID in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end        
end
endtask





 

//// C28SOI non flip compiler power functionality 
always @(gndmreg )
begin
 if (power_up_done === 1 && $realtime > 0) begin    
    if(gndmreg !== 1'b0 ) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or gndsm is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
        corrupt_all;
        init_pulse_done = 0;
        power_up_done = 0;
     `ifdef NO_BLOCK_MEM
     `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of ground pins.Ground must be maintained at 0 Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime);
        debug_level = 2'b11;
     `endif   

    end   
 end

end




always @(vddmareg )
begin

if (vddmareg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddma(Array Supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 
    end
   end   
   else if (SLEEPint === 1) begin
    WriteMemX;
   end

end

if ((vddmareg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1 ) && $realtime > 0) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddm or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         corrupt_all;
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif

end


end

always @(vddmpreg )
begin
 if (vddmpreg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or vddsmp is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmp(Periphery Supply)/vddsmp(Substrate power supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 

    end
   end   
   else if (SLEEPint === 1) begin
    WriteOutX;
    ScanChainX;
    ScanOutX;
    delScanOutX;//immediately;
    OutReg_data = WordX; 
    delOutReg_data=WordX;
   end
 end

if( (vddmpreg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1'b1 )  && $realtime > 0) begin
         corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif
end
 
 
end


always @(vddmoreg)
begin
  if (power_up_done === 1 && $realtime > 0) begin   
      if (vddmoreg !== 1'b1)  begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin
           corrupt_all;
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
         end //if (vddmareg === 1'b1 

      else if (vddmareg === 1'b0 && vddmpreg === 1'b0   && SLEEPint === 1'b1 &&  $realtime > 0)
        begin 
            if((debug_level < 2) && ($realtime > 0)) $display("%m - %t WARNING: Illegal Value on power pin(s). Memory and Output Corrupted ", $realtime);
 
           corrupt_all;
        end //else if (vddmareg === 1'b 
     end   // if (vddmoreg !== 1'b1)
     else if (vddmoreg === 1'b1 && $realtime > 0 ) begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin     
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           corrupt_all;
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
        end        
     end // else if (vddmoreg === 1'b1
  end 
end // always @(vddmoreg)












always @(gndmreg) begin
 if (gndmreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 0. ",$realtime);
 end
 else if (gndmreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 1. ",$realtime);
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to invalid state. ",$realtime);
 end
end




 
always @(vddmareg) begin
 if (vddmareg === 0) begin 
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 0. ",$realtime);
  vddma_fall_time = $realtime;
 end
 else if (vddmareg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 1. ",$realtime);
  vddma_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to invalid state. ",$realtime);
  vddma_fall_time = $realtime;
 end 

 

end

always @(vddmpreg) begin
 if (vddmpreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 0. ",$realtime);
  vddmp_fall_time = $realtime;
 end
 else if (vddmpreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 1. ",$realtime);
  vddmp_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to invalid state. ",$realtime);
  vddmp_fall_time = $realtime;
 end

 
 
end



// end of C28SOI power functionality 
 


assign supply_ok          =  (vddmareg === 1'b1 && vddmpreg  === 1'b1  && gndmreg === 1'b0 && vddmoreg === 1'b1 ) ? 1'b1 : 1'b0;
assign core_supply_ok     =  (vddmoreg === 1'b1 && vddmareg === 1'b1 && gndmreg === 1'b0 ) ? 1'b1 : 1'b0;
assign peri_supply_ok     =  (vddmoreg === 1'b1 && vddmpreg === 1'b1 && gndmreg === 1'b0  ) ? 1'b1 : 1'b0;

assign full_shutdown = (vddmpreg === 1'b0 && vddmareg === 1'b0   ) ? 1'b1 : 1'b0 ;




`ifdef functional
`else


task WriteLocMskX_bwise;
   input [Addr-1 : 0] Address;
   input [Bits-1 : 0] Mask;

reg [Bits+Red_extrabit:0] tempReg1;
integer num1; 
begin
   tempReg1 = WordX;
   if (^Address !== X )
   begin
      tempReg1 = Mem[Address];
             
      for (j = 0;j< Bits; j=j+1) begin
         num1=j;
        if (Mask[j] === 1'bx)
            tempReg1[num1] = 1'bx;
      end
      Mem[Address] = tempReg1;
      task_insert_faults_in_memory;
   end//if (^Address !== X
   else begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      WriteMemX;
   end   
end
endtask


/****************Actions taken on timing violations*****************/

 always @(TimingViol_data)
// tds or tdh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  for (l = 0; l < Bits; l = l + 1) begin   
    if (CSWEMTBYPASS[l] !== 0) begin
     if((TimingViol_data[l] !== TimingViol_data_last[l])) begin


         Mreg[l] = 1'bx;
     end    
     WriteLocMskX_bwise(Areg,Mreg);
    end   
   end 
  end
    if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin
     scanreg_dl =1'bx; 
     scanreg_dr =1'bx; 
     SDLOint=X;
     SDROint=X;
     `ifdef functional
     `else
     SDLO_data<=1'bx;
     SDRO_data<=1'bx;
     `endif
    end
     TimingViol_data_last = TimingViol_data; 
end





always @(TimingViol_addr)
// tas or tah
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
      scanreg_ctrl=1'bx; 
      SCTRLOint=X;
      `ifdef functional
      `else
      SCTRLO_data<=1'bx;
      `endif
  end
end


always @(TimingViol_WEN)
//tws or twh
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WEN pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end 

always @(TimingViol_CSN )
// tps or tph 
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;

   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CSN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end

always @(TimingViol_tcycle )
//tcycle
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
   if (MEMEN !== 0 && MEMEN_prev !== 0) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckl )
// tckl 
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckh) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end


always @(TimingViol_tcycle_se )
//tcycle_se
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckl_se  )
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckh_se) begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tbist) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
   end
   if (TBYPASSint !== 1'b0) begin 
    WriteOutX;
   end 
   if (INITNreg !==0 && STDBYreg !== 1 && TBYPASS_reg !== 1 && SLEEPreg !== 1 && SE_reg !== 1 && IGreg !== 1 && DEreg !== 1) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBIST pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end






always @(TimingViol_tbypass)
//ttmck
begin
#0  
  WriteOutX;
  if (INITNreg !== 0 && SLEEPreg !== 1 && SE_reg !== 1 && STDBYreg !== 1 &&  DEreg !== 1) begin
   Invalid_next_cycle_dft_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
end



always @(TimingViol_sleep)
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_stdby)
begin
#0
  if (CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin 
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (ATPreg !== 0) begin 
   Invalid_next_cycle_dft_tim;
  end
end






always @(TimingViol_se) begin
#0
   if (TBYPASS_reg !== 0) begin 
    WriteOutX;
   end 
  if (TBYPASS_reg === 0) begin
     WriteOutX;
     WriteMemX;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE timing violation  Memory State Machine is corrupted. Output Corrupted ",$realtime); 
  end 
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
  end
end

always @(TimingViol_sctrli) begin
  scanreg_ctrl=1'bx; 
end


always @(TimingViol_sdli) begin
 scanreg_dl=1'bx; 
end

always @(TimingViol_sdri) begin
   scanreg_dr=1'bx;
end

 

always @(TimingViol_initnl) begin
init_pulse_done=0;
WriteOutX;
OutReg_data = WordX; 
delOutReg_data=WordX;
ScanOutX;
delScanOutX;
ScanChainX;
WriteMemX;
end

always @(TimingViol_initn) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end

always @(TimingViol_ig) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && INITNreg !== 0 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: IG pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   ScanChainX;
   ScanOutX;
   delScanOutX;       
  end
end

always @(TimingViol_atp) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin  
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_rm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^WMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: RM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
   end
end
 
always @(TimingViol_wm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^RMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);        
   end
end 


`endif


endmodule




module ST_SPREG_LOLEAK_256x21m2_Tl_lock_up_latch (EN,D,Q);
input EN,D;
output reg Q;

  always @ (EN or D) begin
    if (EN === 1) begin
       Q = D;
    end
    else if ((EN === 1'bz || EN === 1'bx  )&& D !== Q) begin
        Q=1'bx;
    end    
  end
endmodule

module ST_SPREG_LOLEAK_256x21m2_Tl_SCFF (D,TI,TE,CP,Q,OUTX);
input D,TI,TE,CP;
input OUTX;
output reg Q;
wire Dint;
assign Dint= (TE===1)?TI:(TE===0)?D:1'bx;

always @(posedge CP)
        begin
          if(Dint === 1'bZ || CP ===1'bx || OUTX === 1'bx)
          begin
                  Q = 1'bx;
          end
          else
          begin
                  Q = Dint;
          end        
        end
always @(posedge OUTX)
Q = 1'bx;
endmodule



`undef setup_time
`undef hold_time
`undef access_time
`undef retain_time
`undef cycle_time
`undef pulse_width_time
`undef initin_low_pulse


`delay_mode_path
`endcelldefine
`nosuppress_faults






/****************************************************************
--  Description         : Verilog Model 
--  ModelVersion        : 1.2
--  Date                : Apr, 2013
--  Changes Made by	: PS
--  Revision History    : 
 
****************************************************************/


/******************** START OF HEADER****************************
   This Header Gives Information about the parameters & options present in the Model
   
   words = 64
   bits  = 23
   mux   = 4 
   
   
   
   write_mask = no 
   
   margin_control = yes 
   
   
   Dft = Yes  

    ------------------------------------------------------------------------------------
     Signal Name             | Description       |             Port Mode        | Active When
                             |                   |          r    |  w   | rw    |
   ------------------------------------------------------------------------------------

    D 	        Data in                     na     x      na       -  
    IG    Input Gate Enable           x      x      na       High     
    ATP            ATPG Enable                 x      x      na       High     
    INITN                 INITN pin                   x      x      na       Low
    
    
     
    Q 	        Data out	            x      na     na       -
    A              Address                     x      x      na       high and low
    
    CK                Clock	                    x      x      na       posedge
    CSN          Chip Enable                 x      x      na       low
    
    RM         Read Margins                 x      x      na       High 
    SCTRLI         Scan Input (Control)
    SCTRLO        Scan Output (Control)
    SDLI         Scan Input (Data-Left)
    SDLO        Scan Output (Data-Left)
    SDRI         Scan Input (Data-Right)
    SDRO        Scan Output (Data-Right)
    SE          Scan Enable pin 
    STDBY              Standby pin                 x      x      na       High
    
    SLEEP                        Sleep pin                   x      x      na        High 
    
     
     
    TBIST          Bist Enable Pin 
    
    TBYPASS                      Memory Bypass                na     na     na        High
    
    TED        Bist Even Data pin
    TOD         Bist Odd Data Pin
     
    TA         Bist Read Address
    TCSN     Bist Read Chip Select
    
    TWEN    Bist Write Enable 
    WEN         Write Enable                na     x      na       Low 
    
    WM        Write Margins Code          x      x      na       -
     

******************** END OF HEADER ****************************/


//********************************************//
// ST_SPREG_LOLEAK_64x23m4_Tl Verilog Model                 //  
//********************************************//




`ifdef slm
        `define functional
`endif

`celldefine
`suppress_faults
  `ifdef functional
   `delay_mode_unit
  `else
   `delay_mode_path
  `endif

`define setup_time 0.0
`define hold_time 0.0
`define access_time 1.0
`define retain_time 0.9
`define cycle_time 0.0
`define pulse_width_time 0.0
`define initin_low_pulse 0.0



 






`timescale 1ns / 1ps


module ST_SPREG_LOLEAK_64x23m4_Tl (A,ATP,CK,CSN,D ,IG,INITN , Q ,RM    ,SCTRLI,SCTRLO,SDLI,SDLO,SDRI,SDRO,SE,SLEEP   , STDBY  ,TA,TBIST   ,TBYPASS ,TCSN,TED ,TOD   ,TWEN ,WEN,WM  );

 parameter
  Words = 64,
  Bits = 23,
  Addr = 6,
  mux = 4,
  repair_address_width = 4,
  write_margin_size = 2, 
  read_margin_size = 3; 

 //  INPUT OUTPUT PORTS DECLARATION DONE SEPARATELY FOR SPREG and ROM
 // ========================


        output [Bits-1 : 0] Q;
         
        output SCTRLO;
        input SE,SCTRLI;
        
        input [Addr-1 : 0] A;
        
        input [read_margin_size-1 : 0] RM;
        
         
        input CK,CSN,INITN,IG,ATP; 
        
        
        input [Addr-1 :0 ] TA;
input TBIST,TCSN ;
        
        input STDBY;
        
        input SLEEP; 
        
         
        
        
         
        output SDLO;
        output SDRO;
        
        
        
        
        input [Bits-1 : 0] D ;
	
          
         
        
        input [write_margin_size-1 : 0] WM;
        
        
        input TBYPASS;
        
        input WEN;
        
        
         
        input SDLI,SDRI  ; 
        
        
        
        //Bist inputs
        // ===========
        input TWEN,TED,TOD; 
        
        
        
        

        






    parameter
        Fault_file_name = "ST_SPREG_LOLEAK_64x23m4_Tl_faults.txt",
        `ifdef ConfigFault
        ConfigFault = 1,
        `else
        ConfigFault = 0,
        `endif
        max_faults = 66,
        
        MEM_INITIALIZE  = 1'b0,
        BinaryInit = 1'b0, 
        InitFileName = "ST_SPREG_LOLEAK_64x23m4_Tl.cde",
        Debug_mode = "all_warning_mode",
        File_load_time=0,
        Initn_reset_value={23{1'b0}},
        InstancePath = "ST_SPREG_LOLEAK_64x23m4_Tl";
    
    parameter
        
        bank = 1, 
        mux_bits=2,
        Red_extrabit=0,
        bank_bits = 0,
        RedWords = mux * 2 * bank,
        max_address_bits = 15 ,
        Rows = Words/mux;

  
    parameter 

     

        
           scanchains=3,    
          
        
        scanlen_ctrl=15,
        
        

      

        
        scanlen_r=(Bits)/2,
        
        scanlen_l=(Bits+1)/2 ; 
      
      

    parameter
        
        `ifdef functional  
            RW_assertions_en = 0,
        `endif
        WordX = {Bits{1'bx}},
        AddrX = {Addr{1'bx}},
        Word0 = {Bits{1'b0}},
        X = 1'bx;
   



//  WIRE DECLARATION RELATED TO POWER PINS
//  ======================================
	
        wire supply_ok, full_shutdown;
        
        wire core_supply_ok;
        wire peri_supply_ok;

        wire gndmint, gndsmint;
         
        
        wire vddmpint;
        wire vddmoint;
        wire vddmaint;
        wire vddsmpint;  
        wire vddsmaint;  
        
        

//  WIRE DECLARATION 
//  ==================
        wire [Bits-1 : 0] CSWEMTBYPASS;
        wire [Bits-1 : 0] Dint, Dsys;
        wire [Bits-1 : 0] Mint; 
        wire [23-1:0] Msys;
	wire [Addr-1 : 0] Aint;
        wire [Addr-1 : 0] Asys;

       


        wire [max_address_bits-1 : 0] A_int; 
                
	wire CKint_dft;
	wire CKint_func;
	wire CSNint;
        wire MEMEN;
        wire MEMEN_dft;
        wire TSE;

	wire WENint;
	wire WENsys;
        wire SLEEPint;
        wire STDBYint;
        wire SEint;
        wire SEsys;
        wire SCTRLIint;
        wire SDLIint;
        wire SDRIint;
        
        wire INITNint;
        wire TBYPASSint;
        wire TBYPASSsys;
        wire LSint; 
        wire HSint; 
        wire ATPint;
        wire DEint;
        
        wire [Addr-1 : 0] TAint;
        wire TBISTint;
        wire TBISTsys;
        wire TCSNint;
        wire TEDint;
        wire TODint;
        wire TEMint;
        wire TOMint;
        wire [Bits-1 : 0] TMint;
        wire [Bits-1 : 0] TDint;
        wire TWENint;
        wire IGint;
        wire IGbuf;
        wire CSNbuf;
        wire WENbuf;
        wire [read_margin_size-1:0] RMint;
        wire [write_margin_size-1:0] WMint;

        //Wires for scan chains
        //  ====================     
        wire [scanlen_ctrl -1:0]scanreg_ctrl_wire;
        wire [scanlen_l -1:0]  scanreg_dl_wire; 
        wire [scanlen_r -1:0]  scanreg_dr_wire; 
   
        wire [scanlen_l -1:0]  scanreg_ml_wire; 
        wire [scanlen_r -1:0]  scanreg_mr_wire; 


        wire [repair_address_width -1 : 0] RRAint;
        wire RRAEint;
        wire TRRAEint;    
        wire red_en;
        wire [repair_address_width -1 : 0] repair_add, next_repair_add;


//  REG DECLARATION
//  ====================     
        reg MEMEN_reg;
        reg MEMEN_prev;
        reg reg_mem_block;
        reg flag_mem_block;
        reg SCTRLIint_temp;
        reg SDLIint_temp;
        reg SDRIint_temp;
        reg SMLIint_temp;
        reg SMRIint_temp;

        //  REG DECLARATION
        //  ====================
        reg SCTRLOint;
        
        reg SDLOint,SDROint;
         
        
        reg next_cycle_corrupt_func;
        reg next_cycle_corrupt_dft;
        reg [Bits-1 : 0] delOutReg_data;//delayed Output Register
        reg [Bits-1 : 0] OutReg_data;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_tbypass;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_scan;   // Data Output registe
        reg [Bits-1 : 0] OutReg_rado_retained;   // register for retaining rado data when SLEEP --> 1
        reg delSCTRLO_data,SCTRLO_data;      // delayed Output Register
        reg delSDLO_data,SDLO_data;      // delayed Output Register
        reg delSDRO_data,SDRO_data;      // delayed Output Register
        
        
        // SCAN CHAINS register
        reg scanreg_ctrl; 
        reg scanreg_dl; 
        reg scanreg_dr; 
        
        
        reg CK_sc;
        reg Latch_open=0;
        reg lastCK_dft,CKreg_dft;
        reg lastCK_func,CKreg_func;
        reg lastSLEEP;
        reg lastPSWLARGEMP,lastPSWLARGEMA,lastPSWSMALLMP,lastPSWSMALLMA;
        reg CSNreg;
        reg init_pulse_done; //if == 1 then it implies that initb low pulse has been applied
        reg power_up_done; //if == 1 then it implies that power up has been done
        `ifdef slm
        `else
	      
             reg [Bits-1 : 0] Mem [Words-1 : 0];
             reg [Bits-1 : 0] RedMem [RedWords-1 : 0];
 
        `endif
        
	reg [Bits-1 :0] Mem_temp;
        reg [Bits-1 :0] Mem_slm; 
	reg ValidAddress;
	reg ValidDebugCode;
        reg decoding_start;
        reg file_loaded;
        reg [Bits-1 :0] Dreg;
        reg [Bits-1 :0] Mreg;
        reg WENreg;
        reg [Addr-1 :0] Areg;
        reg SE_reg;
        reg TBYPASS_reg;
        reg INITNreg;
        reg IGreg;
        reg DEreg;
        reg SLEEPreg;
        reg STDBYreg;
        reg ATPreg;
        reg MEMEN_dft_reg;
        reg MEMEN_dft_prev;
        reg RRMATCHreg;
        reg RRMATCHreg_last;//changes_made
        reg RRMATCHreg_glitch;
        reg [repair_address_width -1 : 0] repair_add_last;
        reg RRAEint_last;
        reg [Addr-mux_bits-1:0] row_add_temp;
        reg [Addr-mux_bits-bank_bits-1:0] row_add_cmp_temp;

       
        //parameter registers
        reg [2047:0] reg_Fault_file_name;
        reg reg_ConfigFault;
        reg reg_MEM_INITIALIZE;
        reg reg_BinaryInit;
        reg [2047:0] reg_InitFileName;
        reg [Bits -1 :0] reg_Initn_reset_value;
        time reg_File_load_time;

        //Power Supply Registers        
        reg vddmireg;
        reg vddmreg;
        reg vddsmreg;
        reg gndmreg;
        reg gndsmreg;   
        reg vddmpreg;
        reg vddmpireg;
        reg vddmareg;
        reg vddsmpreg;
        reg vddsmareg;
        reg vddmoreg;
        time vddmp_rise_time;
        time vddmp_fall_time;
        time vddsmp_rise_time;
        time vddsmp_fall_time;
        time vddma_rise_time;
        time vddma_fall_time;
        time vddsma_rise_time;
        time vddsma_fall_time;
        reg reg_check_rise;
        reg reg_check_fall;
        reg reg_check_rise_vddma;
        reg reg_check_fall_vddsma;
        reg  reg_check_rise_vddm, reg_check_fall_vddsm ;
        time vddm_fall_time,  vddm_rise_time,  vddsm_fall_time, vddsm_rise_time ;
  /* This register is used to force all warning messages 
  ** OFF during run time.
  ** It is a 2 bit register.
  ** USAGE :
  ** debug_level_off = 2'b00 -> ALL MESSAGES(INFO/WARNINGS/ERRORS) will be DISPLAYED 
  ** debug_level = 2'b01     -> ONLY WARNINGS/ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b10     -> ONLY ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b11     -> NO MESSAGES will be DISPLAYED.
  */ 
        reg [1:0] debug_level;
        reg [8*10: 0] operating_mode;
        reg [8*44: 0] message_status;

        integer i, k, j, l,m,q,w,r,s,num1,redcnt,n,num2,FirstHalf,Bfaileff,memcnt,ptr;
        integer decoder[Bits-1:0];
        `ifdef slm
           integer MemAddr;
        `endif


        //************************************************************
        //****** CONFIG FAULT IMPLEMENTATION VARIABLES*************** 
        //************************************************************ 

        integer file_ptr, ret_val;
        integer fault_word;
        integer fault_bit;
        integer fcnt, Fault_in_memory,faultnum,stop_loop,count;
        integer t;  
        integer FailureLocn [max_faults -1 :0];
        integer Failurebit [max_faults -1 :0];
        reg [100 : 0] stuck_at;
        reg [100 : 0] fault_array;
        reg [200 : 0] tempStr;
        reg [7:0] fault_char;
        reg [7:0] fault_char1; // 8 Bit File Pointer
        reg [Addr -1 : 0] std_fault_word;
        reg [Addr -1 : mux_bits] fault_row_add [max_faults -1 :0];
        reg [max_faults -1 :0] fault_repair_flag;
        reg [max_faults -1 :0] dont_insert_fault;
        reg [max_faults -1 :0] repair_flag;
        reg [100 : 0] array_stuck_at[max_faults -1 : 0] ;
        reg [100 : 0] mem_red_array_stuck_at[max_faults -1 : 0] ; 
        reg msgcnt;
        
       
        reg [Bits - 1: 0] stuck_at_0fault [max_faults -1 : 0];
        reg [Bits - 1: 0] stuck_at_1fault [max_faults -1 : 0];
        reg [Bits -1 : 0] stuck0;
        reg [Bits -1 : 0] stuck1;

        reg [Bits+Red_extrabit :0] Mem_last;
        

        `ifdef slm
        reg [Bits -1 : 0] slm_temp_data;
        `endif
        
        real time_CK_func_rise , time_RADCK_rise;
        real time_fall_sleep,time_fall_PSWLARGEMP,time_fall_PSWLARGEMP_0,time_fall_PSWLARGEMA,time_fall_PSWLARGEMA_0,time_fall_PSWSMALLMP,time_fall_PSWSMALLMA;
        integer flag_error;
        
//BUFFER INSTANTIATION
//=========================
       `ifdef functional
       
         buf (SCTRLO,delSCTRLO_data); 
         buf bufq [Bits-1:0] (Q,delOutReg_data);
      `else
       
         buf (SCTRLO,SCTRLO_data);
         buf bufq [Bits-1:0] (Q,OutReg_data);
      `endif
      
  
        buf (SEsys,SE);
	buf (SCTRLIint, SCTRLI);
   

	buf (CKint_func, CK);
	buf (CKint_dft, CK);
        buf bufaddr [Addr-1:0] (Asys,A);
        buf (INITNint,INITN);
        
        buf (LSint,1'b0); 
        buf (IGbuf,IG);
        buf (ATPint,ATP);

        buf bufTaddr [Addr-1 : 0] (TAint,TA);
        buf (TBISTsys,TBIST);
        buf (TCSNint,TCSN);

        buf (CSNsys,CSN);
        buf (STDBYint,STDBY );   
        
        buf (SLEEPint,SLEEP ); 

        buf bufrm [read_margin_size-1:0] (RMint, RM); 

        
        

        assign RRAEint = 1'b0;
        assign TRRAEint = 1'b0;
        assign repair_add = 0;
        assign next_repair_add = 0;
        assign red_en = 1'b0; 
        
        
        
        
        
        
        
        buf (PSWLARGEMPint,1'b0);
        buf (PSWSMALLMPint,1'b0); 
        buf (PSWLARGEMAint,1'b0);
        buf (PSWSMALLMAint,1'b0);   

      `ifdef functional
       
       
         buf (SDLO,delSDLO_data);
         buf (SDRO,delSDRO_data);
        
      `else
       
         buf (SDLO,SDLO_data);
         buf (SDRO,SDRO_data);
         
      `endif
       
         
       
        buf bufdata [Bits-1:0] (Dsys,D);
        
        
        assign Msys=23'b0; 
	

        
        buf (TBYPASSsys, TBYPASS);
        


        buf (WENsys,WEN);
	 
	buf (SDLIint, SDLI);
	buf (SDRIint, SDRI);
	 
        
        buf (HSint,1'b0); 

        
        buf (TEDint,TED);
        buf (TODint,TOD);
         
        buf (TWENint,TWEN);
        
        
        buf bufwm [write_margin_size-1:0] (WMint, WM); 
        



//      assign scanreg_ctrl_wire={scanreg_ctrl[scanlen_ctrl - 2:0],SCTRLIint};
//      assign scanreg_dl_wire={scanreg_dl[scanlen_l - 2:0],SDLIint};
//      assign scanreg_dr_wire={scanreg_dr[scanlen_r - 2:0],SDRIint};
      
        
      assign Aint   = (TBISTint === 1'b0 ) ? Asys : (TBISTint === 1'bx ) ? {Addr{1'bx}} : TAint;  

        
//        assign A_int = Aint;
	
        
                
        assign Dint[0] = (TBISTint === 1'b0) ? Dsys[0] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[1] = (TBISTint === 1'b0) ? Dsys[1] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[2] = (TBISTint === 1'b0) ? Dsys[2] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[3] = (TBISTint === 1'b0) ? Dsys[3] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[4] = (TBISTint === 1'b0) ? Dsys[4] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[5] = (TBISTint === 1'b0) ? Dsys[5] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[6] = (TBISTint === 1'b0) ? Dsys[6] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[7] = (TBISTint === 1'b0) ? Dsys[7] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[8] = (TBISTint === 1'b0) ? Dsys[8] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[9] = (TBISTint === 1'b0) ? Dsys[9] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[10] = (TBISTint === 1'b0) ? Dsys[10] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[11] = (TBISTint === 1'b0) ? Dsys[11] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[12] = (TBISTint === 1'b0) ? Dsys[12] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[13] = (TBISTint === 1'b0) ? Dsys[13] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[14] = (TBISTint === 1'b0) ? Dsys[14] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[15] = (TBISTint === 1'b0) ? Dsys[15] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[16] = (TBISTint === 1'b0) ? Dsys[16] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[17] = (TBISTint === 1'b0) ? Dsys[17] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[18] = (TBISTint === 1'b0) ? Dsys[18] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[19] = (TBISTint === 1'b0) ? Dsys[19] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[20] = (TBISTint === 1'b0) ? Dsys[20] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[21] = (TBISTint === 1'b0) ? Dsys[21] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[22] = (TBISTint === 1'b0) ? Dsys[22] : (TBISTint === 1'b1) ? TEDint : 1'bx;          
	 
        assign Mint = 23'b0;
         

        assign WENbuf = (TBISTint === 1'b0 ) ? WENsys : (TBISTint === 1'bx ) ? 1'bx : TWENint;  
        assign WENint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? WENbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[13] : (ATPint === 1'b0 ) ? WENsys : 1'bx ; 
        
        assign CSNbuf = (TBISTint === 1'b0 ) ? CSNsys : (TBISTint === 1'bx ) ? 1'bx : TCSNint;  
        assign CSNint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? CSNbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[11] : (ATPint === 1'b0 ) ? CSNsys : 1'bx ; 
        assign IGint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? IGbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[14] : (ATPint === 1'b0 ) ? IGbuf : 1'bx;

        
        assign DEint = (LSint === 1'bx || (LSint === 1'b0 && HSint === 1'bx) || ^RMint !== 1'b0 || ^WMint !== 1'b0 ) ? 1'bx : 1'b0;
        
     
     and (TBISTint, ATPint, TBISTsys);
     and (SEint, ATPint, SEsys);
     and (TBYPASSint, ATPint, TBYPASSsys);
     and (TSE,TBYPASSint,!SEsys);
     and (MEMEN,INITNint,!CSNint,!SLEEPint,!TBYPASSint,!SEint,!IGint,!DEint,!STDBYint );
     and (MEMEN_dft,INITNint, !SLEEPint, ATPint,!STDBYint);

 `ifdef functional
/*****************assertions added to optimize dynamic power consumption**********/

//psl a_M: assert always ({( RW_assertions_en);(MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1))  } |-> (stable(Msys))) @(posedge CK); 

//psl a_WEN: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(WENsys))) @(posedge CK); 

//psl a_A: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(Asys))) @(posedge CK); 

//psl a_D: assert always ({( RW_assertions_en);((MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1)) && TBYPASSint === 1'b0)  } |-> (stable(Dsys))) @(posedge CK); 

/**********************************************************************************************/
`endif       

     

         
reg vddmp,vddmo, vddma, vddsmp, vddsma, gndsm, gndm,  vddmpi ; 
 
initial 
begin

        vddmp = 1'b1 ; 
        vddmo = 1'b1 ;
        vddma = 1'b1 ;
        
        vddsmp = 1'b1 ;
        
        
         gndm = 1'b0 ;
          
end

        
         assign gndmint = (reg_mem_block === 0) ? gndm : 1'b1;
         
         
         
         
         assign vddmpint = vddmp;
         assign vddmoint = vddmo;
         assign vddmaint = vddma;
         
          
        
         

        //CPF Changes

        
                
        initial
        begin : cpfvddmp 
           vddmpreg = vddmpint;
        end

        always @(vddmpint) begin
           vddmpreg = vddmpint;
        end
        
        initial
        begin : cpfvddmo 
           vddmoreg = vddmoint;
        end

        always @(vddmoint) begin
           vddmoreg = vddmoint;
        end
        
        initial
        begin : cpfvddma 
           vddmareg = vddmaint;
        end

        always @(vddmaint) begin
           vddmareg = vddmaint;
        end

        
        
 
        initial
        begin : cpfgndm 
           gndmreg = gndmint;
        end

        always @(gndmint) begin
           gndmreg = gndmint;
        end

        
        



 `ifdef functional
  `else
  initial begin
    if (debug_level < 1) begin
     $display ("%m  INFORMATION");
     $display ("***************************************");
     $display ("The Model is Operating in TIMING MODE");
     $display ("Please make sure that SDF is properly annotated otherwise dummy values will be used");
     $display ("%s", message_status);
     $display ("***************************************");
    end
  end

//////////////////////////
 //REG DECLARATIONS
   //======================

   reg [Bits-1 : 0] TimingViol_data;
   reg  [Bits-1 : 0] TimingViol_mask;
   reg [Bits-1 : 0] TimingViol_data_last, TimingViol_mask_last;
	reg TimingViol_data_0;
	reg TimingViol_data_1;
	reg TimingViol_data_2;
	reg TimingViol_data_3;
	reg TimingViol_data_4;
	reg TimingViol_data_5;
	reg TimingViol_data_6;
	reg TimingViol_data_7;
	reg TimingViol_data_8;
	reg TimingViol_data_9;
	reg TimingViol_data_10;
	reg TimingViol_data_11;
	reg TimingViol_data_12;
	reg TimingViol_data_13;
	reg TimingViol_data_14;
	reg TimingViol_data_15;
	reg TimingViol_data_16;
	reg TimingViol_data_17;
	reg TimingViol_data_18;
	reg TimingViol_data_19;
	reg TimingViol_data_20;
	reg TimingViol_data_21;
	reg TimingViol_data_22;
 reg TimingViol_mask_0;
 reg TimingViol_mask_1;
 reg TimingViol_mask_2;
 reg TimingViol_mask_3;
 reg TimingViol_mask_4;
 reg TimingViol_mask_5;
 reg TimingViol_mask_6;
 reg TimingViol_mask_7;
 reg TimingViol_mask_8;
 reg TimingViol_mask_9;
 reg TimingViol_mask_10;
 reg TimingViol_mask_11;
 reg TimingViol_mask_12;
 reg TimingViol_mask_13;
 reg TimingViol_mask_14;
 reg TimingViol_mask_15;
 reg TimingViol_mask_16;
 reg TimingViol_mask_17;
 reg TimingViol_mask_18;
 reg TimingViol_mask_19;
 reg TimingViol_mask_20;
 reg TimingViol_mask_21;
 reg TimingViol_mask_22;

   reg TimingViol_addr;
   reg TimingViol_CSN, TimingViol_WEN, TimingViol_tbypass;
   reg TimingViol_tckh, TimingViol_tckl, TimingViol_tcycle;
   reg TimingViol_tckh_se, TimingViol_tckl_se, TimingViol_tcycle_se;
   reg TimingViol_sctrli,TimingViol_sdli,TimingViol_sdri,TimingViol_se;
   reg TimingViol_smli,TimingViol_smri;
   reg TimingViol_sctrli_flag,TimingViol_sdli_flag,TimingViol_sdri_flag;
   reg TimingViol_smli_flag,TimingViol_smri_flag;
   reg TimingViol_initnl;
   reg TimingViol_initn;
   reg TimingViol_ls;
   reg TimingViol_hs;
   reg TimingViol_sleep;
   reg TimingViol_stdby;
   reg TimingViol_rm;
   reg TimingViol_wm;
   reg TimingViol_tbist,TimingViol_ig,TimingViol_atp,TimingViol_TED,TimingViol_TOD,TimingViol_TEM,TimingViol_TOM;
   reg TimingViolRRAE,TimingViolRRA;

   wire CSTBYPASSN,cond_sdf_tas,cond_sdf_tds,cond_sdf_tms,cond_sdf_tws,cond_sdf_tbas,cond_sdf_tbps,cond_sdf_tbws,cond_sdf_tbdes,cond_sdf_tbdos,cond_sdf_tbmes,cond_sdf_tbmos;
   wire SETB_EN,CSIG_EN,MEM_ACT,EN_ADM,CS_EN,CS_ADM,cond_sdf_tps,IG_EN,IG_ADM,cond_sdf_tigs,cond_sdf_taa,cond_sdf_taa_ls1,cond_sdf_taa_hs1,cond_tseq_tm;
   wire cond_sdf_tcycle,cond_sdf_tcycle_ls1,cond_sdf_tcycle_hs1,cond_sdf_tcycle_se,cond_sdf_tckl_se,cond_sdf_tsctrlis,cond_sdf_tsdlis,cond_sdf_tsdris,cond_sdf_tsmlis,cond_sdf_tsmris;
   wire cond_sdf_tckh_se,cond_sdf_taa_sctrlo_se,cond_sdf_taa_sdlo_se,cond_sdf_taa_sdro_se,cond_sdf_taa_smlo_se,cond_sdf_taa_smro_se,cond_sdf_tckl,cond_sdf_tckh;
   wire cond_sdf_ttms,cond_sdf_tbists,INITNandnotSLEEPandATPandnotSE,cond_sdf_taa_sctrlo,cond_sdf_taa_sdlo,cond_sdf_taa_sdro,cond_sdf_taa_smlo,cond_sdf_taa_smro;
   wire cond_sdf_taa_tm,cond_sdf_taa_tm_ls1, cond_sdf_taa_tm_hs1,cond_sdf_taa_tckq_tm,cond_sdf_taa_tseq_tm;

   wire CSWETBYPASSN;
   wire cond_sdf_tstdbys,cond_sdf_tsls,sleep_en,atp_csn_en;
   wire cond_sdf_tlss,cond_sdf_thss,cond_sdf_trms,cond_sdf_twms; 
   wire cond_sdf_tses,cond_sdf_tinitns;
   wire tby_se_en;
   wire rra_en;
   wire tbist_atp_en;
   wire rrae_en;
   wire tbist_rrae_en;
   wire cond_sdf_trraes;
   wire cond_sdf_ttrraes;
   wire cond_sdf_taa_trramatch;
   wire cond_sdf_ttrraematch;
   wire cond_sdf_tamatch;
   wire cond_sdf_ttamatch;
   wire cond_sdf_tatpmatch;
   wire cond_sdf_ttbistmatch;



 and (CSWEMTBYPASS[0], !Mreg[0], CSWETBYPASSN);
 and (CSWEMTBYPASS[1], !Mreg[1], CSWETBYPASSN);
 and (CSWEMTBYPASS[2], !Mreg[2], CSWETBYPASSN);
 and (CSWEMTBYPASS[3], !Mreg[3], CSWETBYPASSN);
 and (CSWEMTBYPASS[4], !Mreg[4], CSWETBYPASSN);
 and (CSWEMTBYPASS[5], !Mreg[5], CSWETBYPASSN);
 and (CSWEMTBYPASS[6], !Mreg[6], CSWETBYPASSN);
 and (CSWEMTBYPASS[7], !Mreg[7], CSWETBYPASSN);
 and (CSWEMTBYPASS[8], !Mreg[8], CSWETBYPASSN);
 and (CSWEMTBYPASS[9], !Mreg[9], CSWETBYPASSN);
 and (CSWEMTBYPASS[10], !Mreg[10], CSWETBYPASSN);
 and (CSWEMTBYPASS[11], !Mreg[11], CSWETBYPASSN);
 and (CSWEMTBYPASS[12], !Mreg[12], CSWETBYPASSN);
 and (CSWEMTBYPASS[13], !Mreg[13], CSWETBYPASSN);
 and (CSWEMTBYPASS[14], !Mreg[14], CSWETBYPASSN);
 and (CSWEMTBYPASS[15], !Mreg[15], CSWETBYPASSN);
 and (CSWEMTBYPASS[16], !Mreg[16], CSWETBYPASSN);
 and (CSWEMTBYPASS[17], !Mreg[17], CSWETBYPASSN);
 and (CSWEMTBYPASS[18], !Mreg[18], CSWETBYPASSN);
 and (CSWEMTBYPASS[19], !Mreg[19], CSWETBYPASSN);
 and (CSWEMTBYPASS[20], !Mreg[20], CSWETBYPASSN);
 and (CSWEMTBYPASS[21], !Mreg[21], CSWETBYPASSN);
 and (CSWEMTBYPASS[22], !Mreg[22], CSWETBYPASSN);

and (atp_csn_en,!ATPint,!CSNint,!IGint);
or (sleep_en,atp_csn_en,ATPint);
or (SETB_EN,SEint,TBISTint);
and (ATP_SETB_EN,ATPint,SETB_EN); 
or (CSIG_EN,IGint,CSNint);
and (MEM_ACT,!ATPint,CSIG_EN);
or (EN_ADM,MEM_ACT,ATP_SETB_EN);
and (CS_EN,!ATPint,IGint);
or (CS_ADM,CS_EN,ATP_SETB_EN);
and (atp_ig_csn_en,!ATPint,!CSNint,!IGint);
and (atp_se_en,!SEsys,ATPint);
or (cycle_en,atp_ig_csn_en,atp_se_en);
and (atp_ig_csn_en_reg,!ATPreg,!CSNreg,!IGreg);
and (atp_se_en_reg,!SE_reg,ATPreg);
or (cycle_en_reg,atp_ig_csn_en,atp_se_en);
and (INITNandnotSLEEPandATPandnotSE,cond_gac,!SEsys,ATPint);
and (csn_ig_en,!IGint,!CSNint);
and (atp_tby_ls_en,atp_se_en,cond_ls_tby_en);
and (IG_EN,!ATPint,!CSNint);
or (IG_ADM,IG_EN,atp_se_en);
and (CSWETBYPASSN, !WENreg, 1'b1);



assign cond_sdf_tsls=((sleep_en && INITNint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tstdbys=((sleep_en && INITNint && !SLEEPint) !==0) ? 1:0;
assign cond_sdf_atps=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_gac=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tas=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tds=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tms=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tws=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tps=((cond_gac && !CS_ADM) !==0) ? 1:0;
assign cond_sdf_tcycle=((cond_gac && cycle_en && !LSint && !HSint) !==0) ? 1:0;  
assign cond_sdf_tcycle_ls1=((cond_gac && cycle_en && LSint) !==0) ? 1:0;
assign cond_sdf_tcycle_hs1=((cond_gac && cycle_en && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_tckh=((cond_gac && cycle_en_reg) !==0) ? 1:0;
assign cond_sdf_tckl=((cond_gac && cycle_en) !==0) ? 1:0;
assign cond_sdf_tcycle_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckl_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsctrlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckh_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_ttms=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_tbists=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_tckq_tm=((cond_gac && SE_reg && ATPreg && TBYPASSsys) !==0) ? 1:0;
assign cond_ls_en=((atp_ig_csn_en || atp_tby_ls_en) !==0) ? 1:0;
assign cond_sdf_tlss=((cond_ls_en && cond_gac) !==0) ? 1:0;
assign cond_sdf_thss=((cond_ls_en && cond_gac && !LSint) !==0) ? 1:0;
assign cond_sdf_trms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_twms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_tses=((cond_gac && ATPint) !==0) ? 1:0;
assign cond_sdf_tbas=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbps=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbws=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tigs=((cond_gac && IG_ADM) !==0) ? 1:0;
assign cond_sdf_taa=((MEMEN_reg && WENreg && !LSint && !HSint) !==0) ? 1:0; 
// assign cond_sdf_taa_tbypass_q = ((MEMEN_reg && ATPint && TBYPASSint) !== 1'b0) ? 1'b1 : 1'b0;
assign cond_sdf_taa_ls1=((MEMEN_reg && WENreg && LSint) !==0) ? 1:0; 
assign cond_sdf_taa_hs1=((MEMEN_reg && WENreg && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && !HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_ls1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && LSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_hs1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tseq_tm=((cond_gac && TBYPASSint) !==0) ? 1:0;
assign cond_sdf_tinitns =(( sleep_en && !STDBYint && !SLEEPint) !==0) ? 1:0;
assign cond_ls_tby_en=((TBYPASSsys || csn_ig_en) !==0) ? 1:0;



//specify block begins

specify
    specparam
    
         PATHPULSE$CK$Q = 0,
         PATHPULSE$CK$SCTRLO = 0,

         PATHPULSE$CK$SDLO = 0,
         PATHPULSE$CK$SDRO = 0,
        
         PATHPULSE$SE$Q = 0,
         
//         PATHPULSE$TBYPASS$Q = 0,


        
         
        
         tsls = `setup_time,
         tslh = `hold_time ,
         tstdbys = `setup_time,
         tstdbyh = `hold_time , 
	 

         
         tcycle = `cycle_time,
         
         
         tckh = `pulse_width_time,
         tckl = `pulse_width_time,
         tcycle_se = `cycle_time,
         tckh_se = `pulse_width_time,
         tckl_se = `pulse_width_time,
         
         ttms = `setup_time,
         ttmh = `hold_time ,
         tps = `setup_time,
         tph = `hold_time ,
         tws = `setup_time,
         twh = `hold_time ,
         tds = `setup_time,
         tdh = `hold_time , 
         tas = `setup_time,
         tah = `hold_time ,
         tses= `setup_time,
         tseh= `hold_time ,
         tsctrlis=`setup_time,
         tsctrlih=`hold_time ,
         tsdlis=`setup_time,
         tsdlih=`hold_time ,
         tsdris=`setup_time,
         tsdrih=`hold_time , 
         tbists=`setup_time,
         tbisth=`hold_time ,
         tbps=`setup_time,
         tbph=`hold_time ,
         tbws=`setup_time,
         tbwh=`hold_time ,
         tbdes=`setup_time,
         tbdeh=`hold_time ,
         tbdos=`setup_time,
         tbdoh=`hold_time ,
         
         tbas=`setup_time,
         tbah=`hold_time ,
         tinitnl=`initin_low_pulse,
         tinitns=`setup_time,
         tinitnh=`hold_time ,
         tatps=`setup_time,
         tatph=`hold_time ,
         tigs=`setup_time,
         tigh=`hold_time ,
         
         
         trms=`setup_time,
         trmh=`hold_time ,
         twms=`setup_time,
         twmh=`hold_time , 

/*************************************************************************************************/
           // taa_tbypass_q = `access_time,
           // th_tbypass_q  = `retain_time,
            taa =`access_time,
            th = `retain_time,

 


            taa_tm =`access_time,
            th_tm = `retain_time,

            
            taa_tseq_tm =`access_time,
            th_tseq_tm = `retain_time,
            taa_tckq_tm   = `access_time,
            th_tckq_tm    = `retain_time,
            taa_sctrlo=`access_time,
            th_sctrlo= `retain_time,
            taa_sdlo=`access_time,
            th_sdlo= `retain_time,
            taa_sdro=`access_time,
            th_sdro= `retain_time,
            
         
            taa_sctrlo_se=`access_time,
            th_sctrlo_se= `retain_time
,
            taa_sdlo_se=`access_time,
            th_sdlo_se= `retain_time,
            taa_sdro_se=`access_time,
            th_sdro_se= `retain_time
         ;  


        /*---------------------- Timing Checks ---------------------*/

	$setup(posedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[5], tah, TimingViol_addr);

	$setup(posedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(posedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(posedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(posedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(posedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(posedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(posedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(posedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(posedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(posedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(posedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(posedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(posedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(posedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(posedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(posedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(posedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(posedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(posedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(posedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(posedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(posedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$setup(posedge D[22], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_22);
	$setup(negedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(negedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(negedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(negedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(negedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(negedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(negedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(negedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(negedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(negedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(negedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(negedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(negedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(negedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(negedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(negedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(negedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(negedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(negedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(negedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(negedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(negedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$setup(negedge D[22], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_22);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[21], tdh, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[22], tdh, TimingViol_data_22);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[21], tdh, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[22], tdh, TimingViol_data_22);

        



        $setup(posedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $setup(negedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, posedge WEN, twh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, negedge WEN, twh, TimingViol_WEN); 
        $setup(posedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$setup(negedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, posedge CSN, tph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, negedge CSN, tph, TimingViol_CSN);
        $period(posedge CK &&& cond_sdf_tcycle, tcycle, TimingViol_tcycle);  

        
        $width(posedge CK  &&& cond_sdf_tckh, tckh, 0, TimingViol_tckh);
        $width(negedge CK  &&& cond_sdf_tckl, tckl, 0, TimingViol_tckl);
        $period(posedge CK &&& cond_sdf_tcycle_se, tcycle_se, TimingViol_tcycle_se);
        $width(posedge CK  &&& cond_sdf_tckh_se, tckh_se, 0, TimingViol_tckh_se);
        $width(negedge CK  &&& cond_sdf_tckl_se, tckl_se, 0, TimingViol_tckl_se);

        
        $setup(posedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $setup(negedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $hold(posedge CK &&& cond_sdf_ttms, posedge TBYPASS, ttmh, TimingViol_tbypass); 
        $hold(posedge CK &&& cond_sdf_ttms, negedge TBYPASS, ttmh, TimingViol_tbypass); 
 



        
        $setup(posedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $setup(negedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $hold(posedge CK &&& cond_sdf_tsls, posedge SLEEP, tslh, TimingViol_sleep);        
        $hold(posedge CK &&& cond_sdf_tsls, negedge SLEEP, tslh, TimingViol_sleep);

        $setup(posedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $setup(negedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $hold(posedge CK &&& cond_sdf_tstdbys, posedge STDBY, tstdbyh, TimingViol_stdby);        
        $hold(posedge CK &&& cond_sdf_tstdbys, negedge STDBY, tstdbyh, TimingViol_stdby); 
        
        
        $setup (posedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
	$setup (negedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
        
        $hold (posedge CK &&& cond_sdf_tses, posedge SE ,tseh,TimingViol_se);
	$hold (posedge CK &&& cond_sdf_tses, negedge SE ,tseh,TimingViol_se);
        
        $setup(posedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis , tsctrlis, TimingViol_sctrli);
        $setup(negedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis, tsctrlis, TimingViol_sctrli);
        $hold(posedge CK &&& cond_sdf_tsctrlis , posedge SCTRLI, tsctrlih, TimingViol_sctrli);        
        $hold(posedge CK &&& cond_sdf_tsctrlis , negedge SCTRLI, tsctrlih, TimingViol_sctrli);

        $setup(posedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $setup(negedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $hold(posedge CK &&& cond_sdf_tsdlis, posedge SDLI, tsdlih, TimingViol_sdli);        
        $hold(posedge CK &&& cond_sdf_tsdlis, negedge SDLI, tsdlih, TimingViol_sdli);

        $setup(posedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $setup(negedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $hold(posedge CK &&& cond_sdf_tsdris, posedge SDRI, tsdrih, TimingViol_sdri);        
        $hold(posedge CK &&& cond_sdf_tsdris, negedge SDRI, tsdrih, TimingViol_sdri);
        
 
	
         
        $width(negedge INITN , tinitnl, 0, TimingViol_initnl);
        
        $setup(posedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        $setup(negedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        
        $hold (posedge CK &&& cond_sdf_tinitns,posedge INITN, tinitnh, TimingViol_initn);
        $hold (posedge CK &&& cond_sdf_tinitns,negedge INITN, tinitnh, TimingViol_initn);

        $setup(posedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $setup(negedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $hold(posedge CK &&& cond_sdf_atps, posedge ATP, tatph, TimingViol_atp);        
        $hold(posedge CK &&& cond_sdf_atps, negedge ATP, tatph, TimingViol_atp);
        
        $setup(posedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $setup(negedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $hold(posedge CK &&& cond_sdf_tigs, posedge IG, tigh, TimingViol_ig);        
        $hold(posedge CK &&& cond_sdf_tigs, negedge IG, tigh, TimingViol_ig);



         
$setup(posedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[2], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[2], trmh, TimingViol_rm); 

        
$setup(posedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(posedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[1], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[1], twmh, TimingViol_wm);
 
        
        $setup(posedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $setup(negedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $hold(posedge CK &&& cond_sdf_tbists, posedge TBIST, tbisth, TimingViol_tbist);        
        $hold(posedge CK &&& cond_sdf_tbists, negedge TBIST, tbisth, TimingViol_tbist);
        
        	$setup(posedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$setup(negedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[5], tbah, TimingViol_addr);
       	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[5], tbah, TimingViol_addr);

        $setup(posedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$setup(negedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, posedge TCSN, tbph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, negedge TCSN, tbph, TimingViol_CSN); 
       
        $setup(posedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $setup(negedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, posedge TWEN, tbwh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, negedge TWEN, tbwh, TimingViol_WEN);
       
       
        $setup(posedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $setup(negedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, posedge TED, tbdeh, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, negedge TED, tbdeh, TimingViol_TED);

        $setup(posedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $setup(negedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, posedge TOD, tbdoh, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, negedge TOD, tbdoh, TimingViol_TOD);

          


          

          /*-------------------- Propagation Delays ------------------*/
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[22] +: OutReg_data[22])) = (taa, taa, th, taa, th, taa);
                 

/* // //	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[0] +: OutReg_data[0])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[1] +: OutReg_data[1])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[2] +: OutReg_data[2])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[3] +: OutReg_data[3])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[4] +: OutReg_data[4])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[5] +: OutReg_data[5])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[6] +: OutReg_data[6])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[7] +: OutReg_data[7])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[8] +: OutReg_data[8])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[9] +: OutReg_data[9])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[10] +: OutReg_data[10])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[11] +: OutReg_data[11])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[12] +: OutReg_data[12])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[13] +: OutReg_data[13])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[14] +: OutReg_data[14])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[15] +: OutReg_data[15])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[16] +: OutReg_data[16])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[17] +: OutReg_data[17])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[18] +: OutReg_data[18])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[19] +: OutReg_data[19])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[20] +: OutReg_data[20])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[21] +: OutReg_data[21])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[22] +: OutReg_data[22])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q); */ 








	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[22] +: OutReg_data[22])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                





	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[22] +: OutReg_data[22])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[22] +: OutReg_data[22])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                 

	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[0] +: OutReg_data[0])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[1] +: OutReg_data[1])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[2] +: OutReg_data[2])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[3] +: OutReg_data[3])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[4] +: OutReg_data[4])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[5] +: OutReg_data[5])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[6] +: OutReg_data[6])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[7] +: OutReg_data[7])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[8] +: OutReg_data[8])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[9] +: OutReg_data[9])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[10] +: OutReg_data[10])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[11] +: OutReg_data[11])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[12] +: OutReg_data[12])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[13] +: OutReg_data[13])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[14] +: OutReg_data[14])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[15] +: OutReg_data[15])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[16] +: OutReg_data[16])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[17] +: OutReg_data[17])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[18] +: OutReg_data[18])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[19] +: OutReg_data[19])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[20] +: OutReg_data[20])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[21] +: OutReg_data[21])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[22] +: OutReg_data[22])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                



if (cond_sdf_taa_sctrlo) 
        (posedge CK *> (SCTRLO :  SCTRLI)) = (taa_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo); 

if (cond_sdf_taa_sctrlo_se) 
        (negedge CK *> (SCTRLO : SCTRLI)) = (taa_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se); 
 

if (cond_sdf_taa_sdlo) 
        (posedge CK *> (SDLO :  SDLI)) = (taa_sdlo,taa_sdlo,th_sdlo,taa_sdlo,th_sdlo,taa_sdlo); 

if (cond_sdf_taa_sdlo_se) 
        (negedge CK *> (SDLO : SDLI)) = (taa_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se);

if (cond_sdf_taa_sdro) 
        (posedge CK *> (SDRO :  SDRI)) = (taa_sdro,taa_sdro,th_sdro,taa_sdro,th_sdro,taa_sdro); 

if (cond_sdf_taa_sdro_se) 
        (negedge CK *> (SDRO : SDRI)) = (taa_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se); 

  
     




endspecify //specify block ends






// conversion from registers to array elements for data setup violation notifiers

always @(TimingViol_data_0   or TimingViol_TED  )
begin
        TimingViol_data[0]=~TimingViol_data[0];   
end


always @(TimingViol_data_1   or TimingViol_TOD  )
begin
        TimingViol_data[1]=~TimingViol_data[1];   
end


always @(TimingViol_data_2   or TimingViol_TED  )
begin
        TimingViol_data[2]=~TimingViol_data[2];   
end


always @(TimingViol_data_3   or TimingViol_TOD  )
begin
        TimingViol_data[3]=~TimingViol_data[3];   
end


always @(TimingViol_data_4   or TimingViol_TED  )
begin
        TimingViol_data[4]=~TimingViol_data[4];   
end


always @(TimingViol_data_5   or TimingViol_TOD  )
begin
        TimingViol_data[5]=~TimingViol_data[5];   
end


always @(TimingViol_data_6   or TimingViol_TED  )
begin
        TimingViol_data[6]=~TimingViol_data[6];   
end


always @(TimingViol_data_7   or TimingViol_TOD  )
begin
        TimingViol_data[7]=~TimingViol_data[7];   
end


always @(TimingViol_data_8   or TimingViol_TED  )
begin
        TimingViol_data[8]=~TimingViol_data[8];   
end


always @(TimingViol_data_9   or TimingViol_TOD  )
begin
        TimingViol_data[9]=~TimingViol_data[9];   
end


always @(TimingViol_data_10   or TimingViol_TED  )
begin
        TimingViol_data[10]=~TimingViol_data[10];   
end


always @(TimingViol_data_11   or TimingViol_TOD  )
begin
        TimingViol_data[11]=~TimingViol_data[11];   
end


always @(TimingViol_data_12   or TimingViol_TED  )
begin
        TimingViol_data[12]=~TimingViol_data[12];   
end


always @(TimingViol_data_13   or TimingViol_TOD  )
begin
        TimingViol_data[13]=~TimingViol_data[13];   
end


always @(TimingViol_data_14   or TimingViol_TED  )
begin
        TimingViol_data[14]=~TimingViol_data[14];   
end


always @(TimingViol_data_15   or TimingViol_TOD  )
begin
        TimingViol_data[15]=~TimingViol_data[15];   
end


always @(TimingViol_data_16   or TimingViol_TED  )
begin
        TimingViol_data[16]=~TimingViol_data[16];   
end


always @(TimingViol_data_17   or TimingViol_TOD  )
begin
        TimingViol_data[17]=~TimingViol_data[17];   
end


always @(TimingViol_data_18   or TimingViol_TED  )
begin
        TimingViol_data[18]=~TimingViol_data[18];   
end


always @(TimingViol_data_19   or TimingViol_TOD  )
begin
        TimingViol_data[19]=~TimingViol_data[19];   
end


always @(TimingViol_data_20   or TimingViol_TED  )
begin
        TimingViol_data[20]=~TimingViol_data[20];   
end


always @(TimingViol_data_21   or TimingViol_TOD  )
begin
        TimingViol_data[21]=~TimingViol_data[21];   
end


always @(TimingViol_data_22   or TimingViol_TED  )
begin
        TimingViol_data[22]=~TimingViol_data[22];   
end


`endif


// TASK DEFINITION DESCRIPTION
// ================================



task task_insert_faults_in_memory;
begin
   if (reg_ConfigFault)
   begin   
     for(i = 0;i< fcnt;i = i+ 1) begin
        if(mem_red_array_stuck_at[i] === "mem_array") begin
          if (array_stuck_at[i] === "sa0") begin
           `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data & stuck_at_0fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
          `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] & stuck_at_0fault[i];
          `endif
         end //if(array_stuck_at)
                                        
         if(array_stuck_at[i] === "sa1") begin
         `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data | stuck_at_1fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
         `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] | stuck_at_1fault[i]; 
         `endif
         end //if(array_stuck_at)
       end //if mem_red_array_stuck_at
    
    
     end    // end of for
   end  
end
endtask



task task_read_fault_file;
begin
/*  -----------Implemetation for config fault starts------*/
   msgcnt = X;
   t = 0;
   fault_repair_flag = {max_faults{1'b1}};
   repair_flag = {max_faults{1'b1}};
   if(reg_ConfigFault) 
   begin
      file_ptr = $fopen(reg_Fault_file_name , "r");
      if(file_ptr == 0)
      begin     
          if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: File cannot be opened ",$realtime);
      end        
      else                
      begin : read_fault_file
        t = 0;
        for (i = 0; i< max_faults; i= i + 1)
        begin
         
           stuck0 = {Bits{1'b1}};
           stuck1 = {Bits{1'b0}};
           fault_char1 = $fgetc (file_ptr);
           if (fault_char1 == 8'b11111111)
              disable read_fault_file;
           ret_val = $ungetc (fault_char1, file_ptr);
           ret_val = $fgets(tempStr, file_ptr);
           ret_val = $sscanf(tempStr, "%s %d %d %s",fault_array,fault_word, fault_bit, stuck_at) ;
           flag_error = 0; 
           if(ret_val !== 0)
           begin         
              if(ret_val == 3 || ret_val == 4)
              begin
                if(ret_val == 3)
                   stuck_at = "sa0";

                if(stuck_at !== "sa0" && stuck_at !== "sa1" && stuck_at !== "none")
                begin
                    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: Wrong value for stuck at in fault file ",$realtime);
                   flag_error = 1;
                end    
                      
                if(fault_word >= Words)
                begin
                   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Address out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                if(fault_bit >= Bits)
                begin  
                    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Faulty bit out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                
                        
                if(fault_array !== "mem_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array is not mem_array ",$realtime);
                  flag_error = 1;
                end

                if(fault_array === "red_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array can't be on redundancy array in non redundancy cut.",$realtime);
                  flag_error = 1;
                end

                
                

                if(flag_error == 0)
                //Correct Inputs
                begin
                   if(stuck_at === "none")
                   begin
                       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
                   end
                   else
                   //Adding the faults
                   begin
                      FailureLocn[t] = fault_word;
                      Failurebit[t]  = fault_bit ;
                      std_fault_word = fault_word;
                      fault_row_add[t] = std_fault_word[Addr-1:mux_bits];
                      mem_red_array_stuck_at[t] = fault_array;
                      fault_repair_flag[t] = 1'b0;
                      if (stuck_at === "sa0" )
                      begin
                         stuck0[fault_bit] = 1'b0;         
                         stuck_at_0fault[t] = stuck0;
                      end     
                      if (stuck_at === "sa1" )
                      begin
                         stuck1[fault_bit] = 1'b1;
                         stuck_at_1fault[t] = stuck1; 
                      end

                      array_stuck_at[t] = stuck_at;
                      t = t + 1;
                   end //if(stuck_at === "none")  
                end //if(flag_error == 0)
              end //if(ret_val == 2 || ret_val == 3 
              else
              //wrong number of arguments
              begin
                if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: WRONG VALUES ENTERED FOR FAULTY WORD OR FAULTY BIT OR STUCK_AT IN Fault_file_name ",$realtime); 
                flag_error = 1;
              end
           end //if(ret_val !== 0)
           else
           begin 
               if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
           end    
        end //for (i = 0; i< m
      end //begin: read_fault_file  
      $fclose (file_ptr);

      fcnt = t;
      
      //fault injection at time 0.
      task_insert_faults_in_memory;
  end // config_fault 
end
endtask


task WriteMemX;
begin

`ifdef slm
   $slm_ResetMemory(MemAddr, WordX);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = WordX;
   
`endif        
 task_insert_faults_in_memory;
end
endtask

task WriteMem0;
begin
`ifdef slm
   $slm_ResetMemory(MemAddr, Word0);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = Word0;
  
`endif 
   task_insert_faults_in_memory;
end
endtask


task WriteOutX;                
begin
   OutReg_data <= #0 WordX;
end
endtask


task Invalid_next_cycle_func;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_func = 1;
     `else 
       #0 next_cycle_corrupt_func = 0; 
     `endif  
   end 
end
endtask

task Invalid_next_cycle_dft;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_dft = 1;
     `else 
       #0 next_cycle_corrupt_dft = 0; 
     `endif  
  end
end
endtask

task Invalid_next_cycle_func_tim;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
   #0 next_cycle_corrupt_func <= 1;
  end 
end
endtask

task Invalid_next_cycle_dft_tim;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
  #0 next_cycle_corrupt_dft <= 1;
  end
end
endtask


task ScanOutX;                
begin
   
   dff_SCTRLO_SE.Q <= 1'bx;   
   dff_SDLO_SE.Q <= 1'bx; 
   dff_SDRO_SE.Q <= 1'bx; 
    
   
   SCTRLOint=X;
   SDLOint=X;
   SDROint=X;
    
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   SDLO_data<=1'bx;
   SDRO_data<=1'bx;
    
   `endif
end
endtask

task delScanOutX;                
begin
   delSCTRLO_data<=X;
   delSDLO_data<=X;
   delSDRO_data<=X;
    
end
endtask

task ScanChainX;                
begin
 scanreg_ctrl=1'bx; 
 scanreg_dl=1'bx; 
 scanreg_dr =1'bx; 
  
end
endtask

task mem_blocked;
begin
 
   WriteMemX;
   WriteOutX;
   ScanChainX;
   ScanOutX;//immediately;
   delScanOutX;//immediately
   `ifdef POWER_SEQUENCING_OFF
   `else
   reg_mem_block=1;
   `endif
   debug_level = 2'b11;
end
endtask

task corrupt_all;
begin
 
  WriteMemX;
  WriteOutX;
  ScanChainX;
  ScanOutX;
  delScanOutX;//immediately;
  OutReg_data = WordX; 
  delOutReg_data=WordX;
  
end
endtask

task WriteCycle;                  
input [Addr-1 : 0] Address;
reg [Bits-1:0] tempReg1;
reg [Bits-1:0] tempReg_slm;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;


reg repair_flag;

integer po,i,num,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;
begin

   tempReg1 = WordX;
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];

   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};
   
   if (ValidAddress === X )   begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
        WriteMemX;
        if (INITNint !== 0) begin
        `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
           #0 next_cycle_corrupt_func = 1;
       `else 
           #0 next_cycle_corrupt_func = 0; 
       `endif  
   end 

   end


   if (ValidAddress !== X && next_cycle_corrupt_func === 0  )
   begin
         if (red_en === 1 && ((Row_Add_cmp === repair_add) || (Row_Add_cmp === next_repair_add)) ) begin
             repair_flag = 1'b1;
             
             Bank_sel_integer = 0;
                     
             if (Row_Add_cmp === repair_add) begin
               Col_Add_integer  = Col_Add; 
             end
             else if (Row_Add_cmp === next_repair_add) begin
               Col_Add_integer  = Col_Add + mux; 
             end  
             RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
        end  

        if(repair_flag === 0 && ValidAddress === 1) begin
           `ifdef slm
              $slm_ReadMemoryS(MemAddr, Address, tempReg_slm);
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = Mem[Address];
            `endif
          end  
        else if(repair_flag === 1) begin
           `ifdef slm
//              $slm_ReadMemoryS(RedMemAddr, RedMem_address, tempReg_slm);
          
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = RedMem[RedMem_address];
            `endif
        end
        
        for (num=0;num<Bits;num=num+1) begin
             po=num;        
             if ( Dint [num] !== tempReg1 [po]) begin
                if (Mint[num] === 1'b0)
                   tempReg1[po] = Dint[num];
                else if (Mint[num] === 1'bX)
                   tempReg1[po] = 1'bx;
             end                
        end //for (num=0
            
         if(repair_flag === 0 ) begin    
            if(ValidAddress === 1) begin  
              `ifdef slm
                  tempReg_slm=tempReg1; 
                  $slm_WriteMemory(MemAddr, Address, tempReg_slm);
              `else
                   Mem[Address] = tempReg1;
              `endif
            end
            else begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address Out Of Range. ",$realtime);
            end        
         end
         else if (repair_flag === 1 ) begin
            `ifdef slm
                tempReg_slm=tempReg1; 
//                $slm_WriteMemory(RedMemAddr, RedMem_address, tempReg_slm);
            `else
                RedMem[RedMem_address] = tempReg1;
            `endif
         end
   end //if (ValidAddress !== X
   task_insert_faults_in_memory;
end
endtask 

task ReadCycle;
input [Addr-1 : 0] Address;

reg [Bits-1:0] MemData_tmp;
reg [Bits-1:0] MemData;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;

reg repair_flag;

integer a,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;

begin
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];
   
   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};

   

   if (ValidAddress !== X && next_cycle_corrupt_func === 0 ) begin   
       if(red_en === 1 && ( Row_Add_cmp === repair_add ||  Row_Add_cmp === next_repair_add )) begin
              repair_flag = 1;
              
              Bank_sel_integer = 0;
               
              if(Row_Add_cmp === repair_add) begin
                Col_Add_integer = Col_Add;
              end
              else if (Row_Add_cmp === next_repair_add) begin
                Col_Add_integer = Col_Add + mux; 
              end
              RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
       end

      if(repair_flag === 0) begin
          if(ValidAddress === 1) begin 
           `ifdef slm
              $slm_ReadMemory(MemAddr, Address, MemData);
           `else
              MemData = Mem[Address];
           `endif
          end
          else begin
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Address Out Of Range. Output Corrupted ",$realtime);
             MemData = WordX;
          end
     end
      else if(repair_flag === 1) begin
        `ifdef slm
//           $slm_ReadMemory(RedMemAddr, RedMem_address, MemData);
        `else
           MemData = RedMem[RedMem_address];
        `endif
      end
   end //if (ValidAddress)  
   
   if(ValidAddress === X)
   begin
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Illegal Value on Address Bus. Memory and Output Corrupted ",$realtime); 
         Invalid_next_cycle_func;
   end 
   
  if(ValidAddress !== X && next_cycle_corrupt_func === 0 )
   begin
   for (a = 0; a < Bits; a = a + 1)
   begin
      if (MemData[a] !== OutReg_data[a])
         OutReg_data[a] = WordX[a];
   end//for (a = 0; a <  
         OutReg_data <= MemData;
   end     
end
endtask



// SCAN CHAINS
supply0 gnd;
buf (A_int[0], Aint[0]);
buf (A_int[1], Aint[1]);
buf (A_int[2], Aint[2]);
buf (A_int[3], Aint[3]);
buf (A_int[4], Aint[4]);
buf (A_int[5], Aint[5]);                  //used for capturing
buf (A_int[6], gnd);
buf (A_int[7], gnd);
buf (A_int[8], gnd);
buf (A_int[9], gnd);
buf (A_int[10], gnd);
buf (A_int[11], gnd);
buf (A_int[12], gnd);
buf (A_int[13], gnd);
buf (A_int[14], gnd);   //used for capturing

buf (WEN_int, WENint);
buf (CSN_int, CSNint);
buf (IG_int, IGint);


// Scan flops



// CONTROL SCAN CHAIN
     ST_SPREG_LOLEAK_64x23m4_Tl_SCFF cntrl_scff_0 (.D(1'b0), .TI(SCTRLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[0]), .OUTX(scanreg_ctrl));

      
 ST_SPREG_LOLEAK_64x23m4_Tl_SCFF cntrl_scff_1 (.D(A_int[3]), .TI(scanreg_ctrl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[1]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m4_Tl_SCFF cntrl_scff_2 (.D(A_int[5]), .TI(scanreg_ctrl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[2]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m4_Tl_SCFF cntrl_scff_3 (.D(A_int[8]), .TI(scanreg_ctrl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[3]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m4_Tl_SCFF cntrl_scff_4 (.D(A_int[2]), .TI(scanreg_ctrl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[4]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m4_Tl_SCFF cntrl_scff_5 (.D(A_int[10]), .TI(scanreg_ctrl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[5]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m4_Tl_SCFF cntrl_scff_6 (.D(A_int[9]), .TI(scanreg_ctrl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[6]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m4_Tl_SCFF cntrl_scff_7 (.D(A_int[1]), .TI(scanreg_ctrl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[7]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m4_Tl_SCFF cntrl_scff_8 (.D(A_int[0]), .TI(scanreg_ctrl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[8]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m4_Tl_SCFF cntrl_scff_9 (.D(A_int[4]), .TI(scanreg_ctrl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[9]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m4_Tl_SCFF cntrl_scff_10 (.D(A_int[6]), .TI(scanreg_ctrl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[10]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m4_Tl_SCFF cntrl_scff_11 (.D(CSN_int), .TI(scanreg_ctrl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[11]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m4_Tl_SCFF cntrl_scff_12 (.D(A_int[7]), .TI(scanreg_ctrl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[12]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m4_Tl_SCFF cntrl_scff_13 (.D(WEN_int), .TI(scanreg_ctrl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[13]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m4_Tl_SCFF cntrl_scff_14 (.D(scanreg_ctrl_wire[14]), .TI(scanreg_ctrl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[14]), .OUTX(scanreg_ctrl));  

reg LP_CK_gate;

// Lock Up Latch
wire SCTRLO_temp;
 ST_SPREG_LOLEAK_64x23m4_Tl_lock_up_latch  dff_SCTRLO_SE (Latch_open, scanreg_ctrl_wire[14], SCTRLO_temp);

always @(SCTRLO_temp) begin
     SCTRLOint= SCTRLO_temp;
 `ifdef functional
 `else
 if (SCTRLOint !== SCTRLO_data) begin 
  if (SCTRLOint !==X)
   SCTRLO_data=1'bx;
   SCTRLO_data <= SCTRLOint;
 end 
 `endif
end  


// LEFT DATA SCAN CHAIN
     ST_SPREG_LOLEAK_64x23m4_Tl_SCFF ldata_scff_0 (.D(Dint[11]), .TI(SDLI), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[0]), .OUTX(scanreg_dl));
      
   
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF ldata_scff_1 (.D(Dint[10]), .TI(scanreg_dl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[1]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF ldata_scff_2 (.D(Dint[9]), .TI(scanreg_dl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[2]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF ldata_scff_3 (.D(Dint[8]), .TI(scanreg_dl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[3]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF ldata_scff_4 (.D(Dint[7]), .TI(scanreg_dl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[4]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF ldata_scff_5 (.D(Dint[6]), .TI(scanreg_dl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[5]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF ldata_scff_6 (.D(Dint[5]), .TI(scanreg_dl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[6]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF ldata_scff_7 (.D(Dint[4]), .TI(scanreg_dl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[7]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF ldata_scff_8 (.D(Dint[3]), .TI(scanreg_dl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[8]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF ldata_scff_9 (.D(Dint[2]), .TI(scanreg_dl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[9]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF ldata_scff_10 (.D(Dint[1]), .TI(scanreg_dl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[10]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF ldata_scff_11 (.D(Dint[0]), .TI(scanreg_dl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[11]), .OUTX(scanreg_dl));



// Lock Up Latch
wire SDLO_temp;
 ST_SPREG_LOLEAK_64x23m4_Tl_lock_up_latch  dff_SDLO_SE (Latch_open, scanreg_dl_wire[11], SDLO_temp);

always @(SDLO_temp) begin
     SDLOint= SDLO_temp;
 `ifdef functional
 `else
 if (SDLOint !== SDLO_data) begin 
  if (SDLOint !==X)
   SDLO_data=1'bx;
   SDLO_data <= SDLOint;
 end 
 `endif
end  






// RIGHT DATA SCAN CHAIN

     ST_SPREG_LOLEAK_64x23m4_Tl_SCFF rdata_scff_0 (.D(Dint[22]), .TI(SDRI), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[0]), .OUTX(scanreg_dr));
     
 
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF rdata_scff_1 (.D(Dint[21]), .TI(scanreg_dr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[1]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF rdata_scff_2 (.D(Dint[20]), .TI(scanreg_dr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[2]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF rdata_scff_3 (.D(Dint[19]), .TI(scanreg_dr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[3]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF rdata_scff_4 (.D(Dint[18]), .TI(scanreg_dr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[4]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF rdata_scff_5 (.D(Dint[17]), .TI(scanreg_dr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[5]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF rdata_scff_6 (.D(Dint[16]), .TI(scanreg_dr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[6]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF rdata_scff_7 (.D(Dint[15]), .TI(scanreg_dr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[7]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF rdata_scff_8 (.D(Dint[14]), .TI(scanreg_dr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[8]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF rdata_scff_9 (.D(Dint[13]), .TI(scanreg_dr_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[9]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m4_Tl_SCFF rdata_scff_10 (.D(Dint[12]), .TI(scanreg_dr_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[10]), .OUTX(scanreg_dr)); 


// Lock Up Latch
wire SDRO_temp;
 ST_SPREG_LOLEAK_64x23m4_Tl_lock_up_latch  dff_SDRO_SE (Latch_open, scanreg_dr_wire[10], SDRO_temp);


always @(SDRO_temp) begin
     SDROint= SDRO_temp;
 `ifdef functional
 `else
 if (SDROint !== SDRO_data) begin 
  if (SDROint !==X)
   SDRO_data=1'bx;
   SDRO_data <= SDROint;
 end 
 `endif
end






//


 //////// CAPTURE TASK //////
task scan_acquire;
begin
   if (supply_ok === 1) begin 
      if ( SEsys === 0 && ((LP_CK_gate === 0 && TBYPASSsys !== 1'bx)|| TBYPASSsys===0)) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
         
         Latch_open=1;
         

      end //if ( SEint === 0
   end//if(supply_ok 
end
endtask

task scan_shift;
begin
 if (supply_ok === 1) begin
   if (STDBYint === 0 && SLEEPint === 0) begin
      if (CKint_dft === X && INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0) begin
         ScanChainX;
         ScanOutX;
      end
      else if (CKint_dft === 1 && lastCK_dft === 0 ) begin
          //// SHIFT
        if (SEsys === 1) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
           
        //// SHIFT Ends
        end //if (SEsys === 1
        else if (SEsys === X) begin
            ScanChainX;
            ScanOutX;
            delScanOutX;
        end//if (SEint ==X
      
      end///if (CKint === 
    
      else if (CKint_dft === 0 && lastCK_dft === 1 ) begin
        Latch_open=1;
      end
    end  //if (STDByint === 0 && SLEEPint === 0
 end//if(supply_ok
end
endtask






// BEHAVIOURAL MODULE DESCRIPTION
// ================================

initial
begin
  // Define format for timing value
  $timeformat (-9, 3, " ns", 0);
  `ifdef slm
  $slm_RegisterMemory(MemAddr, Words, Bits);
  `endif   
   reg_mem_block=0;
   flag_mem_block=0;
  `ifdef functional
  `else
   TimingViol_data=0;
   TimingViol_mask=0;
   `endif
   decoding_start=0;
  
   //Parameter Assignment
   
   reg_Fault_file_name = Fault_file_name; 
   reg_ConfigFault     = ConfigFault;
   reg_MEM_INITIALIZE  = MEM_INITIALIZE;
   reg_BinaryInit      = BinaryInit;
   reg_InitFileName    = InitFileName;
   reg_Initn_reset_value = Initn_reset_value;
   reg_File_load_time    = File_load_time;

   time_fall_sleep=0;
   time_fall_PSWLARGEMP=0;
   time_fall_PSWLARGEMP_0=0;
   time_fall_PSWLARGEMA=0;
   time_fall_PSWLARGEMA_0=0;
   time_fall_PSWSMALLMP=0;
   time_fall_PSWSMALLMA=0;

   vddmp_rise_time=0;
   vddmp_fall_time=0;
   vddsmp_rise_time=0;
   vddsmp_fall_time=0;
   vddma_rise_time=0;
   vddma_fall_time=0;
   vddsma_rise_time=0;
   vddsma_fall_time=0;
   vddm_fall_time=0;  
   vddm_rise_time=0;  
   vddsm_fall_time=0; 
   vddsm_rise_time=0;

   next_cycle_corrupt_func=0;
   next_cycle_corrupt_dft=0;
   init_pulse_done = 0;
   power_up_done = 0;
   file_loaded=1;
   debug_level= 2'b01;
   message_status = "ONLY WARNINGS/ERRORS are Switched ON.For INFO also use debug_level=2'b00";
  `ifdef  NO_WARNING_MODE
     debug_level = 2'b11;
     message_status = "All Warning/Errors/Info Messages are Switched OFF";
  `endif  
  `ifdef  ONLY_ERROR_MODE
     debug_level = 2'b10;
     message_status = "All Warning/Info Messages are Switched OFF.Errors are switched on";
  `endif 
  `ifdef  ALL_MSG_MODE
     debug_level = 2'b00;
     message_status = "All Messages are Switched ON";
  `endif 
  
  `ifdef slm
     operating_mode = "SLM";
   `else
      `ifdef functional
         operating_mode = "FUNCTIONAL";
       `else
         operating_mode = "TIMING";
      `endif
   `endif   
  
  if (debug_level < 1) begin
  $display ("%m INFORMATION ");
  $display ("***************************************");
  $display ("The Model is Operating in %s MODE", operating_mode);
  $display ("%s", message_status);
  if(reg_ConfigFault)
  $display ("Configurable Fault Functionality is ON");   
  else
  $display ("Configurable Fault Functionality is OFF");   
  $display("Fault File used by the model Fault_File_Name=%s" ,reg_Fault_file_name);
  $display("Values of Config_fault used in model=%d" ,reg_ConfigFault);
  $display("Values of Mem_INITALIZE used in model=%d" ,reg_MEM_INITIALIZE);
  $display("Values of BinaryInit used in model=%d" ,reg_BinaryInit);
  $display("Values of InitFileName used in model=%s" ,reg_InitFileName);
  $display("Values of Initn_reset_value used in model=%d" ,reg_Initn_reset_value);
  $display("Values of File_load_time used in model=%t" ,reg_File_load_time);

  $display ("***************************************");
  end
     
  task_read_fault_file; 
   if(!INITNint) begin
    if(supply_ok ) begin 
      init_pulse_done = 1;
      power_up_done = 1;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif 
    end 
   end 
        
   lastCK_func = CKint_func;
   lastCK_dft = CKint_dft;

 `ifdef MEM_CONTENTS_SLEEP
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","w");
   $fclose(ptr);
 `endif 

   
end  // initial block ends



//+++++++++++++++++++++++++++++++ CONFIG FAULT IMPLEMETATION ENDS+++++++++++++++++++++++++++++++//
        




//INITN block starts
//================================
always @(INITNint  or supply_ok )
begin
 if (INITNint === 1'b0) begin
   if(supply_ok) begin
     init_pulse_done = 1;
     power_up_done = 1;
     lastCK_func=CKint_func;
     lastCK_dft=CKint_dft;
     next_cycle_corrupt_func = 0;
     next_cycle_corrupt_dft = 0;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif     
   end 
 end        

 if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && INITNint !== 1)
   begin
     ScanOutX;
     ScanChainX;
     delScanOutX;
   end  
         
 if (init_pulse_done === 0 && INITNint !== 0) begin
     if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) INFO: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
 end
 
end//always @(INITNint)


// Clock Generation 
//wire gated_clock;
//wire clock_gate_en;
//ST_SPREG_LOLEAK_64x23m4_Tl_lock_up_latch CK_SE_latch (!CK , SE, SE_latch_CK);
//and (clock_gate_en, ATP, TBYPASS, !SE_latch_CK);

//ST_SPREG_LOLEAK_64x23m4_Tl_lock_up_latch LP_latch (!CK , scanreg_ctrl_wire[14], LP_latch_CK);
//and (gated_clock,CK,!LP_latch_CK);
//assign CK_new= clock_gate_en ===0 ? CK : (clock_gate_en ===1 ? gated_clock: (CK===0) ? 0 :1'bx);


// Clock Generation Ends


// Functional CK block starts
//======================================
always @(CKint_func)
begin
   lastCK_func=CKreg_func;  
   CKreg_func=CKint_func;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
        if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
      if (CKreg_func === 1'bX || (CKreg_func === 1'b1 && lastCK_func === 1'bx)) begin
        if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
         
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
         Invalid_next_cycle_func;
        end
      end
      else if (CKreg_func === 1'b1 && lastCK_func === 1'b0 ) begin
        time_CK_func_rise=$realtime;
        MEMEN_prev = MEMEN_reg;
        MEMEN_reg = MEMEN;
        CSNreg = CSNint;
        IGreg = IGint;
        DEreg = DEint;
        SE_reg = SEsys;
        TBYPASS_reg = TBYPASSsys;
        ATPreg = ATPint;
        INITNreg = INITNint;
        SLEEPreg = SLEEPint;
        STDBYreg = STDBYint;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 

    `ifdef functional
    `else
        Mem_last=Mem[Aint];
    `endif 
        if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.INITN pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SLEEP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.STANDBY pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg === X && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.chip select  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg === X && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.IG pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg === X && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.Debug pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg === X && (SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.ATP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg === X && TBYPASS_reg !== 1) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SE pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg !== 1 && TBYPASS_reg === X) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.TBYPASS pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end

        else if ((INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0))) && WENint === X) begin
            // Uncertain write cycle
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: write enable going to X  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end 
        else if (next_cycle_corrupt_func === 1) begin
          next_cycle_corrupt_func = X;
        end
        else if (next_cycle_corrupt_func === 1'bx) begin
          next_cycle_corrupt_func = 0;
        end 
        
//        if (next_cycle_corrupt_func === 0 ) begin 
         
          /*---------------------- File initialization -----------------*/
          
          if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0)) && flag_mem_block === 1'b0) begin
                 Areg=Aint;
                 Dreg=Dint;
                 Mreg=Mint;
                 WENreg=WENint;     
             if (reg_MEM_INITIALIZE === 1'b1 && $realtime >= reg_File_load_time && file_loaded ) begin   
                `ifdef slm
                  if (reg_BinaryInit)
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_BIN");
                  else
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_HEX");
   
                `else
                  if (reg_BinaryInit)
                     $readmemb(reg_InitFileName, Mem, 0, Words-1);
                  else
                     $readmemh(reg_InitFileName, Mem, 0, Words-1);
                `endif
                 file_loaded = 0;
             end
   
             if (^Aint === X)
               ValidAddress = X;
             else if (Aint < Words)
               ValidAddress = 1;
             else    
               ValidAddress = 0;
   
             if(red_en === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Redundancy Enable is Invalid. Either RRAE is X or TRRAE is X",$realtime);
                ValidAddress = X; 
           end
           else if(red_en === 1'b1 && ^repair_add === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Repair Address is invalid.RRA is X",$realtime);
                ValidAddress = X;
           end
             
             if (ValidAddress)
               `ifdef slm
                   $slm_ReadMemoryS(MemAddr, Aint, Mem_temp);
               `else
                    Mem_temp = Mem[Aint];
               `endif
             else
                Mem_temp = WordX;  
          
     /*---------------------- Normal Read and Write -----------------*/
     
             if (WENint === 1) begin
               ReadCycle(Aint);
             end
       
             else if (WENint === 0) begin
               WriteCycle(Aint);
             end 
                
          
          end //  if (MEMEN === 1'b1 
       
//        end  // if (next_cycle_corrupt_func === 0
      
      end // if (CKint = 1   
   end // if (init_pulse_done === 1           
 end 
end // always @(CKint_func)
        
always @(MEMEN)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) && CKint_func === 1'bx) begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.clock pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
    Invalid_next_cycle_func;
  end
 end 
end

// DFT CK block starts
//======================================
always @(CKint_dft) 
begin
   lastCK_dft=CKreg_dft;
   CKreg_dft=CKint_dft;
   
   Latch_open=0;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
     if (CKreg_dft === 1'bX || (CKreg_dft === 1'b1 && lastCK_dft === 1'bx)) begin
       if (INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0 ) begin
        
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: DFT clock  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime); 
         Invalid_next_cycle_dft;
         if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
           WriteOutX;
         end
       end
     end 

     if(CKint_dft === 0 && lastCK_dft === 1) begin
      if(ATPreg === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
       if(SE_reg === 1'b1 && SEsys === 1'b0) begin
        if(TBYPASSint === 1'b1) begin   
    
       
       
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],
scanreg_dr_wire[10],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9],
scanreg_dl_wire[10], scanreg_dl_wire[scanlen_l-1]}; 
       


         for (i = 0; i < Bits; i = i + 1)
         begin
          if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
         end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
        end 
       end
      end
     end 
     
     else if (CKreg_dft === 1'b1 && lastCK_dft === 1'b0 ) begin
       SE_reg = SEsys;
       TBYPASS_reg = TBYPASSsys;
       ATPreg = ATPint;
       INITNreg = INITNint;
       SLEEPreg = SLEEPint;
       STDBYreg = STDBYint;
       MEMEN_dft_prev = MEMEN_dft_reg;
       MEMEN_dft_reg = MEMEN_dft;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 
       if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ) begin 
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
 //     else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys === X && TBYPASSsys !== 1) begin
///           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
//           Invalid_next_cycle_dft;
//        end       
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys === X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
        end 
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys !== 0 && LP_CK_gate===X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: LP FLOP Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           ScanChainX;
           ScanOutX;   
          if( TBYPASSint !== 0 && SEint !== 1) begin
            WriteOutX;
          end
          next_cycle_corrupt_dft=0;
        end        
       else if (next_cycle_corrupt_dft === 1'b1) begin 
         next_cycle_corrupt_dft = X;
       end 
       else if (next_cycle_corrupt_dft === 1'bx) begin
         next_cycle_corrupt_dft = 0;
       end
       
       if (next_cycle_corrupt_dft === 0 ) begin
         
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1 && flag_mem_block === 1'b0) begin
           
           if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0  && LP_CK_gate===0) begin
              OutReg_data_tbypass = Dint;
              for (i = 0; i < Bits; i = i + 1)
              begin
               if (OutReg_data_tbypass[i] !== OutReg_data[i])
                 OutReg_data[i] = WordX[i];
              end//for (i = 0; i < */ 
              OutReg_data <= OutReg_data_tbypass;
           end
           
             scan_acquire;
         end //MEMEN_dft == 1        
       end // if ( next_cycle_corrupt_dft
       
     end // if (CKint_dft === 1'b1
      //  if (next_cycle_corrupt_dft === 0 ) begin 
       if (SE_reg !== 0) begin
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1  && flag_mem_block === 1'b0) begin
           next_cycle_corrupt_dft = 0;
           if ( next_cycle_corrupt_func === 1) begin
	    next_cycle_corrupt_func = 0 ;
	   end	
           scan_shift;
         end
       end
     //end // if ( next_cycle_corrupt_dft    
     if ((!(TBYPASSsys!==0 && SEsys!==1 && LP_CK_gate!==0 ) && next_cycle_corrupt_dft === 0) || CKint_dft !==1) begin          
       CK_sc=INITNreg & !STDBYreg & !SLEEPreg & ATPreg & CKreg_dft ;
     end     
   end // if (init_pulse_done 
 end // if (supply_ok 
end // always @(CKint_dft)

always @(MEMEN_dft)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) && CKint_dft === 1'bx)  begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.MEMEN_dft and clock should not be X at this time instant. ScanChains and ScanOuts Corrupted ",$realtime); 
    Invalid_next_cycle_dft;
    
    if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
      WriteOutX;
    end
  end
  if ( MEMEN_dft !== 0 && TBYPASSsys !== 0 && SEsys !== 1) begin
     WriteOutX;
     OutReg_data = WordX; 
     delOutReg_data=WordX;
 end 
end
end //always @(MEMEN_dft

always @(TBYPASSsys or ATPint)
begin
   if(supply_ok === 1'b1) begin 
    if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0 && INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1) begin
      if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
    end  
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint === X && SEsys !== 1) ) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end 
end //always @(TBYPASSint





always @(SEsys)
begin
 if(supply_ok === 1'b1) begin 
  if(CKint_dft === 0 && ATPint === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
    if(SE_reg === 1'b1 && SEsys === 1'b0) begin
      if(TBYPASSsys === 1'b1) begin
  
     
         
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],
scanreg_dr_wire[10],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9],
scanreg_dl_wire[10], scanreg_dl_wire[scanlen_l-1]};
           
      


        for (i = 0; i < Bits; i = i + 1)
        begin
         if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
        end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
      end
    end
  end
  if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0) begin
      if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
  end 
  else if ((TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint === X && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end   
end

//assign output data
`ifdef functional        

   
always @(SDLOint)
#0.001 delSDLO_data<=SDLOint;

always @(SDROint)
#0.001 delSDRO_data<=SDROint;

 
always @(SCTRLOint)
#0.001 delSCTRLO_data<=SCTRLOint;


always @(OutReg_data)
   #0.001 delOutReg_data = OutReg_data;
`else
`endif

/***************************** Embeded switch functionality starts here ***********************************/





always @(STDBYint)
begin
  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0 && STDBYint !== 1'b0)
    begin
      ScanOutX;
      ScanChainX;
     delScanOutX;     
    end
  end
end



always @(SLEEPint)
begin


  if (SLEEPint !== 1'b1) begin
    time_fall_sleep = $realtime;
  end

  if (power_up_done === 0)
    begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
    end
  else begin
    if (SLEEPint === 1'b1 && lastSLEEP === 1'b0 ) begin 
      
    end
    else if (SLEEPint !== 1'b1 && lastSLEEP === 1'b1 && full_shutdown !== 1) begin 
      
      if (supply_ok !== 1 && ($realtime > 0)) begin
         if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID LOW_POWER) ERROR: ISOLATION signal removed from the memory but array and periphery supply is not completely switched on.Very High Current would be drawn by the memory. All further operations on memory are blocked",$realtime);
          WriteMemX;
          WriteOutX;
          ScanChainX;
          OutReg_data = WordX; 
          delOutReg_data=WordX;
          ScanOutX;//immediately;
          delScanOutX;//immediately;
          init_pulse_done = 0;
          power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            debug_level = 2'b11;
          `endif
          
      end        
      
       
    end   
    else if (SLEEPint === X && lastSLEEP === 1'b0 && full_shutdown !== 1'b1) begin 
     
    end 
  end  


  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && SLEEPint !== 0)
    begin
      ScanOutX;
      ScanChainX;
        delScanOutX;      
    end
  end

// if (init_pulse_done === 0)
//   begin
//     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
//   end
//
// else if ( SLEEPint !== 1 && (supply_ok !==1) ) begin
//    
//    WriteOutX;
//    OutReg_data = WordX; 
//    delOutReg_data=WordX;
//    ScanOutX;//immediately;
//    delScanOutX;//immediately;
//    ScanChainX;
//    WriteMemX;
//    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies with sleep/Power down signal being low.This scenario can lead to high dc currents and some reliability issues Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
// end

 print_sleep;    
 lastSLEEP=SLEEPint;
end

/********************************** Embeded switch functionality ends here *******************************/

task print_sleep;
begin
  if (SLEEPint === 1'b0) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been deasserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end  
  else if (SLEEPint === 1'b1) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been asserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_ACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif

  end        
  else begin
      if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) ERROR: SLEEP pin is at an invalid state.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INVALID in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end        
end
endtask





 

//// C28SOI non flip compiler power functionality 
always @(gndmreg )
begin
 if (power_up_done === 1 && $realtime > 0) begin    
    if(gndmreg !== 1'b0 ) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or gndsm is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
        corrupt_all;
        init_pulse_done = 0;
        power_up_done = 0;
     `ifdef NO_BLOCK_MEM
     `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of ground pins.Ground must be maintained at 0 Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime);
        debug_level = 2'b11;
     `endif   

    end   
 end

end




always @(vddmareg )
begin

if (vddmareg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddma(Array Supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 
    end
   end   
   else if (SLEEPint === 1) begin
    WriteMemX;
   end

end

if ((vddmareg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1 ) && $realtime > 0) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddm or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         corrupt_all;
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif

end


end

always @(vddmpreg )
begin
 if (vddmpreg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or vddsmp is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmp(Periphery Supply)/vddsmp(Substrate power supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 

    end
   end   
   else if (SLEEPint === 1) begin
    WriteOutX;
    ScanChainX;
    ScanOutX;
    delScanOutX;//immediately;
    OutReg_data = WordX; 
    delOutReg_data=WordX;
   end
 end

if( (vddmpreg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1'b1 )  && $realtime > 0) begin
         corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif
end
 
 
end


always @(vddmoreg)
begin
  if (power_up_done === 1 && $realtime > 0) begin   
      if (vddmoreg !== 1'b1)  begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin
           corrupt_all;
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
         end //if (vddmareg === 1'b1 

      else if (vddmareg === 1'b0 && vddmpreg === 1'b0   && SLEEPint === 1'b1 &&  $realtime > 0)
        begin 
            if((debug_level < 2) && ($realtime > 0)) $display("%m - %t WARNING: Illegal Value on power pin(s). Memory and Output Corrupted ", $realtime);
 
           corrupt_all;
        end //else if (vddmareg === 1'b 
     end   // if (vddmoreg !== 1'b1)
     else if (vddmoreg === 1'b1 && $realtime > 0 ) begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin     
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           corrupt_all;
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
        end        
     end // else if (vddmoreg === 1'b1
  end 
end // always @(vddmoreg)












always @(gndmreg) begin
 if (gndmreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 0. ",$realtime);
 end
 else if (gndmreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 1. ",$realtime);
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to invalid state. ",$realtime);
 end
end




 
always @(vddmareg) begin
 if (vddmareg === 0) begin 
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 0. ",$realtime);
  vddma_fall_time = $realtime;
 end
 else if (vddmareg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 1. ",$realtime);
  vddma_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to invalid state. ",$realtime);
  vddma_fall_time = $realtime;
 end 

 

end

always @(vddmpreg) begin
 if (vddmpreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 0. ",$realtime);
  vddmp_fall_time = $realtime;
 end
 else if (vddmpreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 1. ",$realtime);
  vddmp_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to invalid state. ",$realtime);
  vddmp_fall_time = $realtime;
 end

 
 
end



// end of C28SOI power functionality 
 


assign supply_ok          =  (vddmareg === 1'b1 && vddmpreg  === 1'b1  && gndmreg === 1'b0 && vddmoreg === 1'b1 ) ? 1'b1 : 1'b0;
assign core_supply_ok     =  (vddmoreg === 1'b1 && vddmareg === 1'b1 && gndmreg === 1'b0 ) ? 1'b1 : 1'b0;
assign peri_supply_ok     =  (vddmoreg === 1'b1 && vddmpreg === 1'b1 && gndmreg === 1'b0  ) ? 1'b1 : 1'b0;

assign full_shutdown = (vddmpreg === 1'b0 && vddmareg === 1'b0   ) ? 1'b1 : 1'b0 ;




`ifdef functional
`else


task WriteLocMskX_bwise;
   input [Addr-1 : 0] Address;
   input [Bits-1 : 0] Mask;

reg [Bits+Red_extrabit:0] tempReg1;
integer num1; 
begin
   tempReg1 = WordX;
   if (^Address !== X )
   begin
      tempReg1 = Mem[Address];
             
      for (j = 0;j< Bits; j=j+1) begin
         num1=j;
        if (Mask[j] === 1'bx)
            tempReg1[num1] = 1'bx;
      end
      Mem[Address] = tempReg1;
      task_insert_faults_in_memory;
   end//if (^Address !== X
   else begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      WriteMemX;
   end   
end
endtask


/****************Actions taken on timing violations*****************/

 always @(TimingViol_data)
// tds or tdh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  for (l = 0; l < Bits; l = l + 1) begin   
    if (CSWEMTBYPASS[l] !== 0) begin
     if((TimingViol_data[l] !== TimingViol_data_last[l])) begin


         Mreg[l] = 1'bx;
     end    
     WriteLocMskX_bwise(Areg,Mreg);
    end   
   end 
  end
    if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin
     scanreg_dl =1'bx; 
     scanreg_dr =1'bx; 
     SDLOint=X;
     SDROint=X;
     `ifdef functional
     `else
     SDLO_data<=1'bx;
     SDRO_data<=1'bx;
     `endif
    end
     TimingViol_data_last = TimingViol_data; 
end





always @(TimingViol_addr)
// tas or tah
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
      scanreg_ctrl=1'bx; 
      SCTRLOint=X;
      `ifdef functional
      `else
      SCTRLO_data<=1'bx;
      `endif
  end
end


always @(TimingViol_WEN)
//tws or twh
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WEN pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end 

always @(TimingViol_CSN )
// tps or tph 
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;

   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CSN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end

always @(TimingViol_tcycle )
//tcycle
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
   if (MEMEN !== 0 && MEMEN_prev !== 0) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckl )
// tckl 
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckh) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end


always @(TimingViol_tcycle_se )
//tcycle_se
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckl_se  )
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckh_se) begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tbist) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
   end
   if (TBYPASSint !== 1'b0) begin 
    WriteOutX;
   end 
   if (INITNreg !==0 && STDBYreg !== 1 && TBYPASS_reg !== 1 && SLEEPreg !== 1 && SE_reg !== 1 && IGreg !== 1 && DEreg !== 1) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBIST pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end






always @(TimingViol_tbypass)
//ttmck
begin
#0  
  WriteOutX;
  if (INITNreg !== 0 && SLEEPreg !== 1 && SE_reg !== 1 && STDBYreg !== 1 &&  DEreg !== 1) begin
   Invalid_next_cycle_dft_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
end



always @(TimingViol_sleep)
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_stdby)
begin
#0
  if (CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin 
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (ATPreg !== 0) begin 
   Invalid_next_cycle_dft_tim;
  end
end






always @(TimingViol_se) begin
#0
   if (TBYPASS_reg !== 0) begin 
    WriteOutX;
   end 
  if (TBYPASS_reg === 0) begin
     WriteOutX;
     WriteMemX;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE timing violation  Memory State Machine is corrupted. Output Corrupted ",$realtime); 
  end 
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
  end
end

always @(TimingViol_sctrli) begin
  scanreg_ctrl=1'bx; 
end


always @(TimingViol_sdli) begin
 scanreg_dl=1'bx; 
end

always @(TimingViol_sdri) begin
   scanreg_dr=1'bx;
end

 

always @(TimingViol_initnl) begin
init_pulse_done=0;
WriteOutX;
OutReg_data = WordX; 
delOutReg_data=WordX;
ScanOutX;
delScanOutX;
ScanChainX;
WriteMemX;
end

always @(TimingViol_initn) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end

always @(TimingViol_ig) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && INITNreg !== 0 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: IG pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   ScanChainX;
   ScanOutX;
   delScanOutX;       
  end
end

always @(TimingViol_atp) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin  
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_rm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^WMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: RM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
   end
end
 
always @(TimingViol_wm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^RMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);        
   end
end 


`endif


endmodule




module ST_SPREG_LOLEAK_64x23m4_Tl_lock_up_latch (EN,D,Q);
input EN,D;
output reg Q;

  always @ (EN or D) begin
    if (EN === 1) begin
       Q = D;
    end
    else if ((EN === 1'bz || EN === 1'bx  )&& D !== Q) begin
        Q=1'bx;
    end    
  end
endmodule

module ST_SPREG_LOLEAK_64x23m4_Tl_SCFF (D,TI,TE,CP,Q,OUTX);
input D,TI,TE,CP;
input OUTX;
output reg Q;
wire Dint;
assign Dint= (TE===1)?TI:(TE===0)?D:1'bx;

always @(posedge CP)
        begin
          if(Dint === 1'bZ || CP ===1'bx || OUTX === 1'bx)
          begin
                  Q = 1'bx;
          end
          else
          begin
                  Q = Dint;
          end        
        end
always @(posedge OUTX)
Q = 1'bx;
endmodule



`undef setup_time
`undef hold_time
`undef access_time
`undef retain_time
`undef cycle_time
`undef pulse_width_time
`undef initin_low_pulse


`delay_mode_path
`endcelldefine
`nosuppress_faults






/****************************************************************
--  Description         : Verilog Model 
--  ModelVersion        : 1.2
--  Date                : Apr, 2013
--  Changes Made by	: PS
--  Revision History    : 
 
****************************************************************/


/******************** START OF HEADER****************************
   This Header Gives Information about the parameters & options present in the Model
   
   words = 128
   bits  = 22
   mux   = 4 
   
   
   
   write_mask = no 
   
   margin_control = yes 
   
   
   Dft = Yes  

    ------------------------------------------------------------------------------------
     Signal Name             | Description       |             Port Mode        | Active When
                             |                   |          r    |  w   | rw    |
   ------------------------------------------------------------------------------------

    D 	        Data in                     na     x      na       -  
    IG    Input Gate Enable           x      x      na       High     
    ATP            ATPG Enable                 x      x      na       High     
    INITN                 INITN pin                   x      x      na       Low
    
    
     
    Q 	        Data out	            x      na     na       -
    A              Address                     x      x      na       high and low
    
    CK                Clock	                    x      x      na       posedge
    CSN          Chip Enable                 x      x      na       low
    
    RM         Read Margins                 x      x      na       High 
    SCTRLI         Scan Input (Control)
    SCTRLO        Scan Output (Control)
    SDLI         Scan Input (Data-Left)
    SDLO        Scan Output (Data-Left)
    SDRI         Scan Input (Data-Right)
    SDRO        Scan Output (Data-Right)
    SE          Scan Enable pin 
    STDBY              Standby pin                 x      x      na       High
    
    SLEEP                        Sleep pin                   x      x      na        High 
    
     
     
    TBIST          Bist Enable Pin 
    
    TBYPASS                      Memory Bypass                na     na     na        High
    
    TED        Bist Even Data pin
    TOD         Bist Odd Data Pin
     
    TA         Bist Read Address
    TCSN     Bist Read Chip Select
    
    TWEN    Bist Write Enable 
    WEN         Write Enable                na     x      na       Low 
    
    WM        Write Margins Code          x      x      na       -
     

******************** END OF HEADER ****************************/


//********************************************//
// ST_SPREG_LOLEAK_128x22m4_Tl Verilog Model                 //  
//********************************************//




`ifdef slm
        `define functional
`endif

`celldefine
`suppress_faults
  `ifdef functional
   `delay_mode_unit
  `else
   `delay_mode_path
  `endif

`define setup_time 0.0
`define hold_time 0.0
`define access_time 1.0
`define retain_time 0.9
`define cycle_time 0.0
`define pulse_width_time 0.0
`define initin_low_pulse 0.0



 






`timescale 1ns / 1ps


module ST_SPREG_LOLEAK_128x22m4_Tl (A,ATP,CK,CSN,D ,IG,INITN , Q ,RM    ,SCTRLI,SCTRLO,SDLI,SDLO,SDRI,SDRO,SE,SLEEP   , STDBY  ,TA,TBIST   ,TBYPASS ,TCSN,TED ,TOD   ,TWEN ,WEN,WM  );

 parameter
  Words = 128,
  Bits = 22,
  Addr = 7,
  mux = 4,
  repair_address_width = 5,
  write_margin_size = 2, 
  read_margin_size = 3; 

 //  INPUT OUTPUT PORTS DECLARATION DONE SEPARATELY FOR SPREG and ROM
 // ========================


        output [Bits-1 : 0] Q;
         
        output SCTRLO;
        input SE,SCTRLI;
        
        input [Addr-1 : 0] A;
        
        input [read_margin_size-1 : 0] RM;
        
         
        input CK,CSN,INITN,IG,ATP; 
        
        
        input [Addr-1 :0 ] TA;
input TBIST,TCSN ;
        
        input STDBY;
        
        input SLEEP; 
        
         
        
        
         
        output SDLO;
        output SDRO;
        
        
        
        
        input [Bits-1 : 0] D ;
	
          
         
        
        input [write_margin_size-1 : 0] WM;
        
        
        input TBYPASS;
        
        input WEN;
        
        
         
        input SDLI,SDRI  ; 
        
        
        
        //Bist inputs
        // ===========
        input TWEN,TED,TOD; 
        
        
        
        

        






    parameter
        Fault_file_name = "ST_SPREG_LOLEAK_128x22m4_Tl_faults.txt",
        `ifdef ConfigFault
        ConfigFault = 1,
        `else
        ConfigFault = 0,
        `endif
        max_faults = 130,
        
        MEM_INITIALIZE  = 1'b0,
        BinaryInit = 1'b0, 
        InitFileName = "ST_SPREG_LOLEAK_128x22m4_Tl.cde",
        Debug_mode = "all_warning_mode",
        File_load_time=0,
        Initn_reset_value={22{1'b0}},
        InstancePath = "ST_SPREG_LOLEAK_128x22m4_Tl";
    
    parameter
        
        bank = 1, 
        mux_bits=2,
        Red_extrabit=0,
        bank_bits = 0,
        RedWords = mux * 2 * bank,
        max_address_bits = 15 ,
        Rows = Words/mux;

  
    parameter 

     

        
           scanchains=3,    
          
        
        scanlen_ctrl=15,
        
        

      

        
        scanlen_r=(Bits)/2,
        
        scanlen_l=(Bits+1)/2 ; 
      
      

    parameter
        
        `ifdef functional  
            RW_assertions_en = 0,
        `endif
        WordX = {Bits{1'bx}},
        AddrX = {Addr{1'bx}},
        Word0 = {Bits{1'b0}},
        X = 1'bx;
   



//  WIRE DECLARATION RELATED TO POWER PINS
//  ======================================
	
        wire supply_ok, full_shutdown;
        
        wire core_supply_ok;
        wire peri_supply_ok;

        wire gndmint, gndsmint;
         
        
        wire vddmpint;
        wire vddmoint;
        wire vddmaint;
        wire vddsmpint;  
        wire vddsmaint;  
        
        

//  WIRE DECLARATION 
//  ==================
        wire [Bits-1 : 0] CSWEMTBYPASS;
        wire [Bits-1 : 0] Dint, Dsys;
        wire [Bits-1 : 0] Mint; 
        wire [22-1:0] Msys;
	wire [Addr-1 : 0] Aint;
        wire [Addr-1 : 0] Asys;

       


        wire [max_address_bits-1 : 0] A_int; 
                
	wire CKint_dft;
	wire CKint_func;
	wire CSNint;
        wire MEMEN;
        wire MEMEN_dft;
        wire TSE;

	wire WENint;
	wire WENsys;
        wire SLEEPint;
        wire STDBYint;
        wire SEint;
        wire SEsys;
        wire SCTRLIint;
        wire SDLIint;
        wire SDRIint;
        
        wire INITNint;
        wire TBYPASSint;
        wire TBYPASSsys;
        wire LSint; 
        wire HSint; 
        wire ATPint;
        wire DEint;
        
        wire [Addr-1 : 0] TAint;
        wire TBISTint;
        wire TBISTsys;
        wire TCSNint;
        wire TEDint;
        wire TODint;
        wire TEMint;
        wire TOMint;
        wire [Bits-1 : 0] TMint;
        wire [Bits-1 : 0] TDint;
        wire TWENint;
        wire IGint;
        wire IGbuf;
        wire CSNbuf;
        wire WENbuf;
        wire [read_margin_size-1:0] RMint;
        wire [write_margin_size-1:0] WMint;

        //Wires for scan chains
        //  ====================     
        wire [scanlen_ctrl -1:0]scanreg_ctrl_wire;
        wire [scanlen_l -1:0]  scanreg_dl_wire; 
        wire [scanlen_r -1:0]  scanreg_dr_wire; 
   
        wire [scanlen_l -1:0]  scanreg_ml_wire; 
        wire [scanlen_r -1:0]  scanreg_mr_wire; 


        wire [repair_address_width -1 : 0] RRAint;
        wire RRAEint;
        wire TRRAEint;    
        wire red_en;
        wire [repair_address_width -1 : 0] repair_add, next_repair_add;


//  REG DECLARATION
//  ====================     
        reg MEMEN_reg;
        reg MEMEN_prev;
        reg reg_mem_block;
        reg flag_mem_block;
        reg SCTRLIint_temp;
        reg SDLIint_temp;
        reg SDRIint_temp;
        reg SMLIint_temp;
        reg SMRIint_temp;

        //  REG DECLARATION
        //  ====================
        reg SCTRLOint;
        
        reg SDLOint,SDROint;
         
        
        reg next_cycle_corrupt_func;
        reg next_cycle_corrupt_dft;
        reg [Bits-1 : 0] delOutReg_data;//delayed Output Register
        reg [Bits-1 : 0] OutReg_data;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_tbypass;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_scan;   // Data Output registe
        reg [Bits-1 : 0] OutReg_rado_retained;   // register for retaining rado data when SLEEP --> 1
        reg delSCTRLO_data,SCTRLO_data;      // delayed Output Register
        reg delSDLO_data,SDLO_data;      // delayed Output Register
        reg delSDRO_data,SDRO_data;      // delayed Output Register
        
        
        // SCAN CHAINS register
        reg scanreg_ctrl; 
        reg scanreg_dl; 
        reg scanreg_dr; 
        
        
        reg CK_sc;
        reg Latch_open=0;
        reg lastCK_dft,CKreg_dft;
        reg lastCK_func,CKreg_func;
        reg lastSLEEP;
        reg lastPSWLARGEMP,lastPSWLARGEMA,lastPSWSMALLMP,lastPSWSMALLMA;
        reg CSNreg;
        reg init_pulse_done; //if == 1 then it implies that initb low pulse has been applied
        reg power_up_done; //if == 1 then it implies that power up has been done
        `ifdef slm
        `else
	      
             reg [Bits-1 : 0] Mem [Words-1 : 0];
             reg [Bits-1 : 0] RedMem [RedWords-1 : 0];
 
        `endif
        
	reg [Bits-1 :0] Mem_temp;
        reg [Bits-1 :0] Mem_slm; 
	reg ValidAddress;
	reg ValidDebugCode;
        reg decoding_start;
        reg file_loaded;
        reg [Bits-1 :0] Dreg;
        reg [Bits-1 :0] Mreg;
        reg WENreg;
        reg [Addr-1 :0] Areg;
        reg SE_reg;
        reg TBYPASS_reg;
        reg INITNreg;
        reg IGreg;
        reg DEreg;
        reg SLEEPreg;
        reg STDBYreg;
        reg ATPreg;
        reg MEMEN_dft_reg;
        reg MEMEN_dft_prev;
        reg RRMATCHreg;
        reg RRMATCHreg_last;//changes_made
        reg RRMATCHreg_glitch;
        reg [repair_address_width -1 : 0] repair_add_last;
        reg RRAEint_last;
        reg [Addr-mux_bits-1:0] row_add_temp;
        reg [Addr-mux_bits-bank_bits-1:0] row_add_cmp_temp;

       
        //parameter registers
        reg [2047:0] reg_Fault_file_name;
        reg reg_ConfigFault;
        reg reg_MEM_INITIALIZE;
        reg reg_BinaryInit;
        reg [2047:0] reg_InitFileName;
        reg [Bits -1 :0] reg_Initn_reset_value;
        time reg_File_load_time;

        //Power Supply Registers        
        reg vddmireg;
        reg vddmreg;
        reg vddsmreg;
        reg gndmreg;
        reg gndsmreg;   
        reg vddmpreg;
        reg vddmpireg;
        reg vddmareg;
        reg vddsmpreg;
        reg vddsmareg;
        reg vddmoreg;
        time vddmp_rise_time;
        time vddmp_fall_time;
        time vddsmp_rise_time;
        time vddsmp_fall_time;
        time vddma_rise_time;
        time vddma_fall_time;
        time vddsma_rise_time;
        time vddsma_fall_time;
        reg reg_check_rise;
        reg reg_check_fall;
        reg reg_check_rise_vddma;
        reg reg_check_fall_vddsma;
        reg  reg_check_rise_vddm, reg_check_fall_vddsm ;
        time vddm_fall_time,  vddm_rise_time,  vddsm_fall_time, vddsm_rise_time ;
  /* This register is used to force all warning messages 
  ** OFF during run time.
  ** It is a 2 bit register.
  ** USAGE :
  ** debug_level_off = 2'b00 -> ALL MESSAGES(INFO/WARNINGS/ERRORS) will be DISPLAYED 
  ** debug_level = 2'b01     -> ONLY WARNINGS/ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b10     -> ONLY ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b11     -> NO MESSAGES will be DISPLAYED.
  */ 
        reg [1:0] debug_level;
        reg [8*10: 0] operating_mode;
        reg [8*44: 0] message_status;

        integer i, k, j, l,m,q,w,r,s,num1,redcnt,n,num2,FirstHalf,Bfaileff,memcnt,ptr;
        integer decoder[Bits-1:0];
        `ifdef slm
           integer MemAddr;
        `endif


        //************************************************************
        //****** CONFIG FAULT IMPLEMENTATION VARIABLES*************** 
        //************************************************************ 

        integer file_ptr, ret_val;
        integer fault_word;
        integer fault_bit;
        integer fcnt, Fault_in_memory,faultnum,stop_loop,count;
        integer t;  
        integer FailureLocn [max_faults -1 :0];
        integer Failurebit [max_faults -1 :0];
        reg [100 : 0] stuck_at;
        reg [100 : 0] fault_array;
        reg [200 : 0] tempStr;
        reg [7:0] fault_char;
        reg [7:0] fault_char1; // 8 Bit File Pointer
        reg [Addr -1 : 0] std_fault_word;
        reg [Addr -1 : mux_bits] fault_row_add [max_faults -1 :0];
        reg [max_faults -1 :0] fault_repair_flag;
        reg [max_faults -1 :0] dont_insert_fault;
        reg [max_faults -1 :0] repair_flag;
        reg [100 : 0] array_stuck_at[max_faults -1 : 0] ;
        reg [100 : 0] mem_red_array_stuck_at[max_faults -1 : 0] ; 
        reg msgcnt;
        
       
        reg [Bits - 1: 0] stuck_at_0fault [max_faults -1 : 0];
        reg [Bits - 1: 0] stuck_at_1fault [max_faults -1 : 0];
        reg [Bits -1 : 0] stuck0;
        reg [Bits -1 : 0] stuck1;

        reg [Bits+Red_extrabit :0] Mem_last;
        

        `ifdef slm
        reg [Bits -1 : 0] slm_temp_data;
        `endif
        
        real time_CK_func_rise , time_RADCK_rise;
        real time_fall_sleep,time_fall_PSWLARGEMP,time_fall_PSWLARGEMP_0,time_fall_PSWLARGEMA,time_fall_PSWLARGEMA_0,time_fall_PSWSMALLMP,time_fall_PSWSMALLMA;
        integer flag_error;
        
//BUFFER INSTANTIATION
//=========================
       `ifdef functional
       
         buf (SCTRLO,delSCTRLO_data); 
         buf bufq [Bits-1:0] (Q,delOutReg_data);
      `else
       
         buf (SCTRLO,SCTRLO_data);
         buf bufq [Bits-1:0] (Q,OutReg_data);
      `endif
      
  
        buf (SEsys,SE);
	buf (SCTRLIint, SCTRLI);
   

	buf (CKint_func, CK);
	buf (CKint_dft, CK);
        buf bufaddr [Addr-1:0] (Asys,A);
        buf (INITNint,INITN);
        
        buf (LSint,1'b0); 
        buf (IGbuf,IG);
        buf (ATPint,ATP);

        buf bufTaddr [Addr-1 : 0] (TAint,TA);
        buf (TBISTsys,TBIST);
        buf (TCSNint,TCSN);

        buf (CSNsys,CSN);
        buf (STDBYint,STDBY );   
        
        buf (SLEEPint,SLEEP ); 

        buf bufrm [read_margin_size-1:0] (RMint, RM); 

        
        

        assign RRAEint = 1'b0;
        assign TRRAEint = 1'b0;
        assign repair_add = 0;
        assign next_repair_add = 0;
        assign red_en = 1'b0; 
        
        
        
        
        
        
        
        buf (PSWLARGEMPint,1'b0);
        buf (PSWSMALLMPint,1'b0); 
        buf (PSWLARGEMAint,1'b0);
        buf (PSWSMALLMAint,1'b0);   

      `ifdef functional
       
       
         buf (SDLO,delSDLO_data);
         buf (SDRO,delSDRO_data);
        
      `else
       
         buf (SDLO,SDLO_data);
         buf (SDRO,SDRO_data);
         
      `endif
       
         
       
        buf bufdata [Bits-1:0] (Dsys,D);
        
        
        assign Msys=22'b0; 
	

        
        buf (TBYPASSsys, TBYPASS);
        


        buf (WENsys,WEN);
	 
	buf (SDLIint, SDLI);
	buf (SDRIint, SDRI);
	 
        
        buf (HSint,1'b0); 

        
        buf (TEDint,TED);
        buf (TODint,TOD);
         
        buf (TWENint,TWEN);
        
        
        buf bufwm [write_margin_size-1:0] (WMint, WM); 
        



//      assign scanreg_ctrl_wire={scanreg_ctrl[scanlen_ctrl - 2:0],SCTRLIint};
//      assign scanreg_dl_wire={scanreg_dl[scanlen_l - 2:0],SDLIint};
//      assign scanreg_dr_wire={scanreg_dr[scanlen_r - 2:0],SDRIint};
      
        
      assign Aint   = (TBISTint === 1'b0 ) ? Asys : (TBISTint === 1'bx ) ? {Addr{1'bx}} : TAint;  

        
//        assign A_int = Aint;
	
        
                
        assign Dint[0] = (TBISTint === 1'b0) ? Dsys[0] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[1] = (TBISTint === 1'b0) ? Dsys[1] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[2] = (TBISTint === 1'b0) ? Dsys[2] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[3] = (TBISTint === 1'b0) ? Dsys[3] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[4] = (TBISTint === 1'b0) ? Dsys[4] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[5] = (TBISTint === 1'b0) ? Dsys[5] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[6] = (TBISTint === 1'b0) ? Dsys[6] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[7] = (TBISTint === 1'b0) ? Dsys[7] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[8] = (TBISTint === 1'b0) ? Dsys[8] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[9] = (TBISTint === 1'b0) ? Dsys[9] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[10] = (TBISTint === 1'b0) ? Dsys[10] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[11] = (TBISTint === 1'b0) ? Dsys[11] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[12] = (TBISTint === 1'b0) ? Dsys[12] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[13] = (TBISTint === 1'b0) ? Dsys[13] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[14] = (TBISTint === 1'b0) ? Dsys[14] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[15] = (TBISTint === 1'b0) ? Dsys[15] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[16] = (TBISTint === 1'b0) ? Dsys[16] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[17] = (TBISTint === 1'b0) ? Dsys[17] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[18] = (TBISTint === 1'b0) ? Dsys[18] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[19] = (TBISTint === 1'b0) ? Dsys[19] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[20] = (TBISTint === 1'b0) ? Dsys[20] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[21] = (TBISTint === 1'b0) ? Dsys[21] : (TBISTint === 1'b1) ? TODint : 1'bx;          
	 
        assign Mint = 22'b0;
         

        assign WENbuf = (TBISTint === 1'b0 ) ? WENsys : (TBISTint === 1'bx ) ? 1'bx : TWENint;  
        assign WENint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? WENbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[13] : (ATPint === 1'b0 ) ? WENsys : 1'bx ; 
        
        assign CSNbuf = (TBISTint === 1'b0 ) ? CSNsys : (TBISTint === 1'bx ) ? 1'bx : TCSNint;  
        assign CSNint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? CSNbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[11] : (ATPint === 1'b0 ) ? CSNsys : 1'bx ; 
        assign IGint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? IGbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[14] : (ATPint === 1'b0 ) ? IGbuf : 1'bx;

        
        assign DEint = (LSint === 1'bx || (LSint === 1'b0 && HSint === 1'bx) || ^RMint !== 1'b0 || ^WMint !== 1'b0 ) ? 1'bx : 1'b0;
        
     
     and (TBISTint, ATPint, TBISTsys);
     and (SEint, ATPint, SEsys);
     and (TBYPASSint, ATPint, TBYPASSsys);
     and (TSE,TBYPASSint,!SEsys);
     and (MEMEN,INITNint,!CSNint,!SLEEPint,!TBYPASSint,!SEint,!IGint,!DEint,!STDBYint );
     and (MEMEN_dft,INITNint, !SLEEPint, ATPint,!STDBYint);

 `ifdef functional
/*****************assertions added to optimize dynamic power consumption**********/

//psl a_M: assert always ({( RW_assertions_en);(MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1))  } |-> (stable(Msys))) @(posedge CK); 

//psl a_WEN: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(WENsys))) @(posedge CK); 

//psl a_A: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(Asys))) @(posedge CK); 

//psl a_D: assert always ({( RW_assertions_en);((MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1)) && TBYPASSint === 1'b0)  } |-> (stable(Dsys))) @(posedge CK); 

/**********************************************************************************************/
`endif       

     

         
reg vddmp,vddmo, vddma, vddsmp, vddsma, gndsm, gndm,  vddmpi ; 
 
initial 
begin

        vddmp = 1'b1 ; 
        vddmo = 1'b1 ;
        vddma = 1'b1 ;
        
        vddsmp = 1'b1 ;
        
        
         gndm = 1'b0 ;
          
end

        
         assign gndmint = (reg_mem_block === 0) ? gndm : 1'b1;
         
         
         
         
         assign vddmpint = vddmp;
         assign vddmoint = vddmo;
         assign vddmaint = vddma;
         
          
        
         

        //CPF Changes

        
                
        initial
        begin : cpfvddmp 
           vddmpreg = vddmpint;
        end

        always @(vddmpint) begin
           vddmpreg = vddmpint;
        end
        
        initial
        begin : cpfvddmo 
           vddmoreg = vddmoint;
        end

        always @(vddmoint) begin
           vddmoreg = vddmoint;
        end
        
        initial
        begin : cpfvddma 
           vddmareg = vddmaint;
        end

        always @(vddmaint) begin
           vddmareg = vddmaint;
        end

        
        
 
        initial
        begin : cpfgndm 
           gndmreg = gndmint;
        end

        always @(gndmint) begin
           gndmreg = gndmint;
        end

        
        



 `ifdef functional
  `else
  initial begin
    if (debug_level < 1) begin
     $display ("%m  INFORMATION");
     $display ("***************************************");
     $display ("The Model is Operating in TIMING MODE");
     $display ("Please make sure that SDF is properly annotated otherwise dummy values will be used");
     $display ("%s", message_status);
     $display ("***************************************");
    end
  end

//////////////////////////
 //REG DECLARATIONS
   //======================

   reg [Bits-1 : 0] TimingViol_data;
   reg  [Bits-1 : 0] TimingViol_mask;
   reg [Bits-1 : 0] TimingViol_data_last, TimingViol_mask_last;
	reg TimingViol_data_0;
	reg TimingViol_data_1;
	reg TimingViol_data_2;
	reg TimingViol_data_3;
	reg TimingViol_data_4;
	reg TimingViol_data_5;
	reg TimingViol_data_6;
	reg TimingViol_data_7;
	reg TimingViol_data_8;
	reg TimingViol_data_9;
	reg TimingViol_data_10;
	reg TimingViol_data_11;
	reg TimingViol_data_12;
	reg TimingViol_data_13;
	reg TimingViol_data_14;
	reg TimingViol_data_15;
	reg TimingViol_data_16;
	reg TimingViol_data_17;
	reg TimingViol_data_18;
	reg TimingViol_data_19;
	reg TimingViol_data_20;
	reg TimingViol_data_21;
 reg TimingViol_mask_0;
 reg TimingViol_mask_1;
 reg TimingViol_mask_2;
 reg TimingViol_mask_3;
 reg TimingViol_mask_4;
 reg TimingViol_mask_5;
 reg TimingViol_mask_6;
 reg TimingViol_mask_7;
 reg TimingViol_mask_8;
 reg TimingViol_mask_9;
 reg TimingViol_mask_10;
 reg TimingViol_mask_11;
 reg TimingViol_mask_12;
 reg TimingViol_mask_13;
 reg TimingViol_mask_14;
 reg TimingViol_mask_15;
 reg TimingViol_mask_16;
 reg TimingViol_mask_17;
 reg TimingViol_mask_18;
 reg TimingViol_mask_19;
 reg TimingViol_mask_20;
 reg TimingViol_mask_21;

   reg TimingViol_addr;
   reg TimingViol_CSN, TimingViol_WEN, TimingViol_tbypass;
   reg TimingViol_tckh, TimingViol_tckl, TimingViol_tcycle;
   reg TimingViol_tckh_se, TimingViol_tckl_se, TimingViol_tcycle_se;
   reg TimingViol_sctrli,TimingViol_sdli,TimingViol_sdri,TimingViol_se;
   reg TimingViol_smli,TimingViol_smri;
   reg TimingViol_sctrli_flag,TimingViol_sdli_flag,TimingViol_sdri_flag;
   reg TimingViol_smli_flag,TimingViol_smri_flag;
   reg TimingViol_initnl;
   reg TimingViol_initn;
   reg TimingViol_ls;
   reg TimingViol_hs;
   reg TimingViol_sleep;
   reg TimingViol_stdby;
   reg TimingViol_rm;
   reg TimingViol_wm;
   reg TimingViol_tbist,TimingViol_ig,TimingViol_atp,TimingViol_TED,TimingViol_TOD,TimingViol_TEM,TimingViol_TOM;
   reg TimingViolRRAE,TimingViolRRA;

   wire CSTBYPASSN,cond_sdf_tas,cond_sdf_tds,cond_sdf_tms,cond_sdf_tws,cond_sdf_tbas,cond_sdf_tbps,cond_sdf_tbws,cond_sdf_tbdes,cond_sdf_tbdos,cond_sdf_tbmes,cond_sdf_tbmos;
   wire SETB_EN,CSIG_EN,MEM_ACT,EN_ADM,CS_EN,CS_ADM,cond_sdf_tps,IG_EN,IG_ADM,cond_sdf_tigs,cond_sdf_taa,cond_sdf_taa_ls1,cond_sdf_taa_hs1,cond_tseq_tm;
   wire cond_sdf_tcycle,cond_sdf_tcycle_ls1,cond_sdf_tcycle_hs1,cond_sdf_tcycle_se,cond_sdf_tckl_se,cond_sdf_tsctrlis,cond_sdf_tsdlis,cond_sdf_tsdris,cond_sdf_tsmlis,cond_sdf_tsmris;
   wire cond_sdf_tckh_se,cond_sdf_taa_sctrlo_se,cond_sdf_taa_sdlo_se,cond_sdf_taa_sdro_se,cond_sdf_taa_smlo_se,cond_sdf_taa_smro_se,cond_sdf_tckl,cond_sdf_tckh;
   wire cond_sdf_ttms,cond_sdf_tbists,INITNandnotSLEEPandATPandnotSE,cond_sdf_taa_sctrlo,cond_sdf_taa_sdlo,cond_sdf_taa_sdro,cond_sdf_taa_smlo,cond_sdf_taa_smro;
   wire cond_sdf_taa_tm,cond_sdf_taa_tm_ls1, cond_sdf_taa_tm_hs1,cond_sdf_taa_tckq_tm,cond_sdf_taa_tseq_tm;

   wire CSWETBYPASSN;
   wire cond_sdf_tstdbys,cond_sdf_tsls,sleep_en,atp_csn_en;
   wire cond_sdf_tlss,cond_sdf_thss,cond_sdf_trms,cond_sdf_twms; 
   wire cond_sdf_tses,cond_sdf_tinitns;
   wire tby_se_en;
   wire rra_en;
   wire tbist_atp_en;
   wire rrae_en;
   wire tbist_rrae_en;
   wire cond_sdf_trraes;
   wire cond_sdf_ttrraes;
   wire cond_sdf_taa_trramatch;
   wire cond_sdf_ttrraematch;
   wire cond_sdf_tamatch;
   wire cond_sdf_ttamatch;
   wire cond_sdf_tatpmatch;
   wire cond_sdf_ttbistmatch;



 and (CSWEMTBYPASS[0], !Mreg[0], CSWETBYPASSN);
 and (CSWEMTBYPASS[1], !Mreg[1], CSWETBYPASSN);
 and (CSWEMTBYPASS[2], !Mreg[2], CSWETBYPASSN);
 and (CSWEMTBYPASS[3], !Mreg[3], CSWETBYPASSN);
 and (CSWEMTBYPASS[4], !Mreg[4], CSWETBYPASSN);
 and (CSWEMTBYPASS[5], !Mreg[5], CSWETBYPASSN);
 and (CSWEMTBYPASS[6], !Mreg[6], CSWETBYPASSN);
 and (CSWEMTBYPASS[7], !Mreg[7], CSWETBYPASSN);
 and (CSWEMTBYPASS[8], !Mreg[8], CSWETBYPASSN);
 and (CSWEMTBYPASS[9], !Mreg[9], CSWETBYPASSN);
 and (CSWEMTBYPASS[10], !Mreg[10], CSWETBYPASSN);
 and (CSWEMTBYPASS[11], !Mreg[11], CSWETBYPASSN);
 and (CSWEMTBYPASS[12], !Mreg[12], CSWETBYPASSN);
 and (CSWEMTBYPASS[13], !Mreg[13], CSWETBYPASSN);
 and (CSWEMTBYPASS[14], !Mreg[14], CSWETBYPASSN);
 and (CSWEMTBYPASS[15], !Mreg[15], CSWETBYPASSN);
 and (CSWEMTBYPASS[16], !Mreg[16], CSWETBYPASSN);
 and (CSWEMTBYPASS[17], !Mreg[17], CSWETBYPASSN);
 and (CSWEMTBYPASS[18], !Mreg[18], CSWETBYPASSN);
 and (CSWEMTBYPASS[19], !Mreg[19], CSWETBYPASSN);
 and (CSWEMTBYPASS[20], !Mreg[20], CSWETBYPASSN);
 and (CSWEMTBYPASS[21], !Mreg[21], CSWETBYPASSN);

and (atp_csn_en,!ATPint,!CSNint,!IGint);
or (sleep_en,atp_csn_en,ATPint);
or (SETB_EN,SEint,TBISTint);
and (ATP_SETB_EN,ATPint,SETB_EN); 
or (CSIG_EN,IGint,CSNint);
and (MEM_ACT,!ATPint,CSIG_EN);
or (EN_ADM,MEM_ACT,ATP_SETB_EN);
and (CS_EN,!ATPint,IGint);
or (CS_ADM,CS_EN,ATP_SETB_EN);
and (atp_ig_csn_en,!ATPint,!CSNint,!IGint);
and (atp_se_en,!SEsys,ATPint);
or (cycle_en,atp_ig_csn_en,atp_se_en);
and (atp_ig_csn_en_reg,!ATPreg,!CSNreg,!IGreg);
and (atp_se_en_reg,!SE_reg,ATPreg);
or (cycle_en_reg,atp_ig_csn_en,atp_se_en);
and (INITNandnotSLEEPandATPandnotSE,cond_gac,!SEsys,ATPint);
and (csn_ig_en,!IGint,!CSNint);
and (atp_tby_ls_en,atp_se_en,cond_ls_tby_en);
and (IG_EN,!ATPint,!CSNint);
or (IG_ADM,IG_EN,atp_se_en);
and (CSWETBYPASSN, !WENreg, 1'b1);



assign cond_sdf_tsls=((sleep_en && INITNint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tstdbys=((sleep_en && INITNint && !SLEEPint) !==0) ? 1:0;
assign cond_sdf_atps=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_gac=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tas=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tds=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tms=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tws=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tps=((cond_gac && !CS_ADM) !==0) ? 1:0;
assign cond_sdf_tcycle=((cond_gac && cycle_en && !LSint && !HSint) !==0) ? 1:0;  
assign cond_sdf_tcycle_ls1=((cond_gac && cycle_en && LSint) !==0) ? 1:0;
assign cond_sdf_tcycle_hs1=((cond_gac && cycle_en && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_tckh=((cond_gac && cycle_en_reg) !==0) ? 1:0;
assign cond_sdf_tckl=((cond_gac && cycle_en) !==0) ? 1:0;
assign cond_sdf_tcycle_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckl_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsctrlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckh_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_ttms=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_tbists=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_tckq_tm=((cond_gac && SE_reg && ATPreg && TBYPASSsys) !==0) ? 1:0;
assign cond_ls_en=((atp_ig_csn_en || atp_tby_ls_en) !==0) ? 1:0;
assign cond_sdf_tlss=((cond_ls_en && cond_gac) !==0) ? 1:0;
assign cond_sdf_thss=((cond_ls_en && cond_gac && !LSint) !==0) ? 1:0;
assign cond_sdf_trms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_twms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_tses=((cond_gac && ATPint) !==0) ? 1:0;
assign cond_sdf_tbas=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbps=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbws=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tigs=((cond_gac && IG_ADM) !==0) ? 1:0;
assign cond_sdf_taa=((MEMEN_reg && WENreg && !LSint && !HSint) !==0) ? 1:0; 
// assign cond_sdf_taa_tbypass_q = ((MEMEN_reg && ATPint && TBYPASSint) !== 1'b0) ? 1'b1 : 1'b0;
assign cond_sdf_taa_ls1=((MEMEN_reg && WENreg && LSint) !==0) ? 1:0; 
assign cond_sdf_taa_hs1=((MEMEN_reg && WENreg && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && !HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_ls1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && LSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_hs1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tseq_tm=((cond_gac && TBYPASSint) !==0) ? 1:0;
assign cond_sdf_tinitns =(( sleep_en && !STDBYint && !SLEEPint) !==0) ? 1:0;
assign cond_ls_tby_en=((TBYPASSsys || csn_ig_en) !==0) ? 1:0;



//specify block begins

specify
    specparam
    
         PATHPULSE$CK$Q = 0,
         PATHPULSE$CK$SCTRLO = 0,

         PATHPULSE$CK$SDLO = 0,
         PATHPULSE$CK$SDRO = 0,
        
         PATHPULSE$SE$Q = 0,
         
//         PATHPULSE$TBYPASS$Q = 0,


        
         
        
         tsls = `setup_time,
         tslh = `hold_time ,
         tstdbys = `setup_time,
         tstdbyh = `hold_time , 
	 

         
         tcycle = `cycle_time,
         
         
         tckh = `pulse_width_time,
         tckl = `pulse_width_time,
         tcycle_se = `cycle_time,
         tckh_se = `pulse_width_time,
         tckl_se = `pulse_width_time,
         
         ttms = `setup_time,
         ttmh = `hold_time ,
         tps = `setup_time,
         tph = `hold_time ,
         tws = `setup_time,
         twh = `hold_time ,
         tds = `setup_time,
         tdh = `hold_time , 
         tas = `setup_time,
         tah = `hold_time ,
         tses= `setup_time,
         tseh= `hold_time ,
         tsctrlis=`setup_time,
         tsctrlih=`hold_time ,
         tsdlis=`setup_time,
         tsdlih=`hold_time ,
         tsdris=`setup_time,
         tsdrih=`hold_time , 
         tbists=`setup_time,
         tbisth=`hold_time ,
         tbps=`setup_time,
         tbph=`hold_time ,
         tbws=`setup_time,
         tbwh=`hold_time ,
         tbdes=`setup_time,
         tbdeh=`hold_time ,
         tbdos=`setup_time,
         tbdoh=`hold_time ,
         
         tbas=`setup_time,
         tbah=`hold_time ,
         tinitnl=`initin_low_pulse,
         tinitns=`setup_time,
         tinitnh=`hold_time ,
         tatps=`setup_time,
         tatph=`hold_time ,
         tigs=`setup_time,
         tigh=`hold_time ,
         
         
         trms=`setup_time,
         trmh=`hold_time ,
         twms=`setup_time,
         twmh=`hold_time , 

/*************************************************************************************************/
           // taa_tbypass_q = `access_time,
           // th_tbypass_q  = `retain_time,
            taa =`access_time,
            th = `retain_time,

 


            taa_tm =`access_time,
            th_tm = `retain_time,

            
            taa_tseq_tm =`access_time,
            th_tseq_tm = `retain_time,
            taa_tckq_tm   = `access_time,
            th_tckq_tm    = `retain_time,
            taa_sctrlo=`access_time,
            th_sctrlo= `retain_time,
            taa_sdlo=`access_time,
            th_sdlo= `retain_time,
            taa_sdro=`access_time,
            th_sdro= `retain_time,
            
         
            taa_sctrlo_se=`access_time,
            th_sctrlo_se= `retain_time
,
            taa_sdlo_se=`access_time,
            th_sdlo_se= `retain_time,
            taa_sdro_se=`access_time,
            th_sdro_se= `retain_time
         ;  


        /*---------------------- Timing Checks ---------------------*/

	$setup(posedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[6], tah, TimingViol_addr);

	$setup(posedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(posedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(posedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(posedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(posedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(posedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(posedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(posedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(posedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(posedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(posedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(posedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(posedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(posedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(posedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(posedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(posedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(posedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(posedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(posedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(posedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(posedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$setup(negedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(negedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(negedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(negedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(negedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(negedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(negedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(negedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(negedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(negedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(negedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(negedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(negedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(negedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(negedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(negedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(negedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(negedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(negedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(negedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(negedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(negedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[21], tdh, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[21], tdh, TimingViol_data_21);

        



        $setup(posedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $setup(negedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, posedge WEN, twh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, negedge WEN, twh, TimingViol_WEN); 
        $setup(posedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$setup(negedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, posedge CSN, tph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, negedge CSN, tph, TimingViol_CSN);
        $period(posedge CK &&& cond_sdf_tcycle, tcycle, TimingViol_tcycle);  

        
        $width(posedge CK  &&& cond_sdf_tckh, tckh, 0, TimingViol_tckh);
        $width(negedge CK  &&& cond_sdf_tckl, tckl, 0, TimingViol_tckl);
        $period(posedge CK &&& cond_sdf_tcycle_se, tcycle_se, TimingViol_tcycle_se);
        $width(posedge CK  &&& cond_sdf_tckh_se, tckh_se, 0, TimingViol_tckh_se);
        $width(negedge CK  &&& cond_sdf_tckl_se, tckl_se, 0, TimingViol_tckl_se);

        
        $setup(posedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $setup(negedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $hold(posedge CK &&& cond_sdf_ttms, posedge TBYPASS, ttmh, TimingViol_tbypass); 
        $hold(posedge CK &&& cond_sdf_ttms, negedge TBYPASS, ttmh, TimingViol_tbypass); 
 



        
        $setup(posedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $setup(negedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $hold(posedge CK &&& cond_sdf_tsls, posedge SLEEP, tslh, TimingViol_sleep);        
        $hold(posedge CK &&& cond_sdf_tsls, negedge SLEEP, tslh, TimingViol_sleep);

        $setup(posedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $setup(negedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $hold(posedge CK &&& cond_sdf_tstdbys, posedge STDBY, tstdbyh, TimingViol_stdby);        
        $hold(posedge CK &&& cond_sdf_tstdbys, negedge STDBY, tstdbyh, TimingViol_stdby); 
        
        
        $setup (posedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
	$setup (negedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
        
        $hold (posedge CK &&& cond_sdf_tses, posedge SE ,tseh,TimingViol_se);
	$hold (posedge CK &&& cond_sdf_tses, negedge SE ,tseh,TimingViol_se);
        
        $setup(posedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis , tsctrlis, TimingViol_sctrli);
        $setup(negedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis, tsctrlis, TimingViol_sctrli);
        $hold(posedge CK &&& cond_sdf_tsctrlis , posedge SCTRLI, tsctrlih, TimingViol_sctrli);        
        $hold(posedge CK &&& cond_sdf_tsctrlis , negedge SCTRLI, tsctrlih, TimingViol_sctrli);

        $setup(posedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $setup(negedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $hold(posedge CK &&& cond_sdf_tsdlis, posedge SDLI, tsdlih, TimingViol_sdli);        
        $hold(posedge CK &&& cond_sdf_tsdlis, negedge SDLI, tsdlih, TimingViol_sdli);

        $setup(posedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $setup(negedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $hold(posedge CK &&& cond_sdf_tsdris, posedge SDRI, tsdrih, TimingViol_sdri);        
        $hold(posedge CK &&& cond_sdf_tsdris, negedge SDRI, tsdrih, TimingViol_sdri);
        
 
	
         
        $width(negedge INITN , tinitnl, 0, TimingViol_initnl);
        
        $setup(posedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        $setup(negedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        
        $hold (posedge CK &&& cond_sdf_tinitns,posedge INITN, tinitnh, TimingViol_initn);
        $hold (posedge CK &&& cond_sdf_tinitns,negedge INITN, tinitnh, TimingViol_initn);

        $setup(posedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $setup(negedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $hold(posedge CK &&& cond_sdf_atps, posedge ATP, tatph, TimingViol_atp);        
        $hold(posedge CK &&& cond_sdf_atps, negedge ATP, tatph, TimingViol_atp);
        
        $setup(posedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $setup(negedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $hold(posedge CK &&& cond_sdf_tigs, posedge IG, tigh, TimingViol_ig);        
        $hold(posedge CK &&& cond_sdf_tigs, negedge IG, tigh, TimingViol_ig);



         
$setup(posedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[2], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[2], trmh, TimingViol_rm); 

        
$setup(posedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(posedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[1], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[1], twmh, TimingViol_wm);
 
        
        $setup(posedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $setup(negedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $hold(posedge CK &&& cond_sdf_tbists, posedge TBIST, tbisth, TimingViol_tbist);        
        $hold(posedge CK &&& cond_sdf_tbists, negedge TBIST, tbisth, TimingViol_tbist);
        
        	$setup(posedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$setup(negedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[6], tbah, TimingViol_addr);
       	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[6], tbah, TimingViol_addr);

        $setup(posedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$setup(negedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, posedge TCSN, tbph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, negedge TCSN, tbph, TimingViol_CSN); 
       
        $setup(posedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $setup(negedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, posedge TWEN, tbwh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, negedge TWEN, tbwh, TimingViol_WEN);
       
       
        $setup(posedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $setup(negedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, posedge TED, tbdeh, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, negedge TED, tbdeh, TimingViol_TED);

        $setup(posedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $setup(negedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, posedge TOD, tbdoh, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, negedge TOD, tbdoh, TimingViol_TOD);

          


          

          /*-------------------- Propagation Delays ------------------*/
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa, taa, th, taa, th, taa);
                 

/* // //	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[0] +: OutReg_data[0])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[1] +: OutReg_data[1])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[2] +: OutReg_data[2])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[3] +: OutReg_data[3])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[4] +: OutReg_data[4])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[5] +: OutReg_data[5])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[6] +: OutReg_data[6])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[7] +: OutReg_data[7])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[8] +: OutReg_data[8])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[9] +: OutReg_data[9])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[10] +: OutReg_data[10])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[11] +: OutReg_data[11])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[12] +: OutReg_data[12])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[13] +: OutReg_data[13])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[14] +: OutReg_data[14])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[15] +: OutReg_data[15])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[16] +: OutReg_data[16])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[17] +: OutReg_data[17])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[18] +: OutReg_data[18])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[19] +: OutReg_data[19])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[20] +: OutReg_data[20])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[21] +: OutReg_data[21])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q); */ 








	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                





	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                 

	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[0] +: OutReg_data[0])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[1] +: OutReg_data[1])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[2] +: OutReg_data[2])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[3] +: OutReg_data[3])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[4] +: OutReg_data[4])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[5] +: OutReg_data[5])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[6] +: OutReg_data[6])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[7] +: OutReg_data[7])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[8] +: OutReg_data[8])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[9] +: OutReg_data[9])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[10] +: OutReg_data[10])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[11] +: OutReg_data[11])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[12] +: OutReg_data[12])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[13] +: OutReg_data[13])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[14] +: OutReg_data[14])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[15] +: OutReg_data[15])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[16] +: OutReg_data[16])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[17] +: OutReg_data[17])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[18] +: OutReg_data[18])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[19] +: OutReg_data[19])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[20] +: OutReg_data[20])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[21] +: OutReg_data[21])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                



if (cond_sdf_taa_sctrlo) 
        (posedge CK *> (SCTRLO :  SCTRLI)) = (taa_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo); 

if (cond_sdf_taa_sctrlo_se) 
        (negedge CK *> (SCTRLO : SCTRLI)) = (taa_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se); 
 

if (cond_sdf_taa_sdlo) 
        (posedge CK *> (SDLO :  SDLI)) = (taa_sdlo,taa_sdlo,th_sdlo,taa_sdlo,th_sdlo,taa_sdlo); 

if (cond_sdf_taa_sdlo_se) 
        (negedge CK *> (SDLO : SDLI)) = (taa_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se);

if (cond_sdf_taa_sdro) 
        (posedge CK *> (SDRO :  SDRI)) = (taa_sdro,taa_sdro,th_sdro,taa_sdro,th_sdro,taa_sdro); 

if (cond_sdf_taa_sdro_se) 
        (negedge CK *> (SDRO : SDRI)) = (taa_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se); 

  
     




endspecify //specify block ends






// conversion from registers to array elements for data setup violation notifiers

always @(TimingViol_data_0   or TimingViol_TED  )
begin
        TimingViol_data[0]=~TimingViol_data[0];   
end


always @(TimingViol_data_1   or TimingViol_TOD  )
begin
        TimingViol_data[1]=~TimingViol_data[1];   
end


always @(TimingViol_data_2   or TimingViol_TED  )
begin
        TimingViol_data[2]=~TimingViol_data[2];   
end


always @(TimingViol_data_3   or TimingViol_TOD  )
begin
        TimingViol_data[3]=~TimingViol_data[3];   
end


always @(TimingViol_data_4   or TimingViol_TED  )
begin
        TimingViol_data[4]=~TimingViol_data[4];   
end


always @(TimingViol_data_5   or TimingViol_TOD  )
begin
        TimingViol_data[5]=~TimingViol_data[5];   
end


always @(TimingViol_data_6   or TimingViol_TED  )
begin
        TimingViol_data[6]=~TimingViol_data[6];   
end


always @(TimingViol_data_7   or TimingViol_TOD  )
begin
        TimingViol_data[7]=~TimingViol_data[7];   
end


always @(TimingViol_data_8   or TimingViol_TED  )
begin
        TimingViol_data[8]=~TimingViol_data[8];   
end


always @(TimingViol_data_9   or TimingViol_TOD  )
begin
        TimingViol_data[9]=~TimingViol_data[9];   
end


always @(TimingViol_data_10   or TimingViol_TED  )
begin
        TimingViol_data[10]=~TimingViol_data[10];   
end


always @(TimingViol_data_11   or TimingViol_TOD  )
begin
        TimingViol_data[11]=~TimingViol_data[11];   
end


always @(TimingViol_data_12   or TimingViol_TED  )
begin
        TimingViol_data[12]=~TimingViol_data[12];   
end


always @(TimingViol_data_13   or TimingViol_TOD  )
begin
        TimingViol_data[13]=~TimingViol_data[13];   
end


always @(TimingViol_data_14   or TimingViol_TED  )
begin
        TimingViol_data[14]=~TimingViol_data[14];   
end


always @(TimingViol_data_15   or TimingViol_TOD  )
begin
        TimingViol_data[15]=~TimingViol_data[15];   
end


always @(TimingViol_data_16   or TimingViol_TED  )
begin
        TimingViol_data[16]=~TimingViol_data[16];   
end


always @(TimingViol_data_17   or TimingViol_TOD  )
begin
        TimingViol_data[17]=~TimingViol_data[17];   
end


always @(TimingViol_data_18   or TimingViol_TED  )
begin
        TimingViol_data[18]=~TimingViol_data[18];   
end


always @(TimingViol_data_19   or TimingViol_TOD  )
begin
        TimingViol_data[19]=~TimingViol_data[19];   
end


always @(TimingViol_data_20   or TimingViol_TED  )
begin
        TimingViol_data[20]=~TimingViol_data[20];   
end


always @(TimingViol_data_21   or TimingViol_TOD  )
begin
        TimingViol_data[21]=~TimingViol_data[21];   
end


`endif


// TASK DEFINITION DESCRIPTION
// ================================



task task_insert_faults_in_memory;
begin
   if (reg_ConfigFault)
   begin   
     for(i = 0;i< fcnt;i = i+ 1) begin
        if(mem_red_array_stuck_at[i] === "mem_array") begin
          if (array_stuck_at[i] === "sa0") begin
           `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data & stuck_at_0fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
          `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] & stuck_at_0fault[i];
          `endif
         end //if(array_stuck_at)
                                        
         if(array_stuck_at[i] === "sa1") begin
         `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data | stuck_at_1fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
         `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] | stuck_at_1fault[i]; 
         `endif
         end //if(array_stuck_at)
       end //if mem_red_array_stuck_at
    
    
     end    // end of for
   end  
end
endtask



task task_read_fault_file;
begin
/*  -----------Implemetation for config fault starts------*/
   msgcnt = X;
   t = 0;
   fault_repair_flag = {max_faults{1'b1}};
   repair_flag = {max_faults{1'b1}};
   if(reg_ConfigFault) 
   begin
      file_ptr = $fopen(reg_Fault_file_name , "r");
      if(file_ptr == 0)
      begin     
          if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: File cannot be opened ",$realtime);
      end        
      else                
      begin : read_fault_file
        t = 0;
        for (i = 0; i< max_faults; i= i + 1)
        begin
         
           stuck0 = {Bits{1'b1}};
           stuck1 = {Bits{1'b0}};
           fault_char1 = $fgetc (file_ptr);
           if (fault_char1 == 8'b11111111)
              disable read_fault_file;
           ret_val = $ungetc (fault_char1, file_ptr);
           ret_val = $fgets(tempStr, file_ptr);
           ret_val = $sscanf(tempStr, "%s %d %d %s",fault_array,fault_word, fault_bit, stuck_at) ;
           flag_error = 0; 
           if(ret_val !== 0)
           begin         
              if(ret_val == 3 || ret_val == 4)
              begin
                if(ret_val == 3)
                   stuck_at = "sa0";

                if(stuck_at !== "sa0" && stuck_at !== "sa1" && stuck_at !== "none")
                begin
                    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: Wrong value for stuck at in fault file ",$realtime);
                   flag_error = 1;
                end    
                      
                if(fault_word >= Words)
                begin
                   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Address out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                if(fault_bit >= Bits)
                begin  
                    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Faulty bit out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                
                        
                if(fault_array !== "mem_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array is not mem_array ",$realtime);
                  flag_error = 1;
                end

                if(fault_array === "red_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array can't be on redundancy array in non redundancy cut.",$realtime);
                  flag_error = 1;
                end

                
                

                if(flag_error == 0)
                //Correct Inputs
                begin
                   if(stuck_at === "none")
                   begin
                       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
                   end
                   else
                   //Adding the faults
                   begin
                      FailureLocn[t] = fault_word;
                      Failurebit[t]  = fault_bit ;
                      std_fault_word = fault_word;
                      fault_row_add[t] = std_fault_word[Addr-1:mux_bits];
                      mem_red_array_stuck_at[t] = fault_array;
                      fault_repair_flag[t] = 1'b0;
                      if (stuck_at === "sa0" )
                      begin
                         stuck0[fault_bit] = 1'b0;         
                         stuck_at_0fault[t] = stuck0;
                      end     
                      if (stuck_at === "sa1" )
                      begin
                         stuck1[fault_bit] = 1'b1;
                         stuck_at_1fault[t] = stuck1; 
                      end

                      array_stuck_at[t] = stuck_at;
                      t = t + 1;
                   end //if(stuck_at === "none")  
                end //if(flag_error == 0)
              end //if(ret_val == 2 || ret_val == 3 
              else
              //wrong number of arguments
              begin
                if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: WRONG VALUES ENTERED FOR FAULTY WORD OR FAULTY BIT OR STUCK_AT IN Fault_file_name ",$realtime); 
                flag_error = 1;
              end
           end //if(ret_val !== 0)
           else
           begin 
               if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
           end    
        end //for (i = 0; i< m
      end //begin: read_fault_file  
      $fclose (file_ptr);

      fcnt = t;
      
      //fault injection at time 0.
      task_insert_faults_in_memory;
  end // config_fault 
end
endtask


task WriteMemX;
begin

`ifdef slm
   $slm_ResetMemory(MemAddr, WordX);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = WordX;
   
`endif        
 task_insert_faults_in_memory;
end
endtask

task WriteMem0;
begin
`ifdef slm
   $slm_ResetMemory(MemAddr, Word0);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = Word0;
  
`endif 
   task_insert_faults_in_memory;
end
endtask


task WriteOutX;                
begin
   OutReg_data <= #0 WordX;
end
endtask


task Invalid_next_cycle_func;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_func = 1;
     `else 
       #0 next_cycle_corrupt_func = 0; 
     `endif  
   end 
end
endtask

task Invalid_next_cycle_dft;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_dft = 1;
     `else 
       #0 next_cycle_corrupt_dft = 0; 
     `endif  
  end
end
endtask

task Invalid_next_cycle_func_tim;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
   #0 next_cycle_corrupt_func <= 1;
  end 
end
endtask

task Invalid_next_cycle_dft_tim;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
  #0 next_cycle_corrupt_dft <= 1;
  end
end
endtask


task ScanOutX;                
begin
   
   dff_SCTRLO_SE.Q <= 1'bx;   
   dff_SDLO_SE.Q <= 1'bx; 
   dff_SDRO_SE.Q <= 1'bx; 
    
   
   SCTRLOint=X;
   SDLOint=X;
   SDROint=X;
    
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   SDLO_data<=1'bx;
   SDRO_data<=1'bx;
    
   `endif
end
endtask

task delScanOutX;                
begin
   delSCTRLO_data<=X;
   delSDLO_data<=X;
   delSDRO_data<=X;
    
end
endtask

task ScanChainX;                
begin
 scanreg_ctrl=1'bx; 
 scanreg_dl=1'bx; 
 scanreg_dr =1'bx; 
  
end
endtask

task mem_blocked;
begin
 
   WriteMemX;
   WriteOutX;
   ScanChainX;
   ScanOutX;//immediately;
   delScanOutX;//immediately
   `ifdef POWER_SEQUENCING_OFF
   `else
   reg_mem_block=1;
   `endif
   debug_level = 2'b11;
end
endtask

task corrupt_all;
begin
 
  WriteMemX;
  WriteOutX;
  ScanChainX;
  ScanOutX;
  delScanOutX;//immediately;
  OutReg_data = WordX; 
  delOutReg_data=WordX;
  
end
endtask

task WriteCycle;                  
input [Addr-1 : 0] Address;
reg [Bits-1:0] tempReg1;
reg [Bits-1:0] tempReg_slm;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;


reg repair_flag;

integer po,i,num,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;
begin

   tempReg1 = WordX;
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];

   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};
   
   if (ValidAddress === X )   begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
        WriteMemX;
        if (INITNint !== 0) begin
        `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
           #0 next_cycle_corrupt_func = 1;
       `else 
           #0 next_cycle_corrupt_func = 0; 
       `endif  
   end 

   end


   if (ValidAddress !== X && next_cycle_corrupt_func === 0  )
   begin
         if (red_en === 1 && ((Row_Add_cmp === repair_add) || (Row_Add_cmp === next_repair_add)) ) begin
             repair_flag = 1'b1;
             
             Bank_sel_integer = 0;
                     
             if (Row_Add_cmp === repair_add) begin
               Col_Add_integer  = Col_Add; 
             end
             else if (Row_Add_cmp === next_repair_add) begin
               Col_Add_integer  = Col_Add + mux; 
             end  
             RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
        end  

        if(repair_flag === 0 && ValidAddress === 1) begin
           `ifdef slm
              $slm_ReadMemoryS(MemAddr, Address, tempReg_slm);
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = Mem[Address];
            `endif
          end  
        else if(repair_flag === 1) begin
           `ifdef slm
//              $slm_ReadMemoryS(RedMemAddr, RedMem_address, tempReg_slm);
          
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = RedMem[RedMem_address];
            `endif
        end
        
        for (num=0;num<Bits;num=num+1) begin
             po=num;        
             if ( Dint [num] !== tempReg1 [po]) begin
                if (Mint[num] === 1'b0)
                   tempReg1[po] = Dint[num];
                else if (Mint[num] === 1'bX)
                   tempReg1[po] = 1'bx;
             end                
        end //for (num=0
            
         if(repair_flag === 0 ) begin    
            if(ValidAddress === 1) begin  
              `ifdef slm
                  tempReg_slm=tempReg1; 
                  $slm_WriteMemory(MemAddr, Address, tempReg_slm);
              `else
                   Mem[Address] = tempReg1;
              `endif
            end
            else begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address Out Of Range. ",$realtime);
            end        
         end
         else if (repair_flag === 1 ) begin
            `ifdef slm
                tempReg_slm=tempReg1; 
//                $slm_WriteMemory(RedMemAddr, RedMem_address, tempReg_slm);
            `else
                RedMem[RedMem_address] = tempReg1;
            `endif
         end
   end //if (ValidAddress !== X
   task_insert_faults_in_memory;
end
endtask 

task ReadCycle;
input [Addr-1 : 0] Address;

reg [Bits-1:0] MemData_tmp;
reg [Bits-1:0] MemData;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;

reg repair_flag;

integer a,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;

begin
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];
   
   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};

   

   if (ValidAddress !== X && next_cycle_corrupt_func === 0 ) begin   
       if(red_en === 1 && ( Row_Add_cmp === repair_add ||  Row_Add_cmp === next_repair_add )) begin
              repair_flag = 1;
              
              Bank_sel_integer = 0;
               
              if(Row_Add_cmp === repair_add) begin
                Col_Add_integer = Col_Add;
              end
              else if (Row_Add_cmp === next_repair_add) begin
                Col_Add_integer = Col_Add + mux; 
              end
              RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
       end

      if(repair_flag === 0) begin
          if(ValidAddress === 1) begin 
           `ifdef slm
              $slm_ReadMemory(MemAddr, Address, MemData);
           `else
              MemData = Mem[Address];
           `endif
          end
          else begin
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Address Out Of Range. Output Corrupted ",$realtime);
             MemData = WordX;
          end
     end
      else if(repair_flag === 1) begin
        `ifdef slm
//           $slm_ReadMemory(RedMemAddr, RedMem_address, MemData);
        `else
           MemData = RedMem[RedMem_address];
        `endif
      end
   end //if (ValidAddress)  
   
   if(ValidAddress === X)
   begin
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Illegal Value on Address Bus. Memory and Output Corrupted ",$realtime); 
         Invalid_next_cycle_func;
   end 
   
  if(ValidAddress !== X && next_cycle_corrupt_func === 0 )
   begin
   for (a = 0; a < Bits; a = a + 1)
   begin
      if (MemData[a] !== OutReg_data[a])
         OutReg_data[a] = WordX[a];
   end//for (a = 0; a <  
         OutReg_data <= MemData;
   end     
end
endtask



// SCAN CHAINS
supply0 gnd;
buf (A_int[0], Aint[0]);
buf (A_int[1], Aint[1]);
buf (A_int[2], Aint[2]);
buf (A_int[3], Aint[3]);
buf (A_int[4], Aint[4]);
buf (A_int[5], Aint[5]);
buf (A_int[6], Aint[6]);                  //used for capturing
buf (A_int[7], gnd);
buf (A_int[8], gnd);
buf (A_int[9], gnd);
buf (A_int[10], gnd);
buf (A_int[11], gnd);
buf (A_int[12], gnd);
buf (A_int[13], gnd);
buf (A_int[14], gnd);   //used for capturing

buf (WEN_int, WENint);
buf (CSN_int, CSNint);
buf (IG_int, IGint);


// Scan flops



// CONTROL SCAN CHAIN
     ST_SPREG_LOLEAK_128x22m4_Tl_SCFF cntrl_scff_0 (.D(1'b0), .TI(SCTRLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[0]), .OUTX(scanreg_ctrl));

      
 ST_SPREG_LOLEAK_128x22m4_Tl_SCFF cntrl_scff_1 (.D(A_int[3]), .TI(scanreg_ctrl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[1]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m4_Tl_SCFF cntrl_scff_2 (.D(A_int[5]), .TI(scanreg_ctrl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[2]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m4_Tl_SCFF cntrl_scff_3 (.D(A_int[8]), .TI(scanreg_ctrl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[3]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m4_Tl_SCFF cntrl_scff_4 (.D(A_int[2]), .TI(scanreg_ctrl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[4]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m4_Tl_SCFF cntrl_scff_5 (.D(A_int[10]), .TI(scanreg_ctrl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[5]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m4_Tl_SCFF cntrl_scff_6 (.D(A_int[9]), .TI(scanreg_ctrl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[6]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m4_Tl_SCFF cntrl_scff_7 (.D(A_int[1]), .TI(scanreg_ctrl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[7]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m4_Tl_SCFF cntrl_scff_8 (.D(A_int[0]), .TI(scanreg_ctrl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[8]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m4_Tl_SCFF cntrl_scff_9 (.D(A_int[4]), .TI(scanreg_ctrl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[9]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m4_Tl_SCFF cntrl_scff_10 (.D(A_int[6]), .TI(scanreg_ctrl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[10]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m4_Tl_SCFF cntrl_scff_11 (.D(CSN_int), .TI(scanreg_ctrl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[11]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m4_Tl_SCFF cntrl_scff_12 (.D(A_int[7]), .TI(scanreg_ctrl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[12]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m4_Tl_SCFF cntrl_scff_13 (.D(WEN_int), .TI(scanreg_ctrl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[13]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m4_Tl_SCFF cntrl_scff_14 (.D(scanreg_ctrl_wire[14]), .TI(scanreg_ctrl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[14]), .OUTX(scanreg_ctrl));  

reg LP_CK_gate;

// Lock Up Latch
wire SCTRLO_temp;
 ST_SPREG_LOLEAK_128x22m4_Tl_lock_up_latch  dff_SCTRLO_SE (Latch_open, scanreg_ctrl_wire[14], SCTRLO_temp);

always @(SCTRLO_temp) begin
     SCTRLOint= SCTRLO_temp;
 `ifdef functional
 `else
 if (SCTRLOint !== SCTRLO_data) begin 
  if (SCTRLOint !==X)
   SCTRLO_data=1'bx;
   SCTRLO_data <= SCTRLOint;
 end 
 `endif
end  


// LEFT DATA SCAN CHAIN
     ST_SPREG_LOLEAK_128x22m4_Tl_SCFF ldata_scff_0 (.D(Dint[10]), .TI(SDLI), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[0]), .OUTX(scanreg_dl));
      
   
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF ldata_scff_1 (.D(Dint[9]), .TI(scanreg_dl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[1]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF ldata_scff_2 (.D(Dint[8]), .TI(scanreg_dl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[2]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF ldata_scff_3 (.D(Dint[7]), .TI(scanreg_dl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[3]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF ldata_scff_4 (.D(Dint[6]), .TI(scanreg_dl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[4]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF ldata_scff_5 (.D(Dint[5]), .TI(scanreg_dl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[5]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF ldata_scff_6 (.D(Dint[4]), .TI(scanreg_dl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[6]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF ldata_scff_7 (.D(Dint[3]), .TI(scanreg_dl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[7]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF ldata_scff_8 (.D(Dint[2]), .TI(scanreg_dl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[8]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF ldata_scff_9 (.D(Dint[1]), .TI(scanreg_dl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[9]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF ldata_scff_10 (.D(Dint[0]), .TI(scanreg_dl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[10]), .OUTX(scanreg_dl));



// Lock Up Latch
wire SDLO_temp;
 ST_SPREG_LOLEAK_128x22m4_Tl_lock_up_latch  dff_SDLO_SE (Latch_open, scanreg_dl_wire[10], SDLO_temp);

always @(SDLO_temp) begin
     SDLOint= SDLO_temp;
 `ifdef functional
 `else
 if (SDLOint !== SDLO_data) begin 
  if (SDLOint !==X)
   SDLO_data=1'bx;
   SDLO_data <= SDLOint;
 end 
 `endif
end  






// RIGHT DATA SCAN CHAIN

     ST_SPREG_LOLEAK_128x22m4_Tl_SCFF rdata_scff_0 (.D(Dint[21]), .TI(SDRI), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[0]), .OUTX(scanreg_dr));
     
 
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF rdata_scff_1 (.D(Dint[20]), .TI(scanreg_dr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[1]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF rdata_scff_2 (.D(Dint[19]), .TI(scanreg_dr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[2]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF rdata_scff_3 (.D(Dint[18]), .TI(scanreg_dr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[3]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF rdata_scff_4 (.D(Dint[17]), .TI(scanreg_dr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[4]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF rdata_scff_5 (.D(Dint[16]), .TI(scanreg_dr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[5]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF rdata_scff_6 (.D(Dint[15]), .TI(scanreg_dr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[6]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF rdata_scff_7 (.D(Dint[14]), .TI(scanreg_dr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[7]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF rdata_scff_8 (.D(Dint[13]), .TI(scanreg_dr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[8]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF rdata_scff_9 (.D(Dint[12]), .TI(scanreg_dr_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[9]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m4_Tl_SCFF rdata_scff_10 (.D(Dint[11]), .TI(scanreg_dr_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[10]), .OUTX(scanreg_dr)); 


// Lock Up Latch
wire SDRO_temp;
 ST_SPREG_LOLEAK_128x22m4_Tl_lock_up_latch  dff_SDRO_SE (Latch_open, scanreg_dr_wire[10], SDRO_temp);


always @(SDRO_temp) begin
     SDROint= SDRO_temp;
 `ifdef functional
 `else
 if (SDROint !== SDRO_data) begin 
  if (SDROint !==X)
   SDRO_data=1'bx;
   SDRO_data <= SDROint;
 end 
 `endif
end






//


 //////// CAPTURE TASK //////
task scan_acquire;
begin
   if (supply_ok === 1) begin 
      if ( SEsys === 0 && ((LP_CK_gate === 0 && TBYPASSsys !== 1'bx)|| TBYPASSsys===0)) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
         
         Latch_open=1;
         

      end //if ( SEint === 0
   end//if(supply_ok 
end
endtask

task scan_shift;
begin
 if (supply_ok === 1) begin
   if (STDBYint === 0 && SLEEPint === 0) begin
      if (CKint_dft === X && INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0) begin
         ScanChainX;
         ScanOutX;
      end
      else if (CKint_dft === 1 && lastCK_dft === 0 ) begin
          //// SHIFT
        if (SEsys === 1) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
           
        //// SHIFT Ends
        end //if (SEsys === 1
        else if (SEsys === X) begin
            ScanChainX;
            ScanOutX;
            delScanOutX;
        end//if (SEint ==X
      
      end///if (CKint === 
    
      else if (CKint_dft === 0 && lastCK_dft === 1 ) begin
        Latch_open=1;
      end
    end  //if (STDByint === 0 && SLEEPint === 0
 end//if(supply_ok
end
endtask






// BEHAVIOURAL MODULE DESCRIPTION
// ================================

initial
begin
  // Define format for timing value
  $timeformat (-9, 3, " ns", 0);
  `ifdef slm
  $slm_RegisterMemory(MemAddr, Words, Bits);
  `endif   
   reg_mem_block=0;
   flag_mem_block=0;
  `ifdef functional
  `else
   TimingViol_data=0;
   TimingViol_mask=0;
   `endif
   decoding_start=0;
  
   //Parameter Assignment
   
   reg_Fault_file_name = Fault_file_name; 
   reg_ConfigFault     = ConfigFault;
   reg_MEM_INITIALIZE  = MEM_INITIALIZE;
   reg_BinaryInit      = BinaryInit;
   reg_InitFileName    = InitFileName;
   reg_Initn_reset_value = Initn_reset_value;
   reg_File_load_time    = File_load_time;

   time_fall_sleep=0;
   time_fall_PSWLARGEMP=0;
   time_fall_PSWLARGEMP_0=0;
   time_fall_PSWLARGEMA=0;
   time_fall_PSWLARGEMA_0=0;
   time_fall_PSWSMALLMP=0;
   time_fall_PSWSMALLMA=0;

   vddmp_rise_time=0;
   vddmp_fall_time=0;
   vddsmp_rise_time=0;
   vddsmp_fall_time=0;
   vddma_rise_time=0;
   vddma_fall_time=0;
   vddsma_rise_time=0;
   vddsma_fall_time=0;
   vddm_fall_time=0;  
   vddm_rise_time=0;  
   vddsm_fall_time=0; 
   vddsm_rise_time=0;

   next_cycle_corrupt_func=0;
   next_cycle_corrupt_dft=0;
   init_pulse_done = 0;
   power_up_done = 0;
   file_loaded=1;
   debug_level= 2'b01;
   message_status = "ONLY WARNINGS/ERRORS are Switched ON.For INFO also use debug_level=2'b00";
  `ifdef  NO_WARNING_MODE
     debug_level = 2'b11;
     message_status = "All Warning/Errors/Info Messages are Switched OFF";
  `endif  
  `ifdef  ONLY_ERROR_MODE
     debug_level = 2'b10;
     message_status = "All Warning/Info Messages are Switched OFF.Errors are switched on";
  `endif 
  `ifdef  ALL_MSG_MODE
     debug_level = 2'b00;
     message_status = "All Messages are Switched ON";
  `endif 
  
  `ifdef slm
     operating_mode = "SLM";
   `else
      `ifdef functional
         operating_mode = "FUNCTIONAL";
       `else
         operating_mode = "TIMING";
      `endif
   `endif   
  
  if (debug_level < 1) begin
  $display ("%m INFORMATION ");
  $display ("***************************************");
  $display ("The Model is Operating in %s MODE", operating_mode);
  $display ("%s", message_status);
  if(reg_ConfigFault)
  $display ("Configurable Fault Functionality is ON");   
  else
  $display ("Configurable Fault Functionality is OFF");   
  $display("Fault File used by the model Fault_File_Name=%s" ,reg_Fault_file_name);
  $display("Values of Config_fault used in model=%d" ,reg_ConfigFault);
  $display("Values of Mem_INITALIZE used in model=%d" ,reg_MEM_INITIALIZE);
  $display("Values of BinaryInit used in model=%d" ,reg_BinaryInit);
  $display("Values of InitFileName used in model=%s" ,reg_InitFileName);
  $display("Values of Initn_reset_value used in model=%d" ,reg_Initn_reset_value);
  $display("Values of File_load_time used in model=%t" ,reg_File_load_time);

  $display ("***************************************");
  end
     
  task_read_fault_file; 
   if(!INITNint) begin
    if(supply_ok ) begin 
      init_pulse_done = 1;
      power_up_done = 1;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif 
    end 
   end 
        
   lastCK_func = CKint_func;
   lastCK_dft = CKint_dft;

 `ifdef MEM_CONTENTS_SLEEP
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","w");
   $fclose(ptr);
 `endif 

   
end  // initial block ends



//+++++++++++++++++++++++++++++++ CONFIG FAULT IMPLEMETATION ENDS+++++++++++++++++++++++++++++++//
        




//INITN block starts
//================================
always @(INITNint  or supply_ok )
begin
 if (INITNint === 1'b0) begin
   if(supply_ok) begin
     init_pulse_done = 1;
     power_up_done = 1;
     lastCK_func=CKint_func;
     lastCK_dft=CKint_dft;
     next_cycle_corrupt_func = 0;
     next_cycle_corrupt_dft = 0;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif     
   end 
 end        

 if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && INITNint !== 1)
   begin
     ScanOutX;
     ScanChainX;
     delScanOutX;
   end  
         
 if (init_pulse_done === 0 && INITNint !== 0) begin
     if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) INFO: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
 end
 
end//always @(INITNint)


// Clock Generation 
//wire gated_clock;
//wire clock_gate_en;
//ST_SPREG_LOLEAK_128x22m4_Tl_lock_up_latch CK_SE_latch (!CK , SE, SE_latch_CK);
//and (clock_gate_en, ATP, TBYPASS, !SE_latch_CK);

//ST_SPREG_LOLEAK_128x22m4_Tl_lock_up_latch LP_latch (!CK , scanreg_ctrl_wire[14], LP_latch_CK);
//and (gated_clock,CK,!LP_latch_CK);
//assign CK_new= clock_gate_en ===0 ? CK : (clock_gate_en ===1 ? gated_clock: (CK===0) ? 0 :1'bx);


// Clock Generation Ends


// Functional CK block starts
//======================================
always @(CKint_func)
begin
   lastCK_func=CKreg_func;  
   CKreg_func=CKint_func;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
        if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
      if (CKreg_func === 1'bX || (CKreg_func === 1'b1 && lastCK_func === 1'bx)) begin
        if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
         
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
         Invalid_next_cycle_func;
        end
      end
      else if (CKreg_func === 1'b1 && lastCK_func === 1'b0 ) begin
        time_CK_func_rise=$realtime;
        MEMEN_prev = MEMEN_reg;
        MEMEN_reg = MEMEN;
        CSNreg = CSNint;
        IGreg = IGint;
        DEreg = DEint;
        SE_reg = SEsys;
        TBYPASS_reg = TBYPASSsys;
        ATPreg = ATPint;
        INITNreg = INITNint;
        SLEEPreg = SLEEPint;
        STDBYreg = STDBYint;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 

    `ifdef functional
    `else
        Mem_last=Mem[Aint];
    `endif 
        if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.INITN pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SLEEP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.STANDBY pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg === X && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.chip select  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg === X && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.IG pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg === X && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.Debug pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg === X && (SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.ATP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg === X && TBYPASS_reg !== 1) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SE pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg !== 1 && TBYPASS_reg === X) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.TBYPASS pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end

        else if ((INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0))) && WENint === X) begin
            // Uncertain write cycle
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: write enable going to X  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end 
        else if (next_cycle_corrupt_func === 1) begin
          next_cycle_corrupt_func = X;
        end
        else if (next_cycle_corrupt_func === 1'bx) begin
          next_cycle_corrupt_func = 0;
        end 
        
//        if (next_cycle_corrupt_func === 0 ) begin 
         
          /*---------------------- File initialization -----------------*/
          
          if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0)) && flag_mem_block === 1'b0) begin
                 Areg=Aint;
                 Dreg=Dint;
                 Mreg=Mint;
                 WENreg=WENint;     
             if (reg_MEM_INITIALIZE === 1'b1 && $realtime >= reg_File_load_time && file_loaded ) begin   
                `ifdef slm
                  if (reg_BinaryInit)
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_BIN");
                  else
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_HEX");
   
                `else
                  if (reg_BinaryInit)
                     $readmemb(reg_InitFileName, Mem, 0, Words-1);
                  else
                     $readmemh(reg_InitFileName, Mem, 0, Words-1);
                `endif
                 file_loaded = 0;
             end
   
             if (^Aint === X)
               ValidAddress = X;
             else if (Aint < Words)
               ValidAddress = 1;
             else    
               ValidAddress = 0;
   
             if(red_en === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Redundancy Enable is Invalid. Either RRAE is X or TRRAE is X",$realtime);
                ValidAddress = X; 
           end
           else if(red_en === 1'b1 && ^repair_add === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Repair Address is invalid.RRA is X",$realtime);
                ValidAddress = X;
           end
             
             if (ValidAddress)
               `ifdef slm
                   $slm_ReadMemoryS(MemAddr, Aint, Mem_temp);
               `else
                    Mem_temp = Mem[Aint];
               `endif
             else
                Mem_temp = WordX;  
          
     /*---------------------- Normal Read and Write -----------------*/
     
             if (WENint === 1) begin
               ReadCycle(Aint);
             end
       
             else if (WENint === 0) begin
               WriteCycle(Aint);
             end 
                
          
          end //  if (MEMEN === 1'b1 
       
//        end  // if (next_cycle_corrupt_func === 0
      
      end // if (CKint = 1   
   end // if (init_pulse_done === 1           
 end 
end // always @(CKint_func)
        
always @(MEMEN)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) && CKint_func === 1'bx) begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.clock pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
    Invalid_next_cycle_func;
  end
 end 
end

// DFT CK block starts
//======================================
always @(CKint_dft) 
begin
   lastCK_dft=CKreg_dft;
   CKreg_dft=CKint_dft;
   
   Latch_open=0;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
     if (CKreg_dft === 1'bX || (CKreg_dft === 1'b1 && lastCK_dft === 1'bx)) begin
       if (INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0 ) begin
        
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: DFT clock  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime); 
         Invalid_next_cycle_dft;
         if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
           WriteOutX;
         end
       end
     end 

     if(CKint_dft === 0 && lastCK_dft === 1) begin
      if(ATPreg === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
       if(SE_reg === 1'b1 && SEsys === 1'b0) begin
        if(TBYPASSint === 1'b1) begin   
    
       
       
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],
scanreg_dr_wire[10],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9], scanreg_dl_wire[scanlen_l-1]}; 
       


         for (i = 0; i < Bits; i = i + 1)
         begin
          if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
         end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
        end 
       end
      end
     end 
     
     else if (CKreg_dft === 1'b1 && lastCK_dft === 1'b0 ) begin
       SE_reg = SEsys;
       TBYPASS_reg = TBYPASSsys;
       ATPreg = ATPint;
       INITNreg = INITNint;
       SLEEPreg = SLEEPint;
       STDBYreg = STDBYint;
       MEMEN_dft_prev = MEMEN_dft_reg;
       MEMEN_dft_reg = MEMEN_dft;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 
       if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ) begin 
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
 //     else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys === X && TBYPASSsys !== 1) begin
///           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
//           Invalid_next_cycle_dft;
//        end       
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys === X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
        end 
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys !== 0 && LP_CK_gate===X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: LP FLOP Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           ScanChainX;
           ScanOutX;   
          if( TBYPASSint !== 0 && SEint !== 1) begin
            WriteOutX;
          end
          next_cycle_corrupt_dft=0;
        end        
       else if (next_cycle_corrupt_dft === 1'b1) begin 
         next_cycle_corrupt_dft = X;
       end 
       else if (next_cycle_corrupt_dft === 1'bx) begin
         next_cycle_corrupt_dft = 0;
       end
       
       if (next_cycle_corrupt_dft === 0 ) begin
         
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1 && flag_mem_block === 1'b0) begin
           
           if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0  && LP_CK_gate===0) begin
              OutReg_data_tbypass = Dint;
              for (i = 0; i < Bits; i = i + 1)
              begin
               if (OutReg_data_tbypass[i] !== OutReg_data[i])
                 OutReg_data[i] = WordX[i];
              end//for (i = 0; i < */ 
              OutReg_data <= OutReg_data_tbypass;
           end
           
             scan_acquire;
         end //MEMEN_dft == 1        
       end // if ( next_cycle_corrupt_dft
       
     end // if (CKint_dft === 1'b1
      //  if (next_cycle_corrupt_dft === 0 ) begin 
       if (SE_reg !== 0) begin
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1  && flag_mem_block === 1'b0) begin
           next_cycle_corrupt_dft = 0;
           if ( next_cycle_corrupt_func === 1) begin
	    next_cycle_corrupt_func = 0 ;
	   end	
           scan_shift;
         end
       end
     //end // if ( next_cycle_corrupt_dft    
     if ((!(TBYPASSsys!==0 && SEsys!==1 && LP_CK_gate!==0 ) && next_cycle_corrupt_dft === 0) || CKint_dft !==1) begin          
       CK_sc=INITNreg & !STDBYreg & !SLEEPreg & ATPreg & CKreg_dft ;
     end     
   end // if (init_pulse_done 
 end // if (supply_ok 
end // always @(CKint_dft)

always @(MEMEN_dft)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) && CKint_dft === 1'bx)  begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.MEMEN_dft and clock should not be X at this time instant. ScanChains and ScanOuts Corrupted ",$realtime); 
    Invalid_next_cycle_dft;
    
    if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
      WriteOutX;
    end
  end
  if ( MEMEN_dft !== 0 && TBYPASSsys !== 0 && SEsys !== 1) begin
     WriteOutX;
     OutReg_data = WordX; 
     delOutReg_data=WordX;
 end 
end
end //always @(MEMEN_dft

always @(TBYPASSsys or ATPint)
begin
   if(supply_ok === 1'b1) begin 
    if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0 && INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1) begin
      if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
    end  
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint === X && SEsys !== 1) ) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end 
end //always @(TBYPASSint





always @(SEsys)
begin
 if(supply_ok === 1'b1) begin 
  if(CKint_dft === 0 && ATPint === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
    if(SE_reg === 1'b1 && SEsys === 1'b0) begin
      if(TBYPASSsys === 1'b1) begin
  
     
         
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],
scanreg_dr_wire[10],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9], scanreg_dl_wire[scanlen_l-1]};
           
      


        for (i = 0; i < Bits; i = i + 1)
        begin
         if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
        end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
      end
    end
  end
  if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0) begin
      if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
  end 
  else if ((TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint === X && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end   
end

//assign output data
`ifdef functional        

   
always @(SDLOint)
#0.001 delSDLO_data<=SDLOint;

always @(SDROint)
#0.001 delSDRO_data<=SDROint;

 
always @(SCTRLOint)
#0.001 delSCTRLO_data<=SCTRLOint;


always @(OutReg_data)
   #0.001 delOutReg_data = OutReg_data;
`else
`endif

/***************************** Embeded switch functionality starts here ***********************************/





always @(STDBYint)
begin
  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0 && STDBYint !== 1'b0)
    begin
      ScanOutX;
      ScanChainX;
     delScanOutX;     
    end
  end
end



always @(SLEEPint)
begin


  if (SLEEPint !== 1'b1) begin
    time_fall_sleep = $realtime;
  end

  if (power_up_done === 0)
    begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
    end
  else begin
    if (SLEEPint === 1'b1 && lastSLEEP === 1'b0 ) begin 
      
    end
    else if (SLEEPint !== 1'b1 && lastSLEEP === 1'b1 && full_shutdown !== 1) begin 
      
      if (supply_ok !== 1 && ($realtime > 0)) begin
         if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID LOW_POWER) ERROR: ISOLATION signal removed from the memory but array and periphery supply is not completely switched on.Very High Current would be drawn by the memory. All further operations on memory are blocked",$realtime);
          WriteMemX;
          WriteOutX;
          ScanChainX;
          OutReg_data = WordX; 
          delOutReg_data=WordX;
          ScanOutX;//immediately;
          delScanOutX;//immediately;
          init_pulse_done = 0;
          power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            debug_level = 2'b11;
          `endif
          
      end        
      
       
    end   
    else if (SLEEPint === X && lastSLEEP === 1'b0 && full_shutdown !== 1'b1) begin 
     
    end 
  end  


  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && SLEEPint !== 0)
    begin
      ScanOutX;
      ScanChainX;
        delScanOutX;      
    end
  end

// if (init_pulse_done === 0)
//   begin
//     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
//   end
//
// else if ( SLEEPint !== 1 && (supply_ok !==1) ) begin
//    
//    WriteOutX;
//    OutReg_data = WordX; 
//    delOutReg_data=WordX;
//    ScanOutX;//immediately;
//    delScanOutX;//immediately;
//    ScanChainX;
//    WriteMemX;
//    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies with sleep/Power down signal being low.This scenario can lead to high dc currents and some reliability issues Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
// end

 print_sleep;    
 lastSLEEP=SLEEPint;
end

/********************************** Embeded switch functionality ends here *******************************/

task print_sleep;
begin
  if (SLEEPint === 1'b0) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been deasserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end  
  else if (SLEEPint === 1'b1) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been asserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_ACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif

  end        
  else begin
      if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) ERROR: SLEEP pin is at an invalid state.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INVALID in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end        
end
endtask





 

//// C28SOI non flip compiler power functionality 
always @(gndmreg )
begin
 if (power_up_done === 1 && $realtime > 0) begin    
    if(gndmreg !== 1'b0 ) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or gndsm is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
        corrupt_all;
        init_pulse_done = 0;
        power_up_done = 0;
     `ifdef NO_BLOCK_MEM
     `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of ground pins.Ground must be maintained at 0 Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime);
        debug_level = 2'b11;
     `endif   

    end   
 end

end




always @(vddmareg )
begin

if (vddmareg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddma(Array Supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 
    end
   end   
   else if (SLEEPint === 1) begin
    WriteMemX;
   end

end

if ((vddmareg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1 ) && $realtime > 0) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddm or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         corrupt_all;
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif

end


end

always @(vddmpreg )
begin
 if (vddmpreg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or vddsmp is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmp(Periphery Supply)/vddsmp(Substrate power supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 

    end
   end   
   else if (SLEEPint === 1) begin
    WriteOutX;
    ScanChainX;
    ScanOutX;
    delScanOutX;//immediately;
    OutReg_data = WordX; 
    delOutReg_data=WordX;
   end
 end

if( (vddmpreg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1'b1 )  && $realtime > 0) begin
         corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif
end
 
 
end


always @(vddmoreg)
begin
  if (power_up_done === 1 && $realtime > 0) begin   
      if (vddmoreg !== 1'b1)  begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin
           corrupt_all;
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
         end //if (vddmareg === 1'b1 

      else if (vddmareg === 1'b0 && vddmpreg === 1'b0   && SLEEPint === 1'b1 &&  $realtime > 0)
        begin 
            if((debug_level < 2) && ($realtime > 0)) $display("%m - %t WARNING: Illegal Value on power pin(s). Memory and Output Corrupted ", $realtime);
 
           corrupt_all;
        end //else if (vddmareg === 1'b 
     end   // if (vddmoreg !== 1'b1)
     else if (vddmoreg === 1'b1 && $realtime > 0 ) begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin     
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           corrupt_all;
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
        end        
     end // else if (vddmoreg === 1'b1
  end 
end // always @(vddmoreg)












always @(gndmreg) begin
 if (gndmreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 0. ",$realtime);
 end
 else if (gndmreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 1. ",$realtime);
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to invalid state. ",$realtime);
 end
end




 
always @(vddmareg) begin
 if (vddmareg === 0) begin 
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 0. ",$realtime);
  vddma_fall_time = $realtime;
 end
 else if (vddmareg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 1. ",$realtime);
  vddma_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to invalid state. ",$realtime);
  vddma_fall_time = $realtime;
 end 

 

end

always @(vddmpreg) begin
 if (vddmpreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 0. ",$realtime);
  vddmp_fall_time = $realtime;
 end
 else if (vddmpreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 1. ",$realtime);
  vddmp_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to invalid state. ",$realtime);
  vddmp_fall_time = $realtime;
 end

 
 
end



// end of C28SOI power functionality 
 


assign supply_ok          =  (vddmareg === 1'b1 && vddmpreg  === 1'b1  && gndmreg === 1'b0 && vddmoreg === 1'b1 ) ? 1'b1 : 1'b0;
assign core_supply_ok     =  (vddmoreg === 1'b1 && vddmareg === 1'b1 && gndmreg === 1'b0 ) ? 1'b1 : 1'b0;
assign peri_supply_ok     =  (vddmoreg === 1'b1 && vddmpreg === 1'b1 && gndmreg === 1'b0  ) ? 1'b1 : 1'b0;

assign full_shutdown = (vddmpreg === 1'b0 && vddmareg === 1'b0   ) ? 1'b1 : 1'b0 ;




`ifdef functional
`else


task WriteLocMskX_bwise;
   input [Addr-1 : 0] Address;
   input [Bits-1 : 0] Mask;

reg [Bits+Red_extrabit:0] tempReg1;
integer num1; 
begin
   tempReg1 = WordX;
   if (^Address !== X )
   begin
      tempReg1 = Mem[Address];
             
      for (j = 0;j< Bits; j=j+1) begin
         num1=j;
        if (Mask[j] === 1'bx)
            tempReg1[num1] = 1'bx;
      end
      Mem[Address] = tempReg1;
      task_insert_faults_in_memory;
   end//if (^Address !== X
   else begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      WriteMemX;
   end   
end
endtask


/****************Actions taken on timing violations*****************/

 always @(TimingViol_data)
// tds or tdh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  for (l = 0; l < Bits; l = l + 1) begin   
    if (CSWEMTBYPASS[l] !== 0) begin
     if((TimingViol_data[l] !== TimingViol_data_last[l])) begin


         Mreg[l] = 1'bx;
     end    
     WriteLocMskX_bwise(Areg,Mreg);
    end   
   end 
  end
    if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin
     scanreg_dl =1'bx; 
     scanreg_dr =1'bx; 
     SDLOint=X;
     SDROint=X;
     `ifdef functional
     `else
     SDLO_data<=1'bx;
     SDRO_data<=1'bx;
     `endif
    end
     TimingViol_data_last = TimingViol_data; 
end





always @(TimingViol_addr)
// tas or tah
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
      scanreg_ctrl=1'bx; 
      SCTRLOint=X;
      `ifdef functional
      `else
      SCTRLO_data<=1'bx;
      `endif
  end
end


always @(TimingViol_WEN)
//tws or twh
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WEN pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end 

always @(TimingViol_CSN )
// tps or tph 
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;

   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CSN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end

always @(TimingViol_tcycle )
//tcycle
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
   if (MEMEN !== 0 && MEMEN_prev !== 0) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckl )
// tckl 
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckh) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end


always @(TimingViol_tcycle_se )
//tcycle_se
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckl_se  )
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckh_se) begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tbist) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
   end
   if (TBYPASSint !== 1'b0) begin 
    WriteOutX;
   end 
   if (INITNreg !==0 && STDBYreg !== 1 && TBYPASS_reg !== 1 && SLEEPreg !== 1 && SE_reg !== 1 && IGreg !== 1 && DEreg !== 1) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBIST pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end






always @(TimingViol_tbypass)
//ttmck
begin
#0  
  WriteOutX;
  if (INITNreg !== 0 && SLEEPreg !== 1 && SE_reg !== 1 && STDBYreg !== 1 &&  DEreg !== 1) begin
   Invalid_next_cycle_dft_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
end



always @(TimingViol_sleep)
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_stdby)
begin
#0
  if (CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin 
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (ATPreg !== 0) begin 
   Invalid_next_cycle_dft_tim;
  end
end






always @(TimingViol_se) begin
#0
   if (TBYPASS_reg !== 0) begin 
    WriteOutX;
   end 
  if (TBYPASS_reg === 0) begin
     WriteOutX;
     WriteMemX;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE timing violation  Memory State Machine is corrupted. Output Corrupted ",$realtime); 
  end 
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
  end
end

always @(TimingViol_sctrli) begin
  scanreg_ctrl=1'bx; 
end


always @(TimingViol_sdli) begin
 scanreg_dl=1'bx; 
end

always @(TimingViol_sdri) begin
   scanreg_dr=1'bx;
end

 

always @(TimingViol_initnl) begin
init_pulse_done=0;
WriteOutX;
OutReg_data = WordX; 
delOutReg_data=WordX;
ScanOutX;
delScanOutX;
ScanChainX;
WriteMemX;
end

always @(TimingViol_initn) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end

always @(TimingViol_ig) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && INITNreg !== 0 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: IG pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   ScanChainX;
   ScanOutX;
   delScanOutX;       
  end
end

always @(TimingViol_atp) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin  
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_rm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^WMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: RM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
   end
end
 
always @(TimingViol_wm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^RMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);        
   end
end 


`endif


endmodule




module ST_SPREG_LOLEAK_128x22m4_Tl_lock_up_latch (EN,D,Q);
input EN,D;
output reg Q;

  always @ (EN or D) begin
    if (EN === 1) begin
       Q = D;
    end
    else if ((EN === 1'bz || EN === 1'bx  )&& D !== Q) begin
        Q=1'bx;
    end    
  end
endmodule

module ST_SPREG_LOLEAK_128x22m4_Tl_SCFF (D,TI,TE,CP,Q,OUTX);
input D,TI,TE,CP;
input OUTX;
output reg Q;
wire Dint;
assign Dint= (TE===1)?TI:(TE===0)?D:1'bx;

always @(posedge CP)
        begin
          if(Dint === 1'bZ || CP ===1'bx || OUTX === 1'bx)
          begin
                  Q = 1'bx;
          end
          else
          begin
                  Q = Dint;
          end        
        end
always @(posedge OUTX)
Q = 1'bx;
endmodule



`undef setup_time
`undef hold_time
`undef access_time
`undef retain_time
`undef cycle_time
`undef pulse_width_time
`undef initin_low_pulse


`delay_mode_path
`endcelldefine
`nosuppress_faults






/****************************************************************
--  Description         : Verilog Model 
--  ModelVersion        : 1.2
--  Date                : Apr, 2013
--  Changes Made by	: PS
--  Revision History    : 
 
****************************************************************/


/******************** START OF HEADER****************************
   This Header Gives Information about the parameters & options present in the Model
   
   words = 256
   bits  = 21
   mux   = 4 
   
   
   
   write_mask = no 
   
   margin_control = yes 
   
   
   Dft = Yes  

    ------------------------------------------------------------------------------------
     Signal Name             | Description       |             Port Mode        | Active When
                             |                   |          r    |  w   | rw    |
   ------------------------------------------------------------------------------------

    D 	        Data in                     na     x      na       -  
    IG    Input Gate Enable           x      x      na       High     
    ATP            ATPG Enable                 x      x      na       High     
    INITN                 INITN pin                   x      x      na       Low
    
    
     
    Q 	        Data out	            x      na     na       -
    A              Address                     x      x      na       high and low
    
    CK                Clock	                    x      x      na       posedge
    CSN          Chip Enable                 x      x      na       low
    
    RM         Read Margins                 x      x      na       High 
    SCTRLI         Scan Input (Control)
    SCTRLO        Scan Output (Control)
    SDLI         Scan Input (Data-Left)
    SDLO        Scan Output (Data-Left)
    SDRI         Scan Input (Data-Right)
    SDRO        Scan Output (Data-Right)
    SE          Scan Enable pin 
    STDBY              Standby pin                 x      x      na       High
    
    SLEEP                        Sleep pin                   x      x      na        High 
    
     
     
    TBIST          Bist Enable Pin 
    
    TBYPASS                      Memory Bypass                na     na     na        High
    
    TED        Bist Even Data pin
    TOD         Bist Odd Data Pin
     
    TA         Bist Read Address
    TCSN     Bist Read Chip Select
    
    TWEN    Bist Write Enable 
    WEN         Write Enable                na     x      na       Low 
    
    WM        Write Margins Code          x      x      na       -
     

******************** END OF HEADER ****************************/


//********************************************//
// ST_SPREG_LOLEAK_256x21m4_Tl Verilog Model                 //  
//********************************************//




`ifdef slm
        `define functional
`endif

`celldefine
`suppress_faults
  `ifdef functional
   `delay_mode_unit
  `else
   `delay_mode_path
  `endif

`define setup_time 0.0
`define hold_time 0.0
`define access_time 1.0
`define retain_time 0.9
`define cycle_time 0.0
`define pulse_width_time 0.0
`define initin_low_pulse 0.0



 






`timescale 1ns / 1ps


module ST_SPREG_LOLEAK_256x21m4_Tl (A,ATP,CK,CSN,D ,IG,INITN , Q ,RM    ,SCTRLI,SCTRLO,SDLI,SDLO,SDRI,SDRO,SE,SLEEP   , STDBY  ,TA,TBIST   ,TBYPASS ,TCSN,TED ,TOD   ,TWEN ,WEN,WM  );

 parameter
  Words = 256,
  Bits = 21,
  Addr = 8,
  mux = 4,
  repair_address_width = 6,
  write_margin_size = 2, 
  read_margin_size = 3; 

 //  INPUT OUTPUT PORTS DECLARATION DONE SEPARATELY FOR SPREG and ROM
 // ========================


        output [Bits-1 : 0] Q;
         
        output SCTRLO;
        input SE,SCTRLI;
        
        input [Addr-1 : 0] A;
        
        input [read_margin_size-1 : 0] RM;
        
         
        input CK,CSN,INITN,IG,ATP; 
        
        
        input [Addr-1 :0 ] TA;
input TBIST,TCSN ;
        
        input STDBY;
        
        input SLEEP; 
        
         
        
        
         
        output SDLO;
        output SDRO;
        
        
        
        
        input [Bits-1 : 0] D ;
	
          
         
        
        input [write_margin_size-1 : 0] WM;
        
        
        input TBYPASS;
        
        input WEN;
        
        
         
        input SDLI,SDRI  ; 
        
        
        
        //Bist inputs
        // ===========
        input TWEN,TED,TOD; 
        
        
        
        

        






    parameter
        Fault_file_name = "ST_SPREG_LOLEAK_256x21m4_Tl_faults.txt",
        `ifdef ConfigFault
        ConfigFault = 1,
        `else
        ConfigFault = 0,
        `endif
        max_faults = 258,
        
        MEM_INITIALIZE  = 1'b0,
        BinaryInit = 1'b0, 
        InitFileName = "ST_SPREG_LOLEAK_256x21m4_Tl.cde",
        Debug_mode = "all_warning_mode",
        File_load_time=0,
        Initn_reset_value={21{1'b0}},
        InstancePath = "ST_SPREG_LOLEAK_256x21m4_Tl";
    
    parameter
        
        bank = 1, 
        mux_bits=2,
        Red_extrabit=0,
        bank_bits = 0,
        RedWords = mux * 2 * bank,
        max_address_bits = 15 ,
        Rows = Words/mux;

  
    parameter 

     

        
           scanchains=3,    
          
        
        scanlen_ctrl=15,
        
        

      

        
        scanlen_r=(Bits)/2,
        
        scanlen_l=(Bits+1)/2 ; 
      
      

    parameter
        
        `ifdef functional  
            RW_assertions_en = 0,
        `endif
        WordX = {Bits{1'bx}},
        AddrX = {Addr{1'bx}},
        Word0 = {Bits{1'b0}},
        X = 1'bx;
   



//  WIRE DECLARATION RELATED TO POWER PINS
//  ======================================
	
        wire supply_ok, full_shutdown;
        
        wire core_supply_ok;
        wire peri_supply_ok;

        wire gndmint, gndsmint;
         
        
        wire vddmpint;
        wire vddmoint;
        wire vddmaint;
        wire vddsmpint;  
        wire vddsmaint;  
        
        

//  WIRE DECLARATION 
//  ==================
        wire [Bits-1 : 0] CSWEMTBYPASS;
        wire [Bits-1 : 0] Dint, Dsys;
        wire [Bits-1 : 0] Mint; 
        wire [21-1:0] Msys;
	wire [Addr-1 : 0] Aint;
        wire [Addr-1 : 0] Asys;

       


        wire [max_address_bits-1 : 0] A_int; 
                
	wire CKint_dft;
	wire CKint_func;
	wire CSNint;
        wire MEMEN;
        wire MEMEN_dft;
        wire TSE;

	wire WENint;
	wire WENsys;
        wire SLEEPint;
        wire STDBYint;
        wire SEint;
        wire SEsys;
        wire SCTRLIint;
        wire SDLIint;
        wire SDRIint;
        
        wire INITNint;
        wire TBYPASSint;
        wire TBYPASSsys;
        wire LSint; 
        wire HSint; 
        wire ATPint;
        wire DEint;
        
        wire [Addr-1 : 0] TAint;
        wire TBISTint;
        wire TBISTsys;
        wire TCSNint;
        wire TEDint;
        wire TODint;
        wire TEMint;
        wire TOMint;
        wire [Bits-1 : 0] TMint;
        wire [Bits-1 : 0] TDint;
        wire TWENint;
        wire IGint;
        wire IGbuf;
        wire CSNbuf;
        wire WENbuf;
        wire [read_margin_size-1:0] RMint;
        wire [write_margin_size-1:0] WMint;

        //Wires for scan chains
        //  ====================     
        wire [scanlen_ctrl -1:0]scanreg_ctrl_wire;
        wire [scanlen_l -1:0]  scanreg_dl_wire; 
        wire [scanlen_r -1:0]  scanreg_dr_wire; 
   
        wire [scanlen_l -1:0]  scanreg_ml_wire; 
        wire [scanlen_r -1:0]  scanreg_mr_wire; 


        wire [repair_address_width -1 : 0] RRAint;
        wire RRAEint;
        wire TRRAEint;    
        wire red_en;
        wire [repair_address_width -1 : 0] repair_add, next_repair_add;


//  REG DECLARATION
//  ====================     
        reg MEMEN_reg;
        reg MEMEN_prev;
        reg reg_mem_block;
        reg flag_mem_block;
        reg SCTRLIint_temp;
        reg SDLIint_temp;
        reg SDRIint_temp;
        reg SMLIint_temp;
        reg SMRIint_temp;

        //  REG DECLARATION
        //  ====================
        reg SCTRLOint;
        
        reg SDLOint,SDROint;
         
        
        reg next_cycle_corrupt_func;
        reg next_cycle_corrupt_dft;
        reg [Bits-1 : 0] delOutReg_data;//delayed Output Register
        reg [Bits-1 : 0] OutReg_data;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_tbypass;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_scan;   // Data Output registe
        reg [Bits-1 : 0] OutReg_rado_retained;   // register for retaining rado data when SLEEP --> 1
        reg delSCTRLO_data,SCTRLO_data;      // delayed Output Register
        reg delSDLO_data,SDLO_data;      // delayed Output Register
        reg delSDRO_data,SDRO_data;      // delayed Output Register
        
        
        // SCAN CHAINS register
        reg scanreg_ctrl; 
        reg scanreg_dl; 
        reg scanreg_dr; 
        
        
        reg CK_sc;
        reg Latch_open=0;
        reg lastCK_dft,CKreg_dft;
        reg lastCK_func,CKreg_func;
        reg lastSLEEP;
        reg lastPSWLARGEMP,lastPSWLARGEMA,lastPSWSMALLMP,lastPSWSMALLMA;
        reg CSNreg;
        reg init_pulse_done; //if == 1 then it implies that initb low pulse has been applied
        reg power_up_done; //if == 1 then it implies that power up has been done
        `ifdef slm
        `else
	      
             reg [Bits-1 : 0] Mem [Words-1 : 0];
             reg [Bits-1 : 0] RedMem [RedWords-1 : 0];
 
        `endif
        
	reg [Bits-1 :0] Mem_temp;
        reg [Bits-1 :0] Mem_slm; 
	reg ValidAddress;
	reg ValidDebugCode;
        reg decoding_start;
        reg file_loaded;
        reg [Bits-1 :0] Dreg;
        reg [Bits-1 :0] Mreg;
        reg WENreg;
        reg [Addr-1 :0] Areg;
        reg SE_reg;
        reg TBYPASS_reg;
        reg INITNreg;
        reg IGreg;
        reg DEreg;
        reg SLEEPreg;
        reg STDBYreg;
        reg ATPreg;
        reg MEMEN_dft_reg;
        reg MEMEN_dft_prev;
        reg RRMATCHreg;
        reg RRMATCHreg_last;//changes_made
        reg RRMATCHreg_glitch;
        reg [repair_address_width -1 : 0] repair_add_last;
        reg RRAEint_last;
        reg [Addr-mux_bits-1:0] row_add_temp;
        reg [Addr-mux_bits-bank_bits-1:0] row_add_cmp_temp;

       
        //parameter registers
        reg [2047:0] reg_Fault_file_name;
        reg reg_ConfigFault;
        reg reg_MEM_INITIALIZE;
        reg reg_BinaryInit;
        reg [2047:0] reg_InitFileName;
        reg [Bits -1 :0] reg_Initn_reset_value;
        time reg_File_load_time;

        //Power Supply Registers        
        reg vddmireg;
        reg vddmreg;
        reg vddsmreg;
        reg gndmreg;
        reg gndsmreg;   
        reg vddmpreg;
        reg vddmpireg;
        reg vddmareg;
        reg vddsmpreg;
        reg vddsmareg;
        reg vddmoreg;
        time vddmp_rise_time;
        time vddmp_fall_time;
        time vddsmp_rise_time;
        time vddsmp_fall_time;
        time vddma_rise_time;
        time vddma_fall_time;
        time vddsma_rise_time;
        time vddsma_fall_time;
        reg reg_check_rise;
        reg reg_check_fall;
        reg reg_check_rise_vddma;
        reg reg_check_fall_vddsma;
        reg  reg_check_rise_vddm, reg_check_fall_vddsm ;
        time vddm_fall_time,  vddm_rise_time,  vddsm_fall_time, vddsm_rise_time ;
  /* This register is used to force all warning messages 
  ** OFF during run time.
  ** It is a 2 bit register.
  ** USAGE :
  ** debug_level_off = 2'b00 -> ALL MESSAGES(INFO/WARNINGS/ERRORS) will be DISPLAYED 
  ** debug_level = 2'b01     -> ONLY WARNINGS/ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b10     -> ONLY ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b11     -> NO MESSAGES will be DISPLAYED.
  */ 
        reg [1:0] debug_level;
        reg [8*10: 0] operating_mode;
        reg [8*44: 0] message_status;

        integer i, k, j, l,m,q,w,r,s,num1,redcnt,n,num2,FirstHalf,Bfaileff,memcnt,ptr;
        integer decoder[Bits-1:0];
        `ifdef slm
           integer MemAddr;
        `endif


        //************************************************************
        //****** CONFIG FAULT IMPLEMENTATION VARIABLES*************** 
        //************************************************************ 

        integer file_ptr, ret_val;
        integer fault_word;
        integer fault_bit;
        integer fcnt, Fault_in_memory,faultnum,stop_loop,count;
        integer t;  
        integer FailureLocn [max_faults -1 :0];
        integer Failurebit [max_faults -1 :0];
        reg [100 : 0] stuck_at;
        reg [100 : 0] fault_array;
        reg [200 : 0] tempStr;
        reg [7:0] fault_char;
        reg [7:0] fault_char1; // 8 Bit File Pointer
        reg [Addr -1 : 0] std_fault_word;
        reg [Addr -1 : mux_bits] fault_row_add [max_faults -1 :0];
        reg [max_faults -1 :0] fault_repair_flag;
        reg [max_faults -1 :0] dont_insert_fault;
        reg [max_faults -1 :0] repair_flag;
        reg [100 : 0] array_stuck_at[max_faults -1 : 0] ;
        reg [100 : 0] mem_red_array_stuck_at[max_faults -1 : 0] ; 
        reg msgcnt;
        
       
        reg [Bits - 1: 0] stuck_at_0fault [max_faults -1 : 0];
        reg [Bits - 1: 0] stuck_at_1fault [max_faults -1 : 0];
        reg [Bits -1 : 0] stuck0;
        reg [Bits -1 : 0] stuck1;

        reg [Bits+Red_extrabit :0] Mem_last;
        

        `ifdef slm
        reg [Bits -1 : 0] slm_temp_data;
        `endif
        
        real time_CK_func_rise , time_RADCK_rise;
        real time_fall_sleep,time_fall_PSWLARGEMP,time_fall_PSWLARGEMP_0,time_fall_PSWLARGEMA,time_fall_PSWLARGEMA_0,time_fall_PSWSMALLMP,time_fall_PSWSMALLMA;
        integer flag_error;
        
//BUFFER INSTANTIATION
//=========================
       `ifdef functional
       
         buf (SCTRLO,delSCTRLO_data); 
         buf bufq [Bits-1:0] (Q,delOutReg_data);
      `else
       
         buf (SCTRLO,SCTRLO_data);
         buf bufq [Bits-1:0] (Q,OutReg_data);
      `endif
      
  
        buf (SEsys,SE);
	buf (SCTRLIint, SCTRLI);
   

	buf (CKint_func, CK);
	buf (CKint_dft, CK);
        buf bufaddr [Addr-1:0] (Asys,A);
        buf (INITNint,INITN);
        
        buf (LSint,1'b0); 
        buf (IGbuf,IG);
        buf (ATPint,ATP);

        buf bufTaddr [Addr-1 : 0] (TAint,TA);
        buf (TBISTsys,TBIST);
        buf (TCSNint,TCSN);

        buf (CSNsys,CSN);
        buf (STDBYint,STDBY );   
        
        buf (SLEEPint,SLEEP ); 

        buf bufrm [read_margin_size-1:0] (RMint, RM); 

        
        

        assign RRAEint = 1'b0;
        assign TRRAEint = 1'b0;
        assign repair_add = 0;
        assign next_repair_add = 0;
        assign red_en = 1'b0; 
        
        
        
        
        
        
        
        buf (PSWLARGEMPint,1'b0);
        buf (PSWSMALLMPint,1'b0); 
        buf (PSWLARGEMAint,1'b0);
        buf (PSWSMALLMAint,1'b0);   

      `ifdef functional
       
       
         buf (SDLO,delSDLO_data);
         buf (SDRO,delSDRO_data);
        
      `else
       
         buf (SDLO,SDLO_data);
         buf (SDRO,SDRO_data);
         
      `endif
       
         
       
        buf bufdata [Bits-1:0] (Dsys,D);
        
        
        assign Msys=21'b0; 
	

        
        buf (TBYPASSsys, TBYPASS);
        


        buf (WENsys,WEN);
	 
	buf (SDLIint, SDLI);
	buf (SDRIint, SDRI);
	 
        
        buf (HSint,1'b0); 

        
        buf (TEDint,TED);
        buf (TODint,TOD);
         
        buf (TWENint,TWEN);
        
        
        buf bufwm [write_margin_size-1:0] (WMint, WM); 
        



//      assign scanreg_ctrl_wire={scanreg_ctrl[scanlen_ctrl - 2:0],SCTRLIint};
//      assign scanreg_dl_wire={scanreg_dl[scanlen_l - 2:0],SDLIint};
//      assign scanreg_dr_wire={scanreg_dr[scanlen_r - 2:0],SDRIint};
      
        
      assign Aint   = (TBISTint === 1'b0 ) ? Asys : (TBISTint === 1'bx ) ? {Addr{1'bx}} : TAint;  

        
//        assign A_int = Aint;
	
        
                
        assign Dint[0] = (TBISTint === 1'b0) ? Dsys[0] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[1] = (TBISTint === 1'b0) ? Dsys[1] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[2] = (TBISTint === 1'b0) ? Dsys[2] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[3] = (TBISTint === 1'b0) ? Dsys[3] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[4] = (TBISTint === 1'b0) ? Dsys[4] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[5] = (TBISTint === 1'b0) ? Dsys[5] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[6] = (TBISTint === 1'b0) ? Dsys[6] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[7] = (TBISTint === 1'b0) ? Dsys[7] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[8] = (TBISTint === 1'b0) ? Dsys[8] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[9] = (TBISTint === 1'b0) ? Dsys[9] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[10] = (TBISTint === 1'b0) ? Dsys[10] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[11] = (TBISTint === 1'b0) ? Dsys[11] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[12] = (TBISTint === 1'b0) ? Dsys[12] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[13] = (TBISTint === 1'b0) ? Dsys[13] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[14] = (TBISTint === 1'b0) ? Dsys[14] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[15] = (TBISTint === 1'b0) ? Dsys[15] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[16] = (TBISTint === 1'b0) ? Dsys[16] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[17] = (TBISTint === 1'b0) ? Dsys[17] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[18] = (TBISTint === 1'b0) ? Dsys[18] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[19] = (TBISTint === 1'b0) ? Dsys[19] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[20] = (TBISTint === 1'b0) ? Dsys[20] : (TBISTint === 1'b1) ? TEDint : 1'bx;          
	 
        assign Mint = 21'b0;
         

        assign WENbuf = (TBISTint === 1'b0 ) ? WENsys : (TBISTint === 1'bx ) ? 1'bx : TWENint;  
        assign WENint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? WENbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[13] : (ATPint === 1'b0 ) ? WENsys : 1'bx ; 
        
        assign CSNbuf = (TBISTint === 1'b0 ) ? CSNsys : (TBISTint === 1'bx ) ? 1'bx : TCSNint;  
        assign CSNint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? CSNbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[11] : (ATPint === 1'b0 ) ? CSNsys : 1'bx ; 
        assign IGint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? IGbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[14] : (ATPint === 1'b0 ) ? IGbuf : 1'bx;

        
        assign DEint = (LSint === 1'bx || (LSint === 1'b0 && HSint === 1'bx) || ^RMint !== 1'b0 || ^WMint !== 1'b0 ) ? 1'bx : 1'b0;
        
     
     and (TBISTint, ATPint, TBISTsys);
     and (SEint, ATPint, SEsys);
     and (TBYPASSint, ATPint, TBYPASSsys);
     and (TSE,TBYPASSint,!SEsys);
     and (MEMEN,INITNint,!CSNint,!SLEEPint,!TBYPASSint,!SEint,!IGint,!DEint,!STDBYint );
     and (MEMEN_dft,INITNint, !SLEEPint, ATPint,!STDBYint);

 `ifdef functional
/*****************assertions added to optimize dynamic power consumption**********/

//psl a_M: assert always ({( RW_assertions_en);(MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1))  } |-> (stable(Msys))) @(posedge CK); 

//psl a_WEN: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(WENsys))) @(posedge CK); 

//psl a_A: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(Asys))) @(posedge CK); 

//psl a_D: assert always ({( RW_assertions_en);((MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1)) && TBYPASSint === 1'b0)  } |-> (stable(Dsys))) @(posedge CK); 

/**********************************************************************************************/
`endif       

     

         
reg vddmp,vddmo, vddma, vddsmp, vddsma, gndsm, gndm,  vddmpi ; 
 
initial 
begin

        vddmp = 1'b1 ; 
        vddmo = 1'b1 ;
        vddma = 1'b1 ;
        
        vddsmp = 1'b1 ;
        
        
         gndm = 1'b0 ;
          
end

        
         assign gndmint = (reg_mem_block === 0) ? gndm : 1'b1;
         
         
         
         
         assign vddmpint = vddmp;
         assign vddmoint = vddmo;
         assign vddmaint = vddma;
         
          
        
         

        //CPF Changes

        
                
        initial
        begin : cpfvddmp 
           vddmpreg = vddmpint;
        end

        always @(vddmpint) begin
           vddmpreg = vddmpint;
        end
        
        initial
        begin : cpfvddmo 
           vddmoreg = vddmoint;
        end

        always @(vddmoint) begin
           vddmoreg = vddmoint;
        end
        
        initial
        begin : cpfvddma 
           vddmareg = vddmaint;
        end

        always @(vddmaint) begin
           vddmareg = vddmaint;
        end

        
        
 
        initial
        begin : cpfgndm 
           gndmreg = gndmint;
        end

        always @(gndmint) begin
           gndmreg = gndmint;
        end

        
        



 `ifdef functional
  `else
  initial begin
    if (debug_level < 1) begin
     $display ("%m  INFORMATION");
     $display ("***************************************");
     $display ("The Model is Operating in TIMING MODE");
     $display ("Please make sure that SDF is properly annotated otherwise dummy values will be used");
     $display ("%s", message_status);
     $display ("***************************************");
    end
  end

//////////////////////////
 //REG DECLARATIONS
   //======================

   reg [Bits-1 : 0] TimingViol_data;
   reg  [Bits-1 : 0] TimingViol_mask;
   reg [Bits-1 : 0] TimingViol_data_last, TimingViol_mask_last;
	reg TimingViol_data_0;
	reg TimingViol_data_1;
	reg TimingViol_data_2;
	reg TimingViol_data_3;
	reg TimingViol_data_4;
	reg TimingViol_data_5;
	reg TimingViol_data_6;
	reg TimingViol_data_7;
	reg TimingViol_data_8;
	reg TimingViol_data_9;
	reg TimingViol_data_10;
	reg TimingViol_data_11;
	reg TimingViol_data_12;
	reg TimingViol_data_13;
	reg TimingViol_data_14;
	reg TimingViol_data_15;
	reg TimingViol_data_16;
	reg TimingViol_data_17;
	reg TimingViol_data_18;
	reg TimingViol_data_19;
	reg TimingViol_data_20;
 reg TimingViol_mask_0;
 reg TimingViol_mask_1;
 reg TimingViol_mask_2;
 reg TimingViol_mask_3;
 reg TimingViol_mask_4;
 reg TimingViol_mask_5;
 reg TimingViol_mask_6;
 reg TimingViol_mask_7;
 reg TimingViol_mask_8;
 reg TimingViol_mask_9;
 reg TimingViol_mask_10;
 reg TimingViol_mask_11;
 reg TimingViol_mask_12;
 reg TimingViol_mask_13;
 reg TimingViol_mask_14;
 reg TimingViol_mask_15;
 reg TimingViol_mask_16;
 reg TimingViol_mask_17;
 reg TimingViol_mask_18;
 reg TimingViol_mask_19;
 reg TimingViol_mask_20;

   reg TimingViol_addr;
   reg TimingViol_CSN, TimingViol_WEN, TimingViol_tbypass;
   reg TimingViol_tckh, TimingViol_tckl, TimingViol_tcycle;
   reg TimingViol_tckh_se, TimingViol_tckl_se, TimingViol_tcycle_se;
   reg TimingViol_sctrli,TimingViol_sdli,TimingViol_sdri,TimingViol_se;
   reg TimingViol_smli,TimingViol_smri;
   reg TimingViol_sctrli_flag,TimingViol_sdli_flag,TimingViol_sdri_flag;
   reg TimingViol_smli_flag,TimingViol_smri_flag;
   reg TimingViol_initnl;
   reg TimingViol_initn;
   reg TimingViol_ls;
   reg TimingViol_hs;
   reg TimingViol_sleep;
   reg TimingViol_stdby;
   reg TimingViol_rm;
   reg TimingViol_wm;
   reg TimingViol_tbist,TimingViol_ig,TimingViol_atp,TimingViol_TED,TimingViol_TOD,TimingViol_TEM,TimingViol_TOM;
   reg TimingViolRRAE,TimingViolRRA;

   wire CSTBYPASSN,cond_sdf_tas,cond_sdf_tds,cond_sdf_tms,cond_sdf_tws,cond_sdf_tbas,cond_sdf_tbps,cond_sdf_tbws,cond_sdf_tbdes,cond_sdf_tbdos,cond_sdf_tbmes,cond_sdf_tbmos;
   wire SETB_EN,CSIG_EN,MEM_ACT,EN_ADM,CS_EN,CS_ADM,cond_sdf_tps,IG_EN,IG_ADM,cond_sdf_tigs,cond_sdf_taa,cond_sdf_taa_ls1,cond_sdf_taa_hs1,cond_tseq_tm;
   wire cond_sdf_tcycle,cond_sdf_tcycle_ls1,cond_sdf_tcycle_hs1,cond_sdf_tcycle_se,cond_sdf_tckl_se,cond_sdf_tsctrlis,cond_sdf_tsdlis,cond_sdf_tsdris,cond_sdf_tsmlis,cond_sdf_tsmris;
   wire cond_sdf_tckh_se,cond_sdf_taa_sctrlo_se,cond_sdf_taa_sdlo_se,cond_sdf_taa_sdro_se,cond_sdf_taa_smlo_se,cond_sdf_taa_smro_se,cond_sdf_tckl,cond_sdf_tckh;
   wire cond_sdf_ttms,cond_sdf_tbists,INITNandnotSLEEPandATPandnotSE,cond_sdf_taa_sctrlo,cond_sdf_taa_sdlo,cond_sdf_taa_sdro,cond_sdf_taa_smlo,cond_sdf_taa_smro;
   wire cond_sdf_taa_tm,cond_sdf_taa_tm_ls1, cond_sdf_taa_tm_hs1,cond_sdf_taa_tckq_tm,cond_sdf_taa_tseq_tm;

   wire CSWETBYPASSN;
   wire cond_sdf_tstdbys,cond_sdf_tsls,sleep_en,atp_csn_en;
   wire cond_sdf_tlss,cond_sdf_thss,cond_sdf_trms,cond_sdf_twms; 
   wire cond_sdf_tses,cond_sdf_tinitns;
   wire tby_se_en;
   wire rra_en;
   wire tbist_atp_en;
   wire rrae_en;
   wire tbist_rrae_en;
   wire cond_sdf_trraes;
   wire cond_sdf_ttrraes;
   wire cond_sdf_taa_trramatch;
   wire cond_sdf_ttrraematch;
   wire cond_sdf_tamatch;
   wire cond_sdf_ttamatch;
   wire cond_sdf_tatpmatch;
   wire cond_sdf_ttbistmatch;



 and (CSWEMTBYPASS[0], !Mreg[0], CSWETBYPASSN);
 and (CSWEMTBYPASS[1], !Mreg[1], CSWETBYPASSN);
 and (CSWEMTBYPASS[2], !Mreg[2], CSWETBYPASSN);
 and (CSWEMTBYPASS[3], !Mreg[3], CSWETBYPASSN);
 and (CSWEMTBYPASS[4], !Mreg[4], CSWETBYPASSN);
 and (CSWEMTBYPASS[5], !Mreg[5], CSWETBYPASSN);
 and (CSWEMTBYPASS[6], !Mreg[6], CSWETBYPASSN);
 and (CSWEMTBYPASS[7], !Mreg[7], CSWETBYPASSN);
 and (CSWEMTBYPASS[8], !Mreg[8], CSWETBYPASSN);
 and (CSWEMTBYPASS[9], !Mreg[9], CSWETBYPASSN);
 and (CSWEMTBYPASS[10], !Mreg[10], CSWETBYPASSN);
 and (CSWEMTBYPASS[11], !Mreg[11], CSWETBYPASSN);
 and (CSWEMTBYPASS[12], !Mreg[12], CSWETBYPASSN);
 and (CSWEMTBYPASS[13], !Mreg[13], CSWETBYPASSN);
 and (CSWEMTBYPASS[14], !Mreg[14], CSWETBYPASSN);
 and (CSWEMTBYPASS[15], !Mreg[15], CSWETBYPASSN);
 and (CSWEMTBYPASS[16], !Mreg[16], CSWETBYPASSN);
 and (CSWEMTBYPASS[17], !Mreg[17], CSWETBYPASSN);
 and (CSWEMTBYPASS[18], !Mreg[18], CSWETBYPASSN);
 and (CSWEMTBYPASS[19], !Mreg[19], CSWETBYPASSN);
 and (CSWEMTBYPASS[20], !Mreg[20], CSWETBYPASSN);

and (atp_csn_en,!ATPint,!CSNint,!IGint);
or (sleep_en,atp_csn_en,ATPint);
or (SETB_EN,SEint,TBISTint);
and (ATP_SETB_EN,ATPint,SETB_EN); 
or (CSIG_EN,IGint,CSNint);
and (MEM_ACT,!ATPint,CSIG_EN);
or (EN_ADM,MEM_ACT,ATP_SETB_EN);
and (CS_EN,!ATPint,IGint);
or (CS_ADM,CS_EN,ATP_SETB_EN);
and (atp_ig_csn_en,!ATPint,!CSNint,!IGint);
and (atp_se_en,!SEsys,ATPint);
or (cycle_en,atp_ig_csn_en,atp_se_en);
and (atp_ig_csn_en_reg,!ATPreg,!CSNreg,!IGreg);
and (atp_se_en_reg,!SE_reg,ATPreg);
or (cycle_en_reg,atp_ig_csn_en,atp_se_en);
and (INITNandnotSLEEPandATPandnotSE,cond_gac,!SEsys,ATPint);
and (csn_ig_en,!IGint,!CSNint);
and (atp_tby_ls_en,atp_se_en,cond_ls_tby_en);
and (IG_EN,!ATPint,!CSNint);
or (IG_ADM,IG_EN,atp_se_en);
and (CSWETBYPASSN, !WENreg, 1'b1);



assign cond_sdf_tsls=((sleep_en && INITNint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tstdbys=((sleep_en && INITNint && !SLEEPint) !==0) ? 1:0;
assign cond_sdf_atps=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_gac=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tas=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tds=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tms=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tws=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tps=((cond_gac && !CS_ADM) !==0) ? 1:0;
assign cond_sdf_tcycle=((cond_gac && cycle_en && !LSint && !HSint) !==0) ? 1:0;  
assign cond_sdf_tcycle_ls1=((cond_gac && cycle_en && LSint) !==0) ? 1:0;
assign cond_sdf_tcycle_hs1=((cond_gac && cycle_en && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_tckh=((cond_gac && cycle_en_reg) !==0) ? 1:0;
assign cond_sdf_tckl=((cond_gac && cycle_en) !==0) ? 1:0;
assign cond_sdf_tcycle_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckl_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsctrlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckh_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_ttms=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_tbists=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_tckq_tm=((cond_gac && SE_reg && ATPreg && TBYPASSsys) !==0) ? 1:0;
assign cond_ls_en=((atp_ig_csn_en || atp_tby_ls_en) !==0) ? 1:0;
assign cond_sdf_tlss=((cond_ls_en && cond_gac) !==0) ? 1:0;
assign cond_sdf_thss=((cond_ls_en && cond_gac && !LSint) !==0) ? 1:0;
assign cond_sdf_trms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_twms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_tses=((cond_gac && ATPint) !==0) ? 1:0;
assign cond_sdf_tbas=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbps=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbws=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tigs=((cond_gac && IG_ADM) !==0) ? 1:0;
assign cond_sdf_taa=((MEMEN_reg && WENreg && !LSint && !HSint) !==0) ? 1:0; 
// assign cond_sdf_taa_tbypass_q = ((MEMEN_reg && ATPint && TBYPASSint) !== 1'b0) ? 1'b1 : 1'b0;
assign cond_sdf_taa_ls1=((MEMEN_reg && WENreg && LSint) !==0) ? 1:0; 
assign cond_sdf_taa_hs1=((MEMEN_reg && WENreg && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && !HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_ls1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && LSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_hs1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tseq_tm=((cond_gac && TBYPASSint) !==0) ? 1:0;
assign cond_sdf_tinitns =(( sleep_en && !STDBYint && !SLEEPint) !==0) ? 1:0;
assign cond_ls_tby_en=((TBYPASSsys || csn_ig_en) !==0) ? 1:0;



//specify block begins

specify
    specparam
    
         PATHPULSE$CK$Q = 0,
         PATHPULSE$CK$SCTRLO = 0,

         PATHPULSE$CK$SDLO = 0,
         PATHPULSE$CK$SDRO = 0,
        
         PATHPULSE$SE$Q = 0,
         
//         PATHPULSE$TBYPASS$Q = 0,


        
         
        
         tsls = `setup_time,
         tslh = `hold_time ,
         tstdbys = `setup_time,
         tstdbyh = `hold_time , 
	 

         
         tcycle = `cycle_time,
         
         
         tckh = `pulse_width_time,
         tckl = `pulse_width_time,
         tcycle_se = `cycle_time,
         tckh_se = `pulse_width_time,
         tckl_se = `pulse_width_time,
         
         ttms = `setup_time,
         ttmh = `hold_time ,
         tps = `setup_time,
         tph = `hold_time ,
         tws = `setup_time,
         twh = `hold_time ,
         tds = `setup_time,
         tdh = `hold_time , 
         tas = `setup_time,
         tah = `hold_time ,
         tses= `setup_time,
         tseh= `hold_time ,
         tsctrlis=`setup_time,
         tsctrlih=`hold_time ,
         tsdlis=`setup_time,
         tsdlih=`hold_time ,
         tsdris=`setup_time,
         tsdrih=`hold_time , 
         tbists=`setup_time,
         tbisth=`hold_time ,
         tbps=`setup_time,
         tbph=`hold_time ,
         tbws=`setup_time,
         tbwh=`hold_time ,
         tbdes=`setup_time,
         tbdeh=`hold_time ,
         tbdos=`setup_time,
         tbdoh=`hold_time ,
         
         tbas=`setup_time,
         tbah=`hold_time ,
         tinitnl=`initin_low_pulse,
         tinitns=`setup_time,
         tinitnh=`hold_time ,
         tatps=`setup_time,
         tatph=`hold_time ,
         tigs=`setup_time,
         tigh=`hold_time ,
         
         
         trms=`setup_time,
         trmh=`hold_time ,
         twms=`setup_time,
         twmh=`hold_time , 

/*************************************************************************************************/
           // taa_tbypass_q = `access_time,
           // th_tbypass_q  = `retain_time,
            taa =`access_time,
            th = `retain_time,

 


            taa_tm =`access_time,
            th_tm = `retain_time,

            
            taa_tseq_tm =`access_time,
            th_tseq_tm = `retain_time,
            taa_tckq_tm   = `access_time,
            th_tckq_tm    = `retain_time,
            taa_sctrlo=`access_time,
            th_sctrlo= `retain_time,
            taa_sdlo=`access_time,
            th_sdlo= `retain_time,
            taa_sdro=`access_time,
            th_sdro= `retain_time,
            
         
            taa_sctrlo_se=`access_time,
            th_sctrlo_se= `retain_time
,
            taa_sdlo_se=`access_time,
            th_sdlo_se= `retain_time,
            taa_sdro_se=`access_time,
            th_sdro_se= `retain_time
         ;  


        /*---------------------- Timing Checks ---------------------*/

	$setup(posedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[7], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[7], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[7], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[7], tah, TimingViol_addr);

	$setup(posedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(posedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(posedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(posedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(posedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(posedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(posedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(posedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(posedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(posedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(posedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(posedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(posedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(posedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(posedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(posedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(posedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(posedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(posedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(posedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(posedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(negedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(negedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(negedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(negedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(negedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(negedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(negedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(negedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(negedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(negedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(negedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(negedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(negedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(negedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(negedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(negedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(negedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(negedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(negedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(negedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(negedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[20], tdh, TimingViol_data_20);

        



        $setup(posedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $setup(negedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, posedge WEN, twh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, negedge WEN, twh, TimingViol_WEN); 
        $setup(posedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$setup(negedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, posedge CSN, tph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, negedge CSN, tph, TimingViol_CSN);
        $period(posedge CK &&& cond_sdf_tcycle, tcycle, TimingViol_tcycle);  

        
        $width(posedge CK  &&& cond_sdf_tckh, tckh, 0, TimingViol_tckh);
        $width(negedge CK  &&& cond_sdf_tckl, tckl, 0, TimingViol_tckl);
        $period(posedge CK &&& cond_sdf_tcycle_se, tcycle_se, TimingViol_tcycle_se);
        $width(posedge CK  &&& cond_sdf_tckh_se, tckh_se, 0, TimingViol_tckh_se);
        $width(negedge CK  &&& cond_sdf_tckl_se, tckl_se, 0, TimingViol_tckl_se);

        
        $setup(posedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $setup(negedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $hold(posedge CK &&& cond_sdf_ttms, posedge TBYPASS, ttmh, TimingViol_tbypass); 
        $hold(posedge CK &&& cond_sdf_ttms, negedge TBYPASS, ttmh, TimingViol_tbypass); 
 



        
        $setup(posedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $setup(negedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $hold(posedge CK &&& cond_sdf_tsls, posedge SLEEP, tslh, TimingViol_sleep);        
        $hold(posedge CK &&& cond_sdf_tsls, negedge SLEEP, tslh, TimingViol_sleep);

        $setup(posedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $setup(negedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $hold(posedge CK &&& cond_sdf_tstdbys, posedge STDBY, tstdbyh, TimingViol_stdby);        
        $hold(posedge CK &&& cond_sdf_tstdbys, negedge STDBY, tstdbyh, TimingViol_stdby); 
        
        
        $setup (posedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
	$setup (negedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
        
        $hold (posedge CK &&& cond_sdf_tses, posedge SE ,tseh,TimingViol_se);
	$hold (posedge CK &&& cond_sdf_tses, negedge SE ,tseh,TimingViol_se);
        
        $setup(posedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis , tsctrlis, TimingViol_sctrli);
        $setup(negedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis, tsctrlis, TimingViol_sctrli);
        $hold(posedge CK &&& cond_sdf_tsctrlis , posedge SCTRLI, tsctrlih, TimingViol_sctrli);        
        $hold(posedge CK &&& cond_sdf_tsctrlis , negedge SCTRLI, tsctrlih, TimingViol_sctrli);

        $setup(posedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $setup(negedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $hold(posedge CK &&& cond_sdf_tsdlis, posedge SDLI, tsdlih, TimingViol_sdli);        
        $hold(posedge CK &&& cond_sdf_tsdlis, negedge SDLI, tsdlih, TimingViol_sdli);

        $setup(posedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $setup(negedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $hold(posedge CK &&& cond_sdf_tsdris, posedge SDRI, tsdrih, TimingViol_sdri);        
        $hold(posedge CK &&& cond_sdf_tsdris, negedge SDRI, tsdrih, TimingViol_sdri);
        
 
	
         
        $width(negedge INITN , tinitnl, 0, TimingViol_initnl);
        
        $setup(posedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        $setup(negedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        
        $hold (posedge CK &&& cond_sdf_tinitns,posedge INITN, tinitnh, TimingViol_initn);
        $hold (posedge CK &&& cond_sdf_tinitns,negedge INITN, tinitnh, TimingViol_initn);

        $setup(posedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $setup(negedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $hold(posedge CK &&& cond_sdf_atps, posedge ATP, tatph, TimingViol_atp);        
        $hold(posedge CK &&& cond_sdf_atps, negedge ATP, tatph, TimingViol_atp);
        
        $setup(posedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $setup(negedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $hold(posedge CK &&& cond_sdf_tigs, posedge IG, tigh, TimingViol_ig);        
        $hold(posedge CK &&& cond_sdf_tigs, negedge IG, tigh, TimingViol_ig);



         
$setup(posedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[2], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[2], trmh, TimingViol_rm); 

        
$setup(posedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(posedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[1], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[1], twmh, TimingViol_wm);
 
        
        $setup(posedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $setup(negedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $hold(posedge CK &&& cond_sdf_tbists, posedge TBIST, tbisth, TimingViol_tbist);        
        $hold(posedge CK &&& cond_sdf_tbists, negedge TBIST, tbisth, TimingViol_tbist);
        
        	$setup(posedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[7], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$setup(negedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[7], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[6], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[7], tbah, TimingViol_addr);
       	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[6], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[7], tbah, TimingViol_addr);

        $setup(posedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$setup(negedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, posedge TCSN, tbph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, negedge TCSN, tbph, TimingViol_CSN); 
       
        $setup(posedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $setup(negedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, posedge TWEN, tbwh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, negedge TWEN, tbwh, TimingViol_WEN);
       
       
        $setup(posedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $setup(negedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, posedge TED, tbdeh, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, negedge TED, tbdeh, TimingViol_TED);

        $setup(posedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $setup(negedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, posedge TOD, tbdoh, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, negedge TOD, tbdoh, TimingViol_TOD);

          


          

          /*-------------------- Propagation Delays ------------------*/
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa, taa, th, taa, th, taa);
                 

/* // //	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[0] +: OutReg_data[0])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[1] +: OutReg_data[1])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[2] +: OutReg_data[2])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[3] +: OutReg_data[3])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[4] +: OutReg_data[4])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[5] +: OutReg_data[5])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[6] +: OutReg_data[6])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[7] +: OutReg_data[7])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[8] +: OutReg_data[8])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[9] +: OutReg_data[9])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[10] +: OutReg_data[10])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[11] +: OutReg_data[11])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[12] +: OutReg_data[12])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[13] +: OutReg_data[13])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[14] +: OutReg_data[14])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[15] +: OutReg_data[15])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[16] +: OutReg_data[16])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[17] +: OutReg_data[17])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[18] +: OutReg_data[18])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[19] +: OutReg_data[19])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[20] +: OutReg_data[20])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q); */ 








	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                





	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                 

	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[0] +: OutReg_data[0])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[1] +: OutReg_data[1])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[2] +: OutReg_data[2])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[3] +: OutReg_data[3])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[4] +: OutReg_data[4])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[5] +: OutReg_data[5])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[6] +: OutReg_data[6])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[7] +: OutReg_data[7])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[8] +: OutReg_data[8])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[9] +: OutReg_data[9])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[10] +: OutReg_data[10])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[11] +: OutReg_data[11])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[12] +: OutReg_data[12])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[13] +: OutReg_data[13])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[14] +: OutReg_data[14])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[15] +: OutReg_data[15])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[16] +: OutReg_data[16])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[17] +: OutReg_data[17])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[18] +: OutReg_data[18])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[19] +: OutReg_data[19])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[20] +: OutReg_data[20])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                



if (cond_sdf_taa_sctrlo) 
        (posedge CK *> (SCTRLO :  SCTRLI)) = (taa_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo); 

if (cond_sdf_taa_sctrlo_se) 
        (negedge CK *> (SCTRLO : SCTRLI)) = (taa_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se); 
 

if (cond_sdf_taa_sdlo) 
        (posedge CK *> (SDLO :  SDLI)) = (taa_sdlo,taa_sdlo,th_sdlo,taa_sdlo,th_sdlo,taa_sdlo); 

if (cond_sdf_taa_sdlo_se) 
        (negedge CK *> (SDLO : SDLI)) = (taa_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se);

if (cond_sdf_taa_sdro) 
        (posedge CK *> (SDRO :  SDRI)) = (taa_sdro,taa_sdro,th_sdro,taa_sdro,th_sdro,taa_sdro); 

if (cond_sdf_taa_sdro_se) 
        (negedge CK *> (SDRO : SDRI)) = (taa_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se); 

  
     




endspecify //specify block ends






// conversion from registers to array elements for data setup violation notifiers

always @(TimingViol_data_0   or TimingViol_TED  )
begin
        TimingViol_data[0]=~TimingViol_data[0];   
end


always @(TimingViol_data_1   or TimingViol_TOD  )
begin
        TimingViol_data[1]=~TimingViol_data[1];   
end


always @(TimingViol_data_2   or TimingViol_TED  )
begin
        TimingViol_data[2]=~TimingViol_data[2];   
end


always @(TimingViol_data_3   or TimingViol_TOD  )
begin
        TimingViol_data[3]=~TimingViol_data[3];   
end


always @(TimingViol_data_4   or TimingViol_TED  )
begin
        TimingViol_data[4]=~TimingViol_data[4];   
end


always @(TimingViol_data_5   or TimingViol_TOD  )
begin
        TimingViol_data[5]=~TimingViol_data[5];   
end


always @(TimingViol_data_6   or TimingViol_TED  )
begin
        TimingViol_data[6]=~TimingViol_data[6];   
end


always @(TimingViol_data_7   or TimingViol_TOD  )
begin
        TimingViol_data[7]=~TimingViol_data[7];   
end


always @(TimingViol_data_8   or TimingViol_TED  )
begin
        TimingViol_data[8]=~TimingViol_data[8];   
end


always @(TimingViol_data_9   or TimingViol_TOD  )
begin
        TimingViol_data[9]=~TimingViol_data[9];   
end


always @(TimingViol_data_10   or TimingViol_TED  )
begin
        TimingViol_data[10]=~TimingViol_data[10];   
end


always @(TimingViol_data_11   or TimingViol_TOD  )
begin
        TimingViol_data[11]=~TimingViol_data[11];   
end


always @(TimingViol_data_12   or TimingViol_TED  )
begin
        TimingViol_data[12]=~TimingViol_data[12];   
end


always @(TimingViol_data_13   or TimingViol_TOD  )
begin
        TimingViol_data[13]=~TimingViol_data[13];   
end


always @(TimingViol_data_14   or TimingViol_TED  )
begin
        TimingViol_data[14]=~TimingViol_data[14];   
end


always @(TimingViol_data_15   or TimingViol_TOD  )
begin
        TimingViol_data[15]=~TimingViol_data[15];   
end


always @(TimingViol_data_16   or TimingViol_TED  )
begin
        TimingViol_data[16]=~TimingViol_data[16];   
end


always @(TimingViol_data_17   or TimingViol_TOD  )
begin
        TimingViol_data[17]=~TimingViol_data[17];   
end


always @(TimingViol_data_18   or TimingViol_TED  )
begin
        TimingViol_data[18]=~TimingViol_data[18];   
end


always @(TimingViol_data_19   or TimingViol_TOD  )
begin
        TimingViol_data[19]=~TimingViol_data[19];   
end


always @(TimingViol_data_20   or TimingViol_TED  )
begin
        TimingViol_data[20]=~TimingViol_data[20];   
end


`endif


// TASK DEFINITION DESCRIPTION
// ================================



task task_insert_faults_in_memory;
begin
   if (reg_ConfigFault)
   begin   
     for(i = 0;i< fcnt;i = i+ 1) begin
        if(mem_red_array_stuck_at[i] === "mem_array") begin
          if (array_stuck_at[i] === "sa0") begin
           `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data & stuck_at_0fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
          `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] & stuck_at_0fault[i];
          `endif
         end //if(array_stuck_at)
                                        
         if(array_stuck_at[i] === "sa1") begin
         `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data | stuck_at_1fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
         `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] | stuck_at_1fault[i]; 
         `endif
         end //if(array_stuck_at)
       end //if mem_red_array_stuck_at
    
    
     end    // end of for
   end  
end
endtask



task task_read_fault_file;
begin
/*  -----------Implemetation for config fault starts------*/
   msgcnt = X;
   t = 0;
   fault_repair_flag = {max_faults{1'b1}};
   repair_flag = {max_faults{1'b1}};
   if(reg_ConfigFault) 
   begin
      file_ptr = $fopen(reg_Fault_file_name , "r");
      if(file_ptr == 0)
      begin     
          if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: File cannot be opened ",$realtime);
      end        
      else                
      begin : read_fault_file
        t = 0;
        for (i = 0; i< max_faults; i= i + 1)
        begin
         
           stuck0 = {Bits{1'b1}};
           stuck1 = {Bits{1'b0}};
           fault_char1 = $fgetc (file_ptr);
           if (fault_char1 == 8'b11111111)
              disable read_fault_file;
           ret_val = $ungetc (fault_char1, file_ptr);
           ret_val = $fgets(tempStr, file_ptr);
           ret_val = $sscanf(tempStr, "%s %d %d %s",fault_array,fault_word, fault_bit, stuck_at) ;
           flag_error = 0; 
           if(ret_val !== 0)
           begin         
              if(ret_val == 3 || ret_val == 4)
              begin
                if(ret_val == 3)
                   stuck_at = "sa0";

                if(stuck_at !== "sa0" && stuck_at !== "sa1" && stuck_at !== "none")
                begin
                    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: Wrong value for stuck at in fault file ",$realtime);
                   flag_error = 1;
                end    
                      
                if(fault_word >= Words)
                begin
                   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Address out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                if(fault_bit >= Bits)
                begin  
                    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Faulty bit out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                
                        
                if(fault_array !== "mem_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array is not mem_array ",$realtime);
                  flag_error = 1;
                end

                if(fault_array === "red_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array can't be on redundancy array in non redundancy cut.",$realtime);
                  flag_error = 1;
                end

                
                

                if(flag_error == 0)
                //Correct Inputs
                begin
                   if(stuck_at === "none")
                   begin
                       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
                   end
                   else
                   //Adding the faults
                   begin
                      FailureLocn[t] = fault_word;
                      Failurebit[t]  = fault_bit ;
                      std_fault_word = fault_word;
                      fault_row_add[t] = std_fault_word[Addr-1:mux_bits];
                      mem_red_array_stuck_at[t] = fault_array;
                      fault_repair_flag[t] = 1'b0;
                      if (stuck_at === "sa0" )
                      begin
                         stuck0[fault_bit] = 1'b0;         
                         stuck_at_0fault[t] = stuck0;
                      end     
                      if (stuck_at === "sa1" )
                      begin
                         stuck1[fault_bit] = 1'b1;
                         stuck_at_1fault[t] = stuck1; 
                      end

                      array_stuck_at[t] = stuck_at;
                      t = t + 1;
                   end //if(stuck_at === "none")  
                end //if(flag_error == 0)
              end //if(ret_val == 2 || ret_val == 3 
              else
              //wrong number of arguments
              begin
                if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: WRONG VALUES ENTERED FOR FAULTY WORD OR FAULTY BIT OR STUCK_AT IN Fault_file_name ",$realtime); 
                flag_error = 1;
              end
           end //if(ret_val !== 0)
           else
           begin 
               if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
           end    
        end //for (i = 0; i< m
      end //begin: read_fault_file  
      $fclose (file_ptr);

      fcnt = t;
      
      //fault injection at time 0.
      task_insert_faults_in_memory;
  end // config_fault 
end
endtask


task WriteMemX;
begin

`ifdef slm
   $slm_ResetMemory(MemAddr, WordX);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = WordX;
   
`endif        
 task_insert_faults_in_memory;
end
endtask

task WriteMem0;
begin
`ifdef slm
   $slm_ResetMemory(MemAddr, Word0);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = Word0;
  
`endif 
   task_insert_faults_in_memory;
end
endtask


task WriteOutX;                
begin
   OutReg_data <= #0 WordX;
end
endtask


task Invalid_next_cycle_func;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_func = 1;
     `else 
       #0 next_cycle_corrupt_func = 0; 
     `endif  
   end 
end
endtask

task Invalid_next_cycle_dft;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_dft = 1;
     `else 
       #0 next_cycle_corrupt_dft = 0; 
     `endif  
  end
end
endtask

task Invalid_next_cycle_func_tim;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
   #0 next_cycle_corrupt_func <= 1;
  end 
end
endtask

task Invalid_next_cycle_dft_tim;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
  #0 next_cycle_corrupt_dft <= 1;
  end
end
endtask


task ScanOutX;                
begin
   
   dff_SCTRLO_SE.Q <= 1'bx;   
   dff_SDLO_SE.Q <= 1'bx; 
   dff_SDRO_SE.Q <= 1'bx; 
    
   
   SCTRLOint=X;
   SDLOint=X;
   SDROint=X;
    
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   SDLO_data<=1'bx;
   SDRO_data<=1'bx;
    
   `endif
end
endtask

task delScanOutX;                
begin
   delSCTRLO_data<=X;
   delSDLO_data<=X;
   delSDRO_data<=X;
    
end
endtask

task ScanChainX;                
begin
 scanreg_ctrl=1'bx; 
 scanreg_dl=1'bx; 
 scanreg_dr =1'bx; 
  
end
endtask

task mem_blocked;
begin
 
   WriteMemX;
   WriteOutX;
   ScanChainX;
   ScanOutX;//immediately;
   delScanOutX;//immediately
   `ifdef POWER_SEQUENCING_OFF
   `else
   reg_mem_block=1;
   `endif
   debug_level = 2'b11;
end
endtask

task corrupt_all;
begin
 
  WriteMemX;
  WriteOutX;
  ScanChainX;
  ScanOutX;
  delScanOutX;//immediately;
  OutReg_data = WordX; 
  delOutReg_data=WordX;
  
end
endtask

task WriteCycle;                  
input [Addr-1 : 0] Address;
reg [Bits-1:0] tempReg1;
reg [Bits-1:0] tempReg_slm;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;


reg repair_flag;

integer po,i,num,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;
begin

   tempReg1 = WordX;
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];

   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};
   
   if (ValidAddress === X )   begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
        WriteMemX;
        if (INITNint !== 0) begin
        `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
           #0 next_cycle_corrupt_func = 1;
       `else 
           #0 next_cycle_corrupt_func = 0; 
       `endif  
   end 

   end


   if (ValidAddress !== X && next_cycle_corrupt_func === 0  )
   begin
         if (red_en === 1 && ((Row_Add_cmp === repair_add) || (Row_Add_cmp === next_repair_add)) ) begin
             repair_flag = 1'b1;
             
             Bank_sel_integer = 0;
                     
             if (Row_Add_cmp === repair_add) begin
               Col_Add_integer  = Col_Add; 
             end
             else if (Row_Add_cmp === next_repair_add) begin
               Col_Add_integer  = Col_Add + mux; 
             end  
             RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
        end  

        if(repair_flag === 0 && ValidAddress === 1) begin
           `ifdef slm
              $slm_ReadMemoryS(MemAddr, Address, tempReg_slm);
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = Mem[Address];
            `endif
          end  
        else if(repair_flag === 1) begin
           `ifdef slm
//              $slm_ReadMemoryS(RedMemAddr, RedMem_address, tempReg_slm);
          
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = RedMem[RedMem_address];
            `endif
        end
        
        for (num=0;num<Bits;num=num+1) begin
             po=num;        
             if ( Dint [num] !== tempReg1 [po]) begin
                if (Mint[num] === 1'b0)
                   tempReg1[po] = Dint[num];
                else if (Mint[num] === 1'bX)
                   tempReg1[po] = 1'bx;
             end                
        end //for (num=0
            
         if(repair_flag === 0 ) begin    
            if(ValidAddress === 1) begin  
              `ifdef slm
                  tempReg_slm=tempReg1; 
                  $slm_WriteMemory(MemAddr, Address, tempReg_slm);
              `else
                   Mem[Address] = tempReg1;
              `endif
            end
            else begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address Out Of Range. ",$realtime);
            end        
         end
         else if (repair_flag === 1 ) begin
            `ifdef slm
                tempReg_slm=tempReg1; 
//                $slm_WriteMemory(RedMemAddr, RedMem_address, tempReg_slm);
            `else
                RedMem[RedMem_address] = tempReg1;
            `endif
         end
   end //if (ValidAddress !== X
   task_insert_faults_in_memory;
end
endtask 

task ReadCycle;
input [Addr-1 : 0] Address;

reg [Bits-1:0] MemData_tmp;
reg [Bits-1:0] MemData;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;

reg repair_flag;

integer a,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;

begin
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];
   
   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};

   

   if (ValidAddress !== X && next_cycle_corrupt_func === 0 ) begin   
       if(red_en === 1 && ( Row_Add_cmp === repair_add ||  Row_Add_cmp === next_repair_add )) begin
              repair_flag = 1;
              
              Bank_sel_integer = 0;
               
              if(Row_Add_cmp === repair_add) begin
                Col_Add_integer = Col_Add;
              end
              else if (Row_Add_cmp === next_repair_add) begin
                Col_Add_integer = Col_Add + mux; 
              end
              RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
       end

      if(repair_flag === 0) begin
          if(ValidAddress === 1) begin 
           `ifdef slm
              $slm_ReadMemory(MemAddr, Address, MemData);
           `else
              MemData = Mem[Address];
           `endif
          end
          else begin
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Address Out Of Range. Output Corrupted ",$realtime);
             MemData = WordX;
          end
     end
      else if(repair_flag === 1) begin
        `ifdef slm
//           $slm_ReadMemory(RedMemAddr, RedMem_address, MemData);
        `else
           MemData = RedMem[RedMem_address];
        `endif
      end
   end //if (ValidAddress)  
   
   if(ValidAddress === X)
   begin
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Illegal Value on Address Bus. Memory and Output Corrupted ",$realtime); 
         Invalid_next_cycle_func;
   end 
   
  if(ValidAddress !== X && next_cycle_corrupt_func === 0 )
   begin
   for (a = 0; a < Bits; a = a + 1)
   begin
      if (MemData[a] !== OutReg_data[a])
         OutReg_data[a] = WordX[a];
   end//for (a = 0; a <  
         OutReg_data <= MemData;
   end     
end
endtask



// SCAN CHAINS
supply0 gnd;
buf (A_int[0], Aint[0]);
buf (A_int[1], Aint[1]);
buf (A_int[2], Aint[2]);
buf (A_int[3], Aint[3]);
buf (A_int[4], Aint[4]);
buf (A_int[5], Aint[5]);
buf (A_int[6], Aint[6]);
buf (A_int[7], Aint[7]);                  //used for capturing
buf (A_int[8], gnd);
buf (A_int[9], gnd);
buf (A_int[10], gnd);
buf (A_int[11], gnd);
buf (A_int[12], gnd);
buf (A_int[13], gnd);
buf (A_int[14], gnd);   //used for capturing

buf (WEN_int, WENint);
buf (CSN_int, CSNint);
buf (IG_int, IGint);


// Scan flops



// CONTROL SCAN CHAIN
     ST_SPREG_LOLEAK_256x21m4_Tl_SCFF cntrl_scff_0 (.D(1'b0), .TI(SCTRLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[0]), .OUTX(scanreg_ctrl));

      
 ST_SPREG_LOLEAK_256x21m4_Tl_SCFF cntrl_scff_1 (.D(A_int[3]), .TI(scanreg_ctrl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[1]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m4_Tl_SCFF cntrl_scff_2 (.D(A_int[5]), .TI(scanreg_ctrl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[2]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m4_Tl_SCFF cntrl_scff_3 (.D(A_int[8]), .TI(scanreg_ctrl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[3]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m4_Tl_SCFF cntrl_scff_4 (.D(A_int[2]), .TI(scanreg_ctrl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[4]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m4_Tl_SCFF cntrl_scff_5 (.D(A_int[10]), .TI(scanreg_ctrl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[5]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m4_Tl_SCFF cntrl_scff_6 (.D(A_int[9]), .TI(scanreg_ctrl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[6]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m4_Tl_SCFF cntrl_scff_7 (.D(A_int[1]), .TI(scanreg_ctrl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[7]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m4_Tl_SCFF cntrl_scff_8 (.D(A_int[0]), .TI(scanreg_ctrl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[8]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m4_Tl_SCFF cntrl_scff_9 (.D(A_int[4]), .TI(scanreg_ctrl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[9]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m4_Tl_SCFF cntrl_scff_10 (.D(A_int[6]), .TI(scanreg_ctrl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[10]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m4_Tl_SCFF cntrl_scff_11 (.D(CSN_int), .TI(scanreg_ctrl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[11]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m4_Tl_SCFF cntrl_scff_12 (.D(A_int[7]), .TI(scanreg_ctrl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[12]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m4_Tl_SCFF cntrl_scff_13 (.D(WEN_int), .TI(scanreg_ctrl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[13]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m4_Tl_SCFF cntrl_scff_14 (.D(scanreg_ctrl_wire[14]), .TI(scanreg_ctrl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[14]), .OUTX(scanreg_ctrl));  

reg LP_CK_gate;

// Lock Up Latch
wire SCTRLO_temp;
 ST_SPREG_LOLEAK_256x21m4_Tl_lock_up_latch  dff_SCTRLO_SE (Latch_open, scanreg_ctrl_wire[14], SCTRLO_temp);

always @(SCTRLO_temp) begin
     SCTRLOint= SCTRLO_temp;
 `ifdef functional
 `else
 if (SCTRLOint !== SCTRLO_data) begin 
  if (SCTRLOint !==X)
   SCTRLO_data=1'bx;
   SCTRLO_data <= SCTRLOint;
 end 
 `endif
end  


// LEFT DATA SCAN CHAIN
     ST_SPREG_LOLEAK_256x21m4_Tl_SCFF ldata_scff_0 (.D(Dint[10]), .TI(SDLI), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[0]), .OUTX(scanreg_dl));
      
   
 
        ST_SPREG_LOLEAK_256x21m4_Tl_SCFF ldata_scff_1 (.D(Dint[9]), .TI(scanreg_dl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[1]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m4_Tl_SCFF ldata_scff_2 (.D(Dint[8]), .TI(scanreg_dl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[2]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m4_Tl_SCFF ldata_scff_3 (.D(Dint[7]), .TI(scanreg_dl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[3]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m4_Tl_SCFF ldata_scff_4 (.D(Dint[6]), .TI(scanreg_dl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[4]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m4_Tl_SCFF ldata_scff_5 (.D(Dint[5]), .TI(scanreg_dl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[5]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m4_Tl_SCFF ldata_scff_6 (.D(Dint[4]), .TI(scanreg_dl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[6]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m4_Tl_SCFF ldata_scff_7 (.D(Dint[3]), .TI(scanreg_dl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[7]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m4_Tl_SCFF ldata_scff_8 (.D(Dint[2]), .TI(scanreg_dl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[8]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m4_Tl_SCFF ldata_scff_9 (.D(Dint[1]), .TI(scanreg_dl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[9]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m4_Tl_SCFF ldata_scff_10 (.D(Dint[0]), .TI(scanreg_dl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[10]), .OUTX(scanreg_dl));



// Lock Up Latch
wire SDLO_temp;
 ST_SPREG_LOLEAK_256x21m4_Tl_lock_up_latch  dff_SDLO_SE (Latch_open, scanreg_dl_wire[10], SDLO_temp);

always @(SDLO_temp) begin
     SDLOint= SDLO_temp;
 `ifdef functional
 `else
 if (SDLOint !== SDLO_data) begin 
  if (SDLOint !==X)
   SDLO_data=1'bx;
   SDLO_data <= SDLOint;
 end 
 `endif
end  






// RIGHT DATA SCAN CHAIN

     ST_SPREG_LOLEAK_256x21m4_Tl_SCFF rdata_scff_0 (.D(Dint[20]), .TI(SDRI), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[0]), .OUTX(scanreg_dr));
     
 
 
        ST_SPREG_LOLEAK_256x21m4_Tl_SCFF rdata_scff_1 (.D(Dint[19]), .TI(scanreg_dr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[1]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m4_Tl_SCFF rdata_scff_2 (.D(Dint[18]), .TI(scanreg_dr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[2]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m4_Tl_SCFF rdata_scff_3 (.D(Dint[17]), .TI(scanreg_dr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[3]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m4_Tl_SCFF rdata_scff_4 (.D(Dint[16]), .TI(scanreg_dr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[4]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m4_Tl_SCFF rdata_scff_5 (.D(Dint[15]), .TI(scanreg_dr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[5]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m4_Tl_SCFF rdata_scff_6 (.D(Dint[14]), .TI(scanreg_dr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[6]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m4_Tl_SCFF rdata_scff_7 (.D(Dint[13]), .TI(scanreg_dr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[7]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m4_Tl_SCFF rdata_scff_8 (.D(Dint[12]), .TI(scanreg_dr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[8]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m4_Tl_SCFF rdata_scff_9 (.D(Dint[11]), .TI(scanreg_dr_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[9]), .OUTX(scanreg_dr)); 


// Lock Up Latch
wire SDRO_temp;
 ST_SPREG_LOLEAK_256x21m4_Tl_lock_up_latch  dff_SDRO_SE (Latch_open, scanreg_dr_wire[9], SDRO_temp);


always @(SDRO_temp) begin
     SDROint= SDRO_temp;
 `ifdef functional
 `else
 if (SDROint !== SDRO_data) begin 
  if (SDROint !==X)
   SDRO_data=1'bx;
   SDRO_data <= SDROint;
 end 
 `endif
end






//


 //////// CAPTURE TASK //////
task scan_acquire;
begin
   if (supply_ok === 1) begin 
      if ( SEsys === 0 && ((LP_CK_gate === 0 && TBYPASSsys !== 1'bx)|| TBYPASSsys===0)) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
         
         Latch_open=1;
         

      end //if ( SEint === 0
   end//if(supply_ok 
end
endtask

task scan_shift;
begin
 if (supply_ok === 1) begin
   if (STDBYint === 0 && SLEEPint === 0) begin
      if (CKint_dft === X && INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0) begin
         ScanChainX;
         ScanOutX;
      end
      else if (CKint_dft === 1 && lastCK_dft === 0 ) begin
          //// SHIFT
        if (SEsys === 1) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
           
        //// SHIFT Ends
        end //if (SEsys === 1
        else if (SEsys === X) begin
            ScanChainX;
            ScanOutX;
            delScanOutX;
        end//if (SEint ==X
      
      end///if (CKint === 
    
      else if (CKint_dft === 0 && lastCK_dft === 1 ) begin
        Latch_open=1;
      end
    end  //if (STDByint === 0 && SLEEPint === 0
 end//if(supply_ok
end
endtask






// BEHAVIOURAL MODULE DESCRIPTION
// ================================

initial
begin
  // Define format for timing value
  $timeformat (-9, 3, " ns", 0);
  `ifdef slm
  $slm_RegisterMemory(MemAddr, Words, Bits);
  `endif   
   reg_mem_block=0;
   flag_mem_block=0;
  `ifdef functional
  `else
   TimingViol_data=0;
   TimingViol_mask=0;
   `endif
   decoding_start=0;
  
   //Parameter Assignment
   
   reg_Fault_file_name = Fault_file_name; 
   reg_ConfigFault     = ConfigFault;
   reg_MEM_INITIALIZE  = MEM_INITIALIZE;
   reg_BinaryInit      = BinaryInit;
   reg_InitFileName    = InitFileName;
   reg_Initn_reset_value = Initn_reset_value;
   reg_File_load_time    = File_load_time;

   time_fall_sleep=0;
   time_fall_PSWLARGEMP=0;
   time_fall_PSWLARGEMP_0=0;
   time_fall_PSWLARGEMA=0;
   time_fall_PSWLARGEMA_0=0;
   time_fall_PSWSMALLMP=0;
   time_fall_PSWSMALLMA=0;

   vddmp_rise_time=0;
   vddmp_fall_time=0;
   vddsmp_rise_time=0;
   vddsmp_fall_time=0;
   vddma_rise_time=0;
   vddma_fall_time=0;
   vddsma_rise_time=0;
   vddsma_fall_time=0;
   vddm_fall_time=0;  
   vddm_rise_time=0;  
   vddsm_fall_time=0; 
   vddsm_rise_time=0;

   next_cycle_corrupt_func=0;
   next_cycle_corrupt_dft=0;
   init_pulse_done = 0;
   power_up_done = 0;
   file_loaded=1;
   debug_level= 2'b01;
   message_status = "ONLY WARNINGS/ERRORS are Switched ON.For INFO also use debug_level=2'b00";
  `ifdef  NO_WARNING_MODE
     debug_level = 2'b11;
     message_status = "All Warning/Errors/Info Messages are Switched OFF";
  `endif  
  `ifdef  ONLY_ERROR_MODE
     debug_level = 2'b10;
     message_status = "All Warning/Info Messages are Switched OFF.Errors are switched on";
  `endif 
  `ifdef  ALL_MSG_MODE
     debug_level = 2'b00;
     message_status = "All Messages are Switched ON";
  `endif 
  
  `ifdef slm
     operating_mode = "SLM";
   `else
      `ifdef functional
         operating_mode = "FUNCTIONAL";
       `else
         operating_mode = "TIMING";
      `endif
   `endif   
  
  if (debug_level < 1) begin
  $display ("%m INFORMATION ");
  $display ("***************************************");
  $display ("The Model is Operating in %s MODE", operating_mode);
  $display ("%s", message_status);
  if(reg_ConfigFault)
  $display ("Configurable Fault Functionality is ON");   
  else
  $display ("Configurable Fault Functionality is OFF");   
  $display("Fault File used by the model Fault_File_Name=%s" ,reg_Fault_file_name);
  $display("Values of Config_fault used in model=%d" ,reg_ConfigFault);
  $display("Values of Mem_INITALIZE used in model=%d" ,reg_MEM_INITIALIZE);
  $display("Values of BinaryInit used in model=%d" ,reg_BinaryInit);
  $display("Values of InitFileName used in model=%s" ,reg_InitFileName);
  $display("Values of Initn_reset_value used in model=%d" ,reg_Initn_reset_value);
  $display("Values of File_load_time used in model=%t" ,reg_File_load_time);

  $display ("***************************************");
  end
     
  task_read_fault_file; 
   if(!INITNint) begin
    if(supply_ok ) begin 
      init_pulse_done = 1;
      power_up_done = 1;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif 
    end 
   end 
        
   lastCK_func = CKint_func;
   lastCK_dft = CKint_dft;

 `ifdef MEM_CONTENTS_SLEEP
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","w");
   $fclose(ptr);
 `endif 

   
end  // initial block ends



//+++++++++++++++++++++++++++++++ CONFIG FAULT IMPLEMETATION ENDS+++++++++++++++++++++++++++++++//
        




//INITN block starts
//================================
always @(INITNint  or supply_ok )
begin
 if (INITNint === 1'b0) begin
   if(supply_ok) begin
     init_pulse_done = 1;
     power_up_done = 1;
     lastCK_func=CKint_func;
     lastCK_dft=CKint_dft;
     next_cycle_corrupt_func = 0;
     next_cycle_corrupt_dft = 0;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif     
   end 
 end        

 if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && INITNint !== 1)
   begin
     ScanOutX;
     ScanChainX;
     delScanOutX;
   end  
         
 if (init_pulse_done === 0 && INITNint !== 0) begin
     if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) INFO: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
 end
 
end//always @(INITNint)


// Clock Generation 
//wire gated_clock;
//wire clock_gate_en;
//ST_SPREG_LOLEAK_256x21m4_Tl_lock_up_latch CK_SE_latch (!CK , SE, SE_latch_CK);
//and (clock_gate_en, ATP, TBYPASS, !SE_latch_CK);

//ST_SPREG_LOLEAK_256x21m4_Tl_lock_up_latch LP_latch (!CK , scanreg_ctrl_wire[14], LP_latch_CK);
//and (gated_clock,CK,!LP_latch_CK);
//assign CK_new= clock_gate_en ===0 ? CK : (clock_gate_en ===1 ? gated_clock: (CK===0) ? 0 :1'bx);


// Clock Generation Ends


// Functional CK block starts
//======================================
always @(CKint_func)
begin
   lastCK_func=CKreg_func;  
   CKreg_func=CKint_func;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
        if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
      if (CKreg_func === 1'bX || (CKreg_func === 1'b1 && lastCK_func === 1'bx)) begin
        if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
         
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
         Invalid_next_cycle_func;
        end
      end
      else if (CKreg_func === 1'b1 && lastCK_func === 1'b0 ) begin
        time_CK_func_rise=$realtime;
        MEMEN_prev = MEMEN_reg;
        MEMEN_reg = MEMEN;
        CSNreg = CSNint;
        IGreg = IGint;
        DEreg = DEint;
        SE_reg = SEsys;
        TBYPASS_reg = TBYPASSsys;
        ATPreg = ATPint;
        INITNreg = INITNint;
        SLEEPreg = SLEEPint;
        STDBYreg = STDBYint;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 

    `ifdef functional
    `else
        Mem_last=Mem[Aint];
    `endif 
        if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.INITN pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SLEEP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.STANDBY pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg === X && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.chip select  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg === X && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.IG pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg === X && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.Debug pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg === X && (SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.ATP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg === X && TBYPASS_reg !== 1) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SE pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg !== 1 && TBYPASS_reg === X) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.TBYPASS pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end

        else if ((INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0))) && WENint === X) begin
            // Uncertain write cycle
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: write enable going to X  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end 
        else if (next_cycle_corrupt_func === 1) begin
          next_cycle_corrupt_func = X;
        end
        else if (next_cycle_corrupt_func === 1'bx) begin
          next_cycle_corrupt_func = 0;
        end 
        
//        if (next_cycle_corrupt_func === 0 ) begin 
         
          /*---------------------- File initialization -----------------*/
          
          if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0)) && flag_mem_block === 1'b0) begin
                 Areg=Aint;
                 Dreg=Dint;
                 Mreg=Mint;
                 WENreg=WENint;     
             if (reg_MEM_INITIALIZE === 1'b1 && $realtime >= reg_File_load_time && file_loaded ) begin   
                `ifdef slm
                  if (reg_BinaryInit)
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_BIN");
                  else
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_HEX");
   
                `else
                  if (reg_BinaryInit)
                     $readmemb(reg_InitFileName, Mem, 0, Words-1);
                  else
                     $readmemh(reg_InitFileName, Mem, 0, Words-1);
                `endif
                 file_loaded = 0;
             end
   
             if (^Aint === X)
               ValidAddress = X;
             else if (Aint < Words)
               ValidAddress = 1;
             else    
               ValidAddress = 0;
   
             if(red_en === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Redundancy Enable is Invalid. Either RRAE is X or TRRAE is X",$realtime);
                ValidAddress = X; 
           end
           else if(red_en === 1'b1 && ^repair_add === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Repair Address is invalid.RRA is X",$realtime);
                ValidAddress = X;
           end
             
             if (ValidAddress)
               `ifdef slm
                   $slm_ReadMemoryS(MemAddr, Aint, Mem_temp);
               `else
                    Mem_temp = Mem[Aint];
               `endif
             else
                Mem_temp = WordX;  
          
     /*---------------------- Normal Read and Write -----------------*/
     
             if (WENint === 1) begin
               ReadCycle(Aint);
             end
       
             else if (WENint === 0) begin
               WriteCycle(Aint);
             end 
                
          
          end //  if (MEMEN === 1'b1 
       
//        end  // if (next_cycle_corrupt_func === 0
      
      end // if (CKint = 1   
   end // if (init_pulse_done === 1           
 end 
end // always @(CKint_func)
        
always @(MEMEN)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) && CKint_func === 1'bx) begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.clock pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
    Invalid_next_cycle_func;
  end
 end 
end

// DFT CK block starts
//======================================
always @(CKint_dft) 
begin
   lastCK_dft=CKreg_dft;
   CKreg_dft=CKint_dft;
   
   Latch_open=0;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
     if (CKreg_dft === 1'bX || (CKreg_dft === 1'b1 && lastCK_dft === 1'bx)) begin
       if (INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0 ) begin
        
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: DFT clock  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime); 
         Invalid_next_cycle_dft;
         if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
           WriteOutX;
         end
       end
     end 

     if(CKint_dft === 0 && lastCK_dft === 1) begin
      if(ATPreg === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
       if(SE_reg === 1'b1 && SEsys === 1'b0) begin
        if(TBYPASSint === 1'b1) begin   
    
       
       
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9], scanreg_dl_wire[scanlen_l-1]}; 
       


         for (i = 0; i < Bits; i = i + 1)
         begin
          if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
         end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
        end 
       end
      end
     end 
     
     else if (CKreg_dft === 1'b1 && lastCK_dft === 1'b0 ) begin
       SE_reg = SEsys;
       TBYPASS_reg = TBYPASSsys;
       ATPreg = ATPint;
       INITNreg = INITNint;
       SLEEPreg = SLEEPint;
       STDBYreg = STDBYint;
       MEMEN_dft_prev = MEMEN_dft_reg;
       MEMEN_dft_reg = MEMEN_dft;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 
       if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ) begin 
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
 //     else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys === X && TBYPASSsys !== 1) begin
///           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
//           Invalid_next_cycle_dft;
//        end       
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys === X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
        end 
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys !== 0 && LP_CK_gate===X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: LP FLOP Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           ScanChainX;
           ScanOutX;   
          if( TBYPASSint !== 0 && SEint !== 1) begin
            WriteOutX;
          end
          next_cycle_corrupt_dft=0;
        end        
       else if (next_cycle_corrupt_dft === 1'b1) begin 
         next_cycle_corrupt_dft = X;
       end 
       else if (next_cycle_corrupt_dft === 1'bx) begin
         next_cycle_corrupt_dft = 0;
       end
       
       if (next_cycle_corrupt_dft === 0 ) begin
         
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1 && flag_mem_block === 1'b0) begin
           
           if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0  && LP_CK_gate===0) begin
              OutReg_data_tbypass = Dint;
              for (i = 0; i < Bits; i = i + 1)
              begin
               if (OutReg_data_tbypass[i] !== OutReg_data[i])
                 OutReg_data[i] = WordX[i];
              end//for (i = 0; i < */ 
              OutReg_data <= OutReg_data_tbypass;
           end
           
             scan_acquire;
         end //MEMEN_dft == 1        
       end // if ( next_cycle_corrupt_dft
       
     end // if (CKint_dft === 1'b1
      //  if (next_cycle_corrupt_dft === 0 ) begin 
       if (SE_reg !== 0) begin
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1  && flag_mem_block === 1'b0) begin
           next_cycle_corrupt_dft = 0;
           if ( next_cycle_corrupt_func === 1) begin
	    next_cycle_corrupt_func = 0 ;
	   end	
           scan_shift;
         end
       end
     //end // if ( next_cycle_corrupt_dft    
     if ((!(TBYPASSsys!==0 && SEsys!==1 && LP_CK_gate!==0 ) && next_cycle_corrupt_dft === 0) || CKint_dft !==1) begin          
       CK_sc=INITNreg & !STDBYreg & !SLEEPreg & ATPreg & CKreg_dft ;
     end     
   end // if (init_pulse_done 
 end // if (supply_ok 
end // always @(CKint_dft)

always @(MEMEN_dft)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) && CKint_dft === 1'bx)  begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.MEMEN_dft and clock should not be X at this time instant. ScanChains and ScanOuts Corrupted ",$realtime); 
    Invalid_next_cycle_dft;
    
    if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
      WriteOutX;
    end
  end
  if ( MEMEN_dft !== 0 && TBYPASSsys !== 0 && SEsys !== 1) begin
     WriteOutX;
     OutReg_data = WordX; 
     delOutReg_data=WordX;
 end 
end
end //always @(MEMEN_dft

always @(TBYPASSsys or ATPint)
begin
   if(supply_ok === 1'b1) begin 
    if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0 && INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1) begin
      if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
    end  
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint === X && SEsys !== 1) ) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end 
end //always @(TBYPASSint





always @(SEsys)
begin
 if(supply_ok === 1'b1) begin 
  if(CKint_dft === 0 && ATPint === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
    if(SE_reg === 1'b1 && SEsys === 1'b0) begin
      if(TBYPASSsys === 1'b1) begin
  
     
         
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9], scanreg_dl_wire[scanlen_l-1]};
           
      


        for (i = 0; i < Bits; i = i + 1)
        begin
         if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
        end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
      end
    end
  end
  if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0) begin
      if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
  end 
  else if ((TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint === X && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end   
end

//assign output data
`ifdef functional        

   
always @(SDLOint)
#0.001 delSDLO_data<=SDLOint;

always @(SDROint)
#0.001 delSDRO_data<=SDROint;

 
always @(SCTRLOint)
#0.001 delSCTRLO_data<=SCTRLOint;


always @(OutReg_data)
   #0.001 delOutReg_data = OutReg_data;
`else
`endif

/***************************** Embeded switch functionality starts here ***********************************/





always @(STDBYint)
begin
  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0 && STDBYint !== 1'b0)
    begin
      ScanOutX;
      ScanChainX;
     delScanOutX;     
    end
  end
end



always @(SLEEPint)
begin


  if (SLEEPint !== 1'b1) begin
    time_fall_sleep = $realtime;
  end

  if (power_up_done === 0)
    begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
    end
  else begin
    if (SLEEPint === 1'b1 && lastSLEEP === 1'b0 ) begin 
      
    end
    else if (SLEEPint !== 1'b1 && lastSLEEP === 1'b1 && full_shutdown !== 1) begin 
      
      if (supply_ok !== 1 && ($realtime > 0)) begin
         if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID LOW_POWER) ERROR: ISOLATION signal removed from the memory but array and periphery supply is not completely switched on.Very High Current would be drawn by the memory. All further operations on memory are blocked",$realtime);
          WriteMemX;
          WriteOutX;
          ScanChainX;
          OutReg_data = WordX; 
          delOutReg_data=WordX;
          ScanOutX;//immediately;
          delScanOutX;//immediately;
          init_pulse_done = 0;
          power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            debug_level = 2'b11;
          `endif
          
      end        
      
       
    end   
    else if (SLEEPint === X && lastSLEEP === 1'b0 && full_shutdown !== 1'b1) begin 
     
    end 
  end  


  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && SLEEPint !== 0)
    begin
      ScanOutX;
      ScanChainX;
        delScanOutX;      
    end
  end

// if (init_pulse_done === 0)
//   begin
//     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
//   end
//
// else if ( SLEEPint !== 1 && (supply_ok !==1) ) begin
//    
//    WriteOutX;
//    OutReg_data = WordX; 
//    delOutReg_data=WordX;
//    ScanOutX;//immediately;
//    delScanOutX;//immediately;
//    ScanChainX;
//    WriteMemX;
//    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies with sleep/Power down signal being low.This scenario can lead to high dc currents and some reliability issues Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
// end

 print_sleep;    
 lastSLEEP=SLEEPint;
end

/********************************** Embeded switch functionality ends here *******************************/

task print_sleep;
begin
  if (SLEEPint === 1'b0) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been deasserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end  
  else if (SLEEPint === 1'b1) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been asserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_ACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif

  end        
  else begin
      if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) ERROR: SLEEP pin is at an invalid state.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INVALID in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end        
end
endtask





 

//// C28SOI non flip compiler power functionality 
always @(gndmreg )
begin
 if (power_up_done === 1 && $realtime > 0) begin    
    if(gndmreg !== 1'b0 ) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or gndsm is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
        corrupt_all;
        init_pulse_done = 0;
        power_up_done = 0;
     `ifdef NO_BLOCK_MEM
     `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of ground pins.Ground must be maintained at 0 Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime);
        debug_level = 2'b11;
     `endif   

    end   
 end

end




always @(vddmareg )
begin

if (vddmareg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddma(Array Supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 
    end
   end   
   else if (SLEEPint === 1) begin
    WriteMemX;
   end

end

if ((vddmareg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1 ) && $realtime > 0) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddm or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         corrupt_all;
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif

end


end

always @(vddmpreg )
begin
 if (vddmpreg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or vddsmp is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmp(Periphery Supply)/vddsmp(Substrate power supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 

    end
   end   
   else if (SLEEPint === 1) begin
    WriteOutX;
    ScanChainX;
    ScanOutX;
    delScanOutX;//immediately;
    OutReg_data = WordX; 
    delOutReg_data=WordX;
   end
 end

if( (vddmpreg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1'b1 )  && $realtime > 0) begin
         corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif
end
 
 
end


always @(vddmoreg)
begin
  if (power_up_done === 1 && $realtime > 0) begin   
      if (vddmoreg !== 1'b1)  begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin
           corrupt_all;
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
         end //if (vddmareg === 1'b1 

      else if (vddmareg === 1'b0 && vddmpreg === 1'b0   && SLEEPint === 1'b1 &&  $realtime > 0)
        begin 
            if((debug_level < 2) && ($realtime > 0)) $display("%m - %t WARNING: Illegal Value on power pin(s). Memory and Output Corrupted ", $realtime);
 
           corrupt_all;
        end //else if (vddmareg === 1'b 
     end   // if (vddmoreg !== 1'b1)
     else if (vddmoreg === 1'b1 && $realtime > 0 ) begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin     
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           corrupt_all;
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
        end        
     end // else if (vddmoreg === 1'b1
  end 
end // always @(vddmoreg)












always @(gndmreg) begin
 if (gndmreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 0. ",$realtime);
 end
 else if (gndmreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 1. ",$realtime);
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to invalid state. ",$realtime);
 end
end




 
always @(vddmareg) begin
 if (vddmareg === 0) begin 
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 0. ",$realtime);
  vddma_fall_time = $realtime;
 end
 else if (vddmareg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 1. ",$realtime);
  vddma_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to invalid state. ",$realtime);
  vddma_fall_time = $realtime;
 end 

 

end

always @(vddmpreg) begin
 if (vddmpreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 0. ",$realtime);
  vddmp_fall_time = $realtime;
 end
 else if (vddmpreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 1. ",$realtime);
  vddmp_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to invalid state. ",$realtime);
  vddmp_fall_time = $realtime;
 end

 
 
end



// end of C28SOI power functionality 
 


assign supply_ok          =  (vddmareg === 1'b1 && vddmpreg  === 1'b1  && gndmreg === 1'b0 && vddmoreg === 1'b1 ) ? 1'b1 : 1'b0;
assign core_supply_ok     =  (vddmoreg === 1'b1 && vddmareg === 1'b1 && gndmreg === 1'b0 ) ? 1'b1 : 1'b0;
assign peri_supply_ok     =  (vddmoreg === 1'b1 && vddmpreg === 1'b1 && gndmreg === 1'b0  ) ? 1'b1 : 1'b0;

assign full_shutdown = (vddmpreg === 1'b0 && vddmareg === 1'b0   ) ? 1'b1 : 1'b0 ;




`ifdef functional
`else


task WriteLocMskX_bwise;
   input [Addr-1 : 0] Address;
   input [Bits-1 : 0] Mask;

reg [Bits+Red_extrabit:0] tempReg1;
integer num1; 
begin
   tempReg1 = WordX;
   if (^Address !== X )
   begin
      tempReg1 = Mem[Address];
             
      for (j = 0;j< Bits; j=j+1) begin
         num1=j;
        if (Mask[j] === 1'bx)
            tempReg1[num1] = 1'bx;
      end
      Mem[Address] = tempReg1;
      task_insert_faults_in_memory;
   end//if (^Address !== X
   else begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      WriteMemX;
   end   
end
endtask


/****************Actions taken on timing violations*****************/

 always @(TimingViol_data)
// tds or tdh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  for (l = 0; l < Bits; l = l + 1) begin   
    if (CSWEMTBYPASS[l] !== 0) begin
     if((TimingViol_data[l] !== TimingViol_data_last[l])) begin


         Mreg[l] = 1'bx;
     end    
     WriteLocMskX_bwise(Areg,Mreg);
    end   
   end 
  end
    if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin
     scanreg_dl =1'bx; 
     scanreg_dr =1'bx; 
     SDLOint=X;
     SDROint=X;
     `ifdef functional
     `else
     SDLO_data<=1'bx;
     SDRO_data<=1'bx;
     `endif
    end
     TimingViol_data_last = TimingViol_data; 
end





always @(TimingViol_addr)
// tas or tah
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
      scanreg_ctrl=1'bx; 
      SCTRLOint=X;
      `ifdef functional
      `else
      SCTRLO_data<=1'bx;
      `endif
  end
end


always @(TimingViol_WEN)
//tws or twh
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WEN pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end 

always @(TimingViol_CSN )
// tps or tph 
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;

   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CSN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end

always @(TimingViol_tcycle )
//tcycle
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
   if (MEMEN !== 0 && MEMEN_prev !== 0) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckl )
// tckl 
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckh) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end


always @(TimingViol_tcycle_se )
//tcycle_se
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckl_se  )
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckh_se) begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tbist) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
   end
   if (TBYPASSint !== 1'b0) begin 
    WriteOutX;
   end 
   if (INITNreg !==0 && STDBYreg !== 1 && TBYPASS_reg !== 1 && SLEEPreg !== 1 && SE_reg !== 1 && IGreg !== 1 && DEreg !== 1) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBIST pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end






always @(TimingViol_tbypass)
//ttmck
begin
#0  
  WriteOutX;
  if (INITNreg !== 0 && SLEEPreg !== 1 && SE_reg !== 1 && STDBYreg !== 1 &&  DEreg !== 1) begin
   Invalid_next_cycle_dft_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
end



always @(TimingViol_sleep)
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_stdby)
begin
#0
  if (CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin 
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (ATPreg !== 0) begin 
   Invalid_next_cycle_dft_tim;
  end
end






always @(TimingViol_se) begin
#0
   if (TBYPASS_reg !== 0) begin 
    WriteOutX;
   end 
  if (TBYPASS_reg === 0) begin
     WriteOutX;
     WriteMemX;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE timing violation  Memory State Machine is corrupted. Output Corrupted ",$realtime); 
  end 
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
  end
end

always @(TimingViol_sctrli) begin
  scanreg_ctrl=1'bx; 
end


always @(TimingViol_sdli) begin
 scanreg_dl=1'bx; 
end

always @(TimingViol_sdri) begin
   scanreg_dr=1'bx;
end

 

always @(TimingViol_initnl) begin
init_pulse_done=0;
WriteOutX;
OutReg_data = WordX; 
delOutReg_data=WordX;
ScanOutX;
delScanOutX;
ScanChainX;
WriteMemX;
end

always @(TimingViol_initn) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end

always @(TimingViol_ig) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && INITNreg !== 0 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: IG pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   ScanChainX;
   ScanOutX;
   delScanOutX;       
  end
end

always @(TimingViol_atp) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin  
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_rm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^WMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: RM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
   end
end
 
always @(TimingViol_wm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^RMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);        
   end
end 


`endif


endmodule




module ST_SPREG_LOLEAK_256x21m4_Tl_lock_up_latch (EN,D,Q);
input EN,D;
output reg Q;

  always @ (EN or D) begin
    if (EN === 1) begin
       Q = D;
    end
    else if ((EN === 1'bz || EN === 1'bx  )&& D !== Q) begin
        Q=1'bx;
    end    
  end
endmodule

module ST_SPREG_LOLEAK_256x21m4_Tl_SCFF (D,TI,TE,CP,Q,OUTX);
input D,TI,TE,CP;
input OUTX;
output reg Q;
wire Dint;
assign Dint= (TE===1)?TI:(TE===0)?D:1'bx;

always @(posedge CP)
        begin
          if(Dint === 1'bZ || CP ===1'bx || OUTX === 1'bx)
          begin
                  Q = 1'bx;
          end
          else
          begin
                  Q = Dint;
          end        
        end
always @(posedge OUTX)
Q = 1'bx;
endmodule



`undef setup_time
`undef hold_time
`undef access_time
`undef retain_time
`undef cycle_time
`undef pulse_width_time
`undef initin_low_pulse


`delay_mode_path
`endcelldefine
`nosuppress_faults






/****************************************************************
--  Description         : Verilog Model 
--  ModelVersion        : 1.2
--  Date                : Apr, 2013
--  Changes Made by	: PS
--  Revision History    : 
 
****************************************************************/


/******************** START OF HEADER****************************
   This Header Gives Information about the parameters & options present in the Model
   
   words = 512
   bits  = 20
   mux   = 2 
   
   
   
   write_mask = no 
   
   margin_control = yes 
   
   
   Dft = Yes  

    ------------------------------------------------------------------------------------
     Signal Name             | Description       |             Port Mode        | Active When
                             |                   |          r    |  w   | rw    |
   ------------------------------------------------------------------------------------

    D 	        Data in                     na     x      na       -  
    IG    Input Gate Enable           x      x      na       High     
    ATP            ATPG Enable                 x      x      na       High     
    INITN                 INITN pin                   x      x      na       Low
    
    
     
    Q 	        Data out	            x      na     na       -
    A              Address                     x      x      na       high and low
    
    CK                Clock	                    x      x      na       posedge
    CSN          Chip Enable                 x      x      na       low
    
    RM         Read Margins                 x      x      na       High 
    SCTRLI         Scan Input (Control)
    SCTRLO        Scan Output (Control)
    SDLI         Scan Input (Data-Left)
    SDLO        Scan Output (Data-Left)
    SDRI         Scan Input (Data-Right)
    SDRO        Scan Output (Data-Right)
    SE          Scan Enable pin 
    STDBY              Standby pin                 x      x      na       High
    
    SLEEP                        Sleep pin                   x      x      na        High 
    
     
     
    TBIST          Bist Enable Pin 
    
    TBYPASS                      Memory Bypass                na     na     na        High
    
    TED        Bist Even Data pin
    TOD         Bist Odd Data Pin
     
    TA         Bist Read Address
    TCSN     Bist Read Chip Select
    
    TWEN    Bist Write Enable 
    WEN         Write Enable                na     x      na       Low 
    
    WM        Write Margins Code          x      x      na       -
     

******************** END OF HEADER ****************************/


//********************************************//
// ST_SPREG_LOLEAK_512x20m2_Tl Verilog Model                 //  
//********************************************//




`ifdef slm
        `define functional
`endif

`celldefine
`suppress_faults
  `ifdef functional
   `delay_mode_unit
  `else
   `delay_mode_path
  `endif

`define setup_time 0.0
`define hold_time 0.0
`define access_time 1.0
`define retain_time 0.9
`define cycle_time 0.0
`define pulse_width_time 0.0
`define initin_low_pulse 0.0



 






`timescale 1ns / 1ps


module ST_SPREG_LOLEAK_512x20m2_Tl (A,ATP,CK,CSN,D ,IG,INITN , Q ,RM    ,SCTRLI,SCTRLO,SDLI,SDLO,SDRI,SDRO,SE,SLEEP   , STDBY  ,TA,TBIST   ,TBYPASS ,TCSN,TED ,TOD   ,TWEN ,WEN,WM  );

 parameter
  Words = 512,
  Bits = 20,
  Addr = 9,
  mux = 2,
  repair_address_width = 8,
  write_margin_size = 2, 
  read_margin_size = 3; 

 //  INPUT OUTPUT PORTS DECLARATION DONE SEPARATELY FOR SPREG and ROM
 // ========================


        output [Bits-1 : 0] Q;
         
        output SCTRLO;
        input SE,SCTRLI;
        
        input [Addr-1 : 0] A;
        
        input [read_margin_size-1 : 0] RM;
        
         
        input CK,CSN,INITN,IG,ATP; 
        
        
        input [Addr-1 :0 ] TA;
input TBIST,TCSN ;
        
        input STDBY;
        
        input SLEEP; 
        
         
        
        
         
        output SDLO;
        output SDRO;
        
        
        
        
        input [Bits-1 : 0] D ;
	
          
         
        
        input [write_margin_size-1 : 0] WM;
        
        
        input TBYPASS;
        
        input WEN;
        
        
         
        input SDLI,SDRI  ; 
        
        
        
        //Bist inputs
        // ===========
        input TWEN,TED,TOD; 
        
        
        
        

        






    parameter
        Fault_file_name = "ST_SPREG_LOLEAK_512x20m2_Tl_faults.txt",
        `ifdef ConfigFault
        ConfigFault = 1,
        `else
        ConfigFault = 0,
        `endif
        max_faults = 514,
        
        MEM_INITIALIZE  = 1'b0,
        BinaryInit = 1'b0, 
        InitFileName = "ST_SPREG_LOLEAK_512x20m2_Tl.cde",
        Debug_mode = "all_warning_mode",
        File_load_time=0,
        Initn_reset_value={20{1'b0}},
        InstancePath = "ST_SPREG_LOLEAK_512x20m2_Tl";
    
    parameter
        
        bank = 1, 
        mux_bits=1,
        Red_extrabit=0,
        bank_bits = 0,
        RedWords = mux * 2 * bank,
        max_address_bits = 15 ,
        Rows = Words/mux;

  
    parameter 

     

        
           scanchains=3,    
          
        
        scanlen_ctrl=15,
        
        

      

        
        
        scanlen_r=(2*(Bits/4)),
        
        scanlen_l=(Bits-(2*(Bits/4)))  ; 
      
      

    parameter
        
        `ifdef functional  
            RW_assertions_en = 0,
        `endif
        WordX = {Bits{1'bx}},
        AddrX = {Addr{1'bx}},
        Word0 = {Bits{1'b0}},
        X = 1'bx;
   



//  WIRE DECLARATION RELATED TO POWER PINS
//  ======================================
	
        wire supply_ok, full_shutdown;
        
        wire core_supply_ok;
        wire peri_supply_ok;

        wire gndmint, gndsmint;
         
        
        wire vddmpint;
        wire vddmoint;
        wire vddmaint;
        wire vddsmpint;  
        wire vddsmaint;  
        
        

//  WIRE DECLARATION 
//  ==================
        wire [Bits-1 : 0] CSWEMTBYPASS;
        wire [Bits-1 : 0] Dint, Dsys;
        wire [Bits-1 : 0] Mint; 
        wire [20-1:0] Msys;
	wire [Addr-1 : 0] Aint;
        wire [Addr-1 : 0] Asys;

       


        wire [max_address_bits-1 : 0] A_int; 
                
	wire CKint_dft;
	wire CKint_func;
	wire CSNint;
        wire MEMEN;
        wire MEMEN_dft;
        wire TSE;

	wire WENint;
	wire WENsys;
        wire SLEEPint;
        wire STDBYint;
        wire SEint;
        wire SEsys;
        wire SCTRLIint;
        wire SDLIint;
        wire SDRIint;
        
        wire INITNint;
        wire TBYPASSint;
        wire TBYPASSsys;
        wire LSint; 
        wire HSint; 
        wire ATPint;
        wire DEint;
        
        wire [Addr-1 : 0] TAint;
        wire TBISTint;
        wire TBISTsys;
        wire TCSNint;
        wire TEDint;
        wire TODint;
        wire TEMint;
        wire TOMint;
        wire [Bits-1 : 0] TMint;
        wire [Bits-1 : 0] TDint;
        wire TWENint;
        wire IGint;
        wire IGbuf;
        wire CSNbuf;
        wire WENbuf;
        wire [read_margin_size-1:0] RMint;
        wire [write_margin_size-1:0] WMint;

        //Wires for scan chains
        //  ====================     
        wire [scanlen_ctrl -1:0]scanreg_ctrl_wire;
        wire [scanlen_l -1:0]  scanreg_dl_wire; 
        wire [scanlen_r -1:0]  scanreg_dr_wire; 
   
        wire [scanlen_l -1:0]  scanreg_ml_wire; 
        wire [scanlen_r -1:0]  scanreg_mr_wire; 


        wire [repair_address_width -1 : 0] RRAint;
        wire RRAEint;
        wire TRRAEint;    
        wire red_en;
        wire [repair_address_width -1 : 0] repair_add, next_repair_add;


//  REG DECLARATION
//  ====================     
        reg MEMEN_reg;
        reg MEMEN_prev;
        reg reg_mem_block;
        reg flag_mem_block;
        reg SCTRLIint_temp;
        reg SDLIint_temp;
        reg SDRIint_temp;
        reg SMLIint_temp;
        reg SMRIint_temp;

        //  REG DECLARATION
        //  ====================
        reg SCTRLOint;
        
        reg SDLOint,SDROint;
         
        
        reg next_cycle_corrupt_func;
        reg next_cycle_corrupt_dft;
        reg [Bits-1 : 0] delOutReg_data;//delayed Output Register
        reg [Bits-1 : 0] OutReg_data;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_tbypass;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_scan;   // Data Output registe
        reg [Bits-1 : 0] OutReg_rado_retained;   // register for retaining rado data when SLEEP --> 1
        reg delSCTRLO_data,SCTRLO_data;      // delayed Output Register
        reg delSDLO_data,SDLO_data;      // delayed Output Register
        reg delSDRO_data,SDRO_data;      // delayed Output Register
        
        
        // SCAN CHAINS register
        reg scanreg_ctrl; 
        reg scanreg_dl; 
        reg scanreg_dr; 
        
        
        reg CK_sc;
        reg Latch_open=0;
        reg lastCK_dft,CKreg_dft;
        reg lastCK_func,CKreg_func;
        reg lastSLEEP;
        reg lastPSWLARGEMP,lastPSWLARGEMA,lastPSWSMALLMP,lastPSWSMALLMA;
        reg CSNreg;
        reg init_pulse_done; //if == 1 then it implies that initb low pulse has been applied
        reg power_up_done; //if == 1 then it implies that power up has been done
        `ifdef slm
        `else
	      
             reg [Bits-1 : 0] Mem [Words-1 : 0];
             reg [Bits-1 : 0] RedMem [RedWords-1 : 0];
 
        `endif
        
	reg [Bits-1 :0] Mem_temp;
        reg [Bits-1 :0] Mem_slm; 
	reg ValidAddress;
	reg ValidDebugCode;
        reg decoding_start;
        reg file_loaded;
        reg [Bits-1 :0] Dreg;
        reg [Bits-1 :0] Mreg;
        reg WENreg;
        reg [Addr-1 :0] Areg;
        reg SE_reg;
        reg TBYPASS_reg;
        reg INITNreg;
        reg IGreg;
        reg DEreg;
        reg SLEEPreg;
        reg STDBYreg;
        reg ATPreg;
        reg MEMEN_dft_reg;
        reg MEMEN_dft_prev;
        reg RRMATCHreg;
        reg RRMATCHreg_last;//changes_made
        reg RRMATCHreg_glitch;
        reg [repair_address_width -1 : 0] repair_add_last;
        reg RRAEint_last;
        reg [Addr-mux_bits-1:0] row_add_temp;
        reg [Addr-mux_bits-bank_bits-1:0] row_add_cmp_temp;

       
        //parameter registers
        reg [2047:0] reg_Fault_file_name;
        reg reg_ConfigFault;
        reg reg_MEM_INITIALIZE;
        reg reg_BinaryInit;
        reg [2047:0] reg_InitFileName;
        reg [Bits -1 :0] reg_Initn_reset_value;
        time reg_File_load_time;

        //Power Supply Registers        
        reg vddmireg;
        reg vddmreg;
        reg vddsmreg;
        reg gndmreg;
        reg gndsmreg;   
        reg vddmpreg;
        reg vddmpireg;
        reg vddmareg;
        reg vddsmpreg;
        reg vddsmareg;
        reg vddmoreg;
        time vddmp_rise_time;
        time vddmp_fall_time;
        time vddsmp_rise_time;
        time vddsmp_fall_time;
        time vddma_rise_time;
        time vddma_fall_time;
        time vddsma_rise_time;
        time vddsma_fall_time;
        reg reg_check_rise;
        reg reg_check_fall;
        reg reg_check_rise_vddma;
        reg reg_check_fall_vddsma;
        reg  reg_check_rise_vddm, reg_check_fall_vddsm ;
        time vddm_fall_time,  vddm_rise_time,  vddsm_fall_time, vddsm_rise_time ;
  /* This register is used to force all warning messages 
  ** OFF during run time.
  ** It is a 2 bit register.
  ** USAGE :
  ** debug_level_off = 2'b00 -> ALL MESSAGES(INFO/WARNINGS/ERRORS) will be DISPLAYED 
  ** debug_level = 2'b01     -> ONLY WARNINGS/ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b10     -> ONLY ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b11     -> NO MESSAGES will be DISPLAYED.
  */ 
        reg [1:0] debug_level;
        reg [8*10: 0] operating_mode;
        reg [8*44: 0] message_status;

        integer i, k, j, l,m,q,w,r,s,num1,redcnt,n,num2,FirstHalf,Bfaileff,memcnt,ptr;
        integer decoder[Bits-1:0];
        `ifdef slm
           integer MemAddr;
        `endif


        //************************************************************
        //****** CONFIG FAULT IMPLEMENTATION VARIABLES*************** 
        //************************************************************ 

        integer file_ptr, ret_val;
        integer fault_word;
        integer fault_bit;
        integer fcnt, Fault_in_memory,faultnum,stop_loop,count;
        integer t;  
        integer FailureLocn [max_faults -1 :0];
        integer Failurebit [max_faults -1 :0];
        reg [100 : 0] stuck_at;
        reg [100 : 0] fault_array;
        reg [200 : 0] tempStr;
        reg [7:0] fault_char;
        reg [7:0] fault_char1; // 8 Bit File Pointer
        reg [Addr -1 : 0] std_fault_word;
        reg [Addr -1 : mux_bits] fault_row_add [max_faults -1 :0];
        reg [max_faults -1 :0] fault_repair_flag;
        reg [max_faults -1 :0] dont_insert_fault;
        reg [max_faults -1 :0] repair_flag;
        reg [100 : 0] array_stuck_at[max_faults -1 : 0] ;
        reg [100 : 0] mem_red_array_stuck_at[max_faults -1 : 0] ; 
        reg msgcnt;
        
       
        reg [Bits - 1: 0] stuck_at_0fault [max_faults -1 : 0];
        reg [Bits - 1: 0] stuck_at_1fault [max_faults -1 : 0];
        reg [Bits -1 : 0] stuck0;
        reg [Bits -1 : 0] stuck1;

        reg [Bits+Red_extrabit :0] Mem_last;
        

        `ifdef slm
        reg [Bits -1 : 0] slm_temp_data;
        `endif
        
        real time_CK_func_rise , time_RADCK_rise;
        real time_fall_sleep,time_fall_PSWLARGEMP,time_fall_PSWLARGEMP_0,time_fall_PSWLARGEMA,time_fall_PSWLARGEMA_0,time_fall_PSWSMALLMP,time_fall_PSWSMALLMA;
        integer flag_error;
        
//BUFFER INSTANTIATION
//=========================
       `ifdef functional
       
         buf (SCTRLO,delSCTRLO_data); 
         buf bufq [Bits-1:0] (Q,delOutReg_data);
      `else
       
         buf (SCTRLO,SCTRLO_data);
         buf bufq [Bits-1:0] (Q,OutReg_data);
      `endif
      
  
        buf (SEsys,SE);
	buf (SCTRLIint, SCTRLI);
   

	buf (CKint_func, CK);
	buf (CKint_dft, CK);
        buf bufaddr [Addr-1:0] (Asys,A);
        buf (INITNint,INITN);
        
        buf (LSint,1'b0); 
        buf (IGbuf,IG);
        buf (ATPint,ATP);

        buf bufTaddr [Addr-1 : 0] (TAint,TA);
        buf (TBISTsys,TBIST);
        buf (TCSNint,TCSN);

        buf (CSNsys,CSN);
        buf (STDBYint,STDBY );   
        
        buf (SLEEPint,SLEEP ); 

        buf bufrm [read_margin_size-1:0] (RMint, RM); 

        
        

        assign RRAEint = 1'b0;
        assign TRRAEint = 1'b0;
        assign repair_add = 0;
        assign next_repair_add = 0;
        assign red_en = 1'b0; 
        
        
        
        
        
        
        
        buf (PSWLARGEMPint,1'b0);
        buf (PSWSMALLMPint,1'b0); 
        buf (PSWLARGEMAint,1'b0);
        buf (PSWSMALLMAint,1'b0);   

      `ifdef functional
       
       
         buf (SDLO,delSDLO_data);
         buf (SDRO,delSDRO_data);
        
      `else
       
         buf (SDLO,SDLO_data);
         buf (SDRO,SDRO_data);
         
      `endif
       
         
       
        buf bufdata [Bits-1:0] (Dsys,D);
        
        
        assign Msys=20'b0; 
	

        
        buf (TBYPASSsys, TBYPASS);
        


        buf (WENsys,WEN);
	 
	buf (SDLIint, SDLI);
	buf (SDRIint, SDRI);
	 
        
        buf (HSint,1'b0); 

        
        buf (TEDint,TED);
        buf (TODint,TOD);
         
        buf (TWENint,TWEN);
        
        
        buf bufwm [write_margin_size-1:0] (WMint, WM); 
        



//      assign scanreg_ctrl_wire={scanreg_ctrl[scanlen_ctrl - 2:0],SCTRLIint};
//      assign scanreg_dl_wire={scanreg_dl[scanlen_l - 2:0],SDLIint};
//      assign scanreg_dr_wire={scanreg_dr[scanlen_r - 2:0],SDRIint};
      
        
      assign Aint   = (TBISTint === 1'b0 ) ? Asys : (TBISTint === 1'bx ) ? {Addr{1'bx}} : TAint;  

        
//        assign A_int = Aint;
	
        
                
        assign Dint[0] = (TBISTint === 1'b0) ? Dsys[0] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[1] = (TBISTint === 1'b0) ? Dsys[1] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[2] = (TBISTint === 1'b0) ? Dsys[2] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[3] = (TBISTint === 1'b0) ? Dsys[3] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[4] = (TBISTint === 1'b0) ? Dsys[4] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[5] = (TBISTint === 1'b0) ? Dsys[5] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[6] = (TBISTint === 1'b0) ? Dsys[6] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[7] = (TBISTint === 1'b0) ? Dsys[7] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[8] = (TBISTint === 1'b0) ? Dsys[8] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[9] = (TBISTint === 1'b0) ? Dsys[9] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[10] = (TBISTint === 1'b0) ? Dsys[10] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[11] = (TBISTint === 1'b0) ? Dsys[11] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[12] = (TBISTint === 1'b0) ? Dsys[12] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[13] = (TBISTint === 1'b0) ? Dsys[13] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[14] = (TBISTint === 1'b0) ? Dsys[14] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[15] = (TBISTint === 1'b0) ? Dsys[15] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[16] = (TBISTint === 1'b0) ? Dsys[16] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[17] = (TBISTint === 1'b0) ? Dsys[17] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[18] = (TBISTint === 1'b0) ? Dsys[18] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[19] = (TBISTint === 1'b0) ? Dsys[19] : (TBISTint === 1'b1) ? TODint : 1'bx;          
	 
        assign Mint = 20'b0;
         

        assign WENbuf = (TBISTint === 1'b0 ) ? WENsys : (TBISTint === 1'bx ) ? 1'bx : TWENint;  
        assign WENint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? WENbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[13] : (ATPint === 1'b0 ) ? WENsys : 1'bx ; 
        
        assign CSNbuf = (TBISTint === 1'b0 ) ? CSNsys : (TBISTint === 1'bx ) ? 1'bx : TCSNint;  
        assign CSNint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? CSNbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[11] : (ATPint === 1'b0 ) ? CSNsys : 1'bx ; 
        assign IGint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? IGbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[14] : (ATPint === 1'b0 ) ? IGbuf : 1'bx;

        
        assign DEint = (LSint === 1'bx || (LSint === 1'b0 && HSint === 1'bx) || ^RMint !== 1'b0 || ^WMint !== 1'b0 ) ? 1'bx : 1'b0;
        
     
     and (TBISTint, ATPint, TBISTsys);
     and (SEint, ATPint, SEsys);
     and (TBYPASSint, ATPint, TBYPASSsys);
     and (TSE,TBYPASSint,!SEsys);
     and (MEMEN,INITNint,!CSNint,!SLEEPint,!TBYPASSint,!SEint,!IGint,!DEint,!STDBYint );
     and (MEMEN_dft,INITNint, !SLEEPint, ATPint,!STDBYint);

 `ifdef functional
/*****************assertions added to optimize dynamic power consumption**********/

//psl a_M: assert always ({( RW_assertions_en);(MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1))  } |-> (stable(Msys))) @(posedge CK); 

//psl a_WEN: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(WENsys))) @(posedge CK); 

//psl a_A: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(Asys))) @(posedge CK); 

//psl a_D: assert always ({( RW_assertions_en);((MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1)) && TBYPASSint === 1'b0)  } |-> (stable(Dsys))) @(posedge CK); 

/**********************************************************************************************/
`endif       

     

         
reg vddmp,vddmo, vddma, vddsmp, vddsma, gndsm, gndm,  vddmpi ; 
 
initial 
begin

        vddmp = 1'b1 ; 
        vddmo = 1'b1 ;
        vddma = 1'b1 ;
        
        vddsmp = 1'b1 ;
        
        
         gndm = 1'b0 ;
          
end

        
         assign gndmint = (reg_mem_block === 0) ? gndm : 1'b1;
         
         
         
         
         assign vddmpint = vddmp;
         assign vddmoint = vddmo;
         assign vddmaint = vddma;
         
          
        
         

        //CPF Changes

        
                
        initial
        begin : cpfvddmp 
           vddmpreg = vddmpint;
        end

        always @(vddmpint) begin
           vddmpreg = vddmpint;
        end
        
        initial
        begin : cpfvddmo 
           vddmoreg = vddmoint;
        end

        always @(vddmoint) begin
           vddmoreg = vddmoint;
        end
        
        initial
        begin : cpfvddma 
           vddmareg = vddmaint;
        end

        always @(vddmaint) begin
           vddmareg = vddmaint;
        end

        
        
 
        initial
        begin : cpfgndm 
           gndmreg = gndmint;
        end

        always @(gndmint) begin
           gndmreg = gndmint;
        end

        
        



 `ifdef functional
  `else
  initial begin
    if (debug_level < 1) begin
     $display ("%m  INFORMATION");
     $display ("***************************************");
     $display ("The Model is Operating in TIMING MODE");
     $display ("Please make sure that SDF is properly annotated otherwise dummy values will be used");
     $display ("%s", message_status);
     $display ("***************************************");
    end
  end

//////////////////////////
 //REG DECLARATIONS
   //======================

   reg [Bits-1 : 0] TimingViol_data;
   reg  [Bits-1 : 0] TimingViol_mask;
   reg [Bits-1 : 0] TimingViol_data_last, TimingViol_mask_last;
	reg TimingViol_data_0;
	reg TimingViol_data_1;
	reg TimingViol_data_2;
	reg TimingViol_data_3;
	reg TimingViol_data_4;
	reg TimingViol_data_5;
	reg TimingViol_data_6;
	reg TimingViol_data_7;
	reg TimingViol_data_8;
	reg TimingViol_data_9;
	reg TimingViol_data_10;
	reg TimingViol_data_11;
	reg TimingViol_data_12;
	reg TimingViol_data_13;
	reg TimingViol_data_14;
	reg TimingViol_data_15;
	reg TimingViol_data_16;
	reg TimingViol_data_17;
	reg TimingViol_data_18;
	reg TimingViol_data_19;
 reg TimingViol_mask_0;
 reg TimingViol_mask_1;
 reg TimingViol_mask_2;
 reg TimingViol_mask_3;
 reg TimingViol_mask_4;
 reg TimingViol_mask_5;
 reg TimingViol_mask_6;
 reg TimingViol_mask_7;
 reg TimingViol_mask_8;
 reg TimingViol_mask_9;
 reg TimingViol_mask_10;
 reg TimingViol_mask_11;
 reg TimingViol_mask_12;
 reg TimingViol_mask_13;
 reg TimingViol_mask_14;
 reg TimingViol_mask_15;
 reg TimingViol_mask_16;
 reg TimingViol_mask_17;
 reg TimingViol_mask_18;
 reg TimingViol_mask_19;

   reg TimingViol_addr;
   reg TimingViol_CSN, TimingViol_WEN, TimingViol_tbypass;
   reg TimingViol_tckh, TimingViol_tckl, TimingViol_tcycle;
   reg TimingViol_tckh_se, TimingViol_tckl_se, TimingViol_tcycle_se;
   reg TimingViol_sctrli,TimingViol_sdli,TimingViol_sdri,TimingViol_se;
   reg TimingViol_smli,TimingViol_smri;
   reg TimingViol_sctrli_flag,TimingViol_sdli_flag,TimingViol_sdri_flag;
   reg TimingViol_smli_flag,TimingViol_smri_flag;
   reg TimingViol_initnl;
   reg TimingViol_initn;
   reg TimingViol_ls;
   reg TimingViol_hs;
   reg TimingViol_sleep;
   reg TimingViol_stdby;
   reg TimingViol_rm;
   reg TimingViol_wm;
   reg TimingViol_tbist,TimingViol_ig,TimingViol_atp,TimingViol_TED,TimingViol_TOD,TimingViol_TEM,TimingViol_TOM;
   reg TimingViolRRAE,TimingViolRRA;

   wire CSTBYPASSN,cond_sdf_tas,cond_sdf_tds,cond_sdf_tms,cond_sdf_tws,cond_sdf_tbas,cond_sdf_tbps,cond_sdf_tbws,cond_sdf_tbdes,cond_sdf_tbdos,cond_sdf_tbmes,cond_sdf_tbmos;
   wire SETB_EN,CSIG_EN,MEM_ACT,EN_ADM,CS_EN,CS_ADM,cond_sdf_tps,IG_EN,IG_ADM,cond_sdf_tigs,cond_sdf_taa,cond_sdf_taa_ls1,cond_sdf_taa_hs1,cond_tseq_tm;
   wire cond_sdf_tcycle,cond_sdf_tcycle_ls1,cond_sdf_tcycle_hs1,cond_sdf_tcycle_se,cond_sdf_tckl_se,cond_sdf_tsctrlis,cond_sdf_tsdlis,cond_sdf_tsdris,cond_sdf_tsmlis,cond_sdf_tsmris;
   wire cond_sdf_tckh_se,cond_sdf_taa_sctrlo_se,cond_sdf_taa_sdlo_se,cond_sdf_taa_sdro_se,cond_sdf_taa_smlo_se,cond_sdf_taa_smro_se,cond_sdf_tckl,cond_sdf_tckh;
   wire cond_sdf_ttms,cond_sdf_tbists,INITNandnotSLEEPandATPandnotSE,cond_sdf_taa_sctrlo,cond_sdf_taa_sdlo,cond_sdf_taa_sdro,cond_sdf_taa_smlo,cond_sdf_taa_smro;
   wire cond_sdf_taa_tm,cond_sdf_taa_tm_ls1, cond_sdf_taa_tm_hs1,cond_sdf_taa_tckq_tm,cond_sdf_taa_tseq_tm;

   wire CSWETBYPASSN;
   wire cond_sdf_tstdbys,cond_sdf_tsls,sleep_en,atp_csn_en;
   wire cond_sdf_tlss,cond_sdf_thss,cond_sdf_trms,cond_sdf_twms; 
   wire cond_sdf_tses,cond_sdf_tinitns;
   wire tby_se_en;
   wire rra_en;
   wire tbist_atp_en;
   wire rrae_en;
   wire tbist_rrae_en;
   wire cond_sdf_trraes;
   wire cond_sdf_ttrraes;
   wire cond_sdf_taa_trramatch;
   wire cond_sdf_ttrraematch;
   wire cond_sdf_tamatch;
   wire cond_sdf_ttamatch;
   wire cond_sdf_tatpmatch;
   wire cond_sdf_ttbistmatch;



 and (CSWEMTBYPASS[0], !Mreg[0], CSWETBYPASSN);
 and (CSWEMTBYPASS[1], !Mreg[1], CSWETBYPASSN);
 and (CSWEMTBYPASS[2], !Mreg[2], CSWETBYPASSN);
 and (CSWEMTBYPASS[3], !Mreg[3], CSWETBYPASSN);
 and (CSWEMTBYPASS[4], !Mreg[4], CSWETBYPASSN);
 and (CSWEMTBYPASS[5], !Mreg[5], CSWETBYPASSN);
 and (CSWEMTBYPASS[6], !Mreg[6], CSWETBYPASSN);
 and (CSWEMTBYPASS[7], !Mreg[7], CSWETBYPASSN);
 and (CSWEMTBYPASS[8], !Mreg[8], CSWETBYPASSN);
 and (CSWEMTBYPASS[9], !Mreg[9], CSWETBYPASSN);
 and (CSWEMTBYPASS[10], !Mreg[10], CSWETBYPASSN);
 and (CSWEMTBYPASS[11], !Mreg[11], CSWETBYPASSN);
 and (CSWEMTBYPASS[12], !Mreg[12], CSWETBYPASSN);
 and (CSWEMTBYPASS[13], !Mreg[13], CSWETBYPASSN);
 and (CSWEMTBYPASS[14], !Mreg[14], CSWETBYPASSN);
 and (CSWEMTBYPASS[15], !Mreg[15], CSWETBYPASSN);
 and (CSWEMTBYPASS[16], !Mreg[16], CSWETBYPASSN);
 and (CSWEMTBYPASS[17], !Mreg[17], CSWETBYPASSN);
 and (CSWEMTBYPASS[18], !Mreg[18], CSWETBYPASSN);
 and (CSWEMTBYPASS[19], !Mreg[19], CSWETBYPASSN);

and (atp_csn_en,!ATPint,!CSNint,!IGint);
or (sleep_en,atp_csn_en,ATPint);
or (SETB_EN,SEint,TBISTint);
and (ATP_SETB_EN,ATPint,SETB_EN); 
or (CSIG_EN,IGint,CSNint);
and (MEM_ACT,!ATPint,CSIG_EN);
or (EN_ADM,MEM_ACT,ATP_SETB_EN);
and (CS_EN,!ATPint,IGint);
or (CS_ADM,CS_EN,ATP_SETB_EN);
and (atp_ig_csn_en,!ATPint,!CSNint,!IGint);
and (atp_se_en,!SEsys,ATPint);
or (cycle_en,atp_ig_csn_en,atp_se_en);
and (atp_ig_csn_en_reg,!ATPreg,!CSNreg,!IGreg);
and (atp_se_en_reg,!SE_reg,ATPreg);
or (cycle_en_reg,atp_ig_csn_en,atp_se_en);
and (INITNandnotSLEEPandATPandnotSE,cond_gac,!SEsys,ATPint);
and (csn_ig_en,!IGint,!CSNint);
and (atp_tby_ls_en,atp_se_en,cond_ls_tby_en);
and (IG_EN,!ATPint,!CSNint);
or (IG_ADM,IG_EN,atp_se_en);
and (CSWETBYPASSN, !WENreg, 1'b1);



assign cond_sdf_tsls=((sleep_en && INITNint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tstdbys=((sleep_en && INITNint && !SLEEPint) !==0) ? 1:0;
assign cond_sdf_atps=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_gac=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tas=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tds=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tms=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tws=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tps=((cond_gac && !CS_ADM) !==0) ? 1:0;
assign cond_sdf_tcycle=((cond_gac && cycle_en && !LSint && !HSint) !==0) ? 1:0;  
assign cond_sdf_tcycle_ls1=((cond_gac && cycle_en && LSint) !==0) ? 1:0;
assign cond_sdf_tcycle_hs1=((cond_gac && cycle_en && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_tckh=((cond_gac && cycle_en_reg) !==0) ? 1:0;
assign cond_sdf_tckl=((cond_gac && cycle_en) !==0) ? 1:0;
assign cond_sdf_tcycle_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckl_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsctrlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckh_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_ttms=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_tbists=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_tckq_tm=((cond_gac && SE_reg && ATPreg && TBYPASSsys) !==0) ? 1:0;
assign cond_ls_en=((atp_ig_csn_en || atp_tby_ls_en) !==0) ? 1:0;
assign cond_sdf_tlss=((cond_ls_en && cond_gac) !==0) ? 1:0;
assign cond_sdf_thss=((cond_ls_en && cond_gac && !LSint) !==0) ? 1:0;
assign cond_sdf_trms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_twms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_tses=((cond_gac && ATPint) !==0) ? 1:0;
assign cond_sdf_tbas=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbps=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbws=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tigs=((cond_gac && IG_ADM) !==0) ? 1:0;
assign cond_sdf_taa=((MEMEN_reg && WENreg && !LSint && !HSint) !==0) ? 1:0; 
// assign cond_sdf_taa_tbypass_q = ((MEMEN_reg && ATPint && TBYPASSint) !== 1'b0) ? 1'b1 : 1'b0;
assign cond_sdf_taa_ls1=((MEMEN_reg && WENreg && LSint) !==0) ? 1:0; 
assign cond_sdf_taa_hs1=((MEMEN_reg && WENreg && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && !HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_ls1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && LSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_hs1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tseq_tm=((cond_gac && TBYPASSint) !==0) ? 1:0;
assign cond_sdf_tinitns =(( sleep_en && !STDBYint && !SLEEPint) !==0) ? 1:0;
assign cond_ls_tby_en=((TBYPASSsys || csn_ig_en) !==0) ? 1:0;



//specify block begins

specify
    specparam
    
         PATHPULSE$CK$Q = 0,
         PATHPULSE$CK$SCTRLO = 0,

         PATHPULSE$CK$SDLO = 0,
         PATHPULSE$CK$SDRO = 0,
        
         PATHPULSE$SE$Q = 0,
         
//         PATHPULSE$TBYPASS$Q = 0,


        
         
        
         tsls = `setup_time,
         tslh = `hold_time ,
         tstdbys = `setup_time,
         tstdbyh = `hold_time , 
	 

         
         tcycle = `cycle_time,
         
         
         tckh = `pulse_width_time,
         tckl = `pulse_width_time,
         tcycle_se = `cycle_time,
         tckh_se = `pulse_width_time,
         tckl_se = `pulse_width_time,
         
         ttms = `setup_time,
         ttmh = `hold_time ,
         tps = `setup_time,
         tph = `hold_time ,
         tws = `setup_time,
         twh = `hold_time ,
         tds = `setup_time,
         tdh = `hold_time , 
         tas = `setup_time,
         tah = `hold_time ,
         tses= `setup_time,
         tseh= `hold_time ,
         tsctrlis=`setup_time,
         tsctrlih=`hold_time ,
         tsdlis=`setup_time,
         tsdlih=`hold_time ,
         tsdris=`setup_time,
         tsdrih=`hold_time , 
         tbists=`setup_time,
         tbisth=`hold_time ,
         tbps=`setup_time,
         tbph=`hold_time ,
         tbws=`setup_time,
         tbwh=`hold_time ,
         tbdes=`setup_time,
         tbdeh=`hold_time ,
         tbdos=`setup_time,
         tbdoh=`hold_time ,
         
         tbas=`setup_time,
         tbah=`hold_time ,
         tinitnl=`initin_low_pulse,
         tinitns=`setup_time,
         tinitnh=`hold_time ,
         tatps=`setup_time,
         tatph=`hold_time ,
         tigs=`setup_time,
         tigh=`hold_time ,
         
         
         trms=`setup_time,
         trmh=`hold_time ,
         twms=`setup_time,
         twmh=`hold_time , 

/*************************************************************************************************/
           // taa_tbypass_q = `access_time,
           // th_tbypass_q  = `retain_time,
            taa =`access_time,
            th = `retain_time,

 


            taa_tm =`access_time,
            th_tm = `retain_time,

            
            taa_tseq_tm =`access_time,
            th_tseq_tm = `retain_time,
            taa_tckq_tm   = `access_time,
            th_tckq_tm    = `retain_time,
            taa_sctrlo=`access_time,
            th_sctrlo= `retain_time,
            taa_sdlo=`access_time,
            th_sdlo= `retain_time,
            taa_sdro=`access_time,
            th_sdro= `retain_time,
            
         
            taa_sctrlo_se=`access_time,
            th_sctrlo_se= `retain_time
,
            taa_sdlo_se=`access_time,
            th_sdlo_se= `retain_time,
            taa_sdro_se=`access_time,
            th_sdro_se= `retain_time
         ;  


        /*---------------------- Timing Checks ---------------------*/

	$setup(posedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[7], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[8], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[7], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[8], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[7], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[8], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[7], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[8], tah, TimingViol_addr);

	$setup(posedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(posedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(posedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(posedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(posedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(posedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(posedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(posedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(posedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(posedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(posedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(posedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(posedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(posedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(posedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(posedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(posedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(posedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(posedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(posedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(negedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(negedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(negedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(negedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(negedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(negedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(negedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(negedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(negedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(negedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(negedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(negedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(negedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(negedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(negedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(negedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(negedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(negedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(negedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(negedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[19], tdh, TimingViol_data_19);

        



        $setup(posedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $setup(negedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, posedge WEN, twh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, negedge WEN, twh, TimingViol_WEN); 
        $setup(posedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$setup(negedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, posedge CSN, tph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, negedge CSN, tph, TimingViol_CSN);
        $period(posedge CK &&& cond_sdf_tcycle, tcycle, TimingViol_tcycle);  

        
        $width(posedge CK  &&& cond_sdf_tckh, tckh, 0, TimingViol_tckh);
        $width(negedge CK  &&& cond_sdf_tckl, tckl, 0, TimingViol_tckl);
        $period(posedge CK &&& cond_sdf_tcycle_se, tcycle_se, TimingViol_tcycle_se);
        $width(posedge CK  &&& cond_sdf_tckh_se, tckh_se, 0, TimingViol_tckh_se);
        $width(negedge CK  &&& cond_sdf_tckl_se, tckl_se, 0, TimingViol_tckl_se);

        
        $setup(posedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $setup(negedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $hold(posedge CK &&& cond_sdf_ttms, posedge TBYPASS, ttmh, TimingViol_tbypass); 
        $hold(posedge CK &&& cond_sdf_ttms, negedge TBYPASS, ttmh, TimingViol_tbypass); 
 



        
        $setup(posedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $setup(negedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $hold(posedge CK &&& cond_sdf_tsls, posedge SLEEP, tslh, TimingViol_sleep);        
        $hold(posedge CK &&& cond_sdf_tsls, negedge SLEEP, tslh, TimingViol_sleep);

        $setup(posedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $setup(negedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $hold(posedge CK &&& cond_sdf_tstdbys, posedge STDBY, tstdbyh, TimingViol_stdby);        
        $hold(posedge CK &&& cond_sdf_tstdbys, negedge STDBY, tstdbyh, TimingViol_stdby); 
        
        
        $setup (posedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
	$setup (negedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
        
        $hold (posedge CK &&& cond_sdf_tses, posedge SE ,tseh,TimingViol_se);
	$hold (posedge CK &&& cond_sdf_tses, negedge SE ,tseh,TimingViol_se);
        
        $setup(posedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis , tsctrlis, TimingViol_sctrli);
        $setup(negedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis, tsctrlis, TimingViol_sctrli);
        $hold(posedge CK &&& cond_sdf_tsctrlis , posedge SCTRLI, tsctrlih, TimingViol_sctrli);        
        $hold(posedge CK &&& cond_sdf_tsctrlis , negedge SCTRLI, tsctrlih, TimingViol_sctrli);

        $setup(posedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $setup(negedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $hold(posedge CK &&& cond_sdf_tsdlis, posedge SDLI, tsdlih, TimingViol_sdli);        
        $hold(posedge CK &&& cond_sdf_tsdlis, negedge SDLI, tsdlih, TimingViol_sdli);

        $setup(posedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $setup(negedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $hold(posedge CK &&& cond_sdf_tsdris, posedge SDRI, tsdrih, TimingViol_sdri);        
        $hold(posedge CK &&& cond_sdf_tsdris, negedge SDRI, tsdrih, TimingViol_sdri);
        
 
	
         
        $width(negedge INITN , tinitnl, 0, TimingViol_initnl);
        
        $setup(posedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        $setup(negedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        
        $hold (posedge CK &&& cond_sdf_tinitns,posedge INITN, tinitnh, TimingViol_initn);
        $hold (posedge CK &&& cond_sdf_tinitns,negedge INITN, tinitnh, TimingViol_initn);

        $setup(posedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $setup(negedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $hold(posedge CK &&& cond_sdf_atps, posedge ATP, tatph, TimingViol_atp);        
        $hold(posedge CK &&& cond_sdf_atps, negedge ATP, tatph, TimingViol_atp);
        
        $setup(posedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $setup(negedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $hold(posedge CK &&& cond_sdf_tigs, posedge IG, tigh, TimingViol_ig);        
        $hold(posedge CK &&& cond_sdf_tigs, negedge IG, tigh, TimingViol_ig);



         
$setup(posedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[2], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[2], trmh, TimingViol_rm); 

        
$setup(posedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(posedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[1], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[1], twmh, TimingViol_wm);
 
        
        $setup(posedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $setup(negedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $hold(posedge CK &&& cond_sdf_tbists, posedge TBIST, tbisth, TimingViol_tbist);        
        $hold(posedge CK &&& cond_sdf_tbists, negedge TBIST, tbisth, TimingViol_tbist);
        
        	$setup(posedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[7], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[8], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$setup(negedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[7], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[8], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[6], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[7], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[8], tbah, TimingViol_addr);
       	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[6], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[7], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[8], tbah, TimingViol_addr);

        $setup(posedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$setup(negedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, posedge TCSN, tbph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, negedge TCSN, tbph, TimingViol_CSN); 
       
        $setup(posedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $setup(negedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, posedge TWEN, tbwh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, negedge TWEN, tbwh, TimingViol_WEN);
       
       
        $setup(posedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $setup(negedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, posedge TED, tbdeh, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, negedge TED, tbdeh, TimingViol_TED);

        $setup(posedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $setup(negedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, posedge TOD, tbdoh, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, negedge TOD, tbdoh, TimingViol_TOD);

          


          

          /*-------------------- Propagation Delays ------------------*/
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa, taa, th, taa, th, taa);
                 

/* // //	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[0] +: OutReg_data[0])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[1] +: OutReg_data[1])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[2] +: OutReg_data[2])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[3] +: OutReg_data[3])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[4] +: OutReg_data[4])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[5] +: OutReg_data[5])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[6] +: OutReg_data[6])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[7] +: OutReg_data[7])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[8] +: OutReg_data[8])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[9] +: OutReg_data[9])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[10] +: OutReg_data[10])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[11] +: OutReg_data[11])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[12] +: OutReg_data[12])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[13] +: OutReg_data[13])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[14] +: OutReg_data[14])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[15] +: OutReg_data[15])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[16] +: OutReg_data[16])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[17] +: OutReg_data[17])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[18] +: OutReg_data[18])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[19] +: OutReg_data[19])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q); */ 








	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                





	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                 

	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[0] +: OutReg_data[0])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[1] +: OutReg_data[1])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[2] +: OutReg_data[2])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[3] +: OutReg_data[3])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[4] +: OutReg_data[4])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[5] +: OutReg_data[5])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[6] +: OutReg_data[6])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[7] +: OutReg_data[7])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[8] +: OutReg_data[8])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[9] +: OutReg_data[9])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[10] +: OutReg_data[10])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[11] +: OutReg_data[11])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[12] +: OutReg_data[12])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[13] +: OutReg_data[13])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[14] +: OutReg_data[14])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[15] +: OutReg_data[15])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[16] +: OutReg_data[16])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[17] +: OutReg_data[17])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[18] +: OutReg_data[18])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[19] +: OutReg_data[19])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                



if (cond_sdf_taa_sctrlo) 
        (posedge CK *> (SCTRLO :  SCTRLI)) = (taa_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo); 

if (cond_sdf_taa_sctrlo_se) 
        (negedge CK *> (SCTRLO : SCTRLI)) = (taa_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se); 
 

if (cond_sdf_taa_sdlo) 
        (posedge CK *> (SDLO :  SDLI)) = (taa_sdlo,taa_sdlo,th_sdlo,taa_sdlo,th_sdlo,taa_sdlo); 

if (cond_sdf_taa_sdlo_se) 
        (negedge CK *> (SDLO : SDLI)) = (taa_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se);

if (cond_sdf_taa_sdro) 
        (posedge CK *> (SDRO :  SDRI)) = (taa_sdro,taa_sdro,th_sdro,taa_sdro,th_sdro,taa_sdro); 

if (cond_sdf_taa_sdro_se) 
        (negedge CK *> (SDRO : SDRI)) = (taa_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se); 

  
     




endspecify //specify block ends






// conversion from registers to array elements for data setup violation notifiers

always @(TimingViol_data_0   or TimingViol_TED  )
begin
        TimingViol_data[0]=~TimingViol_data[0];   
end


always @(TimingViol_data_1   or TimingViol_TOD  )
begin
        TimingViol_data[1]=~TimingViol_data[1];   
end


always @(TimingViol_data_2   or TimingViol_TED  )
begin
        TimingViol_data[2]=~TimingViol_data[2];   
end


always @(TimingViol_data_3   or TimingViol_TOD  )
begin
        TimingViol_data[3]=~TimingViol_data[3];   
end


always @(TimingViol_data_4   or TimingViol_TED  )
begin
        TimingViol_data[4]=~TimingViol_data[4];   
end


always @(TimingViol_data_5   or TimingViol_TOD  )
begin
        TimingViol_data[5]=~TimingViol_data[5];   
end


always @(TimingViol_data_6   or TimingViol_TED  )
begin
        TimingViol_data[6]=~TimingViol_data[6];   
end


always @(TimingViol_data_7   or TimingViol_TOD  )
begin
        TimingViol_data[7]=~TimingViol_data[7];   
end


always @(TimingViol_data_8   or TimingViol_TED  )
begin
        TimingViol_data[8]=~TimingViol_data[8];   
end


always @(TimingViol_data_9   or TimingViol_TOD  )
begin
        TimingViol_data[9]=~TimingViol_data[9];   
end


always @(TimingViol_data_10   or TimingViol_TED  )
begin
        TimingViol_data[10]=~TimingViol_data[10];   
end


always @(TimingViol_data_11   or TimingViol_TOD  )
begin
        TimingViol_data[11]=~TimingViol_data[11];   
end


always @(TimingViol_data_12   or TimingViol_TED  )
begin
        TimingViol_data[12]=~TimingViol_data[12];   
end


always @(TimingViol_data_13   or TimingViol_TOD  )
begin
        TimingViol_data[13]=~TimingViol_data[13];   
end


always @(TimingViol_data_14   or TimingViol_TED  )
begin
        TimingViol_data[14]=~TimingViol_data[14];   
end


always @(TimingViol_data_15   or TimingViol_TOD  )
begin
        TimingViol_data[15]=~TimingViol_data[15];   
end


always @(TimingViol_data_16   or TimingViol_TED  )
begin
        TimingViol_data[16]=~TimingViol_data[16];   
end


always @(TimingViol_data_17   or TimingViol_TOD  )
begin
        TimingViol_data[17]=~TimingViol_data[17];   
end


always @(TimingViol_data_18   or TimingViol_TED  )
begin
        TimingViol_data[18]=~TimingViol_data[18];   
end


always @(TimingViol_data_19   or TimingViol_TOD  )
begin
        TimingViol_data[19]=~TimingViol_data[19];   
end


`endif


// TASK DEFINITION DESCRIPTION
// ================================



task task_insert_faults_in_memory;
begin
   if (reg_ConfigFault)
   begin   
     for(i = 0;i< fcnt;i = i+ 1) begin
        if(mem_red_array_stuck_at[i] === "mem_array") begin
          if (array_stuck_at[i] === "sa0") begin
           `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data & stuck_at_0fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
          `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] & stuck_at_0fault[i];
          `endif
         end //if(array_stuck_at)
                                        
         if(array_stuck_at[i] === "sa1") begin
         `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data | stuck_at_1fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
         `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] | stuck_at_1fault[i]; 
         `endif
         end //if(array_stuck_at)
       end //if mem_red_array_stuck_at
    
    
     end    // end of for
   end  
end
endtask



task task_read_fault_file;
begin
/*  -----------Implemetation for config fault starts------*/
   msgcnt = X;
   t = 0;
   fault_repair_flag = {max_faults{1'b1}};
   repair_flag = {max_faults{1'b1}};
   if(reg_ConfigFault) 
   begin
      file_ptr = $fopen(reg_Fault_file_name , "r");
      if(file_ptr == 0)
      begin     
          if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: File cannot be opened ",$realtime);
      end        
      else                
      begin : read_fault_file
        t = 0;
        for (i = 0; i< max_faults; i= i + 1)
        begin
         
           stuck0 = {Bits{1'b1}};
           stuck1 = {Bits{1'b0}};
           fault_char1 = $fgetc (file_ptr);
           if (fault_char1 == 8'b11111111)
              disable read_fault_file;
           ret_val = $ungetc (fault_char1, file_ptr);
           ret_val = $fgets(tempStr, file_ptr);
           ret_val = $sscanf(tempStr, "%s %d %d %s",fault_array,fault_word, fault_bit, stuck_at) ;
           flag_error = 0; 
           if(ret_val !== 0)
           begin         
              if(ret_val == 3 || ret_val == 4)
              begin
                if(ret_val == 3)
                   stuck_at = "sa0";

                if(stuck_at !== "sa0" && stuck_at !== "sa1" && stuck_at !== "none")
                begin
                    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: Wrong value for stuck at in fault file ",$realtime);
                   flag_error = 1;
                end    
                      
                if(fault_word >= Words)
                begin
                   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Address out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                if(fault_bit >= Bits)
                begin  
                    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Faulty bit out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                
                        
                if(fault_array !== "mem_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array is not mem_array ",$realtime);
                  flag_error = 1;
                end

                if(fault_array === "red_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array can't be on redundancy array in non redundancy cut.",$realtime);
                  flag_error = 1;
                end

                
                

                if(flag_error == 0)
                //Correct Inputs
                begin
                   if(stuck_at === "none")
                   begin
                       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
                   end
                   else
                   //Adding the faults
                   begin
                      FailureLocn[t] = fault_word;
                      Failurebit[t]  = fault_bit ;
                      std_fault_word = fault_word;
                      fault_row_add[t] = std_fault_word[Addr-1:mux_bits];
                      mem_red_array_stuck_at[t] = fault_array;
                      fault_repair_flag[t] = 1'b0;
                      if (stuck_at === "sa0" )
                      begin
                         stuck0[fault_bit] = 1'b0;         
                         stuck_at_0fault[t] = stuck0;
                      end     
                      if (stuck_at === "sa1" )
                      begin
                         stuck1[fault_bit] = 1'b1;
                         stuck_at_1fault[t] = stuck1; 
                      end

                      array_stuck_at[t] = stuck_at;
                      t = t + 1;
                   end //if(stuck_at === "none")  
                end //if(flag_error == 0)
              end //if(ret_val == 2 || ret_val == 3 
              else
              //wrong number of arguments
              begin
                if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: WRONG VALUES ENTERED FOR FAULTY WORD OR FAULTY BIT OR STUCK_AT IN Fault_file_name ",$realtime); 
                flag_error = 1;
              end
           end //if(ret_val !== 0)
           else
           begin 
               if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
           end    
        end //for (i = 0; i< m
      end //begin: read_fault_file  
      $fclose (file_ptr);

      fcnt = t;
      
      //fault injection at time 0.
      task_insert_faults_in_memory;
  end // config_fault 
end
endtask


task WriteMemX;
begin

`ifdef slm
   $slm_ResetMemory(MemAddr, WordX);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = WordX;
   
`endif        
 task_insert_faults_in_memory;
end
endtask

task WriteMem0;
begin
`ifdef slm
   $slm_ResetMemory(MemAddr, Word0);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = Word0;
  
`endif 
   task_insert_faults_in_memory;
end
endtask


task WriteOutX;                
begin
   OutReg_data <= #0 WordX;
end
endtask


task Invalid_next_cycle_func;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_func = 1;
     `else 
       #0 next_cycle_corrupt_func = 0; 
     `endif  
   end 
end
endtask

task Invalid_next_cycle_dft;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_dft = 1;
     `else 
       #0 next_cycle_corrupt_dft = 0; 
     `endif  
  end
end
endtask

task Invalid_next_cycle_func_tim;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
   #0 next_cycle_corrupt_func <= 1;
  end 
end
endtask

task Invalid_next_cycle_dft_tim;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
  #0 next_cycle_corrupt_dft <= 1;
  end
end
endtask


task ScanOutX;                
begin
   
   dff_SCTRLO_SE.Q <= 1'bx;   
   dff_SDLO_SE.Q <= 1'bx; 
   dff_SDRO_SE.Q <= 1'bx; 
    
   
   SCTRLOint=X;
   SDLOint=X;
   SDROint=X;
    
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   SDLO_data<=1'bx;
   SDRO_data<=1'bx;
    
   `endif
end
endtask

task delScanOutX;                
begin
   delSCTRLO_data<=X;
   delSDLO_data<=X;
   delSDRO_data<=X;
    
end
endtask

task ScanChainX;                
begin
 scanreg_ctrl=1'bx; 
 scanreg_dl=1'bx; 
 scanreg_dr =1'bx; 
  
end
endtask

task mem_blocked;
begin
 
   WriteMemX;
   WriteOutX;
   ScanChainX;
   ScanOutX;//immediately;
   delScanOutX;//immediately
   `ifdef POWER_SEQUENCING_OFF
   `else
   reg_mem_block=1;
   `endif
   debug_level = 2'b11;
end
endtask

task corrupt_all;
begin
 
  WriteMemX;
  WriteOutX;
  ScanChainX;
  ScanOutX;
  delScanOutX;//immediately;
  OutReg_data = WordX; 
  delOutReg_data=WordX;
  
end
endtask

task WriteCycle;                  
input [Addr-1 : 0] Address;
reg [Bits-1:0] tempReg1;
reg [Bits-1:0] tempReg_slm;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;


reg repair_flag;

integer po,i,num,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;
begin

   tempReg1 = WordX;
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];

   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};
   
   if (ValidAddress === X )   begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
        WriteMemX;
        if (INITNint !== 0) begin
        `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
           #0 next_cycle_corrupt_func = 1;
       `else 
           #0 next_cycle_corrupt_func = 0; 
       `endif  
   end 

   end


   if (ValidAddress !== X && next_cycle_corrupt_func === 0  )
   begin
         if (red_en === 1 && ((Row_Add_cmp === repair_add) || (Row_Add_cmp === next_repair_add)) ) begin
             repair_flag = 1'b1;
             
             Bank_sel_integer = 0;
                     
             if (Row_Add_cmp === repair_add) begin
               Col_Add_integer  = Col_Add; 
             end
             else if (Row_Add_cmp === next_repair_add) begin
               Col_Add_integer  = Col_Add + mux; 
             end  
             RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
        end  

        if(repair_flag === 0 && ValidAddress === 1) begin
           `ifdef slm
              $slm_ReadMemoryS(MemAddr, Address, tempReg_slm);
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = Mem[Address];
            `endif
          end  
        else if(repair_flag === 1) begin
           `ifdef slm
//              $slm_ReadMemoryS(RedMemAddr, RedMem_address, tempReg_slm);
          
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = RedMem[RedMem_address];
            `endif
        end
        
        for (num=0;num<Bits;num=num+1) begin
             po=num;        
             if ( Dint [num] !== tempReg1 [po]) begin
                if (Mint[num] === 1'b0)
                   tempReg1[po] = Dint[num];
                else if (Mint[num] === 1'bX)
                   tempReg1[po] = 1'bx;
             end                
        end //for (num=0
            
         if(repair_flag === 0 ) begin    
            if(ValidAddress === 1) begin  
              `ifdef slm
                  tempReg_slm=tempReg1; 
                  $slm_WriteMemory(MemAddr, Address, tempReg_slm);
              `else
                   Mem[Address] = tempReg1;
              `endif
            end
            else begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address Out Of Range. ",$realtime);
            end        
         end
         else if (repair_flag === 1 ) begin
            `ifdef slm
                tempReg_slm=tempReg1; 
//                $slm_WriteMemory(RedMemAddr, RedMem_address, tempReg_slm);
            `else
                RedMem[RedMem_address] = tempReg1;
            `endif
         end
   end //if (ValidAddress !== X
   task_insert_faults_in_memory;
end
endtask 

task ReadCycle;
input [Addr-1 : 0] Address;

reg [Bits-1:0] MemData_tmp;
reg [Bits-1:0] MemData;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;

reg repair_flag;

integer a,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;

begin
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];
   
   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};

   

   if (ValidAddress !== X && next_cycle_corrupt_func === 0 ) begin   
       if(red_en === 1 && ( Row_Add_cmp === repair_add ||  Row_Add_cmp === next_repair_add )) begin
              repair_flag = 1;
              
              Bank_sel_integer = 0;
               
              if(Row_Add_cmp === repair_add) begin
                Col_Add_integer = Col_Add;
              end
              else if (Row_Add_cmp === next_repair_add) begin
                Col_Add_integer = Col_Add + mux; 
              end
              RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
       end

      if(repair_flag === 0) begin
          if(ValidAddress === 1) begin 
           `ifdef slm
              $slm_ReadMemory(MemAddr, Address, MemData);
           `else
              MemData = Mem[Address];
           `endif
          end
          else begin
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Address Out Of Range. Output Corrupted ",$realtime);
             MemData = WordX;
          end
     end
      else if(repair_flag === 1) begin
        `ifdef slm
//           $slm_ReadMemory(RedMemAddr, RedMem_address, MemData);
        `else
           MemData = RedMem[RedMem_address];
        `endif
      end
   end //if (ValidAddress)  
   
   if(ValidAddress === X)
   begin
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Illegal Value on Address Bus. Memory and Output Corrupted ",$realtime); 
         Invalid_next_cycle_func;
   end 
   
  if(ValidAddress !== X && next_cycle_corrupt_func === 0 )
   begin
   for (a = 0; a < Bits; a = a + 1)
   begin
      if (MemData[a] !== OutReg_data[a])
         OutReg_data[a] = WordX[a];
   end//for (a = 0; a <  
         OutReg_data <= MemData;
   end     
end
endtask



// SCAN CHAINS
supply0 gnd;
buf (A_int[0], Aint[0]);
buf (A_int[1], Aint[1]);
buf (A_int[2], Aint[2]);
buf (A_int[3], Aint[3]);
buf (A_int[4], Aint[4]);
buf (A_int[5], Aint[5]);
buf (A_int[6], Aint[6]);
buf (A_int[7], Aint[7]);
buf (A_int[8], Aint[8]);                  //used for capturing
buf (A_int[9], gnd);
buf (A_int[10], gnd);
buf (A_int[11], gnd);
buf (A_int[12], gnd);
buf (A_int[13], gnd);
buf (A_int[14], gnd);   //used for capturing

buf (WEN_int, WENint);
buf (CSN_int, CSNint);
buf (IG_int, IGint);


// Scan flops



// CONTROL SCAN CHAIN
     ST_SPREG_LOLEAK_512x20m2_Tl_SCFF cntrl_scff_0 (.D(1'b0), .TI(SCTRLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[0]), .OUTX(scanreg_ctrl));

      
 ST_SPREG_LOLEAK_512x20m2_Tl_SCFF cntrl_scff_1 (.D(A_int[2]), .TI(scanreg_ctrl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[1]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m2_Tl_SCFF cntrl_scff_2 (.D(A_int[4]), .TI(scanreg_ctrl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[2]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m2_Tl_SCFF cntrl_scff_3 (.D(A_int[7]), .TI(scanreg_ctrl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[3]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m2_Tl_SCFF cntrl_scff_4 (.D(A_int[1]), .TI(scanreg_ctrl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[4]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m2_Tl_SCFF cntrl_scff_5 (.D(A_int[9]), .TI(scanreg_ctrl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[5]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m2_Tl_SCFF cntrl_scff_6 (.D(A_int[8]), .TI(scanreg_ctrl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[6]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m2_Tl_SCFF cntrl_scff_7 (.D(1'b0), .TI(scanreg_ctrl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[7]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m2_Tl_SCFF cntrl_scff_8 (.D(A_int[0]), .TI(scanreg_ctrl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[8]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m2_Tl_SCFF cntrl_scff_9 (.D(A_int[3]), .TI(scanreg_ctrl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[9]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m2_Tl_SCFF cntrl_scff_10 (.D(A_int[5]), .TI(scanreg_ctrl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[10]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m2_Tl_SCFF cntrl_scff_11 (.D(CSN_int), .TI(scanreg_ctrl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[11]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m2_Tl_SCFF cntrl_scff_12 (.D(A_int[6]), .TI(scanreg_ctrl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[12]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m2_Tl_SCFF cntrl_scff_13 (.D(WEN_int), .TI(scanreg_ctrl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[13]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m2_Tl_SCFF cntrl_scff_14 (.D(scanreg_ctrl_wire[14]), .TI(scanreg_ctrl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[14]), .OUTX(scanreg_ctrl));  

reg LP_CK_gate;

// Lock Up Latch
wire SCTRLO_temp;
 ST_SPREG_LOLEAK_512x20m2_Tl_lock_up_latch  dff_SCTRLO_SE (Latch_open, scanreg_ctrl_wire[14], SCTRLO_temp);

always @(SCTRLO_temp) begin
     SCTRLOint= SCTRLO_temp;
 `ifdef functional
 `else
 if (SCTRLOint !== SCTRLO_data) begin 
  if (SCTRLOint !==X)
   SCTRLO_data=1'bx;
   SCTRLO_data <= SCTRLOint;
 end 
 `endif
end  


// LEFT DATA SCAN CHAIN
     ST_SPREG_LOLEAK_512x20m2_Tl_SCFF ldata_scff_0 (.D(Dint[9]), .TI(SDLI), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[0]), .OUTX(scanreg_dl));
      
   
 
        ST_SPREG_LOLEAK_512x20m2_Tl_SCFF ldata_scff_1 (.D(Dint[8]), .TI(scanreg_dl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[1]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m2_Tl_SCFF ldata_scff_2 (.D(Dint[7]), .TI(scanreg_dl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[2]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m2_Tl_SCFF ldata_scff_3 (.D(Dint[6]), .TI(scanreg_dl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[3]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m2_Tl_SCFF ldata_scff_4 (.D(Dint[5]), .TI(scanreg_dl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[4]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m2_Tl_SCFF ldata_scff_5 (.D(Dint[4]), .TI(scanreg_dl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[5]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m2_Tl_SCFF ldata_scff_6 (.D(Dint[3]), .TI(scanreg_dl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[6]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m2_Tl_SCFF ldata_scff_7 (.D(Dint[2]), .TI(scanreg_dl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[7]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m2_Tl_SCFF ldata_scff_8 (.D(Dint[1]), .TI(scanreg_dl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[8]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m2_Tl_SCFF ldata_scff_9 (.D(Dint[0]), .TI(scanreg_dl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[9]), .OUTX(scanreg_dl));



// Lock Up Latch
wire SDLO_temp;
 ST_SPREG_LOLEAK_512x20m2_Tl_lock_up_latch  dff_SDLO_SE (Latch_open, scanreg_dl_wire[9], SDLO_temp);

always @(SDLO_temp) begin
     SDLOint= SDLO_temp;
 `ifdef functional
 `else
 if (SDLOint !== SDLO_data) begin 
  if (SDLOint !==X)
   SDLO_data=1'bx;
   SDLO_data <= SDLOint;
 end 
 `endif
end  






// RIGHT DATA SCAN CHAIN

     ST_SPREG_LOLEAK_512x20m2_Tl_SCFF rdata_scff_0 (.D(Dint[19]), .TI(SDRI), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[0]), .OUTX(scanreg_dr));
     
 
 
        ST_SPREG_LOLEAK_512x20m2_Tl_SCFF rdata_scff_1 (.D(Dint[18]), .TI(scanreg_dr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[1]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m2_Tl_SCFF rdata_scff_2 (.D(Dint[17]), .TI(scanreg_dr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[2]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m2_Tl_SCFF rdata_scff_3 (.D(Dint[16]), .TI(scanreg_dr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[3]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m2_Tl_SCFF rdata_scff_4 (.D(Dint[15]), .TI(scanreg_dr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[4]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m2_Tl_SCFF rdata_scff_5 (.D(Dint[14]), .TI(scanreg_dr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[5]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m2_Tl_SCFF rdata_scff_6 (.D(Dint[13]), .TI(scanreg_dr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[6]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m2_Tl_SCFF rdata_scff_7 (.D(Dint[12]), .TI(scanreg_dr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[7]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m2_Tl_SCFF rdata_scff_8 (.D(Dint[11]), .TI(scanreg_dr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[8]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m2_Tl_SCFF rdata_scff_9 (.D(Dint[10]), .TI(scanreg_dr_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[9]), .OUTX(scanreg_dr)); 


// Lock Up Latch
wire SDRO_temp;
 ST_SPREG_LOLEAK_512x20m2_Tl_lock_up_latch  dff_SDRO_SE (Latch_open, scanreg_dr_wire[9], SDRO_temp);


always @(SDRO_temp) begin
     SDROint= SDRO_temp;
 `ifdef functional
 `else
 if (SDROint !== SDRO_data) begin 
  if (SDROint !==X)
   SDRO_data=1'bx;
   SDRO_data <= SDROint;
 end 
 `endif
end






//


 //////// CAPTURE TASK //////
task scan_acquire;
begin
   if (supply_ok === 1) begin 
      if ( SEsys === 0 && ((LP_CK_gate === 0 && TBYPASSsys !== 1'bx)|| TBYPASSsys===0)) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
         
         Latch_open=1;
         

      end //if ( SEint === 0
   end//if(supply_ok 
end
endtask

task scan_shift;
begin
 if (supply_ok === 1) begin
   if (STDBYint === 0 && SLEEPint === 0) begin
      if (CKint_dft === X && INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0) begin
         ScanChainX;
         ScanOutX;
      end
      else if (CKint_dft === 1 && lastCK_dft === 0 ) begin
          //// SHIFT
        if (SEsys === 1) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
           
        //// SHIFT Ends
        end //if (SEsys === 1
        else if (SEsys === X) begin
            ScanChainX;
            ScanOutX;
            delScanOutX;
        end//if (SEint ==X
      
      end///if (CKint === 
    
      else if (CKint_dft === 0 && lastCK_dft === 1 ) begin
        Latch_open=1;
      end
    end  //if (STDByint === 0 && SLEEPint === 0
 end//if(supply_ok
end
endtask






// BEHAVIOURAL MODULE DESCRIPTION
// ================================

initial
begin
  // Define format for timing value
  $timeformat (-9, 3, " ns", 0);
  `ifdef slm
  $slm_RegisterMemory(MemAddr, Words, Bits);
  `endif   
   reg_mem_block=0;
   flag_mem_block=0;
  `ifdef functional
  `else
   TimingViol_data=0;
   TimingViol_mask=0;
   `endif
   decoding_start=0;
  
   //Parameter Assignment
   
   reg_Fault_file_name = Fault_file_name; 
   reg_ConfigFault     = ConfigFault;
   reg_MEM_INITIALIZE  = MEM_INITIALIZE;
   reg_BinaryInit      = BinaryInit;
   reg_InitFileName    = InitFileName;
   reg_Initn_reset_value = Initn_reset_value;
   reg_File_load_time    = File_load_time;

   time_fall_sleep=0;
   time_fall_PSWLARGEMP=0;
   time_fall_PSWLARGEMP_0=0;
   time_fall_PSWLARGEMA=0;
   time_fall_PSWLARGEMA_0=0;
   time_fall_PSWSMALLMP=0;
   time_fall_PSWSMALLMA=0;

   vddmp_rise_time=0;
   vddmp_fall_time=0;
   vddsmp_rise_time=0;
   vddsmp_fall_time=0;
   vddma_rise_time=0;
   vddma_fall_time=0;
   vddsma_rise_time=0;
   vddsma_fall_time=0;
   vddm_fall_time=0;  
   vddm_rise_time=0;  
   vddsm_fall_time=0; 
   vddsm_rise_time=0;

   next_cycle_corrupt_func=0;
   next_cycle_corrupt_dft=0;
   init_pulse_done = 0;
   power_up_done = 0;
   file_loaded=1;
   debug_level= 2'b01;
   message_status = "ONLY WARNINGS/ERRORS are Switched ON.For INFO also use debug_level=2'b00";
  `ifdef  NO_WARNING_MODE
     debug_level = 2'b11;
     message_status = "All Warning/Errors/Info Messages are Switched OFF";
  `endif  
  `ifdef  ONLY_ERROR_MODE
     debug_level = 2'b10;
     message_status = "All Warning/Info Messages are Switched OFF.Errors are switched on";
  `endif 
  `ifdef  ALL_MSG_MODE
     debug_level = 2'b00;
     message_status = "All Messages are Switched ON";
  `endif 
  
  `ifdef slm
     operating_mode = "SLM";
   `else
      `ifdef functional
         operating_mode = "FUNCTIONAL";
       `else
         operating_mode = "TIMING";
      `endif
   `endif   
  
  if (debug_level < 1) begin
  $display ("%m INFORMATION ");
  $display ("***************************************");
  $display ("The Model is Operating in %s MODE", operating_mode);
  $display ("%s", message_status);
  if(reg_ConfigFault)
  $display ("Configurable Fault Functionality is ON");   
  else
  $display ("Configurable Fault Functionality is OFF");   
  $display("Fault File used by the model Fault_File_Name=%s" ,reg_Fault_file_name);
  $display("Values of Config_fault used in model=%d" ,reg_ConfigFault);
  $display("Values of Mem_INITALIZE used in model=%d" ,reg_MEM_INITIALIZE);
  $display("Values of BinaryInit used in model=%d" ,reg_BinaryInit);
  $display("Values of InitFileName used in model=%s" ,reg_InitFileName);
  $display("Values of Initn_reset_value used in model=%d" ,reg_Initn_reset_value);
  $display("Values of File_load_time used in model=%t" ,reg_File_load_time);

  $display ("***************************************");
  end
     
  task_read_fault_file; 
   if(!INITNint) begin
    if(supply_ok ) begin 
      init_pulse_done = 1;
      power_up_done = 1;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif 
    end 
   end 
        
   lastCK_func = CKint_func;
   lastCK_dft = CKint_dft;

 `ifdef MEM_CONTENTS_SLEEP
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","w");
   $fclose(ptr);
 `endif 

   
end  // initial block ends



//+++++++++++++++++++++++++++++++ CONFIG FAULT IMPLEMETATION ENDS+++++++++++++++++++++++++++++++//
        




//INITN block starts
//================================
always @(INITNint  or supply_ok )
begin
 if (INITNint === 1'b0) begin
   if(supply_ok) begin
     init_pulse_done = 1;
     power_up_done = 1;
     lastCK_func=CKint_func;
     lastCK_dft=CKint_dft;
     next_cycle_corrupt_func = 0;
     next_cycle_corrupt_dft = 0;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif     
   end 
 end        

 if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && INITNint !== 1)
   begin
     ScanOutX;
     ScanChainX;
     delScanOutX;
   end  
         
 if (init_pulse_done === 0 && INITNint !== 0) begin
     if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) INFO: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
 end
 
end//always @(INITNint)


// Clock Generation 
//wire gated_clock;
//wire clock_gate_en;
//ST_SPREG_LOLEAK_512x20m2_Tl_lock_up_latch CK_SE_latch (!CK , SE, SE_latch_CK);
//and (clock_gate_en, ATP, TBYPASS, !SE_latch_CK);

//ST_SPREG_LOLEAK_512x20m2_Tl_lock_up_latch LP_latch (!CK , scanreg_ctrl_wire[14], LP_latch_CK);
//and (gated_clock,CK,!LP_latch_CK);
//assign CK_new= clock_gate_en ===0 ? CK : (clock_gate_en ===1 ? gated_clock: (CK===0) ? 0 :1'bx);


// Clock Generation Ends


// Functional CK block starts
//======================================
always @(CKint_func)
begin
   lastCK_func=CKreg_func;  
   CKreg_func=CKint_func;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
        if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
      if (CKreg_func === 1'bX || (CKreg_func === 1'b1 && lastCK_func === 1'bx)) begin
        if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
         
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
         Invalid_next_cycle_func;
        end
      end
      else if (CKreg_func === 1'b1 && lastCK_func === 1'b0 ) begin
        time_CK_func_rise=$realtime;
        MEMEN_prev = MEMEN_reg;
        MEMEN_reg = MEMEN;
        CSNreg = CSNint;
        IGreg = IGint;
        DEreg = DEint;
        SE_reg = SEsys;
        TBYPASS_reg = TBYPASSsys;
        ATPreg = ATPint;
        INITNreg = INITNint;
        SLEEPreg = SLEEPint;
        STDBYreg = STDBYint;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 

    `ifdef functional
    `else
        Mem_last=Mem[Aint];
    `endif 
        if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.INITN pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SLEEP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.STANDBY pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg === X && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.chip select  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg === X && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.IG pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg === X && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.Debug pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg === X && (SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.ATP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg === X && TBYPASS_reg !== 1) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SE pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg !== 1 && TBYPASS_reg === X) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.TBYPASS pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end

        else if ((INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0))) && WENint === X) begin
            // Uncertain write cycle
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: write enable going to X  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end 
        else if (next_cycle_corrupt_func === 1) begin
          next_cycle_corrupt_func = X;
        end
        else if (next_cycle_corrupt_func === 1'bx) begin
          next_cycle_corrupt_func = 0;
        end 
        
//        if (next_cycle_corrupt_func === 0 ) begin 
         
          /*---------------------- File initialization -----------------*/
          
          if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0)) && flag_mem_block === 1'b0) begin
                 Areg=Aint;
                 Dreg=Dint;
                 Mreg=Mint;
                 WENreg=WENint;     
             if (reg_MEM_INITIALIZE === 1'b1 && $realtime >= reg_File_load_time && file_loaded ) begin   
                `ifdef slm
                  if (reg_BinaryInit)
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_BIN");
                  else
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_HEX");
   
                `else
                  if (reg_BinaryInit)
                     $readmemb(reg_InitFileName, Mem, 0, Words-1);
                  else
                     $readmemh(reg_InitFileName, Mem, 0, Words-1);
                `endif
                 file_loaded = 0;
             end
   
             if (^Aint === X)
               ValidAddress = X;
             else if (Aint < Words)
               ValidAddress = 1;
             else    
               ValidAddress = 0;
   
             if(red_en === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Redundancy Enable is Invalid. Either RRAE is X or TRRAE is X",$realtime);
                ValidAddress = X; 
           end
           else if(red_en === 1'b1 && ^repair_add === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Repair Address is invalid.RRA is X",$realtime);
                ValidAddress = X;
           end
             
             if (ValidAddress)
               `ifdef slm
                   $slm_ReadMemoryS(MemAddr, Aint, Mem_temp);
               `else
                    Mem_temp = Mem[Aint];
               `endif
             else
                Mem_temp = WordX;  
          
     /*---------------------- Normal Read and Write -----------------*/
     
             if (WENint === 1) begin
               ReadCycle(Aint);
             end
       
             else if (WENint === 0) begin
               WriteCycle(Aint);
             end 
                
          
          end //  if (MEMEN === 1'b1 
       
//        end  // if (next_cycle_corrupt_func === 0
      
      end // if (CKint = 1   
   end // if (init_pulse_done === 1           
 end 
end // always @(CKint_func)
        
always @(MEMEN)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) && CKint_func === 1'bx) begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.clock pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
    Invalid_next_cycle_func;
  end
 end 
end

// DFT CK block starts
//======================================
always @(CKint_dft) 
begin
   lastCK_dft=CKreg_dft;
   CKreg_dft=CKint_dft;
   
   Latch_open=0;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
     if (CKreg_dft === 1'bX || (CKreg_dft === 1'b1 && lastCK_dft === 1'bx)) begin
       if (INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0 ) begin
        
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: DFT clock  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime); 
         Invalid_next_cycle_dft;
         if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
           WriteOutX;
         end
       end
     end 

     if(CKint_dft === 0 && lastCK_dft === 1) begin
      if(ATPreg === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
       if(SE_reg === 1'b1 && SEsys === 1'b0) begin
        if(TBYPASSint === 1'b1) begin   
            
            
    OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8], scanreg_dl_wire[scanlen_l-1]}; 
 
         for (i = 0; i < Bits; i = i + 1)
         begin
          if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
         end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
        end 
       end
      end
     end 
     
     else if (CKreg_dft === 1'b1 && lastCK_dft === 1'b0 ) begin
       SE_reg = SEsys;
       TBYPASS_reg = TBYPASSsys;
       ATPreg = ATPint;
       INITNreg = INITNint;
       SLEEPreg = SLEEPint;
       STDBYreg = STDBYint;
       MEMEN_dft_prev = MEMEN_dft_reg;
       MEMEN_dft_reg = MEMEN_dft;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 
       if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ) begin 
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
 //     else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys === X && TBYPASSsys !== 1) begin
///           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
//           Invalid_next_cycle_dft;
//        end       
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys === X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
        end 
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys !== 0 && LP_CK_gate===X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: LP FLOP Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           ScanChainX;
           ScanOutX;   
          if( TBYPASSint !== 0 && SEint !== 1) begin
            WriteOutX;
          end
          next_cycle_corrupt_dft=0;
        end        
       else if (next_cycle_corrupt_dft === 1'b1) begin 
         next_cycle_corrupt_dft = X;
       end 
       else if (next_cycle_corrupt_dft === 1'bx) begin
         next_cycle_corrupt_dft = 0;
       end
       
       if (next_cycle_corrupt_dft === 0 ) begin
         
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1 && flag_mem_block === 1'b0) begin
           
           if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0  && LP_CK_gate===0) begin
              OutReg_data_tbypass = Dint;
              for (i = 0; i < Bits; i = i + 1)
              begin
               if (OutReg_data_tbypass[i] !== OutReg_data[i])
                 OutReg_data[i] = WordX[i];
              end//for (i = 0; i < */ 
              OutReg_data <= OutReg_data_tbypass;
           end
           
             scan_acquire;
         end //MEMEN_dft == 1        
       end // if ( next_cycle_corrupt_dft
       
     end // if (CKint_dft === 1'b1
      //  if (next_cycle_corrupt_dft === 0 ) begin 
       if (SE_reg !== 0) begin
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1  && flag_mem_block === 1'b0) begin
           next_cycle_corrupt_dft = 0;
           if ( next_cycle_corrupt_func === 1) begin
	    next_cycle_corrupt_func = 0 ;
	   end	
           scan_shift;
         end
       end
     //end // if ( next_cycle_corrupt_dft    
     if ((!(TBYPASSsys!==0 && SEsys!==1 && LP_CK_gate!==0 ) && next_cycle_corrupt_dft === 0) || CKint_dft !==1) begin          
       CK_sc=INITNreg & !STDBYreg & !SLEEPreg & ATPreg & CKreg_dft ;
     end     
   end // if (init_pulse_done 
 end // if (supply_ok 
end // always @(CKint_dft)

always @(MEMEN_dft)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) && CKint_dft === 1'bx)  begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.MEMEN_dft and clock should not be X at this time instant. ScanChains and ScanOuts Corrupted ",$realtime); 
    Invalid_next_cycle_dft;
    
    if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
      WriteOutX;
    end
  end
  if ( MEMEN_dft !== 0 && TBYPASSsys !== 0 && SEsys !== 1) begin
     WriteOutX;
     OutReg_data = WordX; 
     delOutReg_data=WordX;
 end 
end
end //always @(MEMEN_dft

always @(TBYPASSsys or ATPint)
begin
   if(supply_ok === 1'b1) begin 
    if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0 && INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1) begin
      if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
    end  
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint === X && SEsys !== 1) ) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end 
end //always @(TBYPASSint





always @(SEsys)
begin
 if(supply_ok === 1'b1) begin 
  if(CKint_dft === 0 && ATPint === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
    if(SE_reg === 1'b1 && SEsys === 1'b0) begin
      if(TBYPASSsys === 1'b1) begin
          
          
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8], scanreg_dl_wire[scanlen_l-1]};  


        for (i = 0; i < Bits; i = i + 1)
        begin
         if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
        end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
      end
    end
  end
  if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0) begin
      if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
  end 
  else if ((TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint === X && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end   
end

//assign output data
`ifdef functional        

   
always @(SDLOint)
#0.001 delSDLO_data<=SDLOint;

always @(SDROint)
#0.001 delSDRO_data<=SDROint;

 
always @(SCTRLOint)
#0.001 delSCTRLO_data<=SCTRLOint;


always @(OutReg_data)
   #0.001 delOutReg_data = OutReg_data;
`else
`endif

/***************************** Embeded switch functionality starts here ***********************************/





always @(STDBYint)
begin
  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0 && STDBYint !== 1'b0)
    begin
      ScanOutX;
      ScanChainX;
     delScanOutX;     
    end
  end
end



always @(SLEEPint)
begin


  if (SLEEPint !== 1'b1) begin
    time_fall_sleep = $realtime;
  end

  if (power_up_done === 0)
    begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
    end
  else begin
    if (SLEEPint === 1'b1 && lastSLEEP === 1'b0 ) begin 
      
    end
    else if (SLEEPint !== 1'b1 && lastSLEEP === 1'b1 && full_shutdown !== 1) begin 
      
      if (supply_ok !== 1 && ($realtime > 0)) begin
         if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID LOW_POWER) ERROR: ISOLATION signal removed from the memory but array and periphery supply is not completely switched on.Very High Current would be drawn by the memory. All further operations on memory are blocked",$realtime);
          WriteMemX;
          WriteOutX;
          ScanChainX;
          OutReg_data = WordX; 
          delOutReg_data=WordX;
          ScanOutX;//immediately;
          delScanOutX;//immediately;
          init_pulse_done = 0;
          power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            debug_level = 2'b11;
          `endif
          
      end        
      
       
    end   
    else if (SLEEPint === X && lastSLEEP === 1'b0 && full_shutdown !== 1'b1) begin 
     
    end 
  end  


  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && SLEEPint !== 0)
    begin
      ScanOutX;
      ScanChainX;
        delScanOutX;      
    end
  end

// if (init_pulse_done === 0)
//   begin
//     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
//   end
//
// else if ( SLEEPint !== 1 && (supply_ok !==1) ) begin
//    
//    WriteOutX;
//    OutReg_data = WordX; 
//    delOutReg_data=WordX;
//    ScanOutX;//immediately;
//    delScanOutX;//immediately;
//    ScanChainX;
//    WriteMemX;
//    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies with sleep/Power down signal being low.This scenario can lead to high dc currents and some reliability issues Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
// end

 print_sleep;    
 lastSLEEP=SLEEPint;
end

/********************************** Embeded switch functionality ends here *******************************/

task print_sleep;
begin
  if (SLEEPint === 1'b0) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been deasserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end  
  else if (SLEEPint === 1'b1) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been asserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_ACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif

  end        
  else begin
      if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) ERROR: SLEEP pin is at an invalid state.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INVALID in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end        
end
endtask





 

//// C28SOI non flip compiler power functionality 
always @(gndmreg )
begin
 if (power_up_done === 1 && $realtime > 0) begin    
    if(gndmreg !== 1'b0 ) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or gndsm is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
        corrupt_all;
        init_pulse_done = 0;
        power_up_done = 0;
     `ifdef NO_BLOCK_MEM
     `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of ground pins.Ground must be maintained at 0 Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime);
        debug_level = 2'b11;
     `endif   

    end   
 end

end




always @(vddmareg )
begin

if (vddmareg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddma(Array Supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 
    end
   end   
   else if (SLEEPint === 1) begin
    WriteMemX;
   end

end

if ((vddmareg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1 ) && $realtime > 0) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddm or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         corrupt_all;
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif

end


end

always @(vddmpreg )
begin
 if (vddmpreg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or vddsmp is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmp(Periphery Supply)/vddsmp(Substrate power supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 

    end
   end   
   else if (SLEEPint === 1) begin
    WriteOutX;
    ScanChainX;
    ScanOutX;
    delScanOutX;//immediately;
    OutReg_data = WordX; 
    delOutReg_data=WordX;
   end
 end

if( (vddmpreg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1'b1 )  && $realtime > 0) begin
         corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif
end
 
 
end


always @(vddmoreg)
begin
  if (power_up_done === 1 && $realtime > 0) begin   
      if (vddmoreg !== 1'b1)  begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin
           corrupt_all;
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
         end //if (vddmareg === 1'b1 

      else if (vddmareg === 1'b0 && vddmpreg === 1'b0   && SLEEPint === 1'b1 &&  $realtime > 0)
        begin 
            if((debug_level < 2) && ($realtime > 0)) $display("%m - %t WARNING: Illegal Value on power pin(s). Memory and Output Corrupted ", $realtime);
 
           corrupt_all;
        end //else if (vddmareg === 1'b 
     end   // if (vddmoreg !== 1'b1)
     else if (vddmoreg === 1'b1 && $realtime > 0 ) begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin     
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           corrupt_all;
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
        end        
     end // else if (vddmoreg === 1'b1
  end 
end // always @(vddmoreg)












always @(gndmreg) begin
 if (gndmreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 0. ",$realtime);
 end
 else if (gndmreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 1. ",$realtime);
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to invalid state. ",$realtime);
 end
end




 
always @(vddmareg) begin
 if (vddmareg === 0) begin 
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 0. ",$realtime);
  vddma_fall_time = $realtime;
 end
 else if (vddmareg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 1. ",$realtime);
  vddma_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to invalid state. ",$realtime);
  vddma_fall_time = $realtime;
 end 

 

end

always @(vddmpreg) begin
 if (vddmpreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 0. ",$realtime);
  vddmp_fall_time = $realtime;
 end
 else if (vddmpreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 1. ",$realtime);
  vddmp_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to invalid state. ",$realtime);
  vddmp_fall_time = $realtime;
 end

 
 
end



// end of C28SOI power functionality 
 


assign supply_ok          =  (vddmareg === 1'b1 && vddmpreg  === 1'b1  && gndmreg === 1'b0 && vddmoreg === 1'b1 ) ? 1'b1 : 1'b0;
assign core_supply_ok     =  (vddmoreg === 1'b1 && vddmareg === 1'b1 && gndmreg === 1'b0 ) ? 1'b1 : 1'b0;
assign peri_supply_ok     =  (vddmoreg === 1'b1 && vddmpreg === 1'b1 && gndmreg === 1'b0  ) ? 1'b1 : 1'b0;

assign full_shutdown = (vddmpreg === 1'b0 && vddmareg === 1'b0   ) ? 1'b1 : 1'b0 ;




`ifdef functional
`else


task WriteLocMskX_bwise;
   input [Addr-1 : 0] Address;
   input [Bits-1 : 0] Mask;

reg [Bits+Red_extrabit:0] tempReg1;
integer num1; 
begin
   tempReg1 = WordX;
   if (^Address !== X )
   begin
      tempReg1 = Mem[Address];
             
      for (j = 0;j< Bits; j=j+1) begin
         num1=j;
        if (Mask[j] === 1'bx)
            tempReg1[num1] = 1'bx;
      end
      Mem[Address] = tempReg1;
      task_insert_faults_in_memory;
   end//if (^Address !== X
   else begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      WriteMemX;
   end   
end
endtask


/****************Actions taken on timing violations*****************/

 always @(TimingViol_data)
// tds or tdh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  for (l = 0; l < Bits; l = l + 1) begin   
    if (CSWEMTBYPASS[l] !== 0) begin
     if((TimingViol_data[l] !== TimingViol_data_last[l])) begin


         Mreg[l] = 1'bx;
     end    
     WriteLocMskX_bwise(Areg,Mreg);
    end   
   end 
  end
    if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin
     scanreg_dl =1'bx; 
     scanreg_dr =1'bx; 
     SDLOint=X;
     SDROint=X;
     `ifdef functional
     `else
     SDLO_data<=1'bx;
     SDRO_data<=1'bx;
     `endif
    end
     TimingViol_data_last = TimingViol_data; 
end





always @(TimingViol_addr)
// tas or tah
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
      scanreg_ctrl=1'bx; 
      SCTRLOint=X;
      `ifdef functional
      `else
      SCTRLO_data<=1'bx;
      `endif
  end
end


always @(TimingViol_WEN)
//tws or twh
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WEN pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end 

always @(TimingViol_CSN )
// tps or tph 
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;

   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CSN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end

always @(TimingViol_tcycle )
//tcycle
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
   if (MEMEN !== 0 && MEMEN_prev !== 0) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckl )
// tckl 
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckh) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end


always @(TimingViol_tcycle_se )
//tcycle_se
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckl_se  )
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckh_se) begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tbist) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
   end
   if (TBYPASSint !== 1'b0) begin 
    WriteOutX;
   end 
   if (INITNreg !==0 && STDBYreg !== 1 && TBYPASS_reg !== 1 && SLEEPreg !== 1 && SE_reg !== 1 && IGreg !== 1 && DEreg !== 1) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBIST pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end






always @(TimingViol_tbypass)
//ttmck
begin
#0  
  WriteOutX;
  if (INITNreg !== 0 && SLEEPreg !== 1 && SE_reg !== 1 && STDBYreg !== 1 &&  DEreg !== 1) begin
   Invalid_next_cycle_dft_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
end



always @(TimingViol_sleep)
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_stdby)
begin
#0
  if (CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin 
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (ATPreg !== 0) begin 
   Invalid_next_cycle_dft_tim;
  end
end






always @(TimingViol_se) begin
#0
   if (TBYPASS_reg !== 0) begin 
    WriteOutX;
   end 
  if (TBYPASS_reg === 0) begin
     WriteOutX;
     WriteMemX;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE timing violation  Memory State Machine is corrupted. Output Corrupted ",$realtime); 
  end 
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
  end
end

always @(TimingViol_sctrli) begin
  scanreg_ctrl=1'bx; 
end


always @(TimingViol_sdli) begin
 scanreg_dl=1'bx; 
end

always @(TimingViol_sdri) begin
   scanreg_dr=1'bx;
end

 

always @(TimingViol_initnl) begin
init_pulse_done=0;
WriteOutX;
OutReg_data = WordX; 
delOutReg_data=WordX;
ScanOutX;
delScanOutX;
ScanChainX;
WriteMemX;
end

always @(TimingViol_initn) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end

always @(TimingViol_ig) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && INITNreg !== 0 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: IG pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   ScanChainX;
   ScanOutX;
   delScanOutX;       
  end
end

always @(TimingViol_atp) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin  
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_rm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^WMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: RM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
   end
end
 
always @(TimingViol_wm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^RMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);        
   end
end 


`endif


endmodule




module ST_SPREG_LOLEAK_512x20m2_Tl_lock_up_latch (EN,D,Q);
input EN,D;
output reg Q;

  always @ (EN or D) begin
    if (EN === 1) begin
       Q = D;
    end
    else if ((EN === 1'bz || EN === 1'bx  )&& D !== Q) begin
        Q=1'bx;
    end    
  end
endmodule

module ST_SPREG_LOLEAK_512x20m2_Tl_SCFF (D,TI,TE,CP,Q,OUTX);
input D,TI,TE,CP;
input OUTX;
output reg Q;
wire Dint;
assign Dint= (TE===1)?TI:(TE===0)?D:1'bx;

always @(posedge CP)
        begin
          if(Dint === 1'bZ || CP ===1'bx || OUTX === 1'bx)
          begin
                  Q = 1'bx;
          end
          else
          begin
                  Q = Dint;
          end        
        end
always @(posedge OUTX)
Q = 1'bx;
endmodule



`undef setup_time
`undef hold_time
`undef access_time
`undef retain_time
`undef cycle_time
`undef pulse_width_time
`undef initin_low_pulse


`delay_mode_path
`endcelldefine
`nosuppress_faults






/****************************************************************
--  Description         : Verilog Model 
--  ModelVersion        : 1.2
--  Date                : Apr, 2013
--  Changes Made by	: PS
--  Revision History    : 
 
****************************************************************/


/******************** START OF HEADER****************************
   This Header Gives Information about the parameters & options present in the Model
   
   words = 512
   bits  = 20
   mux   = 4 
   
   
   
   write_mask = no 
   
   margin_control = yes 
   
   
   Dft = Yes  

    ------------------------------------------------------------------------------------
     Signal Name             | Description       |             Port Mode        | Active When
                             |                   |          r    |  w   | rw    |
   ------------------------------------------------------------------------------------

    D 	        Data in                     na     x      na       -  
    IG    Input Gate Enable           x      x      na       High     
    ATP            ATPG Enable                 x      x      na       High     
    INITN                 INITN pin                   x      x      na       Low
    
    
     
    Q 	        Data out	            x      na     na       -
    A              Address                     x      x      na       high and low
    
    CK                Clock	                    x      x      na       posedge
    CSN          Chip Enable                 x      x      na       low
    
    RM         Read Margins                 x      x      na       High 
    SCTRLI         Scan Input (Control)
    SCTRLO        Scan Output (Control)
    SDLI         Scan Input (Data-Left)
    SDLO        Scan Output (Data-Left)
    SDRI         Scan Input (Data-Right)
    SDRO        Scan Output (Data-Right)
    SE          Scan Enable pin 
    STDBY              Standby pin                 x      x      na       High
    
    SLEEP                        Sleep pin                   x      x      na        High 
    
     
     
    TBIST          Bist Enable Pin 
    
    TBYPASS                      Memory Bypass                na     na     na        High
    
    TED        Bist Even Data pin
    TOD         Bist Odd Data Pin
     
    TA         Bist Read Address
    TCSN     Bist Read Chip Select
    
    TWEN    Bist Write Enable 
    WEN         Write Enable                na     x      na       Low 
    
    WM        Write Margins Code          x      x      na       -
     

******************** END OF HEADER ****************************/


//********************************************//
// ST_SPREG_LOLEAK_512x20m4_Tl Verilog Model                 //  
//********************************************//




`ifdef slm
        `define functional
`endif

`celldefine
`suppress_faults
  `ifdef functional
   `delay_mode_unit
  `else
   `delay_mode_path
  `endif

`define setup_time 0.0
`define hold_time 0.0
`define access_time 1.0
`define retain_time 0.9
`define cycle_time 0.0
`define pulse_width_time 0.0
`define initin_low_pulse 0.0



 






`timescale 1ns / 1ps


module ST_SPREG_LOLEAK_512x20m4_Tl (A,ATP,CK,CSN,D ,IG,INITN , Q ,RM    ,SCTRLI,SCTRLO,SDLI,SDLO,SDRI,SDRO,SE,SLEEP   , STDBY  ,TA,TBIST   ,TBYPASS ,TCSN,TED ,TOD   ,TWEN ,WEN,WM  );

 parameter
  Words = 512,
  Bits = 20,
  Addr = 9,
  mux = 4,
  repair_address_width = 7,
  write_margin_size = 2, 
  read_margin_size = 3; 

 //  INPUT OUTPUT PORTS DECLARATION DONE SEPARATELY FOR SPREG and ROM
 // ========================


        output [Bits-1 : 0] Q;
         
        output SCTRLO;
        input SE,SCTRLI;
        
        input [Addr-1 : 0] A;
        
        input [read_margin_size-1 : 0] RM;
        
         
        input CK,CSN,INITN,IG,ATP; 
        
        
        input [Addr-1 :0 ] TA;
input TBIST,TCSN ;
        
        input STDBY;
        
        input SLEEP; 
        
         
        
        
         
        output SDLO;
        output SDRO;
        
        
        
        
        input [Bits-1 : 0] D ;
	
          
         
        
        input [write_margin_size-1 : 0] WM;
        
        
        input TBYPASS;
        
        input WEN;
        
        
         
        input SDLI,SDRI  ; 
        
        
        
        //Bist inputs
        // ===========
        input TWEN,TED,TOD; 
        
        
        
        

        






    parameter
        Fault_file_name = "ST_SPREG_LOLEAK_512x20m4_Tl_faults.txt",
        `ifdef ConfigFault
        ConfigFault = 1,
        `else
        ConfigFault = 0,
        `endif
        max_faults = 514,
        
        MEM_INITIALIZE  = 1'b0,
        BinaryInit = 1'b0, 
        InitFileName = "ST_SPREG_LOLEAK_512x20m4_Tl.cde",
        Debug_mode = "all_warning_mode",
        File_load_time=0,
        Initn_reset_value={20{1'b0}},
        InstancePath = "ST_SPREG_LOLEAK_512x20m4_Tl";
    
    parameter
        
        bank = 1, 
        mux_bits=2,
        Red_extrabit=0,
        bank_bits = 0,
        RedWords = mux * 2 * bank,
        max_address_bits = 15 ,
        Rows = Words/mux;

  
    parameter 

     

        
           scanchains=3,    
          
        
        scanlen_ctrl=15,
        
        

      

        
        scanlen_r=(Bits)/2,
        
        scanlen_l=(Bits+1)/2 ; 
      
      

    parameter
        
        `ifdef functional  
            RW_assertions_en = 0,
        `endif
        WordX = {Bits{1'bx}},
        AddrX = {Addr{1'bx}},
        Word0 = {Bits{1'b0}},
        X = 1'bx;
   



//  WIRE DECLARATION RELATED TO POWER PINS
//  ======================================
	
        wire supply_ok, full_shutdown;
        
        wire core_supply_ok;
        wire peri_supply_ok;

        wire gndmint, gndsmint;
         
        
        wire vddmpint;
        wire vddmoint;
        wire vddmaint;
        wire vddsmpint;  
        wire vddsmaint;  
        
        

//  WIRE DECLARATION 
//  ==================
        wire [Bits-1 : 0] CSWEMTBYPASS;
        wire [Bits-1 : 0] Dint, Dsys;
        wire [Bits-1 : 0] Mint; 
        wire [20-1:0] Msys;
	wire [Addr-1 : 0] Aint;
        wire [Addr-1 : 0] Asys;

       


        wire [max_address_bits-1 : 0] A_int; 
                
	wire CKint_dft;
	wire CKint_func;
	wire CSNint;
        wire MEMEN;
        wire MEMEN_dft;
        wire TSE;

	wire WENint;
	wire WENsys;
        wire SLEEPint;
        wire STDBYint;
        wire SEint;
        wire SEsys;
        wire SCTRLIint;
        wire SDLIint;
        wire SDRIint;
        
        wire INITNint;
        wire TBYPASSint;
        wire TBYPASSsys;
        wire LSint; 
        wire HSint; 
        wire ATPint;
        wire DEint;
        
        wire [Addr-1 : 0] TAint;
        wire TBISTint;
        wire TBISTsys;
        wire TCSNint;
        wire TEDint;
        wire TODint;
        wire TEMint;
        wire TOMint;
        wire [Bits-1 : 0] TMint;
        wire [Bits-1 : 0] TDint;
        wire TWENint;
        wire IGint;
        wire IGbuf;
        wire CSNbuf;
        wire WENbuf;
        wire [read_margin_size-1:0] RMint;
        wire [write_margin_size-1:0] WMint;

        //Wires for scan chains
        //  ====================     
        wire [scanlen_ctrl -1:0]scanreg_ctrl_wire;
        wire [scanlen_l -1:0]  scanreg_dl_wire; 
        wire [scanlen_r -1:0]  scanreg_dr_wire; 
   
        wire [scanlen_l -1:0]  scanreg_ml_wire; 
        wire [scanlen_r -1:0]  scanreg_mr_wire; 


        wire [repair_address_width -1 : 0] RRAint;
        wire RRAEint;
        wire TRRAEint;    
        wire red_en;
        wire [repair_address_width -1 : 0] repair_add, next_repair_add;


//  REG DECLARATION
//  ====================     
        reg MEMEN_reg;
        reg MEMEN_prev;
        reg reg_mem_block;
        reg flag_mem_block;
        reg SCTRLIint_temp;
        reg SDLIint_temp;
        reg SDRIint_temp;
        reg SMLIint_temp;
        reg SMRIint_temp;

        //  REG DECLARATION
        //  ====================
        reg SCTRLOint;
        
        reg SDLOint,SDROint;
         
        
        reg next_cycle_corrupt_func;
        reg next_cycle_corrupt_dft;
        reg [Bits-1 : 0] delOutReg_data;//delayed Output Register
        reg [Bits-1 : 0] OutReg_data;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_tbypass;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_scan;   // Data Output registe
        reg [Bits-1 : 0] OutReg_rado_retained;   // register for retaining rado data when SLEEP --> 1
        reg delSCTRLO_data,SCTRLO_data;      // delayed Output Register
        reg delSDLO_data,SDLO_data;      // delayed Output Register
        reg delSDRO_data,SDRO_data;      // delayed Output Register
        
        
        // SCAN CHAINS register
        reg scanreg_ctrl; 
        reg scanreg_dl; 
        reg scanreg_dr; 
        
        
        reg CK_sc;
        reg Latch_open=0;
        reg lastCK_dft,CKreg_dft;
        reg lastCK_func,CKreg_func;
        reg lastSLEEP;
        reg lastPSWLARGEMP,lastPSWLARGEMA,lastPSWSMALLMP,lastPSWSMALLMA;
        reg CSNreg;
        reg init_pulse_done; //if == 1 then it implies that initb low pulse has been applied
        reg power_up_done; //if == 1 then it implies that power up has been done
        `ifdef slm
        `else
	      
             reg [Bits-1 : 0] Mem [Words-1 : 0];
             reg [Bits-1 : 0] RedMem [RedWords-1 : 0];
 
        `endif
        
	reg [Bits-1 :0] Mem_temp;
        reg [Bits-1 :0] Mem_slm; 
	reg ValidAddress;
	reg ValidDebugCode;
        reg decoding_start;
        reg file_loaded;
        reg [Bits-1 :0] Dreg;
        reg [Bits-1 :0] Mreg;
        reg WENreg;
        reg [Addr-1 :0] Areg;
        reg SE_reg;
        reg TBYPASS_reg;
        reg INITNreg;
        reg IGreg;
        reg DEreg;
        reg SLEEPreg;
        reg STDBYreg;
        reg ATPreg;
        reg MEMEN_dft_reg;
        reg MEMEN_dft_prev;
        reg RRMATCHreg;
        reg RRMATCHreg_last;//changes_made
        reg RRMATCHreg_glitch;
        reg [repair_address_width -1 : 0] repair_add_last;
        reg RRAEint_last;
        reg [Addr-mux_bits-1:0] row_add_temp;
        reg [Addr-mux_bits-bank_bits-1:0] row_add_cmp_temp;

       
        //parameter registers
        reg [2047:0] reg_Fault_file_name;
        reg reg_ConfigFault;
        reg reg_MEM_INITIALIZE;
        reg reg_BinaryInit;
        reg [2047:0] reg_InitFileName;
        reg [Bits -1 :0] reg_Initn_reset_value;
        time reg_File_load_time;

        //Power Supply Registers        
        reg vddmireg;
        reg vddmreg;
        reg vddsmreg;
        reg gndmreg;
        reg gndsmreg;   
        reg vddmpreg;
        reg vddmpireg;
        reg vddmareg;
        reg vddsmpreg;
        reg vddsmareg;
        reg vddmoreg;
        time vddmp_rise_time;
        time vddmp_fall_time;
        time vddsmp_rise_time;
        time vddsmp_fall_time;
        time vddma_rise_time;
        time vddma_fall_time;
        time vddsma_rise_time;
        time vddsma_fall_time;
        reg reg_check_rise;
        reg reg_check_fall;
        reg reg_check_rise_vddma;
        reg reg_check_fall_vddsma;
        reg  reg_check_rise_vddm, reg_check_fall_vddsm ;
        time vddm_fall_time,  vddm_rise_time,  vddsm_fall_time, vddsm_rise_time ;
  /* This register is used to force all warning messages 
  ** OFF during run time.
  ** It is a 2 bit register.
  ** USAGE :
  ** debug_level_off = 2'b00 -> ALL MESSAGES(INFO/WARNINGS/ERRORS) will be DISPLAYED 
  ** debug_level = 2'b01     -> ONLY WARNINGS/ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b10     -> ONLY ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b11     -> NO MESSAGES will be DISPLAYED.
  */ 
        reg [1:0] debug_level;
        reg [8*10: 0] operating_mode;
        reg [8*44: 0] message_status;

        integer i, k, j, l,m,q,w,r,s,num1,redcnt,n,num2,FirstHalf,Bfaileff,memcnt,ptr;
        integer decoder[Bits-1:0];
        `ifdef slm
           integer MemAddr;
        `endif


        //************************************************************
        //****** CONFIG FAULT IMPLEMENTATION VARIABLES*************** 
        //************************************************************ 

        integer file_ptr, ret_val;
        integer fault_word;
        integer fault_bit;
        integer fcnt, Fault_in_memory,faultnum,stop_loop,count;
        integer t;  
        integer FailureLocn [max_faults -1 :0];
        integer Failurebit [max_faults -1 :0];
        reg [100 : 0] stuck_at;
        reg [100 : 0] fault_array;
        reg [200 : 0] tempStr;
        reg [7:0] fault_char;
        reg [7:0] fault_char1; // 8 Bit File Pointer
        reg [Addr -1 : 0] std_fault_word;
        reg [Addr -1 : mux_bits] fault_row_add [max_faults -1 :0];
        reg [max_faults -1 :0] fault_repair_flag;
        reg [max_faults -1 :0] dont_insert_fault;
        reg [max_faults -1 :0] repair_flag;
        reg [100 : 0] array_stuck_at[max_faults -1 : 0] ;
        reg [100 : 0] mem_red_array_stuck_at[max_faults -1 : 0] ; 
        reg msgcnt;
        
       
        reg [Bits - 1: 0] stuck_at_0fault [max_faults -1 : 0];
        reg [Bits - 1: 0] stuck_at_1fault [max_faults -1 : 0];
        reg [Bits -1 : 0] stuck0;
        reg [Bits -1 : 0] stuck1;

        reg [Bits+Red_extrabit :0] Mem_last;
        

        `ifdef slm
        reg [Bits -1 : 0] slm_temp_data;
        `endif
        
        real time_CK_func_rise , time_RADCK_rise;
        real time_fall_sleep,time_fall_PSWLARGEMP,time_fall_PSWLARGEMP_0,time_fall_PSWLARGEMA,time_fall_PSWLARGEMA_0,time_fall_PSWSMALLMP,time_fall_PSWSMALLMA;
        integer flag_error;
        
//BUFFER INSTANTIATION
//=========================
       `ifdef functional
       
         buf (SCTRLO,delSCTRLO_data); 
         buf bufq [Bits-1:0] (Q,delOutReg_data);
      `else
       
         buf (SCTRLO,SCTRLO_data);
         buf bufq [Bits-1:0] (Q,OutReg_data);
      `endif
      
  
        buf (SEsys,SE);
	buf (SCTRLIint, SCTRLI);
   

	buf (CKint_func, CK);
	buf (CKint_dft, CK);
        buf bufaddr [Addr-1:0] (Asys,A);
        buf (INITNint,INITN);
        
        buf (LSint,1'b0); 
        buf (IGbuf,IG);
        buf (ATPint,ATP);

        buf bufTaddr [Addr-1 : 0] (TAint,TA);
        buf (TBISTsys,TBIST);
        buf (TCSNint,TCSN);

        buf (CSNsys,CSN);
        buf (STDBYint,STDBY );   
        
        buf (SLEEPint,SLEEP ); 

        buf bufrm [read_margin_size-1:0] (RMint, RM); 

        
        

        assign RRAEint = 1'b0;
        assign TRRAEint = 1'b0;
        assign repair_add = 0;
        assign next_repair_add = 0;
        assign red_en = 1'b0; 
        
        
        
        
        
        
        
        buf (PSWLARGEMPint,1'b0);
        buf (PSWSMALLMPint,1'b0); 
        buf (PSWLARGEMAint,1'b0);
        buf (PSWSMALLMAint,1'b0);   

      `ifdef functional
       
       
         buf (SDLO,delSDLO_data);
         buf (SDRO,delSDRO_data);
        
      `else
       
         buf (SDLO,SDLO_data);
         buf (SDRO,SDRO_data);
         
      `endif
       
         
       
        buf bufdata [Bits-1:0] (Dsys,D);
        
        
        assign Msys=20'b0; 
	

        
        buf (TBYPASSsys, TBYPASS);
        


        buf (WENsys,WEN);
	 
	buf (SDLIint, SDLI);
	buf (SDRIint, SDRI);
	 
        
        buf (HSint,1'b0); 

        
        buf (TEDint,TED);
        buf (TODint,TOD);
         
        buf (TWENint,TWEN);
        
        
        buf bufwm [write_margin_size-1:0] (WMint, WM); 
        



//      assign scanreg_ctrl_wire={scanreg_ctrl[scanlen_ctrl - 2:0],SCTRLIint};
//      assign scanreg_dl_wire={scanreg_dl[scanlen_l - 2:0],SDLIint};
//      assign scanreg_dr_wire={scanreg_dr[scanlen_r - 2:0],SDRIint};
      
        
      assign Aint   = (TBISTint === 1'b0 ) ? Asys : (TBISTint === 1'bx ) ? {Addr{1'bx}} : TAint;  

        
//        assign A_int = Aint;
	
        
                
        assign Dint[0] = (TBISTint === 1'b0) ? Dsys[0] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[1] = (TBISTint === 1'b0) ? Dsys[1] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[2] = (TBISTint === 1'b0) ? Dsys[2] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[3] = (TBISTint === 1'b0) ? Dsys[3] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[4] = (TBISTint === 1'b0) ? Dsys[4] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[5] = (TBISTint === 1'b0) ? Dsys[5] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[6] = (TBISTint === 1'b0) ? Dsys[6] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[7] = (TBISTint === 1'b0) ? Dsys[7] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[8] = (TBISTint === 1'b0) ? Dsys[8] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[9] = (TBISTint === 1'b0) ? Dsys[9] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[10] = (TBISTint === 1'b0) ? Dsys[10] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[11] = (TBISTint === 1'b0) ? Dsys[11] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[12] = (TBISTint === 1'b0) ? Dsys[12] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[13] = (TBISTint === 1'b0) ? Dsys[13] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[14] = (TBISTint === 1'b0) ? Dsys[14] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[15] = (TBISTint === 1'b0) ? Dsys[15] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[16] = (TBISTint === 1'b0) ? Dsys[16] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[17] = (TBISTint === 1'b0) ? Dsys[17] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[18] = (TBISTint === 1'b0) ? Dsys[18] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[19] = (TBISTint === 1'b0) ? Dsys[19] : (TBISTint === 1'b1) ? TODint : 1'bx;          
	 
        assign Mint = 20'b0;
         

        assign WENbuf = (TBISTint === 1'b0 ) ? WENsys : (TBISTint === 1'bx ) ? 1'bx : TWENint;  
        assign WENint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? WENbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[13] : (ATPint === 1'b0 ) ? WENsys : 1'bx ; 
        
        assign CSNbuf = (TBISTint === 1'b0 ) ? CSNsys : (TBISTint === 1'bx ) ? 1'bx : TCSNint;  
        assign CSNint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? CSNbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[11] : (ATPint === 1'b0 ) ? CSNsys : 1'bx ; 
        assign IGint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? IGbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[14] : (ATPint === 1'b0 ) ? IGbuf : 1'bx;

        
        assign DEint = (LSint === 1'bx || (LSint === 1'b0 && HSint === 1'bx) || ^RMint !== 1'b0 || ^WMint !== 1'b0 ) ? 1'bx : 1'b0;
        
     
     and (TBISTint, ATPint, TBISTsys);
     and (SEint, ATPint, SEsys);
     and (TBYPASSint, ATPint, TBYPASSsys);
     and (TSE,TBYPASSint,!SEsys);
     and (MEMEN,INITNint,!CSNint,!SLEEPint,!TBYPASSint,!SEint,!IGint,!DEint,!STDBYint );
     and (MEMEN_dft,INITNint, !SLEEPint, ATPint,!STDBYint);

 `ifdef functional
/*****************assertions added to optimize dynamic power consumption**********/

//psl a_M: assert always ({( RW_assertions_en);(MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1))  } |-> (stable(Msys))) @(posedge CK); 

//psl a_WEN: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(WENsys))) @(posedge CK); 

//psl a_A: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(Asys))) @(posedge CK); 

//psl a_D: assert always ({( RW_assertions_en);((MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1)) && TBYPASSint === 1'b0)  } |-> (stable(Dsys))) @(posedge CK); 

/**********************************************************************************************/
`endif       

     

         
reg vddmp,vddmo, vddma, vddsmp, vddsma, gndsm, gndm,  vddmpi ; 
 
initial 
begin

        vddmp = 1'b1 ; 
        vddmo = 1'b1 ;
        vddma = 1'b1 ;
        
        vddsmp = 1'b1 ;
        
        
         gndm = 1'b0 ;
          
end

        
         assign gndmint = (reg_mem_block === 0) ? gndm : 1'b1;
         
         
         
         
         assign vddmpint = vddmp;
         assign vddmoint = vddmo;
         assign vddmaint = vddma;
         
          
        
         

        //CPF Changes

        
                
        initial
        begin : cpfvddmp 
           vddmpreg = vddmpint;
        end

        always @(vddmpint) begin
           vddmpreg = vddmpint;
        end
        
        initial
        begin : cpfvddmo 
           vddmoreg = vddmoint;
        end

        always @(vddmoint) begin
           vddmoreg = vddmoint;
        end
        
        initial
        begin : cpfvddma 
           vddmareg = vddmaint;
        end

        always @(vddmaint) begin
           vddmareg = vddmaint;
        end

        
        
 
        initial
        begin : cpfgndm 
           gndmreg = gndmint;
        end

        always @(gndmint) begin
           gndmreg = gndmint;
        end

        
        



 `ifdef functional
  `else
  initial begin
    if (debug_level < 1) begin
     $display ("%m  INFORMATION");
     $display ("***************************************");
     $display ("The Model is Operating in TIMING MODE");
     $display ("Please make sure that SDF is properly annotated otherwise dummy values will be used");
     $display ("%s", message_status);
     $display ("***************************************");
    end
  end

//////////////////////////
 //REG DECLARATIONS
   //======================

   reg [Bits-1 : 0] TimingViol_data;
   reg  [Bits-1 : 0] TimingViol_mask;
   reg [Bits-1 : 0] TimingViol_data_last, TimingViol_mask_last;
	reg TimingViol_data_0;
	reg TimingViol_data_1;
	reg TimingViol_data_2;
	reg TimingViol_data_3;
	reg TimingViol_data_4;
	reg TimingViol_data_5;
	reg TimingViol_data_6;
	reg TimingViol_data_7;
	reg TimingViol_data_8;
	reg TimingViol_data_9;
	reg TimingViol_data_10;
	reg TimingViol_data_11;
	reg TimingViol_data_12;
	reg TimingViol_data_13;
	reg TimingViol_data_14;
	reg TimingViol_data_15;
	reg TimingViol_data_16;
	reg TimingViol_data_17;
	reg TimingViol_data_18;
	reg TimingViol_data_19;
 reg TimingViol_mask_0;
 reg TimingViol_mask_1;
 reg TimingViol_mask_2;
 reg TimingViol_mask_3;
 reg TimingViol_mask_4;
 reg TimingViol_mask_5;
 reg TimingViol_mask_6;
 reg TimingViol_mask_7;
 reg TimingViol_mask_8;
 reg TimingViol_mask_9;
 reg TimingViol_mask_10;
 reg TimingViol_mask_11;
 reg TimingViol_mask_12;
 reg TimingViol_mask_13;
 reg TimingViol_mask_14;
 reg TimingViol_mask_15;
 reg TimingViol_mask_16;
 reg TimingViol_mask_17;
 reg TimingViol_mask_18;
 reg TimingViol_mask_19;

   reg TimingViol_addr;
   reg TimingViol_CSN, TimingViol_WEN, TimingViol_tbypass;
   reg TimingViol_tckh, TimingViol_tckl, TimingViol_tcycle;
   reg TimingViol_tckh_se, TimingViol_tckl_se, TimingViol_tcycle_se;
   reg TimingViol_sctrli,TimingViol_sdli,TimingViol_sdri,TimingViol_se;
   reg TimingViol_smli,TimingViol_smri;
   reg TimingViol_sctrli_flag,TimingViol_sdli_flag,TimingViol_sdri_flag;
   reg TimingViol_smli_flag,TimingViol_smri_flag;
   reg TimingViol_initnl;
   reg TimingViol_initn;
   reg TimingViol_ls;
   reg TimingViol_hs;
   reg TimingViol_sleep;
   reg TimingViol_stdby;
   reg TimingViol_rm;
   reg TimingViol_wm;
   reg TimingViol_tbist,TimingViol_ig,TimingViol_atp,TimingViol_TED,TimingViol_TOD,TimingViol_TEM,TimingViol_TOM;
   reg TimingViolRRAE,TimingViolRRA;

   wire CSTBYPASSN,cond_sdf_tas,cond_sdf_tds,cond_sdf_tms,cond_sdf_tws,cond_sdf_tbas,cond_sdf_tbps,cond_sdf_tbws,cond_sdf_tbdes,cond_sdf_tbdos,cond_sdf_tbmes,cond_sdf_tbmos;
   wire SETB_EN,CSIG_EN,MEM_ACT,EN_ADM,CS_EN,CS_ADM,cond_sdf_tps,IG_EN,IG_ADM,cond_sdf_tigs,cond_sdf_taa,cond_sdf_taa_ls1,cond_sdf_taa_hs1,cond_tseq_tm;
   wire cond_sdf_tcycle,cond_sdf_tcycle_ls1,cond_sdf_tcycle_hs1,cond_sdf_tcycle_se,cond_sdf_tckl_se,cond_sdf_tsctrlis,cond_sdf_tsdlis,cond_sdf_tsdris,cond_sdf_tsmlis,cond_sdf_tsmris;
   wire cond_sdf_tckh_se,cond_sdf_taa_sctrlo_se,cond_sdf_taa_sdlo_se,cond_sdf_taa_sdro_se,cond_sdf_taa_smlo_se,cond_sdf_taa_smro_se,cond_sdf_tckl,cond_sdf_tckh;
   wire cond_sdf_ttms,cond_sdf_tbists,INITNandnotSLEEPandATPandnotSE,cond_sdf_taa_sctrlo,cond_sdf_taa_sdlo,cond_sdf_taa_sdro,cond_sdf_taa_smlo,cond_sdf_taa_smro;
   wire cond_sdf_taa_tm,cond_sdf_taa_tm_ls1, cond_sdf_taa_tm_hs1,cond_sdf_taa_tckq_tm,cond_sdf_taa_tseq_tm;

   wire CSWETBYPASSN;
   wire cond_sdf_tstdbys,cond_sdf_tsls,sleep_en,atp_csn_en;
   wire cond_sdf_tlss,cond_sdf_thss,cond_sdf_trms,cond_sdf_twms; 
   wire cond_sdf_tses,cond_sdf_tinitns;
   wire tby_se_en;
   wire rra_en;
   wire tbist_atp_en;
   wire rrae_en;
   wire tbist_rrae_en;
   wire cond_sdf_trraes;
   wire cond_sdf_ttrraes;
   wire cond_sdf_taa_trramatch;
   wire cond_sdf_ttrraematch;
   wire cond_sdf_tamatch;
   wire cond_sdf_ttamatch;
   wire cond_sdf_tatpmatch;
   wire cond_sdf_ttbistmatch;



 and (CSWEMTBYPASS[0], !Mreg[0], CSWETBYPASSN);
 and (CSWEMTBYPASS[1], !Mreg[1], CSWETBYPASSN);
 and (CSWEMTBYPASS[2], !Mreg[2], CSWETBYPASSN);
 and (CSWEMTBYPASS[3], !Mreg[3], CSWETBYPASSN);
 and (CSWEMTBYPASS[4], !Mreg[4], CSWETBYPASSN);
 and (CSWEMTBYPASS[5], !Mreg[5], CSWETBYPASSN);
 and (CSWEMTBYPASS[6], !Mreg[6], CSWETBYPASSN);
 and (CSWEMTBYPASS[7], !Mreg[7], CSWETBYPASSN);
 and (CSWEMTBYPASS[8], !Mreg[8], CSWETBYPASSN);
 and (CSWEMTBYPASS[9], !Mreg[9], CSWETBYPASSN);
 and (CSWEMTBYPASS[10], !Mreg[10], CSWETBYPASSN);
 and (CSWEMTBYPASS[11], !Mreg[11], CSWETBYPASSN);
 and (CSWEMTBYPASS[12], !Mreg[12], CSWETBYPASSN);
 and (CSWEMTBYPASS[13], !Mreg[13], CSWETBYPASSN);
 and (CSWEMTBYPASS[14], !Mreg[14], CSWETBYPASSN);
 and (CSWEMTBYPASS[15], !Mreg[15], CSWETBYPASSN);
 and (CSWEMTBYPASS[16], !Mreg[16], CSWETBYPASSN);
 and (CSWEMTBYPASS[17], !Mreg[17], CSWETBYPASSN);
 and (CSWEMTBYPASS[18], !Mreg[18], CSWETBYPASSN);
 and (CSWEMTBYPASS[19], !Mreg[19], CSWETBYPASSN);

and (atp_csn_en,!ATPint,!CSNint,!IGint);
or (sleep_en,atp_csn_en,ATPint);
or (SETB_EN,SEint,TBISTint);
and (ATP_SETB_EN,ATPint,SETB_EN); 
or (CSIG_EN,IGint,CSNint);
and (MEM_ACT,!ATPint,CSIG_EN);
or (EN_ADM,MEM_ACT,ATP_SETB_EN);
and (CS_EN,!ATPint,IGint);
or (CS_ADM,CS_EN,ATP_SETB_EN);
and (atp_ig_csn_en,!ATPint,!CSNint,!IGint);
and (atp_se_en,!SEsys,ATPint);
or (cycle_en,atp_ig_csn_en,atp_se_en);
and (atp_ig_csn_en_reg,!ATPreg,!CSNreg,!IGreg);
and (atp_se_en_reg,!SE_reg,ATPreg);
or (cycle_en_reg,atp_ig_csn_en,atp_se_en);
and (INITNandnotSLEEPandATPandnotSE,cond_gac,!SEsys,ATPint);
and (csn_ig_en,!IGint,!CSNint);
and (atp_tby_ls_en,atp_se_en,cond_ls_tby_en);
and (IG_EN,!ATPint,!CSNint);
or (IG_ADM,IG_EN,atp_se_en);
and (CSWETBYPASSN, !WENreg, 1'b1);



assign cond_sdf_tsls=((sleep_en && INITNint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tstdbys=((sleep_en && INITNint && !SLEEPint) !==0) ? 1:0;
assign cond_sdf_atps=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_gac=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tas=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tds=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tms=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tws=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tps=((cond_gac && !CS_ADM) !==0) ? 1:0;
assign cond_sdf_tcycle=((cond_gac && cycle_en && !LSint && !HSint) !==0) ? 1:0;  
assign cond_sdf_tcycle_ls1=((cond_gac && cycle_en && LSint) !==0) ? 1:0;
assign cond_sdf_tcycle_hs1=((cond_gac && cycle_en && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_tckh=((cond_gac && cycle_en_reg) !==0) ? 1:0;
assign cond_sdf_tckl=((cond_gac && cycle_en) !==0) ? 1:0;
assign cond_sdf_tcycle_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckl_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsctrlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckh_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_ttms=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_tbists=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_tckq_tm=((cond_gac && SE_reg && ATPreg && TBYPASSsys) !==0) ? 1:0;
assign cond_ls_en=((atp_ig_csn_en || atp_tby_ls_en) !==0) ? 1:0;
assign cond_sdf_tlss=((cond_ls_en && cond_gac) !==0) ? 1:0;
assign cond_sdf_thss=((cond_ls_en && cond_gac && !LSint) !==0) ? 1:0;
assign cond_sdf_trms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_twms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_tses=((cond_gac && ATPint) !==0) ? 1:0;
assign cond_sdf_tbas=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbps=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbws=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tigs=((cond_gac && IG_ADM) !==0) ? 1:0;
assign cond_sdf_taa=((MEMEN_reg && WENreg && !LSint && !HSint) !==0) ? 1:0; 
// assign cond_sdf_taa_tbypass_q = ((MEMEN_reg && ATPint && TBYPASSint) !== 1'b0) ? 1'b1 : 1'b0;
assign cond_sdf_taa_ls1=((MEMEN_reg && WENreg && LSint) !==0) ? 1:0; 
assign cond_sdf_taa_hs1=((MEMEN_reg && WENreg && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && !HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_ls1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && LSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_hs1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tseq_tm=((cond_gac && TBYPASSint) !==0) ? 1:0;
assign cond_sdf_tinitns =(( sleep_en && !STDBYint && !SLEEPint) !==0) ? 1:0;
assign cond_ls_tby_en=((TBYPASSsys || csn_ig_en) !==0) ? 1:0;



//specify block begins

specify
    specparam
    
         PATHPULSE$CK$Q = 0,
         PATHPULSE$CK$SCTRLO = 0,

         PATHPULSE$CK$SDLO = 0,
         PATHPULSE$CK$SDRO = 0,
        
         PATHPULSE$SE$Q = 0,
         
//         PATHPULSE$TBYPASS$Q = 0,


        
         
        
         tsls = `setup_time,
         tslh = `hold_time ,
         tstdbys = `setup_time,
         tstdbyh = `hold_time , 
	 

         
         tcycle = `cycle_time,
         
         
         tckh = `pulse_width_time,
         tckl = `pulse_width_time,
         tcycle_se = `cycle_time,
         tckh_se = `pulse_width_time,
         tckl_se = `pulse_width_time,
         
         ttms = `setup_time,
         ttmh = `hold_time ,
         tps = `setup_time,
         tph = `hold_time ,
         tws = `setup_time,
         twh = `hold_time ,
         tds = `setup_time,
         tdh = `hold_time , 
         tas = `setup_time,
         tah = `hold_time ,
         tses= `setup_time,
         tseh= `hold_time ,
         tsctrlis=`setup_time,
         tsctrlih=`hold_time ,
         tsdlis=`setup_time,
         tsdlih=`hold_time ,
         tsdris=`setup_time,
         tsdrih=`hold_time , 
         tbists=`setup_time,
         tbisth=`hold_time ,
         tbps=`setup_time,
         tbph=`hold_time ,
         tbws=`setup_time,
         tbwh=`hold_time ,
         tbdes=`setup_time,
         tbdeh=`hold_time ,
         tbdos=`setup_time,
         tbdoh=`hold_time ,
         
         tbas=`setup_time,
         tbah=`hold_time ,
         tinitnl=`initin_low_pulse,
         tinitns=`setup_time,
         tinitnh=`hold_time ,
         tatps=`setup_time,
         tatph=`hold_time ,
         tigs=`setup_time,
         tigh=`hold_time ,
         
         
         trms=`setup_time,
         trmh=`hold_time ,
         twms=`setup_time,
         twmh=`hold_time , 

/*************************************************************************************************/
           // taa_tbypass_q = `access_time,
           // th_tbypass_q  = `retain_time,
            taa =`access_time,
            th = `retain_time,

 


            taa_tm =`access_time,
            th_tm = `retain_time,

            
            taa_tseq_tm =`access_time,
            th_tseq_tm = `retain_time,
            taa_tckq_tm   = `access_time,
            th_tckq_tm    = `retain_time,
            taa_sctrlo=`access_time,
            th_sctrlo= `retain_time,
            taa_sdlo=`access_time,
            th_sdlo= `retain_time,
            taa_sdro=`access_time,
            th_sdro= `retain_time,
            
         
            taa_sctrlo_se=`access_time,
            th_sctrlo_se= `retain_time
,
            taa_sdlo_se=`access_time,
            th_sdlo_se= `retain_time,
            taa_sdro_se=`access_time,
            th_sdro_se= `retain_time
         ;  


        /*---------------------- Timing Checks ---------------------*/

	$setup(posedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[7], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[8], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[7], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[8], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[7], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[8], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[7], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[8], tah, TimingViol_addr);

	$setup(posedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(posedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(posedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(posedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(posedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(posedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(posedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(posedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(posedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(posedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(posedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(posedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(posedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(posedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(posedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(posedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(posedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(posedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(posedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(posedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(negedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(negedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(negedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(negedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(negedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(negedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(negedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(negedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(negedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(negedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(negedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(negedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(negedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(negedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(negedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(negedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(negedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(negedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(negedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(negedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[19], tdh, TimingViol_data_19);

        



        $setup(posedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $setup(negedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, posedge WEN, twh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, negedge WEN, twh, TimingViol_WEN); 
        $setup(posedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$setup(negedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, posedge CSN, tph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, negedge CSN, tph, TimingViol_CSN);
        $period(posedge CK &&& cond_sdf_tcycle, tcycle, TimingViol_tcycle);  

        
        $width(posedge CK  &&& cond_sdf_tckh, tckh, 0, TimingViol_tckh);
        $width(negedge CK  &&& cond_sdf_tckl, tckl, 0, TimingViol_tckl);
        $period(posedge CK &&& cond_sdf_tcycle_se, tcycle_se, TimingViol_tcycle_se);
        $width(posedge CK  &&& cond_sdf_tckh_se, tckh_se, 0, TimingViol_tckh_se);
        $width(negedge CK  &&& cond_sdf_tckl_se, tckl_se, 0, TimingViol_tckl_se);

        
        $setup(posedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $setup(negedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $hold(posedge CK &&& cond_sdf_ttms, posedge TBYPASS, ttmh, TimingViol_tbypass); 
        $hold(posedge CK &&& cond_sdf_ttms, negedge TBYPASS, ttmh, TimingViol_tbypass); 
 



        
        $setup(posedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $setup(negedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $hold(posedge CK &&& cond_sdf_tsls, posedge SLEEP, tslh, TimingViol_sleep);        
        $hold(posedge CK &&& cond_sdf_tsls, negedge SLEEP, tslh, TimingViol_sleep);

        $setup(posedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $setup(negedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $hold(posedge CK &&& cond_sdf_tstdbys, posedge STDBY, tstdbyh, TimingViol_stdby);        
        $hold(posedge CK &&& cond_sdf_tstdbys, negedge STDBY, tstdbyh, TimingViol_stdby); 
        
        
        $setup (posedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
	$setup (negedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
        
        $hold (posedge CK &&& cond_sdf_tses, posedge SE ,tseh,TimingViol_se);
	$hold (posedge CK &&& cond_sdf_tses, negedge SE ,tseh,TimingViol_se);
        
        $setup(posedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis , tsctrlis, TimingViol_sctrli);
        $setup(negedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis, tsctrlis, TimingViol_sctrli);
        $hold(posedge CK &&& cond_sdf_tsctrlis , posedge SCTRLI, tsctrlih, TimingViol_sctrli);        
        $hold(posedge CK &&& cond_sdf_tsctrlis , negedge SCTRLI, tsctrlih, TimingViol_sctrli);

        $setup(posedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $setup(negedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $hold(posedge CK &&& cond_sdf_tsdlis, posedge SDLI, tsdlih, TimingViol_sdli);        
        $hold(posedge CK &&& cond_sdf_tsdlis, negedge SDLI, tsdlih, TimingViol_sdli);

        $setup(posedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $setup(negedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $hold(posedge CK &&& cond_sdf_tsdris, posedge SDRI, tsdrih, TimingViol_sdri);        
        $hold(posedge CK &&& cond_sdf_tsdris, negedge SDRI, tsdrih, TimingViol_sdri);
        
 
	
         
        $width(negedge INITN , tinitnl, 0, TimingViol_initnl);
        
        $setup(posedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        $setup(negedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        
        $hold (posedge CK &&& cond_sdf_tinitns,posedge INITN, tinitnh, TimingViol_initn);
        $hold (posedge CK &&& cond_sdf_tinitns,negedge INITN, tinitnh, TimingViol_initn);

        $setup(posedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $setup(negedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $hold(posedge CK &&& cond_sdf_atps, posedge ATP, tatph, TimingViol_atp);        
        $hold(posedge CK &&& cond_sdf_atps, negedge ATP, tatph, TimingViol_atp);
        
        $setup(posedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $setup(negedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $hold(posedge CK &&& cond_sdf_tigs, posedge IG, tigh, TimingViol_ig);        
        $hold(posedge CK &&& cond_sdf_tigs, negedge IG, tigh, TimingViol_ig);



         
$setup(posedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[2], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[2], trmh, TimingViol_rm); 

        
$setup(posedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(posedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[1], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[1], twmh, TimingViol_wm);
 
        
        $setup(posedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $setup(negedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $hold(posedge CK &&& cond_sdf_tbists, posedge TBIST, tbisth, TimingViol_tbist);        
        $hold(posedge CK &&& cond_sdf_tbists, negedge TBIST, tbisth, TimingViol_tbist);
        
        	$setup(posedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[7], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[8], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$setup(negedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[7], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[8], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[6], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[7], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[8], tbah, TimingViol_addr);
       	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[6], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[7], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[8], tbah, TimingViol_addr);

        $setup(posedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$setup(negedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, posedge TCSN, tbph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, negedge TCSN, tbph, TimingViol_CSN); 
       
        $setup(posedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $setup(negedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, posedge TWEN, tbwh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, negedge TWEN, tbwh, TimingViol_WEN);
       
       
        $setup(posedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $setup(negedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, posedge TED, tbdeh, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, negedge TED, tbdeh, TimingViol_TED);

        $setup(posedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $setup(negedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, posedge TOD, tbdoh, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, negedge TOD, tbdoh, TimingViol_TOD);

          


          

          /*-------------------- Propagation Delays ------------------*/
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa, taa, th, taa, th, taa);
                 

/* // //	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[0] +: OutReg_data[0])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[1] +: OutReg_data[1])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[2] +: OutReg_data[2])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[3] +: OutReg_data[3])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[4] +: OutReg_data[4])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[5] +: OutReg_data[5])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[6] +: OutReg_data[6])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[7] +: OutReg_data[7])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[8] +: OutReg_data[8])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[9] +: OutReg_data[9])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[10] +: OutReg_data[10])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[11] +: OutReg_data[11])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[12] +: OutReg_data[12])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[13] +: OutReg_data[13])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[14] +: OutReg_data[14])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[15] +: OutReg_data[15])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[16] +: OutReg_data[16])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[17] +: OutReg_data[17])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[18] +: OutReg_data[18])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[19] +: OutReg_data[19])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q); */ 








	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                





	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                 

	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[0] +: OutReg_data[0])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[1] +: OutReg_data[1])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[2] +: OutReg_data[2])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[3] +: OutReg_data[3])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[4] +: OutReg_data[4])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[5] +: OutReg_data[5])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[6] +: OutReg_data[6])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[7] +: OutReg_data[7])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[8] +: OutReg_data[8])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[9] +: OutReg_data[9])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[10] +: OutReg_data[10])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[11] +: OutReg_data[11])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[12] +: OutReg_data[12])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[13] +: OutReg_data[13])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[14] +: OutReg_data[14])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[15] +: OutReg_data[15])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[16] +: OutReg_data[16])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[17] +: OutReg_data[17])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[18] +: OutReg_data[18])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[19] +: OutReg_data[19])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                



if (cond_sdf_taa_sctrlo) 
        (posedge CK *> (SCTRLO :  SCTRLI)) = (taa_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo); 

if (cond_sdf_taa_sctrlo_se) 
        (negedge CK *> (SCTRLO : SCTRLI)) = (taa_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se); 
 

if (cond_sdf_taa_sdlo) 
        (posedge CK *> (SDLO :  SDLI)) = (taa_sdlo,taa_sdlo,th_sdlo,taa_sdlo,th_sdlo,taa_sdlo); 

if (cond_sdf_taa_sdlo_se) 
        (negedge CK *> (SDLO : SDLI)) = (taa_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se);

if (cond_sdf_taa_sdro) 
        (posedge CK *> (SDRO :  SDRI)) = (taa_sdro,taa_sdro,th_sdro,taa_sdro,th_sdro,taa_sdro); 

if (cond_sdf_taa_sdro_se) 
        (negedge CK *> (SDRO : SDRI)) = (taa_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se); 

  
     




endspecify //specify block ends






// conversion from registers to array elements for data setup violation notifiers

always @(TimingViol_data_0   or TimingViol_TED  )
begin
        TimingViol_data[0]=~TimingViol_data[0];   
end


always @(TimingViol_data_1   or TimingViol_TOD  )
begin
        TimingViol_data[1]=~TimingViol_data[1];   
end


always @(TimingViol_data_2   or TimingViol_TED  )
begin
        TimingViol_data[2]=~TimingViol_data[2];   
end


always @(TimingViol_data_3   or TimingViol_TOD  )
begin
        TimingViol_data[3]=~TimingViol_data[3];   
end


always @(TimingViol_data_4   or TimingViol_TED  )
begin
        TimingViol_data[4]=~TimingViol_data[4];   
end


always @(TimingViol_data_5   or TimingViol_TOD  )
begin
        TimingViol_data[5]=~TimingViol_data[5];   
end


always @(TimingViol_data_6   or TimingViol_TED  )
begin
        TimingViol_data[6]=~TimingViol_data[6];   
end


always @(TimingViol_data_7   or TimingViol_TOD  )
begin
        TimingViol_data[7]=~TimingViol_data[7];   
end


always @(TimingViol_data_8   or TimingViol_TED  )
begin
        TimingViol_data[8]=~TimingViol_data[8];   
end


always @(TimingViol_data_9   or TimingViol_TOD  )
begin
        TimingViol_data[9]=~TimingViol_data[9];   
end


always @(TimingViol_data_10   or TimingViol_TED  )
begin
        TimingViol_data[10]=~TimingViol_data[10];   
end


always @(TimingViol_data_11   or TimingViol_TOD  )
begin
        TimingViol_data[11]=~TimingViol_data[11];   
end


always @(TimingViol_data_12   or TimingViol_TED  )
begin
        TimingViol_data[12]=~TimingViol_data[12];   
end


always @(TimingViol_data_13   or TimingViol_TOD  )
begin
        TimingViol_data[13]=~TimingViol_data[13];   
end


always @(TimingViol_data_14   or TimingViol_TED  )
begin
        TimingViol_data[14]=~TimingViol_data[14];   
end


always @(TimingViol_data_15   or TimingViol_TOD  )
begin
        TimingViol_data[15]=~TimingViol_data[15];   
end


always @(TimingViol_data_16   or TimingViol_TED  )
begin
        TimingViol_data[16]=~TimingViol_data[16];   
end


always @(TimingViol_data_17   or TimingViol_TOD  )
begin
        TimingViol_data[17]=~TimingViol_data[17];   
end


always @(TimingViol_data_18   or TimingViol_TED  )
begin
        TimingViol_data[18]=~TimingViol_data[18];   
end


always @(TimingViol_data_19   or TimingViol_TOD  )
begin
        TimingViol_data[19]=~TimingViol_data[19];   
end


`endif


// TASK DEFINITION DESCRIPTION
// ================================



task task_insert_faults_in_memory;
begin
   if (reg_ConfigFault)
   begin   
     for(i = 0;i< fcnt;i = i+ 1) begin
        if(mem_red_array_stuck_at[i] === "mem_array") begin
          if (array_stuck_at[i] === "sa0") begin
           `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data & stuck_at_0fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
          `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] & stuck_at_0fault[i];
          `endif
         end //if(array_stuck_at)
                                        
         if(array_stuck_at[i] === "sa1") begin
         `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data | stuck_at_1fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
         `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] | stuck_at_1fault[i]; 
         `endif
         end //if(array_stuck_at)
       end //if mem_red_array_stuck_at
    
    
     end    // end of for
   end  
end
endtask



task task_read_fault_file;
begin
/*  -----------Implemetation for config fault starts------*/
   msgcnt = X;
   t = 0;
   fault_repair_flag = {max_faults{1'b1}};
   repair_flag = {max_faults{1'b1}};
   if(reg_ConfigFault) 
   begin
      file_ptr = $fopen(reg_Fault_file_name , "r");
      if(file_ptr == 0)
      begin     
          if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: File cannot be opened ",$realtime);
      end        
      else                
      begin : read_fault_file
        t = 0;
        for (i = 0; i< max_faults; i= i + 1)
        begin
         
           stuck0 = {Bits{1'b1}};
           stuck1 = {Bits{1'b0}};
           fault_char1 = $fgetc (file_ptr);
           if (fault_char1 == 8'b11111111)
              disable read_fault_file;
           ret_val = $ungetc (fault_char1, file_ptr);
           ret_val = $fgets(tempStr, file_ptr);
           ret_val = $sscanf(tempStr, "%s %d %d %s",fault_array,fault_word, fault_bit, stuck_at) ;
           flag_error = 0; 
           if(ret_val !== 0)
           begin         
              if(ret_val == 3 || ret_val == 4)
              begin
                if(ret_val == 3)
                   stuck_at = "sa0";

                if(stuck_at !== "sa0" && stuck_at !== "sa1" && stuck_at !== "none")
                begin
                    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: Wrong value for stuck at in fault file ",$realtime);
                   flag_error = 1;
                end    
                      
                if(fault_word >= Words)
                begin
                   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Address out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                if(fault_bit >= Bits)
                begin  
                    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Faulty bit out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                
                        
                if(fault_array !== "mem_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array is not mem_array ",$realtime);
                  flag_error = 1;
                end

                if(fault_array === "red_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array can't be on redundancy array in non redundancy cut.",$realtime);
                  flag_error = 1;
                end

                
                

                if(flag_error == 0)
                //Correct Inputs
                begin
                   if(stuck_at === "none")
                   begin
                       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
                   end
                   else
                   //Adding the faults
                   begin
                      FailureLocn[t] = fault_word;
                      Failurebit[t]  = fault_bit ;
                      std_fault_word = fault_word;
                      fault_row_add[t] = std_fault_word[Addr-1:mux_bits];
                      mem_red_array_stuck_at[t] = fault_array;
                      fault_repair_flag[t] = 1'b0;
                      if (stuck_at === "sa0" )
                      begin
                         stuck0[fault_bit] = 1'b0;         
                         stuck_at_0fault[t] = stuck0;
                      end     
                      if (stuck_at === "sa1" )
                      begin
                         stuck1[fault_bit] = 1'b1;
                         stuck_at_1fault[t] = stuck1; 
                      end

                      array_stuck_at[t] = stuck_at;
                      t = t + 1;
                   end //if(stuck_at === "none")  
                end //if(flag_error == 0)
              end //if(ret_val == 2 || ret_val == 3 
              else
              //wrong number of arguments
              begin
                if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: WRONG VALUES ENTERED FOR FAULTY WORD OR FAULTY BIT OR STUCK_AT IN Fault_file_name ",$realtime); 
                flag_error = 1;
              end
           end //if(ret_val !== 0)
           else
           begin 
               if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
           end    
        end //for (i = 0; i< m
      end //begin: read_fault_file  
      $fclose (file_ptr);

      fcnt = t;
      
      //fault injection at time 0.
      task_insert_faults_in_memory;
  end // config_fault 
end
endtask


task WriteMemX;
begin

`ifdef slm
   $slm_ResetMemory(MemAddr, WordX);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = WordX;
   
`endif        
 task_insert_faults_in_memory;
end
endtask

task WriteMem0;
begin
`ifdef slm
   $slm_ResetMemory(MemAddr, Word0);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = Word0;
  
`endif 
   task_insert_faults_in_memory;
end
endtask


task WriteOutX;                
begin
   OutReg_data <= #0 WordX;
end
endtask


task Invalid_next_cycle_func;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_func = 1;
     `else 
       #0 next_cycle_corrupt_func = 0; 
     `endif  
   end 
end
endtask

task Invalid_next_cycle_dft;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_dft = 1;
     `else 
       #0 next_cycle_corrupt_dft = 0; 
     `endif  
  end
end
endtask

task Invalid_next_cycle_func_tim;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
   #0 next_cycle_corrupt_func <= 1;
  end 
end
endtask

task Invalid_next_cycle_dft_tim;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
  #0 next_cycle_corrupt_dft <= 1;
  end
end
endtask


task ScanOutX;                
begin
   
   dff_SCTRLO_SE.Q <= 1'bx;   
   dff_SDLO_SE.Q <= 1'bx; 
   dff_SDRO_SE.Q <= 1'bx; 
    
   
   SCTRLOint=X;
   SDLOint=X;
   SDROint=X;
    
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   SDLO_data<=1'bx;
   SDRO_data<=1'bx;
    
   `endif
end
endtask

task delScanOutX;                
begin
   delSCTRLO_data<=X;
   delSDLO_data<=X;
   delSDRO_data<=X;
    
end
endtask

task ScanChainX;                
begin
 scanreg_ctrl=1'bx; 
 scanreg_dl=1'bx; 
 scanreg_dr =1'bx; 
  
end
endtask

task mem_blocked;
begin
 
   WriteMemX;
   WriteOutX;
   ScanChainX;
   ScanOutX;//immediately;
   delScanOutX;//immediately
   `ifdef POWER_SEQUENCING_OFF
   `else
   reg_mem_block=1;
   `endif
   debug_level = 2'b11;
end
endtask

task corrupt_all;
begin
 
  WriteMemX;
  WriteOutX;
  ScanChainX;
  ScanOutX;
  delScanOutX;//immediately;
  OutReg_data = WordX; 
  delOutReg_data=WordX;
  
end
endtask

task WriteCycle;                  
input [Addr-1 : 0] Address;
reg [Bits-1:0] tempReg1;
reg [Bits-1:0] tempReg_slm;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;


reg repair_flag;

integer po,i,num,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;
begin

   tempReg1 = WordX;
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];

   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};
   
   if (ValidAddress === X )   begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
        WriteMemX;
        if (INITNint !== 0) begin
        `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
           #0 next_cycle_corrupt_func = 1;
       `else 
           #0 next_cycle_corrupt_func = 0; 
       `endif  
   end 

   end


   if (ValidAddress !== X && next_cycle_corrupt_func === 0  )
   begin
         if (red_en === 1 && ((Row_Add_cmp === repair_add) || (Row_Add_cmp === next_repair_add)) ) begin
             repair_flag = 1'b1;
             
             Bank_sel_integer = 0;
                     
             if (Row_Add_cmp === repair_add) begin
               Col_Add_integer  = Col_Add; 
             end
             else if (Row_Add_cmp === next_repair_add) begin
               Col_Add_integer  = Col_Add + mux; 
             end  
             RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
        end  

        if(repair_flag === 0 && ValidAddress === 1) begin
           `ifdef slm
              $slm_ReadMemoryS(MemAddr, Address, tempReg_slm);
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = Mem[Address];
            `endif
          end  
        else if(repair_flag === 1) begin
           `ifdef slm
//              $slm_ReadMemoryS(RedMemAddr, RedMem_address, tempReg_slm);
          
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = RedMem[RedMem_address];
            `endif
        end
        
        for (num=0;num<Bits;num=num+1) begin
             po=num;        
             if ( Dint [num] !== tempReg1 [po]) begin
                if (Mint[num] === 1'b0)
                   tempReg1[po] = Dint[num];
                else if (Mint[num] === 1'bX)
                   tempReg1[po] = 1'bx;
             end                
        end //for (num=0
            
         if(repair_flag === 0 ) begin    
            if(ValidAddress === 1) begin  
              `ifdef slm
                  tempReg_slm=tempReg1; 
                  $slm_WriteMemory(MemAddr, Address, tempReg_slm);
              `else
                   Mem[Address] = tempReg1;
              `endif
            end
            else begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address Out Of Range. ",$realtime);
            end        
         end
         else if (repair_flag === 1 ) begin
            `ifdef slm
                tempReg_slm=tempReg1; 
//                $slm_WriteMemory(RedMemAddr, RedMem_address, tempReg_slm);
            `else
                RedMem[RedMem_address] = tempReg1;
            `endif
         end
   end //if (ValidAddress !== X
   task_insert_faults_in_memory;
end
endtask 

task ReadCycle;
input [Addr-1 : 0] Address;

reg [Bits-1:0] MemData_tmp;
reg [Bits-1:0] MemData;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;

reg repair_flag;

integer a,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;

begin
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];
   
   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};

   

   if (ValidAddress !== X && next_cycle_corrupt_func === 0 ) begin   
       if(red_en === 1 && ( Row_Add_cmp === repair_add ||  Row_Add_cmp === next_repair_add )) begin
              repair_flag = 1;
              
              Bank_sel_integer = 0;
               
              if(Row_Add_cmp === repair_add) begin
                Col_Add_integer = Col_Add;
              end
              else if (Row_Add_cmp === next_repair_add) begin
                Col_Add_integer = Col_Add + mux; 
              end
              RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
       end

      if(repair_flag === 0) begin
          if(ValidAddress === 1) begin 
           `ifdef slm
              $slm_ReadMemory(MemAddr, Address, MemData);
           `else
              MemData = Mem[Address];
           `endif
          end
          else begin
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Address Out Of Range. Output Corrupted ",$realtime);
             MemData = WordX;
          end
     end
      else if(repair_flag === 1) begin
        `ifdef slm
//           $slm_ReadMemory(RedMemAddr, RedMem_address, MemData);
        `else
           MemData = RedMem[RedMem_address];
        `endif
      end
   end //if (ValidAddress)  
   
   if(ValidAddress === X)
   begin
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Illegal Value on Address Bus. Memory and Output Corrupted ",$realtime); 
         Invalid_next_cycle_func;
   end 
   
  if(ValidAddress !== X && next_cycle_corrupt_func === 0 )
   begin
   for (a = 0; a < Bits; a = a + 1)
   begin
      if (MemData[a] !== OutReg_data[a])
         OutReg_data[a] = WordX[a];
   end//for (a = 0; a <  
         OutReg_data <= MemData;
   end     
end
endtask



// SCAN CHAINS
supply0 gnd;
buf (A_int[0], Aint[0]);
buf (A_int[1], Aint[1]);
buf (A_int[2], Aint[2]);
buf (A_int[3], Aint[3]);
buf (A_int[4], Aint[4]);
buf (A_int[5], Aint[5]);
buf (A_int[6], Aint[6]);
buf (A_int[7], Aint[7]);
buf (A_int[8], Aint[8]);                  //used for capturing
buf (A_int[9], gnd);
buf (A_int[10], gnd);
buf (A_int[11], gnd);
buf (A_int[12], gnd);
buf (A_int[13], gnd);
buf (A_int[14], gnd);   //used for capturing

buf (WEN_int, WENint);
buf (CSN_int, CSNint);
buf (IG_int, IGint);


// Scan flops



// CONTROL SCAN CHAIN
     ST_SPREG_LOLEAK_512x20m4_Tl_SCFF cntrl_scff_0 (.D(1'b0), .TI(SCTRLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[0]), .OUTX(scanreg_ctrl));

      
 ST_SPREG_LOLEAK_512x20m4_Tl_SCFF cntrl_scff_1 (.D(A_int[3]), .TI(scanreg_ctrl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[1]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m4_Tl_SCFF cntrl_scff_2 (.D(A_int[5]), .TI(scanreg_ctrl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[2]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m4_Tl_SCFF cntrl_scff_3 (.D(A_int[8]), .TI(scanreg_ctrl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[3]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m4_Tl_SCFF cntrl_scff_4 (.D(A_int[2]), .TI(scanreg_ctrl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[4]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m4_Tl_SCFF cntrl_scff_5 (.D(A_int[10]), .TI(scanreg_ctrl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[5]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m4_Tl_SCFF cntrl_scff_6 (.D(A_int[9]), .TI(scanreg_ctrl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[6]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m4_Tl_SCFF cntrl_scff_7 (.D(A_int[1]), .TI(scanreg_ctrl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[7]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m4_Tl_SCFF cntrl_scff_8 (.D(A_int[0]), .TI(scanreg_ctrl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[8]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m4_Tl_SCFF cntrl_scff_9 (.D(A_int[4]), .TI(scanreg_ctrl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[9]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m4_Tl_SCFF cntrl_scff_10 (.D(A_int[6]), .TI(scanreg_ctrl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[10]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m4_Tl_SCFF cntrl_scff_11 (.D(CSN_int), .TI(scanreg_ctrl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[11]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m4_Tl_SCFF cntrl_scff_12 (.D(A_int[7]), .TI(scanreg_ctrl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[12]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m4_Tl_SCFF cntrl_scff_13 (.D(WEN_int), .TI(scanreg_ctrl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[13]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m4_Tl_SCFF cntrl_scff_14 (.D(scanreg_ctrl_wire[14]), .TI(scanreg_ctrl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[14]), .OUTX(scanreg_ctrl));  

reg LP_CK_gate;

// Lock Up Latch
wire SCTRLO_temp;
 ST_SPREG_LOLEAK_512x20m4_Tl_lock_up_latch  dff_SCTRLO_SE (Latch_open, scanreg_ctrl_wire[14], SCTRLO_temp);

always @(SCTRLO_temp) begin
     SCTRLOint= SCTRLO_temp;
 `ifdef functional
 `else
 if (SCTRLOint !== SCTRLO_data) begin 
  if (SCTRLOint !==X)
   SCTRLO_data=1'bx;
   SCTRLO_data <= SCTRLOint;
 end 
 `endif
end  


// LEFT DATA SCAN CHAIN
     ST_SPREG_LOLEAK_512x20m4_Tl_SCFF ldata_scff_0 (.D(Dint[9]), .TI(SDLI), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[0]), .OUTX(scanreg_dl));
      
   
 
        ST_SPREG_LOLEAK_512x20m4_Tl_SCFF ldata_scff_1 (.D(Dint[8]), .TI(scanreg_dl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[1]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m4_Tl_SCFF ldata_scff_2 (.D(Dint[7]), .TI(scanreg_dl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[2]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m4_Tl_SCFF ldata_scff_3 (.D(Dint[6]), .TI(scanreg_dl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[3]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m4_Tl_SCFF ldata_scff_4 (.D(Dint[5]), .TI(scanreg_dl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[4]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m4_Tl_SCFF ldata_scff_5 (.D(Dint[4]), .TI(scanreg_dl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[5]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m4_Tl_SCFF ldata_scff_6 (.D(Dint[3]), .TI(scanreg_dl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[6]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m4_Tl_SCFF ldata_scff_7 (.D(Dint[2]), .TI(scanreg_dl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[7]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m4_Tl_SCFF ldata_scff_8 (.D(Dint[1]), .TI(scanreg_dl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[8]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m4_Tl_SCFF ldata_scff_9 (.D(Dint[0]), .TI(scanreg_dl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[9]), .OUTX(scanreg_dl));



// Lock Up Latch
wire SDLO_temp;
 ST_SPREG_LOLEAK_512x20m4_Tl_lock_up_latch  dff_SDLO_SE (Latch_open, scanreg_dl_wire[9], SDLO_temp);

always @(SDLO_temp) begin
     SDLOint= SDLO_temp;
 `ifdef functional
 `else
 if (SDLOint !== SDLO_data) begin 
  if (SDLOint !==X)
   SDLO_data=1'bx;
   SDLO_data <= SDLOint;
 end 
 `endif
end  






// RIGHT DATA SCAN CHAIN

     ST_SPREG_LOLEAK_512x20m4_Tl_SCFF rdata_scff_0 (.D(Dint[19]), .TI(SDRI), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[0]), .OUTX(scanreg_dr));
     
 
 
        ST_SPREG_LOLEAK_512x20m4_Tl_SCFF rdata_scff_1 (.D(Dint[18]), .TI(scanreg_dr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[1]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m4_Tl_SCFF rdata_scff_2 (.D(Dint[17]), .TI(scanreg_dr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[2]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m4_Tl_SCFF rdata_scff_3 (.D(Dint[16]), .TI(scanreg_dr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[3]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m4_Tl_SCFF rdata_scff_4 (.D(Dint[15]), .TI(scanreg_dr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[4]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m4_Tl_SCFF rdata_scff_5 (.D(Dint[14]), .TI(scanreg_dr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[5]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m4_Tl_SCFF rdata_scff_6 (.D(Dint[13]), .TI(scanreg_dr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[6]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m4_Tl_SCFF rdata_scff_7 (.D(Dint[12]), .TI(scanreg_dr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[7]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m4_Tl_SCFF rdata_scff_8 (.D(Dint[11]), .TI(scanreg_dr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[8]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m4_Tl_SCFF rdata_scff_9 (.D(Dint[10]), .TI(scanreg_dr_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[9]), .OUTX(scanreg_dr)); 


// Lock Up Latch
wire SDRO_temp;
 ST_SPREG_LOLEAK_512x20m4_Tl_lock_up_latch  dff_SDRO_SE (Latch_open, scanreg_dr_wire[9], SDRO_temp);


always @(SDRO_temp) begin
     SDROint= SDRO_temp;
 `ifdef functional
 `else
 if (SDROint !== SDRO_data) begin 
  if (SDROint !==X)
   SDRO_data=1'bx;
   SDRO_data <= SDROint;
 end 
 `endif
end






//


 //////// CAPTURE TASK //////
task scan_acquire;
begin
   if (supply_ok === 1) begin 
      if ( SEsys === 0 && ((LP_CK_gate === 0 && TBYPASSsys !== 1'bx)|| TBYPASSsys===0)) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
         
         Latch_open=1;
         

      end //if ( SEint === 0
   end//if(supply_ok 
end
endtask

task scan_shift;
begin
 if (supply_ok === 1) begin
   if (STDBYint === 0 && SLEEPint === 0) begin
      if (CKint_dft === X && INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0) begin
         ScanChainX;
         ScanOutX;
      end
      else if (CKint_dft === 1 && lastCK_dft === 0 ) begin
          //// SHIFT
        if (SEsys === 1) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
           
        //// SHIFT Ends
        end //if (SEsys === 1
        else if (SEsys === X) begin
            ScanChainX;
            ScanOutX;
            delScanOutX;
        end//if (SEint ==X
      
      end///if (CKint === 
    
      else if (CKint_dft === 0 && lastCK_dft === 1 ) begin
        Latch_open=1;
      end
    end  //if (STDByint === 0 && SLEEPint === 0
 end//if(supply_ok
end
endtask






// BEHAVIOURAL MODULE DESCRIPTION
// ================================

initial
begin
  // Define format for timing value
  $timeformat (-9, 3, " ns", 0);
  `ifdef slm
  $slm_RegisterMemory(MemAddr, Words, Bits);
  `endif   
   reg_mem_block=0;
   flag_mem_block=0;
  `ifdef functional
  `else
   TimingViol_data=0;
   TimingViol_mask=0;
   `endif
   decoding_start=0;
  
   //Parameter Assignment
   
   reg_Fault_file_name = Fault_file_name; 
   reg_ConfigFault     = ConfigFault;
   reg_MEM_INITIALIZE  = MEM_INITIALIZE;
   reg_BinaryInit      = BinaryInit;
   reg_InitFileName    = InitFileName;
   reg_Initn_reset_value = Initn_reset_value;
   reg_File_load_time    = File_load_time;

   time_fall_sleep=0;
   time_fall_PSWLARGEMP=0;
   time_fall_PSWLARGEMP_0=0;
   time_fall_PSWLARGEMA=0;
   time_fall_PSWLARGEMA_0=0;
   time_fall_PSWSMALLMP=0;
   time_fall_PSWSMALLMA=0;

   vddmp_rise_time=0;
   vddmp_fall_time=0;
   vddsmp_rise_time=0;
   vddsmp_fall_time=0;
   vddma_rise_time=0;
   vddma_fall_time=0;
   vddsma_rise_time=0;
   vddsma_fall_time=0;
   vddm_fall_time=0;  
   vddm_rise_time=0;  
   vddsm_fall_time=0; 
   vddsm_rise_time=0;

   next_cycle_corrupt_func=0;
   next_cycle_corrupt_dft=0;
   init_pulse_done = 0;
   power_up_done = 0;
   file_loaded=1;
   debug_level= 2'b01;
   message_status = "ONLY WARNINGS/ERRORS are Switched ON.For INFO also use debug_level=2'b00";
  `ifdef  NO_WARNING_MODE
     debug_level = 2'b11;
     message_status = "All Warning/Errors/Info Messages are Switched OFF";
  `endif  
  `ifdef  ONLY_ERROR_MODE
     debug_level = 2'b10;
     message_status = "All Warning/Info Messages are Switched OFF.Errors are switched on";
  `endif 
  `ifdef  ALL_MSG_MODE
     debug_level = 2'b00;
     message_status = "All Messages are Switched ON";
  `endif 
  
  `ifdef slm
     operating_mode = "SLM";
   `else
      `ifdef functional
         operating_mode = "FUNCTIONAL";
       `else
         operating_mode = "TIMING";
      `endif
   `endif   
  
  if (debug_level < 1) begin
  $display ("%m INFORMATION ");
  $display ("***************************************");
  $display ("The Model is Operating in %s MODE", operating_mode);
  $display ("%s", message_status);
  if(reg_ConfigFault)
  $display ("Configurable Fault Functionality is ON");   
  else
  $display ("Configurable Fault Functionality is OFF");   
  $display("Fault File used by the model Fault_File_Name=%s" ,reg_Fault_file_name);
  $display("Values of Config_fault used in model=%d" ,reg_ConfigFault);
  $display("Values of Mem_INITALIZE used in model=%d" ,reg_MEM_INITIALIZE);
  $display("Values of BinaryInit used in model=%d" ,reg_BinaryInit);
  $display("Values of InitFileName used in model=%s" ,reg_InitFileName);
  $display("Values of Initn_reset_value used in model=%d" ,reg_Initn_reset_value);
  $display("Values of File_load_time used in model=%t" ,reg_File_load_time);

  $display ("***************************************");
  end
     
  task_read_fault_file; 
   if(!INITNint) begin
    if(supply_ok ) begin 
      init_pulse_done = 1;
      power_up_done = 1;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif 
    end 
   end 
        
   lastCK_func = CKint_func;
   lastCK_dft = CKint_dft;

 `ifdef MEM_CONTENTS_SLEEP
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","w");
   $fclose(ptr);
 `endif 

   
end  // initial block ends



//+++++++++++++++++++++++++++++++ CONFIG FAULT IMPLEMETATION ENDS+++++++++++++++++++++++++++++++//
        




//INITN block starts
//================================
always @(INITNint  or supply_ok )
begin
 if (INITNint === 1'b0) begin
   if(supply_ok) begin
     init_pulse_done = 1;
     power_up_done = 1;
     lastCK_func=CKint_func;
     lastCK_dft=CKint_dft;
     next_cycle_corrupt_func = 0;
     next_cycle_corrupt_dft = 0;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif     
   end 
 end        

 if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && INITNint !== 1)
   begin
     ScanOutX;
     ScanChainX;
     delScanOutX;
   end  
         
 if (init_pulse_done === 0 && INITNint !== 0) begin
     if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) INFO: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
 end
 
end//always @(INITNint)


// Clock Generation 
//wire gated_clock;
//wire clock_gate_en;
//ST_SPREG_LOLEAK_512x20m4_Tl_lock_up_latch CK_SE_latch (!CK , SE, SE_latch_CK);
//and (clock_gate_en, ATP, TBYPASS, !SE_latch_CK);

//ST_SPREG_LOLEAK_512x20m4_Tl_lock_up_latch LP_latch (!CK , scanreg_ctrl_wire[14], LP_latch_CK);
//and (gated_clock,CK,!LP_latch_CK);
//assign CK_new= clock_gate_en ===0 ? CK : (clock_gate_en ===1 ? gated_clock: (CK===0) ? 0 :1'bx);


// Clock Generation Ends


// Functional CK block starts
//======================================
always @(CKint_func)
begin
   lastCK_func=CKreg_func;  
   CKreg_func=CKint_func;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
        if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
      if (CKreg_func === 1'bX || (CKreg_func === 1'b1 && lastCK_func === 1'bx)) begin
        if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
         
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
         Invalid_next_cycle_func;
        end
      end
      else if (CKreg_func === 1'b1 && lastCK_func === 1'b0 ) begin
        time_CK_func_rise=$realtime;
        MEMEN_prev = MEMEN_reg;
        MEMEN_reg = MEMEN;
        CSNreg = CSNint;
        IGreg = IGint;
        DEreg = DEint;
        SE_reg = SEsys;
        TBYPASS_reg = TBYPASSsys;
        ATPreg = ATPint;
        INITNreg = INITNint;
        SLEEPreg = SLEEPint;
        STDBYreg = STDBYint;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 

    `ifdef functional
    `else
        Mem_last=Mem[Aint];
    `endif 
        if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.INITN pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SLEEP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.STANDBY pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg === X && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.chip select  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg === X && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.IG pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg === X && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.Debug pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg === X && (SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.ATP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg === X && TBYPASS_reg !== 1) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SE pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg !== 1 && TBYPASS_reg === X) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.TBYPASS pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end

        else if ((INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0))) && WENint === X) begin
            // Uncertain write cycle
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: write enable going to X  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end 
        else if (next_cycle_corrupt_func === 1) begin
          next_cycle_corrupt_func = X;
        end
        else if (next_cycle_corrupt_func === 1'bx) begin
          next_cycle_corrupt_func = 0;
        end 
        
//        if (next_cycle_corrupt_func === 0 ) begin 
         
          /*---------------------- File initialization -----------------*/
          
          if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0)) && flag_mem_block === 1'b0) begin
                 Areg=Aint;
                 Dreg=Dint;
                 Mreg=Mint;
                 WENreg=WENint;     
             if (reg_MEM_INITIALIZE === 1'b1 && $realtime >= reg_File_load_time && file_loaded ) begin   
                `ifdef slm
                  if (reg_BinaryInit)
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_BIN");
                  else
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_HEX");
   
                `else
                  if (reg_BinaryInit)
                     $readmemb(reg_InitFileName, Mem, 0, Words-1);
                  else
                     $readmemh(reg_InitFileName, Mem, 0, Words-1);
                `endif
                 file_loaded = 0;
             end
   
             if (^Aint === X)
               ValidAddress = X;
             else if (Aint < Words)
               ValidAddress = 1;
             else    
               ValidAddress = 0;
   
             if(red_en === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Redundancy Enable is Invalid. Either RRAE is X or TRRAE is X",$realtime);
                ValidAddress = X; 
           end
           else if(red_en === 1'b1 && ^repair_add === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Repair Address is invalid.RRA is X",$realtime);
                ValidAddress = X;
           end
             
             if (ValidAddress)
               `ifdef slm
                   $slm_ReadMemoryS(MemAddr, Aint, Mem_temp);
               `else
                    Mem_temp = Mem[Aint];
               `endif
             else
                Mem_temp = WordX;  
          
     /*---------------------- Normal Read and Write -----------------*/
     
             if (WENint === 1) begin
               ReadCycle(Aint);
             end
       
             else if (WENint === 0) begin
               WriteCycle(Aint);
             end 
                
          
          end //  if (MEMEN === 1'b1 
       
//        end  // if (next_cycle_corrupt_func === 0
      
      end // if (CKint = 1   
   end // if (init_pulse_done === 1           
 end 
end // always @(CKint_func)
        
always @(MEMEN)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) && CKint_func === 1'bx) begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.clock pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
    Invalid_next_cycle_func;
  end
 end 
end

// DFT CK block starts
//======================================
always @(CKint_dft) 
begin
   lastCK_dft=CKreg_dft;
   CKreg_dft=CKint_dft;
   
   Latch_open=0;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
     if (CKreg_dft === 1'bX || (CKreg_dft === 1'b1 && lastCK_dft === 1'bx)) begin
       if (INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0 ) begin
        
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: DFT clock  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime); 
         Invalid_next_cycle_dft;
         if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
           WriteOutX;
         end
       end
     end 

     if(CKint_dft === 0 && lastCK_dft === 1) begin
      if(ATPreg === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
       if(SE_reg === 1'b1 && SEsys === 1'b0) begin
        if(TBYPASSint === 1'b1) begin   
    
       
       
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8], scanreg_dl_wire[scanlen_l-1]}; 
       


         for (i = 0; i < Bits; i = i + 1)
         begin
          if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
         end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
        end 
       end
      end
     end 
     
     else if (CKreg_dft === 1'b1 && lastCK_dft === 1'b0 ) begin
       SE_reg = SEsys;
       TBYPASS_reg = TBYPASSsys;
       ATPreg = ATPint;
       INITNreg = INITNint;
       SLEEPreg = SLEEPint;
       STDBYreg = STDBYint;
       MEMEN_dft_prev = MEMEN_dft_reg;
       MEMEN_dft_reg = MEMEN_dft;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 
       if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ) begin 
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
 //     else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys === X && TBYPASSsys !== 1) begin
///           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
//           Invalid_next_cycle_dft;
//        end       
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys === X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
        end 
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys !== 0 && LP_CK_gate===X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: LP FLOP Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           ScanChainX;
           ScanOutX;   
          if( TBYPASSint !== 0 && SEint !== 1) begin
            WriteOutX;
          end
          next_cycle_corrupt_dft=0;
        end        
       else if (next_cycle_corrupt_dft === 1'b1) begin 
         next_cycle_corrupt_dft = X;
       end 
       else if (next_cycle_corrupt_dft === 1'bx) begin
         next_cycle_corrupt_dft = 0;
       end
       
       if (next_cycle_corrupt_dft === 0 ) begin
         
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1 && flag_mem_block === 1'b0) begin
           
           if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0  && LP_CK_gate===0) begin
              OutReg_data_tbypass = Dint;
              for (i = 0; i < Bits; i = i + 1)
              begin
               if (OutReg_data_tbypass[i] !== OutReg_data[i])
                 OutReg_data[i] = WordX[i];
              end//for (i = 0; i < */ 
              OutReg_data <= OutReg_data_tbypass;
           end
           
             scan_acquire;
         end //MEMEN_dft == 1        
       end // if ( next_cycle_corrupt_dft
       
     end // if (CKint_dft === 1'b1
      //  if (next_cycle_corrupt_dft === 0 ) begin 
       if (SE_reg !== 0) begin
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1  && flag_mem_block === 1'b0) begin
           next_cycle_corrupt_dft = 0;
           if ( next_cycle_corrupt_func === 1) begin
	    next_cycle_corrupt_func = 0 ;
	   end	
           scan_shift;
         end
       end
     //end // if ( next_cycle_corrupt_dft    
     if ((!(TBYPASSsys!==0 && SEsys!==1 && LP_CK_gate!==0 ) && next_cycle_corrupt_dft === 0) || CKint_dft !==1) begin          
       CK_sc=INITNreg & !STDBYreg & !SLEEPreg & ATPreg & CKreg_dft ;
     end     
   end // if (init_pulse_done 
 end // if (supply_ok 
end // always @(CKint_dft)

always @(MEMEN_dft)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) && CKint_dft === 1'bx)  begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.MEMEN_dft and clock should not be X at this time instant. ScanChains and ScanOuts Corrupted ",$realtime); 
    Invalid_next_cycle_dft;
    
    if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
      WriteOutX;
    end
  end
  if ( MEMEN_dft !== 0 && TBYPASSsys !== 0 && SEsys !== 1) begin
     WriteOutX;
     OutReg_data = WordX; 
     delOutReg_data=WordX;
 end 
end
end //always @(MEMEN_dft

always @(TBYPASSsys or ATPint)
begin
   if(supply_ok === 1'b1) begin 
    if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0 && INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1) begin
      if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
    end  
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint === X && SEsys !== 1) ) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end 
end //always @(TBYPASSint





always @(SEsys)
begin
 if(supply_ok === 1'b1) begin 
  if(CKint_dft === 0 && ATPint === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
    if(SE_reg === 1'b1 && SEsys === 1'b0) begin
      if(TBYPASSsys === 1'b1) begin
  
     
         
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8], scanreg_dl_wire[scanlen_l-1]};
           
      


        for (i = 0; i < Bits; i = i + 1)
        begin
         if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
        end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
      end
    end
  end
  if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0) begin
      if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
  end 
  else if ((TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint === X && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end   
end

//assign output data
`ifdef functional        

   
always @(SDLOint)
#0.001 delSDLO_data<=SDLOint;

always @(SDROint)
#0.001 delSDRO_data<=SDROint;

 
always @(SCTRLOint)
#0.001 delSCTRLO_data<=SCTRLOint;


always @(OutReg_data)
   #0.001 delOutReg_data = OutReg_data;
`else
`endif

/***************************** Embeded switch functionality starts here ***********************************/





always @(STDBYint)
begin
  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0 && STDBYint !== 1'b0)
    begin
      ScanOutX;
      ScanChainX;
     delScanOutX;     
    end
  end
end



always @(SLEEPint)
begin


  if (SLEEPint !== 1'b1) begin
    time_fall_sleep = $realtime;
  end

  if (power_up_done === 0)
    begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
    end
  else begin
    if (SLEEPint === 1'b1 && lastSLEEP === 1'b0 ) begin 
      
    end
    else if (SLEEPint !== 1'b1 && lastSLEEP === 1'b1 && full_shutdown !== 1) begin 
      
      if (supply_ok !== 1 && ($realtime > 0)) begin
         if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID LOW_POWER) ERROR: ISOLATION signal removed from the memory but array and periphery supply is not completely switched on.Very High Current would be drawn by the memory. All further operations on memory are blocked",$realtime);
          WriteMemX;
          WriteOutX;
          ScanChainX;
          OutReg_data = WordX; 
          delOutReg_data=WordX;
          ScanOutX;//immediately;
          delScanOutX;//immediately;
          init_pulse_done = 0;
          power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            debug_level = 2'b11;
          `endif
          
      end        
      
       
    end   
    else if (SLEEPint === X && lastSLEEP === 1'b0 && full_shutdown !== 1'b1) begin 
     
    end 
  end  


  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && SLEEPint !== 0)
    begin
      ScanOutX;
      ScanChainX;
        delScanOutX;      
    end
  end

// if (init_pulse_done === 0)
//   begin
//     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
//   end
//
// else if ( SLEEPint !== 1 && (supply_ok !==1) ) begin
//    
//    WriteOutX;
//    OutReg_data = WordX; 
//    delOutReg_data=WordX;
//    ScanOutX;//immediately;
//    delScanOutX;//immediately;
//    ScanChainX;
//    WriteMemX;
//    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies with sleep/Power down signal being low.This scenario can lead to high dc currents and some reliability issues Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
// end

 print_sleep;    
 lastSLEEP=SLEEPint;
end

/********************************** Embeded switch functionality ends here *******************************/

task print_sleep;
begin
  if (SLEEPint === 1'b0) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been deasserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end  
  else if (SLEEPint === 1'b1) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been asserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_ACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif

  end        
  else begin
      if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) ERROR: SLEEP pin is at an invalid state.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INVALID in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end        
end
endtask





 

//// C28SOI non flip compiler power functionality 
always @(gndmreg )
begin
 if (power_up_done === 1 && $realtime > 0) begin    
    if(gndmreg !== 1'b0 ) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or gndsm is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
        corrupt_all;
        init_pulse_done = 0;
        power_up_done = 0;
     `ifdef NO_BLOCK_MEM
     `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of ground pins.Ground must be maintained at 0 Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime);
        debug_level = 2'b11;
     `endif   

    end   
 end

end




always @(vddmareg )
begin

if (vddmareg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddma(Array Supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 
    end
   end   
   else if (SLEEPint === 1) begin
    WriteMemX;
   end

end

if ((vddmareg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1 ) && $realtime > 0) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddm or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         corrupt_all;
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif

end


end

always @(vddmpreg )
begin
 if (vddmpreg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or vddsmp is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmp(Periphery Supply)/vddsmp(Substrate power supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 

    end
   end   
   else if (SLEEPint === 1) begin
    WriteOutX;
    ScanChainX;
    ScanOutX;
    delScanOutX;//immediately;
    OutReg_data = WordX; 
    delOutReg_data=WordX;
   end
 end

if( (vddmpreg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1'b1 )  && $realtime > 0) begin
         corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif
end
 
 
end


always @(vddmoreg)
begin
  if (power_up_done === 1 && $realtime > 0) begin   
      if (vddmoreg !== 1'b1)  begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin
           corrupt_all;
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
         end //if (vddmareg === 1'b1 

      else if (vddmareg === 1'b0 && vddmpreg === 1'b0   && SLEEPint === 1'b1 &&  $realtime > 0)
        begin 
            if((debug_level < 2) && ($realtime > 0)) $display("%m - %t WARNING: Illegal Value on power pin(s). Memory and Output Corrupted ", $realtime);
 
           corrupt_all;
        end //else if (vddmareg === 1'b 
     end   // if (vddmoreg !== 1'b1)
     else if (vddmoreg === 1'b1 && $realtime > 0 ) begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin     
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           corrupt_all;
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
        end        
     end // else if (vddmoreg === 1'b1
  end 
end // always @(vddmoreg)












always @(gndmreg) begin
 if (gndmreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 0. ",$realtime);
 end
 else if (gndmreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 1. ",$realtime);
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to invalid state. ",$realtime);
 end
end




 
always @(vddmareg) begin
 if (vddmareg === 0) begin 
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 0. ",$realtime);
  vddma_fall_time = $realtime;
 end
 else if (vddmareg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 1. ",$realtime);
  vddma_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to invalid state. ",$realtime);
  vddma_fall_time = $realtime;
 end 

 

end

always @(vddmpreg) begin
 if (vddmpreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 0. ",$realtime);
  vddmp_fall_time = $realtime;
 end
 else if (vddmpreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 1. ",$realtime);
  vddmp_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to invalid state. ",$realtime);
  vddmp_fall_time = $realtime;
 end

 
 
end



// end of C28SOI power functionality 
 


assign supply_ok          =  (vddmareg === 1'b1 && vddmpreg  === 1'b1  && gndmreg === 1'b0 && vddmoreg === 1'b1 ) ? 1'b1 : 1'b0;
assign core_supply_ok     =  (vddmoreg === 1'b1 && vddmareg === 1'b1 && gndmreg === 1'b0 ) ? 1'b1 : 1'b0;
assign peri_supply_ok     =  (vddmoreg === 1'b1 && vddmpreg === 1'b1 && gndmreg === 1'b0  ) ? 1'b1 : 1'b0;

assign full_shutdown = (vddmpreg === 1'b0 && vddmareg === 1'b0   ) ? 1'b1 : 1'b0 ;




`ifdef functional
`else


task WriteLocMskX_bwise;
   input [Addr-1 : 0] Address;
   input [Bits-1 : 0] Mask;

reg [Bits+Red_extrabit:0] tempReg1;
integer num1; 
begin
   tempReg1 = WordX;
   if (^Address !== X )
   begin
      tempReg1 = Mem[Address];
             
      for (j = 0;j< Bits; j=j+1) begin
         num1=j;
        if (Mask[j] === 1'bx)
            tempReg1[num1] = 1'bx;
      end
      Mem[Address] = tempReg1;
      task_insert_faults_in_memory;
   end//if (^Address !== X
   else begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      WriteMemX;
   end   
end
endtask


/****************Actions taken on timing violations*****************/

 always @(TimingViol_data)
// tds or tdh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  for (l = 0; l < Bits; l = l + 1) begin   
    if (CSWEMTBYPASS[l] !== 0) begin
     if((TimingViol_data[l] !== TimingViol_data_last[l])) begin


         Mreg[l] = 1'bx;
     end    
     WriteLocMskX_bwise(Areg,Mreg);
    end   
   end 
  end
    if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin
     scanreg_dl =1'bx; 
     scanreg_dr =1'bx; 
     SDLOint=X;
     SDROint=X;
     `ifdef functional
     `else
     SDLO_data<=1'bx;
     SDRO_data<=1'bx;
     `endif
    end
     TimingViol_data_last = TimingViol_data; 
end





always @(TimingViol_addr)
// tas or tah
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
      scanreg_ctrl=1'bx; 
      SCTRLOint=X;
      `ifdef functional
      `else
      SCTRLO_data<=1'bx;
      `endif
  end
end


always @(TimingViol_WEN)
//tws or twh
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WEN pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end 

always @(TimingViol_CSN )
// tps or tph 
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;

   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CSN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end

always @(TimingViol_tcycle )
//tcycle
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
   if (MEMEN !== 0 && MEMEN_prev !== 0) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckl )
// tckl 
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckh) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end


always @(TimingViol_tcycle_se )
//tcycle_se
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckl_se  )
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckh_se) begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tbist) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
   end
   if (TBYPASSint !== 1'b0) begin 
    WriteOutX;
   end 
   if (INITNreg !==0 && STDBYreg !== 1 && TBYPASS_reg !== 1 && SLEEPreg !== 1 && SE_reg !== 1 && IGreg !== 1 && DEreg !== 1) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBIST pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end






always @(TimingViol_tbypass)
//ttmck
begin
#0  
  WriteOutX;
  if (INITNreg !== 0 && SLEEPreg !== 1 && SE_reg !== 1 && STDBYreg !== 1 &&  DEreg !== 1) begin
   Invalid_next_cycle_dft_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
end



always @(TimingViol_sleep)
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_stdby)
begin
#0
  if (CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin 
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (ATPreg !== 0) begin 
   Invalid_next_cycle_dft_tim;
  end
end






always @(TimingViol_se) begin
#0
   if (TBYPASS_reg !== 0) begin 
    WriteOutX;
   end 
  if (TBYPASS_reg === 0) begin
     WriteOutX;
     WriteMemX;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE timing violation  Memory State Machine is corrupted. Output Corrupted ",$realtime); 
  end 
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
  end
end

always @(TimingViol_sctrli) begin
  scanreg_ctrl=1'bx; 
end


always @(TimingViol_sdli) begin
 scanreg_dl=1'bx; 
end

always @(TimingViol_sdri) begin
   scanreg_dr=1'bx;
end

 

always @(TimingViol_initnl) begin
init_pulse_done=0;
WriteOutX;
OutReg_data = WordX; 
delOutReg_data=WordX;
ScanOutX;
delScanOutX;
ScanChainX;
WriteMemX;
end

always @(TimingViol_initn) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end

always @(TimingViol_ig) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && INITNreg !== 0 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: IG pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   ScanChainX;
   ScanOutX;
   delScanOutX;       
  end
end

always @(TimingViol_atp) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin  
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_rm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^WMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: RM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
   end
end
 
always @(TimingViol_wm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^RMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);        
   end
end 


`endif


endmodule




module ST_SPREG_LOLEAK_512x20m4_Tl_lock_up_latch (EN,D,Q);
input EN,D;
output reg Q;

  always @ (EN or D) begin
    if (EN === 1) begin
       Q = D;
    end
    else if ((EN === 1'bz || EN === 1'bx  )&& D !== Q) begin
        Q=1'bx;
    end    
  end
endmodule

module ST_SPREG_LOLEAK_512x20m4_Tl_SCFF (D,TI,TE,CP,Q,OUTX);
input D,TI,TE,CP;
input OUTX;
output reg Q;
wire Dint;
assign Dint= (TE===1)?TI:(TE===0)?D:1'bx;

always @(posedge CP)
        begin
          if(Dint === 1'bZ || CP ===1'bx || OUTX === 1'bx)
          begin
                  Q = 1'bx;
          end
          else
          begin
                  Q = Dint;
          end        
        end
always @(posedge OUTX)
Q = 1'bx;
endmodule



`undef setup_time
`undef hold_time
`undef access_time
`undef retain_time
`undef cycle_time
`undef pulse_width_time
`undef initin_low_pulse


`delay_mode_path
`endcelldefine
`nosuppress_faults






/****************************************************************
--  Description         : Verilog Model 
--  ModelVersion        : 1.2
--  Date                : Apr, 2013
--  Changes Made by	: PS
--  Revision History    : 
 
****************************************************************/


/******************** START OF HEADER****************************
   This Header Gives Information about the parameters & options present in the Model
   
   words = 64
   bits  = 23
   mux   = 8 
   
   
   
   write_mask = no 
   
   margin_control = yes 
   
   
   Dft = Yes  

    ------------------------------------------------------------------------------------
     Signal Name             | Description       |             Port Mode        | Active When
                             |                   |          r    |  w   | rw    |
   ------------------------------------------------------------------------------------

    D 	        Data in                     na     x      na       -  
    IG    Input Gate Enable           x      x      na       High     
    ATP            ATPG Enable                 x      x      na       High     
    INITN                 INITN pin                   x      x      na       Low
    
    
     
    Q 	        Data out	            x      na     na       -
    A              Address                     x      x      na       high and low
    
    CK                Clock	                    x      x      na       posedge
    CSN          Chip Enable                 x      x      na       low
    
    RM         Read Margins                 x      x      na       High 
    SCTRLI         Scan Input (Control)
    SCTRLO        Scan Output (Control)
    SDLI         Scan Input (Data-Left)
    SDLO        Scan Output (Data-Left)
    SDRI         Scan Input (Data-Right)
    SDRO        Scan Output (Data-Right)
    SE          Scan Enable pin 
    STDBY              Standby pin                 x      x      na       High
    
    SLEEP                        Sleep pin                   x      x      na        High 
    
     
     
    TBIST          Bist Enable Pin 
    
    TBYPASS                      Memory Bypass                na     na     na        High
    
    TED        Bist Even Data pin
    TOD         Bist Odd Data Pin
     
    TA         Bist Read Address
    TCSN     Bist Read Chip Select
    
    TWEN    Bist Write Enable 
    WEN         Write Enable                na     x      na       Low 
    
    WM        Write Margins Code          x      x      na       -
     

******************** END OF HEADER ****************************/


//********************************************//
// ST_SPREG_LOLEAK_64x23m8_Tl Verilog Model                 //  
//********************************************//




`ifdef slm
        `define functional
`endif

`celldefine
`suppress_faults
  `ifdef functional
   `delay_mode_unit
  `else
   `delay_mode_path
  `endif

`define setup_time 0.0
`define hold_time 0.0
`define access_time 1.0
`define retain_time 0.9
`define cycle_time 0.0
`define pulse_width_time 0.0
`define initin_low_pulse 0.0



 






`timescale 1ns / 1ps


module ST_SPREG_LOLEAK_64x23m8_Tl (A,ATP,CK,CSN,D ,IG,INITN , Q ,RM    ,SCTRLI,SCTRLO,SDLI,SDLO,SDRI,SDRO,SE,SLEEP   , STDBY  ,TA,TBIST   ,TBYPASS ,TCSN,TED ,TOD   ,TWEN ,WEN,WM  );

 parameter
  Words = 64,
  Bits = 23,
  Addr = 6,
  mux = 8,
  repair_address_width = 3,
  write_margin_size = 2, 
  read_margin_size = 3; 

 //  INPUT OUTPUT PORTS DECLARATION DONE SEPARATELY FOR SPREG and ROM
 // ========================


        output [Bits-1 : 0] Q;
         
        output SCTRLO;
        input SE,SCTRLI;
        
        input [Addr-1 : 0] A;
        
        input [read_margin_size-1 : 0] RM;
        
         
        input CK,CSN,INITN,IG,ATP; 
        
        
        input [Addr-1 :0 ] TA;
input TBIST,TCSN ;
        
        input STDBY;
        
        input SLEEP; 
        
         
        
        
         
        output SDLO;
        output SDRO;
        
        
        
        
        input [Bits-1 : 0] D ;
	
          
         
        
        input [write_margin_size-1 : 0] WM;
        
        
        input TBYPASS;
        
        input WEN;
        
        
         
        input SDLI,SDRI  ; 
        
        
        
        //Bist inputs
        // ===========
        input TWEN,TED,TOD; 
        
        
        
        

        






    parameter
        Fault_file_name = "ST_SPREG_LOLEAK_64x23m8_Tl_faults.txt",
        `ifdef ConfigFault
        ConfigFault = 1,
        `else
        ConfigFault = 0,
        `endif
        max_faults = 66,
        
        MEM_INITIALIZE  = 1'b0,
        BinaryInit = 1'b0, 
        InitFileName = "ST_SPREG_LOLEAK_64x23m8_Tl.cde",
        Debug_mode = "all_warning_mode",
        File_load_time=0,
        Initn_reset_value={23{1'b0}},
        InstancePath = "ST_SPREG_LOLEAK_64x23m8_Tl";
    
    parameter
        
        bank = 1, 
        mux_bits=3,
        Red_extrabit=0,
        bank_bits = 0,
        RedWords = mux * 2 * bank,
        max_address_bits = 15 ,
        Rows = Words/mux;

  
    parameter 

     

        
           scanchains=3,    
          
        
        scanlen_ctrl=15,
        
        

      

        
        scanlen_r=(Bits)/2,
        
        scanlen_l=(Bits+1)/2 ; 
      
      

    parameter
        
        `ifdef functional  
            RW_assertions_en = 0,
        `endif
        WordX = {Bits{1'bx}},
        AddrX = {Addr{1'bx}},
        Word0 = {Bits{1'b0}},
        X = 1'bx;
   



//  WIRE DECLARATION RELATED TO POWER PINS
//  ======================================
	
        wire supply_ok, full_shutdown;
        
        wire core_supply_ok;
        wire peri_supply_ok;

        wire gndmint, gndsmint;
         
        
        wire vddmpint;
        wire vddmoint;
        wire vddmaint;
        wire vddsmpint;  
        wire vddsmaint;  
        
        

//  WIRE DECLARATION 
//  ==================
        wire [Bits-1 : 0] CSWEMTBYPASS;
        wire [Bits-1 : 0] Dint, Dsys;
        wire [Bits-1 : 0] Mint; 
        wire [23-1:0] Msys;
	wire [Addr-1 : 0] Aint;
        wire [Addr-1 : 0] Asys;

       


        wire [max_address_bits-1 : 0] A_int; 
                
	wire CKint_dft;
	wire CKint_func;
	wire CSNint;
        wire MEMEN;
        wire MEMEN_dft;
        wire TSE;

	wire WENint;
	wire WENsys;
        wire SLEEPint;
        wire STDBYint;
        wire SEint;
        wire SEsys;
        wire SCTRLIint;
        wire SDLIint;
        wire SDRIint;
        
        wire INITNint;
        wire TBYPASSint;
        wire TBYPASSsys;
        wire LSint; 
        wire HSint; 
        wire ATPint;
        wire DEint;
        
        wire [Addr-1 : 0] TAint;
        wire TBISTint;
        wire TBISTsys;
        wire TCSNint;
        wire TEDint;
        wire TODint;
        wire TEMint;
        wire TOMint;
        wire [Bits-1 : 0] TMint;
        wire [Bits-1 : 0] TDint;
        wire TWENint;
        wire IGint;
        wire IGbuf;
        wire CSNbuf;
        wire WENbuf;
        wire [read_margin_size-1:0] RMint;
        wire [write_margin_size-1:0] WMint;

        //Wires for scan chains
        //  ====================     
        wire [scanlen_ctrl -1:0]scanreg_ctrl_wire;
        wire [scanlen_l -1:0]  scanreg_dl_wire; 
        wire [scanlen_r -1:0]  scanreg_dr_wire; 
   
        wire [scanlen_l -1:0]  scanreg_ml_wire; 
        wire [scanlen_r -1:0]  scanreg_mr_wire; 


        wire [repair_address_width -1 : 0] RRAint;
        wire RRAEint;
        wire TRRAEint;    
        wire red_en;
        wire [repair_address_width -1 : 0] repair_add, next_repair_add;


//  REG DECLARATION
//  ====================     
        reg MEMEN_reg;
        reg MEMEN_prev;
        reg reg_mem_block;
        reg flag_mem_block;
        reg SCTRLIint_temp;
        reg SDLIint_temp;
        reg SDRIint_temp;
        reg SMLIint_temp;
        reg SMRIint_temp;

        //  REG DECLARATION
        //  ====================
        reg SCTRLOint;
        
        reg SDLOint,SDROint;
         
        
        reg next_cycle_corrupt_func;
        reg next_cycle_corrupt_dft;
        reg [Bits-1 : 0] delOutReg_data;//delayed Output Register
        reg [Bits-1 : 0] OutReg_data;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_tbypass;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_scan;   // Data Output registe
        reg [Bits-1 : 0] OutReg_rado_retained;   // register for retaining rado data when SLEEP --> 1
        reg delSCTRLO_data,SCTRLO_data;      // delayed Output Register
        reg delSDLO_data,SDLO_data;      // delayed Output Register
        reg delSDRO_data,SDRO_data;      // delayed Output Register
        
        
        // SCAN CHAINS register
        reg scanreg_ctrl; 
        reg scanreg_dl; 
        reg scanreg_dr; 
        
        
        reg CK_sc;
        reg Latch_open=0;
        reg lastCK_dft,CKreg_dft;
        reg lastCK_func,CKreg_func;
        reg lastSLEEP;
        reg lastPSWLARGEMP,lastPSWLARGEMA,lastPSWSMALLMP,lastPSWSMALLMA;
        reg CSNreg;
        reg init_pulse_done; //if == 1 then it implies that initb low pulse has been applied
        reg power_up_done; //if == 1 then it implies that power up has been done
        `ifdef slm
        `else
	      
             reg [Bits-1 : 0] Mem [Words-1 : 0];
             reg [Bits-1 : 0] RedMem [RedWords-1 : 0];
 
        `endif
        
	reg [Bits-1 :0] Mem_temp;
        reg [Bits-1 :0] Mem_slm; 
	reg ValidAddress;
	reg ValidDebugCode;
        reg decoding_start;
        reg file_loaded;
        reg [Bits-1 :0] Dreg;
        reg [Bits-1 :0] Mreg;
        reg WENreg;
        reg [Addr-1 :0] Areg;
        reg SE_reg;
        reg TBYPASS_reg;
        reg INITNreg;
        reg IGreg;
        reg DEreg;
        reg SLEEPreg;
        reg STDBYreg;
        reg ATPreg;
        reg MEMEN_dft_reg;
        reg MEMEN_dft_prev;
        reg RRMATCHreg;
        reg RRMATCHreg_last;//changes_made
        reg RRMATCHreg_glitch;
        reg [repair_address_width -1 : 0] repair_add_last;
        reg RRAEint_last;
        reg [Addr-mux_bits-1:0] row_add_temp;
        reg [Addr-mux_bits-bank_bits-1:0] row_add_cmp_temp;

       
        //parameter registers
        reg [2047:0] reg_Fault_file_name;
        reg reg_ConfigFault;
        reg reg_MEM_INITIALIZE;
        reg reg_BinaryInit;
        reg [2047:0] reg_InitFileName;
        reg [Bits -1 :0] reg_Initn_reset_value;
        time reg_File_load_time;

        //Power Supply Registers        
        reg vddmireg;
        reg vddmreg;
        reg vddsmreg;
        reg gndmreg;
        reg gndsmreg;   
        reg vddmpreg;
        reg vddmpireg;
        reg vddmareg;
        reg vddsmpreg;
        reg vddsmareg;
        reg vddmoreg;
        time vddmp_rise_time;
        time vddmp_fall_time;
        time vddsmp_rise_time;
        time vddsmp_fall_time;
        time vddma_rise_time;
        time vddma_fall_time;
        time vddsma_rise_time;
        time vddsma_fall_time;
        reg reg_check_rise;
        reg reg_check_fall;
        reg reg_check_rise_vddma;
        reg reg_check_fall_vddsma;
        reg  reg_check_rise_vddm, reg_check_fall_vddsm ;
        time vddm_fall_time,  vddm_rise_time,  vddsm_fall_time, vddsm_rise_time ;
  /* This register is used to force all warning messages 
  ** OFF during run time.
  ** It is a 2 bit register.
  ** USAGE :
  ** debug_level_off = 2'b00 -> ALL MESSAGES(INFO/WARNINGS/ERRORS) will be DISPLAYED 
  ** debug_level = 2'b01     -> ONLY WARNINGS/ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b10     -> ONLY ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b11     -> NO MESSAGES will be DISPLAYED.
  */ 
        reg [1:0] debug_level;
        reg [8*10: 0] operating_mode;
        reg [8*44: 0] message_status;

        integer i, k, j, l,m,q,w,r,s,num1,redcnt,n,num2,FirstHalf,Bfaileff,memcnt,ptr;
        integer decoder[Bits-1:0];
        `ifdef slm
           integer MemAddr;
        `endif


        //************************************************************
        //****** CONFIG FAULT IMPLEMENTATION VARIABLES*************** 
        //************************************************************ 

        integer file_ptr, ret_val;
        integer fault_word;
        integer fault_bit;
        integer fcnt, Fault_in_memory,faultnum,stop_loop,count;
        integer t;  
        integer FailureLocn [max_faults -1 :0];
        integer Failurebit [max_faults -1 :0];
        reg [100 : 0] stuck_at;
        reg [100 : 0] fault_array;
        reg [200 : 0] tempStr;
        reg [7:0] fault_char;
        reg [7:0] fault_char1; // 8 Bit File Pointer
        reg [Addr -1 : 0] std_fault_word;
        reg [Addr -1 : mux_bits] fault_row_add [max_faults -1 :0];
        reg [max_faults -1 :0] fault_repair_flag;
        reg [max_faults -1 :0] dont_insert_fault;
        reg [max_faults -1 :0] repair_flag;
        reg [100 : 0] array_stuck_at[max_faults -1 : 0] ;
        reg [100 : 0] mem_red_array_stuck_at[max_faults -1 : 0] ; 
        reg msgcnt;
        
       
        reg [Bits - 1: 0] stuck_at_0fault [max_faults -1 : 0];
        reg [Bits - 1: 0] stuck_at_1fault [max_faults -1 : 0];
        reg [Bits -1 : 0] stuck0;
        reg [Bits -1 : 0] stuck1;

        reg [Bits+Red_extrabit :0] Mem_last;
        

        `ifdef slm
        reg [Bits -1 : 0] slm_temp_data;
        `endif
        
        real time_CK_func_rise , time_RADCK_rise;
        real time_fall_sleep,time_fall_PSWLARGEMP,time_fall_PSWLARGEMP_0,time_fall_PSWLARGEMA,time_fall_PSWLARGEMA_0,time_fall_PSWSMALLMP,time_fall_PSWSMALLMA;
        integer flag_error;
        
//BUFFER INSTANTIATION
//=========================
       `ifdef functional
       
         buf (SCTRLO,delSCTRLO_data); 
         buf bufq [Bits-1:0] (Q,delOutReg_data);
      `else
       
         buf (SCTRLO,SCTRLO_data);
         buf bufq [Bits-1:0] (Q,OutReg_data);
      `endif
      
  
        buf (SEsys,SE);
	buf (SCTRLIint, SCTRLI);
   

	buf (CKint_func, CK);
	buf (CKint_dft, CK);
        buf bufaddr [Addr-1:0] (Asys,A);
        buf (INITNint,INITN);
        
        buf (LSint,1'b0); 
        buf (IGbuf,IG);
        buf (ATPint,ATP);

        buf bufTaddr [Addr-1 : 0] (TAint,TA);
        buf (TBISTsys,TBIST);
        buf (TCSNint,TCSN);

        buf (CSNsys,CSN);
        buf (STDBYint,STDBY );   
        
        buf (SLEEPint,SLEEP ); 

        buf bufrm [read_margin_size-1:0] (RMint, RM); 

        
        

        assign RRAEint = 1'b0;
        assign TRRAEint = 1'b0;
        assign repair_add = 0;
        assign next_repair_add = 0;
        assign red_en = 1'b0; 
        
        
        
        
        
        
        
        buf (PSWLARGEMPint,1'b0);
        buf (PSWSMALLMPint,1'b0); 
        buf (PSWLARGEMAint,1'b0);
        buf (PSWSMALLMAint,1'b0);   

      `ifdef functional
       
       
         buf (SDLO,delSDLO_data);
         buf (SDRO,delSDRO_data);
        
      `else
       
         buf (SDLO,SDLO_data);
         buf (SDRO,SDRO_data);
         
      `endif
       
         
       
        buf bufdata [Bits-1:0] (Dsys,D);
        
        
        assign Msys=23'b0; 
	

        
        buf (TBYPASSsys, TBYPASS);
        


        buf (WENsys,WEN);
	 
	buf (SDLIint, SDLI);
	buf (SDRIint, SDRI);
	 
        
        buf (HSint,1'b0); 

        
        buf (TEDint,TED);
        buf (TODint,TOD);
         
        buf (TWENint,TWEN);
        
        
        buf bufwm [write_margin_size-1:0] (WMint, WM); 
        



//      assign scanreg_ctrl_wire={scanreg_ctrl[scanlen_ctrl - 2:0],SCTRLIint};
//      assign scanreg_dl_wire={scanreg_dl[scanlen_l - 2:0],SDLIint};
//      assign scanreg_dr_wire={scanreg_dr[scanlen_r - 2:0],SDRIint};
      
        
      assign Aint   = (TBISTint === 1'b0 ) ? Asys : (TBISTint === 1'bx ) ? {Addr{1'bx}} : TAint;  

        
//        assign A_int = Aint;
	
        
                
        assign Dint[0] = (TBISTint === 1'b0) ? Dsys[0] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[1] = (TBISTint === 1'b0) ? Dsys[1] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[2] = (TBISTint === 1'b0) ? Dsys[2] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[3] = (TBISTint === 1'b0) ? Dsys[3] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[4] = (TBISTint === 1'b0) ? Dsys[4] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[5] = (TBISTint === 1'b0) ? Dsys[5] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[6] = (TBISTint === 1'b0) ? Dsys[6] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[7] = (TBISTint === 1'b0) ? Dsys[7] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[8] = (TBISTint === 1'b0) ? Dsys[8] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[9] = (TBISTint === 1'b0) ? Dsys[9] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[10] = (TBISTint === 1'b0) ? Dsys[10] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[11] = (TBISTint === 1'b0) ? Dsys[11] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[12] = (TBISTint === 1'b0) ? Dsys[12] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[13] = (TBISTint === 1'b0) ? Dsys[13] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[14] = (TBISTint === 1'b0) ? Dsys[14] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[15] = (TBISTint === 1'b0) ? Dsys[15] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[16] = (TBISTint === 1'b0) ? Dsys[16] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[17] = (TBISTint === 1'b0) ? Dsys[17] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[18] = (TBISTint === 1'b0) ? Dsys[18] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[19] = (TBISTint === 1'b0) ? Dsys[19] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[20] = (TBISTint === 1'b0) ? Dsys[20] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[21] = (TBISTint === 1'b0) ? Dsys[21] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[22] = (TBISTint === 1'b0) ? Dsys[22] : (TBISTint === 1'b1) ? TEDint : 1'bx;          
	 
        assign Mint = 23'b0;
         

        assign WENbuf = (TBISTint === 1'b0 ) ? WENsys : (TBISTint === 1'bx ) ? 1'bx : TWENint;  
        assign WENint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? WENbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[13] : (ATPint === 1'b0 ) ? WENsys : 1'bx ; 
        
        assign CSNbuf = (TBISTint === 1'b0 ) ? CSNsys : (TBISTint === 1'bx ) ? 1'bx : TCSNint;  
        assign CSNint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? CSNbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[11] : (ATPint === 1'b0 ) ? CSNsys : 1'bx ; 
        assign IGint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? IGbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[14] : (ATPint === 1'b0 ) ? IGbuf : 1'bx;

        
        assign DEint = (LSint === 1'bx || (LSint === 1'b0 && HSint === 1'bx) || ^RMint !== 1'b0 || ^WMint !== 1'b0 ) ? 1'bx : 1'b0;
        
     
     and (TBISTint, ATPint, TBISTsys);
     and (SEint, ATPint, SEsys);
     and (TBYPASSint, ATPint, TBYPASSsys);
     and (TSE,TBYPASSint,!SEsys);
     and (MEMEN,INITNint,!CSNint,!SLEEPint,!TBYPASSint,!SEint,!IGint,!DEint,!STDBYint );
     and (MEMEN_dft,INITNint, !SLEEPint, ATPint,!STDBYint);

 `ifdef functional
/*****************assertions added to optimize dynamic power consumption**********/

//psl a_M: assert always ({( RW_assertions_en);(MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1))  } |-> (stable(Msys))) @(posedge CK); 

//psl a_WEN: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(WENsys))) @(posedge CK); 

//psl a_A: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(Asys))) @(posedge CK); 

//psl a_D: assert always ({( RW_assertions_en);((MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1)) && TBYPASSint === 1'b0)  } |-> (stable(Dsys))) @(posedge CK); 

/**********************************************************************************************/
`endif       

     

         
reg vddmp,vddmo, vddma, vddsmp, vddsma, gndsm, gndm,  vddmpi ; 
 
initial 
begin

        vddmp = 1'b1 ; 
        vddmo = 1'b1 ;
        vddma = 1'b1 ;
        
        vddsmp = 1'b1 ;
        
        
         gndm = 1'b0 ;
          
end

        
         assign gndmint = (reg_mem_block === 0) ? gndm : 1'b1;
         
         
         
         
         assign vddmpint = vddmp;
         assign vddmoint = vddmo;
         assign vddmaint = vddma;
         
          
        
         

        //CPF Changes

        
                
        initial
        begin : cpfvddmp 
           vddmpreg = vddmpint;
        end

        always @(vddmpint) begin
           vddmpreg = vddmpint;
        end
        
        initial
        begin : cpfvddmo 
           vddmoreg = vddmoint;
        end

        always @(vddmoint) begin
           vddmoreg = vddmoint;
        end
        
        initial
        begin : cpfvddma 
           vddmareg = vddmaint;
        end

        always @(vddmaint) begin
           vddmareg = vddmaint;
        end

        
        
 
        initial
        begin : cpfgndm 
           gndmreg = gndmint;
        end

        always @(gndmint) begin
           gndmreg = gndmint;
        end

        
        



 `ifdef functional
  `else
  initial begin
    if (debug_level < 1) begin
     $display ("%m  INFORMATION");
     $display ("***************************************");
     $display ("The Model is Operating in TIMING MODE");
     $display ("Please make sure that SDF is properly annotated otherwise dummy values will be used");
     $display ("%s", message_status);
     $display ("***************************************");
    end
  end

//////////////////////////
 //REG DECLARATIONS
   //======================

   reg [Bits-1 : 0] TimingViol_data;
   reg  [Bits-1 : 0] TimingViol_mask;
   reg [Bits-1 : 0] TimingViol_data_last, TimingViol_mask_last;
	reg TimingViol_data_0;
	reg TimingViol_data_1;
	reg TimingViol_data_2;
	reg TimingViol_data_3;
	reg TimingViol_data_4;
	reg TimingViol_data_5;
	reg TimingViol_data_6;
	reg TimingViol_data_7;
	reg TimingViol_data_8;
	reg TimingViol_data_9;
	reg TimingViol_data_10;
	reg TimingViol_data_11;
	reg TimingViol_data_12;
	reg TimingViol_data_13;
	reg TimingViol_data_14;
	reg TimingViol_data_15;
	reg TimingViol_data_16;
	reg TimingViol_data_17;
	reg TimingViol_data_18;
	reg TimingViol_data_19;
	reg TimingViol_data_20;
	reg TimingViol_data_21;
	reg TimingViol_data_22;
 reg TimingViol_mask_0;
 reg TimingViol_mask_1;
 reg TimingViol_mask_2;
 reg TimingViol_mask_3;
 reg TimingViol_mask_4;
 reg TimingViol_mask_5;
 reg TimingViol_mask_6;
 reg TimingViol_mask_7;
 reg TimingViol_mask_8;
 reg TimingViol_mask_9;
 reg TimingViol_mask_10;
 reg TimingViol_mask_11;
 reg TimingViol_mask_12;
 reg TimingViol_mask_13;
 reg TimingViol_mask_14;
 reg TimingViol_mask_15;
 reg TimingViol_mask_16;
 reg TimingViol_mask_17;
 reg TimingViol_mask_18;
 reg TimingViol_mask_19;
 reg TimingViol_mask_20;
 reg TimingViol_mask_21;
 reg TimingViol_mask_22;

   reg TimingViol_addr;
   reg TimingViol_CSN, TimingViol_WEN, TimingViol_tbypass;
   reg TimingViol_tckh, TimingViol_tckl, TimingViol_tcycle;
   reg TimingViol_tckh_se, TimingViol_tckl_se, TimingViol_tcycle_se;
   reg TimingViol_sctrli,TimingViol_sdli,TimingViol_sdri,TimingViol_se;
   reg TimingViol_smli,TimingViol_smri;
   reg TimingViol_sctrli_flag,TimingViol_sdli_flag,TimingViol_sdri_flag;
   reg TimingViol_smli_flag,TimingViol_smri_flag;
   reg TimingViol_initnl;
   reg TimingViol_initn;
   reg TimingViol_ls;
   reg TimingViol_hs;
   reg TimingViol_sleep;
   reg TimingViol_stdby;
   reg TimingViol_rm;
   reg TimingViol_wm;
   reg TimingViol_tbist,TimingViol_ig,TimingViol_atp,TimingViol_TED,TimingViol_TOD,TimingViol_TEM,TimingViol_TOM;
   reg TimingViolRRAE,TimingViolRRA;

   wire CSTBYPASSN,cond_sdf_tas,cond_sdf_tds,cond_sdf_tms,cond_sdf_tws,cond_sdf_tbas,cond_sdf_tbps,cond_sdf_tbws,cond_sdf_tbdes,cond_sdf_tbdos,cond_sdf_tbmes,cond_sdf_tbmos;
   wire SETB_EN,CSIG_EN,MEM_ACT,EN_ADM,CS_EN,CS_ADM,cond_sdf_tps,IG_EN,IG_ADM,cond_sdf_tigs,cond_sdf_taa,cond_sdf_taa_ls1,cond_sdf_taa_hs1,cond_tseq_tm;
   wire cond_sdf_tcycle,cond_sdf_tcycle_ls1,cond_sdf_tcycle_hs1,cond_sdf_tcycle_se,cond_sdf_tckl_se,cond_sdf_tsctrlis,cond_sdf_tsdlis,cond_sdf_tsdris,cond_sdf_tsmlis,cond_sdf_tsmris;
   wire cond_sdf_tckh_se,cond_sdf_taa_sctrlo_se,cond_sdf_taa_sdlo_se,cond_sdf_taa_sdro_se,cond_sdf_taa_smlo_se,cond_sdf_taa_smro_se,cond_sdf_tckl,cond_sdf_tckh;
   wire cond_sdf_ttms,cond_sdf_tbists,INITNandnotSLEEPandATPandnotSE,cond_sdf_taa_sctrlo,cond_sdf_taa_sdlo,cond_sdf_taa_sdro,cond_sdf_taa_smlo,cond_sdf_taa_smro;
   wire cond_sdf_taa_tm,cond_sdf_taa_tm_ls1, cond_sdf_taa_tm_hs1,cond_sdf_taa_tckq_tm,cond_sdf_taa_tseq_tm;

   wire CSWETBYPASSN;
   wire cond_sdf_tstdbys,cond_sdf_tsls,sleep_en,atp_csn_en;
   wire cond_sdf_tlss,cond_sdf_thss,cond_sdf_trms,cond_sdf_twms; 
   wire cond_sdf_tses,cond_sdf_tinitns;
   wire tby_se_en;
   wire rra_en;
   wire tbist_atp_en;
   wire rrae_en;
   wire tbist_rrae_en;
   wire cond_sdf_trraes;
   wire cond_sdf_ttrraes;
   wire cond_sdf_taa_trramatch;
   wire cond_sdf_ttrraematch;
   wire cond_sdf_tamatch;
   wire cond_sdf_ttamatch;
   wire cond_sdf_tatpmatch;
   wire cond_sdf_ttbistmatch;



 and (CSWEMTBYPASS[0], !Mreg[0], CSWETBYPASSN);
 and (CSWEMTBYPASS[1], !Mreg[1], CSWETBYPASSN);
 and (CSWEMTBYPASS[2], !Mreg[2], CSWETBYPASSN);
 and (CSWEMTBYPASS[3], !Mreg[3], CSWETBYPASSN);
 and (CSWEMTBYPASS[4], !Mreg[4], CSWETBYPASSN);
 and (CSWEMTBYPASS[5], !Mreg[5], CSWETBYPASSN);
 and (CSWEMTBYPASS[6], !Mreg[6], CSWETBYPASSN);
 and (CSWEMTBYPASS[7], !Mreg[7], CSWETBYPASSN);
 and (CSWEMTBYPASS[8], !Mreg[8], CSWETBYPASSN);
 and (CSWEMTBYPASS[9], !Mreg[9], CSWETBYPASSN);
 and (CSWEMTBYPASS[10], !Mreg[10], CSWETBYPASSN);
 and (CSWEMTBYPASS[11], !Mreg[11], CSWETBYPASSN);
 and (CSWEMTBYPASS[12], !Mreg[12], CSWETBYPASSN);
 and (CSWEMTBYPASS[13], !Mreg[13], CSWETBYPASSN);
 and (CSWEMTBYPASS[14], !Mreg[14], CSWETBYPASSN);
 and (CSWEMTBYPASS[15], !Mreg[15], CSWETBYPASSN);
 and (CSWEMTBYPASS[16], !Mreg[16], CSWETBYPASSN);
 and (CSWEMTBYPASS[17], !Mreg[17], CSWETBYPASSN);
 and (CSWEMTBYPASS[18], !Mreg[18], CSWETBYPASSN);
 and (CSWEMTBYPASS[19], !Mreg[19], CSWETBYPASSN);
 and (CSWEMTBYPASS[20], !Mreg[20], CSWETBYPASSN);
 and (CSWEMTBYPASS[21], !Mreg[21], CSWETBYPASSN);
 and (CSWEMTBYPASS[22], !Mreg[22], CSWETBYPASSN);

and (atp_csn_en,!ATPint,!CSNint,!IGint);
or (sleep_en,atp_csn_en,ATPint);
or (SETB_EN,SEint,TBISTint);
and (ATP_SETB_EN,ATPint,SETB_EN); 
or (CSIG_EN,IGint,CSNint);
and (MEM_ACT,!ATPint,CSIG_EN);
or (EN_ADM,MEM_ACT,ATP_SETB_EN);
and (CS_EN,!ATPint,IGint);
or (CS_ADM,CS_EN,ATP_SETB_EN);
and (atp_ig_csn_en,!ATPint,!CSNint,!IGint);
and (atp_se_en,!SEsys,ATPint);
or (cycle_en,atp_ig_csn_en,atp_se_en);
and (atp_ig_csn_en_reg,!ATPreg,!CSNreg,!IGreg);
and (atp_se_en_reg,!SE_reg,ATPreg);
or (cycle_en_reg,atp_ig_csn_en,atp_se_en);
and (INITNandnotSLEEPandATPandnotSE,cond_gac,!SEsys,ATPint);
and (csn_ig_en,!IGint,!CSNint);
and (atp_tby_ls_en,atp_se_en,cond_ls_tby_en);
and (IG_EN,!ATPint,!CSNint);
or (IG_ADM,IG_EN,atp_se_en);
and (CSWETBYPASSN, !WENreg, 1'b1);



assign cond_sdf_tsls=((sleep_en && INITNint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tstdbys=((sleep_en && INITNint && !SLEEPint) !==0) ? 1:0;
assign cond_sdf_atps=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_gac=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tas=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tds=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tms=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tws=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tps=((cond_gac && !CS_ADM) !==0) ? 1:0;
assign cond_sdf_tcycle=((cond_gac && cycle_en && !LSint && !HSint) !==0) ? 1:0;  
assign cond_sdf_tcycle_ls1=((cond_gac && cycle_en && LSint) !==0) ? 1:0;
assign cond_sdf_tcycle_hs1=((cond_gac && cycle_en && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_tckh=((cond_gac && cycle_en_reg) !==0) ? 1:0;
assign cond_sdf_tckl=((cond_gac && cycle_en) !==0) ? 1:0;
assign cond_sdf_tcycle_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckl_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsctrlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckh_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_ttms=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_tbists=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_tckq_tm=((cond_gac && SE_reg && ATPreg && TBYPASSsys) !==0) ? 1:0;
assign cond_ls_en=((atp_ig_csn_en || atp_tby_ls_en) !==0) ? 1:0;
assign cond_sdf_tlss=((cond_ls_en && cond_gac) !==0) ? 1:0;
assign cond_sdf_thss=((cond_ls_en && cond_gac && !LSint) !==0) ? 1:0;
assign cond_sdf_trms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_twms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_tses=((cond_gac && ATPint) !==0) ? 1:0;
assign cond_sdf_tbas=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbps=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbws=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tigs=((cond_gac && IG_ADM) !==0) ? 1:0;
assign cond_sdf_taa=((MEMEN_reg && WENreg && !LSint && !HSint) !==0) ? 1:0; 
// assign cond_sdf_taa_tbypass_q = ((MEMEN_reg && ATPint && TBYPASSint) !== 1'b0) ? 1'b1 : 1'b0;
assign cond_sdf_taa_ls1=((MEMEN_reg && WENreg && LSint) !==0) ? 1:0; 
assign cond_sdf_taa_hs1=((MEMEN_reg && WENreg && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && !HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_ls1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && LSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_hs1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tseq_tm=((cond_gac && TBYPASSint) !==0) ? 1:0;
assign cond_sdf_tinitns =(( sleep_en && !STDBYint && !SLEEPint) !==0) ? 1:0;
assign cond_ls_tby_en=((TBYPASSsys || csn_ig_en) !==0) ? 1:0;



//specify block begins

specify
    specparam
    
         PATHPULSE$CK$Q = 0,
         PATHPULSE$CK$SCTRLO = 0,

         PATHPULSE$CK$SDLO = 0,
         PATHPULSE$CK$SDRO = 0,
        
         PATHPULSE$SE$Q = 0,
         
//         PATHPULSE$TBYPASS$Q = 0,


        
         
        
         tsls = `setup_time,
         tslh = `hold_time ,
         tstdbys = `setup_time,
         tstdbyh = `hold_time , 
	 

         
         tcycle = `cycle_time,
         
         
         tckh = `pulse_width_time,
         tckl = `pulse_width_time,
         tcycle_se = `cycle_time,
         tckh_se = `pulse_width_time,
         tckl_se = `pulse_width_time,
         
         ttms = `setup_time,
         ttmh = `hold_time ,
         tps = `setup_time,
         tph = `hold_time ,
         tws = `setup_time,
         twh = `hold_time ,
         tds = `setup_time,
         tdh = `hold_time , 
         tas = `setup_time,
         tah = `hold_time ,
         tses= `setup_time,
         tseh= `hold_time ,
         tsctrlis=`setup_time,
         tsctrlih=`hold_time ,
         tsdlis=`setup_time,
         tsdlih=`hold_time ,
         tsdris=`setup_time,
         tsdrih=`hold_time , 
         tbists=`setup_time,
         tbisth=`hold_time ,
         tbps=`setup_time,
         tbph=`hold_time ,
         tbws=`setup_time,
         tbwh=`hold_time ,
         tbdes=`setup_time,
         tbdeh=`hold_time ,
         tbdos=`setup_time,
         tbdoh=`hold_time ,
         
         tbas=`setup_time,
         tbah=`hold_time ,
         tinitnl=`initin_low_pulse,
         tinitns=`setup_time,
         tinitnh=`hold_time ,
         tatps=`setup_time,
         tatph=`hold_time ,
         tigs=`setup_time,
         tigh=`hold_time ,
         
         
         trms=`setup_time,
         trmh=`hold_time ,
         twms=`setup_time,
         twmh=`hold_time , 

/*************************************************************************************************/
           // taa_tbypass_q = `access_time,
           // th_tbypass_q  = `retain_time,
            taa =`access_time,
            th = `retain_time,

 


            taa_tm =`access_time,
            th_tm = `retain_time,

            
            taa_tseq_tm =`access_time,
            th_tseq_tm = `retain_time,
            taa_tckq_tm   = `access_time,
            th_tckq_tm    = `retain_time,
            taa_sctrlo=`access_time,
            th_sctrlo= `retain_time,
            taa_sdlo=`access_time,
            th_sdlo= `retain_time,
            taa_sdro=`access_time,
            th_sdro= `retain_time,
            
         
            taa_sctrlo_se=`access_time,
            th_sctrlo_se= `retain_time
,
            taa_sdlo_se=`access_time,
            th_sdlo_se= `retain_time,
            taa_sdro_se=`access_time,
            th_sdro_se= `retain_time
         ;  


        /*---------------------- Timing Checks ---------------------*/

	$setup(posedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[5], tah, TimingViol_addr);

	$setup(posedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(posedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(posedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(posedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(posedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(posedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(posedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(posedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(posedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(posedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(posedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(posedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(posedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(posedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(posedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(posedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(posedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(posedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(posedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(posedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(posedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(posedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$setup(posedge D[22], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_22);
	$setup(negedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(negedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(negedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(negedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(negedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(negedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(negedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(negedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(negedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(negedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(negedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(negedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(negedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(negedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(negedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(negedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(negedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(negedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(negedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(negedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(negedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(negedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$setup(negedge D[22], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_22);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[21], tdh, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[22], tdh, TimingViol_data_22);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[21], tdh, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[22], tdh, TimingViol_data_22);

        



        $setup(posedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $setup(negedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, posedge WEN, twh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, negedge WEN, twh, TimingViol_WEN); 
        $setup(posedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$setup(negedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, posedge CSN, tph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, negedge CSN, tph, TimingViol_CSN);
        $period(posedge CK &&& cond_sdf_tcycle, tcycle, TimingViol_tcycle);  

        
        $width(posedge CK  &&& cond_sdf_tckh, tckh, 0, TimingViol_tckh);
        $width(negedge CK  &&& cond_sdf_tckl, tckl, 0, TimingViol_tckl);
        $period(posedge CK &&& cond_sdf_tcycle_se, tcycle_se, TimingViol_tcycle_se);
        $width(posedge CK  &&& cond_sdf_tckh_se, tckh_se, 0, TimingViol_tckh_se);
        $width(negedge CK  &&& cond_sdf_tckl_se, tckl_se, 0, TimingViol_tckl_se);

        
        $setup(posedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $setup(negedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $hold(posedge CK &&& cond_sdf_ttms, posedge TBYPASS, ttmh, TimingViol_tbypass); 
        $hold(posedge CK &&& cond_sdf_ttms, negedge TBYPASS, ttmh, TimingViol_tbypass); 
 



        
        $setup(posedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $setup(negedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $hold(posedge CK &&& cond_sdf_tsls, posedge SLEEP, tslh, TimingViol_sleep);        
        $hold(posedge CK &&& cond_sdf_tsls, negedge SLEEP, tslh, TimingViol_sleep);

        $setup(posedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $setup(negedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $hold(posedge CK &&& cond_sdf_tstdbys, posedge STDBY, tstdbyh, TimingViol_stdby);        
        $hold(posedge CK &&& cond_sdf_tstdbys, negedge STDBY, tstdbyh, TimingViol_stdby); 
        
        
        $setup (posedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
	$setup (negedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
        
        $hold (posedge CK &&& cond_sdf_tses, posedge SE ,tseh,TimingViol_se);
	$hold (posedge CK &&& cond_sdf_tses, negedge SE ,tseh,TimingViol_se);
        
        $setup(posedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis , tsctrlis, TimingViol_sctrli);
        $setup(negedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis, tsctrlis, TimingViol_sctrli);
        $hold(posedge CK &&& cond_sdf_tsctrlis , posedge SCTRLI, tsctrlih, TimingViol_sctrli);        
        $hold(posedge CK &&& cond_sdf_tsctrlis , negedge SCTRLI, tsctrlih, TimingViol_sctrli);

        $setup(posedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $setup(negedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $hold(posedge CK &&& cond_sdf_tsdlis, posedge SDLI, tsdlih, TimingViol_sdli);        
        $hold(posedge CK &&& cond_sdf_tsdlis, negedge SDLI, tsdlih, TimingViol_sdli);

        $setup(posedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $setup(negedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $hold(posedge CK &&& cond_sdf_tsdris, posedge SDRI, tsdrih, TimingViol_sdri);        
        $hold(posedge CK &&& cond_sdf_tsdris, negedge SDRI, tsdrih, TimingViol_sdri);
        
 
	
         
        $width(negedge INITN , tinitnl, 0, TimingViol_initnl);
        
        $setup(posedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        $setup(negedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        
        $hold (posedge CK &&& cond_sdf_tinitns,posedge INITN, tinitnh, TimingViol_initn);
        $hold (posedge CK &&& cond_sdf_tinitns,negedge INITN, tinitnh, TimingViol_initn);

        $setup(posedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $setup(negedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $hold(posedge CK &&& cond_sdf_atps, posedge ATP, tatph, TimingViol_atp);        
        $hold(posedge CK &&& cond_sdf_atps, negedge ATP, tatph, TimingViol_atp);
        
        $setup(posedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $setup(negedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $hold(posedge CK &&& cond_sdf_tigs, posedge IG, tigh, TimingViol_ig);        
        $hold(posedge CK &&& cond_sdf_tigs, negedge IG, tigh, TimingViol_ig);



         
$setup(posedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[2], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[2], trmh, TimingViol_rm); 

        
$setup(posedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(posedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[1], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[1], twmh, TimingViol_wm);
 
        
        $setup(posedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $setup(negedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $hold(posedge CK &&& cond_sdf_tbists, posedge TBIST, tbisth, TimingViol_tbist);        
        $hold(posedge CK &&& cond_sdf_tbists, negedge TBIST, tbisth, TimingViol_tbist);
        
        	$setup(posedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$setup(negedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[5], tbah, TimingViol_addr);
       	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[5], tbah, TimingViol_addr);

        $setup(posedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$setup(negedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, posedge TCSN, tbph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, negedge TCSN, tbph, TimingViol_CSN); 
       
        $setup(posedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $setup(negedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, posedge TWEN, tbwh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, negedge TWEN, tbwh, TimingViol_WEN);
       
       
        $setup(posedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $setup(negedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, posedge TED, tbdeh, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, negedge TED, tbdeh, TimingViol_TED);

        $setup(posedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $setup(negedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, posedge TOD, tbdoh, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, negedge TOD, tbdoh, TimingViol_TOD);

          


          

          /*-------------------- Propagation Delays ------------------*/
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[22] +: OutReg_data[22])) = (taa, taa, th, taa, th, taa);
                 

/* // //	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[0] +: OutReg_data[0])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[1] +: OutReg_data[1])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[2] +: OutReg_data[2])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[3] +: OutReg_data[3])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[4] +: OutReg_data[4])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[5] +: OutReg_data[5])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[6] +: OutReg_data[6])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[7] +: OutReg_data[7])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[8] +: OutReg_data[8])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[9] +: OutReg_data[9])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[10] +: OutReg_data[10])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[11] +: OutReg_data[11])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[12] +: OutReg_data[12])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[13] +: OutReg_data[13])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[14] +: OutReg_data[14])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[15] +: OutReg_data[15])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[16] +: OutReg_data[16])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[17] +: OutReg_data[17])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[18] +: OutReg_data[18])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[19] +: OutReg_data[19])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[20] +: OutReg_data[20])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[21] +: OutReg_data[21])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[22] +: OutReg_data[22])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q); */ 








	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[22] +: OutReg_data[22])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                





	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[22] +: OutReg_data[22])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[22] +: OutReg_data[22])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                 

	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[0] +: OutReg_data[0])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[1] +: OutReg_data[1])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[2] +: OutReg_data[2])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[3] +: OutReg_data[3])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[4] +: OutReg_data[4])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[5] +: OutReg_data[5])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[6] +: OutReg_data[6])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[7] +: OutReg_data[7])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[8] +: OutReg_data[8])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[9] +: OutReg_data[9])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[10] +: OutReg_data[10])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[11] +: OutReg_data[11])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[12] +: OutReg_data[12])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[13] +: OutReg_data[13])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[14] +: OutReg_data[14])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[15] +: OutReg_data[15])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[16] +: OutReg_data[16])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[17] +: OutReg_data[17])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[18] +: OutReg_data[18])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[19] +: OutReg_data[19])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[20] +: OutReg_data[20])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[21] +: OutReg_data[21])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[22] +: OutReg_data[22])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                



if (cond_sdf_taa_sctrlo) 
        (posedge CK *> (SCTRLO :  SCTRLI)) = (taa_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo); 

if (cond_sdf_taa_sctrlo_se) 
        (negedge CK *> (SCTRLO : SCTRLI)) = (taa_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se); 
 

if (cond_sdf_taa_sdlo) 
        (posedge CK *> (SDLO :  SDLI)) = (taa_sdlo,taa_sdlo,th_sdlo,taa_sdlo,th_sdlo,taa_sdlo); 

if (cond_sdf_taa_sdlo_se) 
        (negedge CK *> (SDLO : SDLI)) = (taa_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se);

if (cond_sdf_taa_sdro) 
        (posedge CK *> (SDRO :  SDRI)) = (taa_sdro,taa_sdro,th_sdro,taa_sdro,th_sdro,taa_sdro); 

if (cond_sdf_taa_sdro_se) 
        (negedge CK *> (SDRO : SDRI)) = (taa_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se); 

  
     




endspecify //specify block ends






// conversion from registers to array elements for data setup violation notifiers

always @(TimingViol_data_0   or TimingViol_TED  )
begin
        TimingViol_data[0]=~TimingViol_data[0];   
end


always @(TimingViol_data_1   or TimingViol_TOD  )
begin
        TimingViol_data[1]=~TimingViol_data[1];   
end


always @(TimingViol_data_2   or TimingViol_TED  )
begin
        TimingViol_data[2]=~TimingViol_data[2];   
end


always @(TimingViol_data_3   or TimingViol_TOD  )
begin
        TimingViol_data[3]=~TimingViol_data[3];   
end


always @(TimingViol_data_4   or TimingViol_TED  )
begin
        TimingViol_data[4]=~TimingViol_data[4];   
end


always @(TimingViol_data_5   or TimingViol_TOD  )
begin
        TimingViol_data[5]=~TimingViol_data[5];   
end


always @(TimingViol_data_6   or TimingViol_TED  )
begin
        TimingViol_data[6]=~TimingViol_data[6];   
end


always @(TimingViol_data_7   or TimingViol_TOD  )
begin
        TimingViol_data[7]=~TimingViol_data[7];   
end


always @(TimingViol_data_8   or TimingViol_TED  )
begin
        TimingViol_data[8]=~TimingViol_data[8];   
end


always @(TimingViol_data_9   or TimingViol_TOD  )
begin
        TimingViol_data[9]=~TimingViol_data[9];   
end


always @(TimingViol_data_10   or TimingViol_TED  )
begin
        TimingViol_data[10]=~TimingViol_data[10];   
end


always @(TimingViol_data_11   or TimingViol_TOD  )
begin
        TimingViol_data[11]=~TimingViol_data[11];   
end


always @(TimingViol_data_12   or TimingViol_TED  )
begin
        TimingViol_data[12]=~TimingViol_data[12];   
end


always @(TimingViol_data_13   or TimingViol_TOD  )
begin
        TimingViol_data[13]=~TimingViol_data[13];   
end


always @(TimingViol_data_14   or TimingViol_TED  )
begin
        TimingViol_data[14]=~TimingViol_data[14];   
end


always @(TimingViol_data_15   or TimingViol_TOD  )
begin
        TimingViol_data[15]=~TimingViol_data[15];   
end


always @(TimingViol_data_16   or TimingViol_TED  )
begin
        TimingViol_data[16]=~TimingViol_data[16];   
end


always @(TimingViol_data_17   or TimingViol_TOD  )
begin
        TimingViol_data[17]=~TimingViol_data[17];   
end


always @(TimingViol_data_18   or TimingViol_TED  )
begin
        TimingViol_data[18]=~TimingViol_data[18];   
end


always @(TimingViol_data_19   or TimingViol_TOD  )
begin
        TimingViol_data[19]=~TimingViol_data[19];   
end


always @(TimingViol_data_20   or TimingViol_TED  )
begin
        TimingViol_data[20]=~TimingViol_data[20];   
end


always @(TimingViol_data_21   or TimingViol_TOD  )
begin
        TimingViol_data[21]=~TimingViol_data[21];   
end


always @(TimingViol_data_22   or TimingViol_TED  )
begin
        TimingViol_data[22]=~TimingViol_data[22];   
end


`endif


// TASK DEFINITION DESCRIPTION
// ================================



task task_insert_faults_in_memory;
begin
   if (reg_ConfigFault)
   begin   
     for(i = 0;i< fcnt;i = i+ 1) begin
        if(mem_red_array_stuck_at[i] === "mem_array") begin
          if (array_stuck_at[i] === "sa0") begin
           `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data & stuck_at_0fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
          `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] & stuck_at_0fault[i];
          `endif
         end //if(array_stuck_at)
                                        
         if(array_stuck_at[i] === "sa1") begin
         `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data | stuck_at_1fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
         `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] | stuck_at_1fault[i]; 
         `endif
         end //if(array_stuck_at)
       end //if mem_red_array_stuck_at
    
    
     end    // end of for
   end  
end
endtask



task task_read_fault_file;
begin
/*  -----------Implemetation for config fault starts------*/
   msgcnt = X;
   t = 0;
   fault_repair_flag = {max_faults{1'b1}};
   repair_flag = {max_faults{1'b1}};
   if(reg_ConfigFault) 
   begin
      file_ptr = $fopen(reg_Fault_file_name , "r");
      if(file_ptr == 0)
      begin     
          if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: File cannot be opened ",$realtime);
      end        
      else                
      begin : read_fault_file
        t = 0;
        for (i = 0; i< max_faults; i= i + 1)
        begin
         
           stuck0 = {Bits{1'b1}};
           stuck1 = {Bits{1'b0}};
           fault_char1 = $fgetc (file_ptr);
           if (fault_char1 == 8'b11111111)
              disable read_fault_file;
           ret_val = $ungetc (fault_char1, file_ptr);
           ret_val = $fgets(tempStr, file_ptr);
           ret_val = $sscanf(tempStr, "%s %d %d %s",fault_array,fault_word, fault_bit, stuck_at) ;
           flag_error = 0; 
           if(ret_val !== 0)
           begin         
              if(ret_val == 3 || ret_val == 4)
              begin
                if(ret_val == 3)
                   stuck_at = "sa0";

                if(stuck_at !== "sa0" && stuck_at !== "sa1" && stuck_at !== "none")
                begin
                    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: Wrong value for stuck at in fault file ",$realtime);
                   flag_error = 1;
                end    
                      
                if(fault_word >= Words)
                begin
                   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Address out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                if(fault_bit >= Bits)
                begin  
                    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Faulty bit out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                
                        
                if(fault_array !== "mem_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array is not mem_array ",$realtime);
                  flag_error = 1;
                end

                if(fault_array === "red_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array can't be on redundancy array in non redundancy cut.",$realtime);
                  flag_error = 1;
                end

                
                

                if(flag_error == 0)
                //Correct Inputs
                begin
                   if(stuck_at === "none")
                   begin
                       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
                   end
                   else
                   //Adding the faults
                   begin
                      FailureLocn[t] = fault_word;
                      Failurebit[t]  = fault_bit ;
                      std_fault_word = fault_word;
                      fault_row_add[t] = std_fault_word[Addr-1:mux_bits];
                      mem_red_array_stuck_at[t] = fault_array;
                      fault_repair_flag[t] = 1'b0;
                      if (stuck_at === "sa0" )
                      begin
                         stuck0[fault_bit] = 1'b0;         
                         stuck_at_0fault[t] = stuck0;
                      end     
                      if (stuck_at === "sa1" )
                      begin
                         stuck1[fault_bit] = 1'b1;
                         stuck_at_1fault[t] = stuck1; 
                      end

                      array_stuck_at[t] = stuck_at;
                      t = t + 1;
                   end //if(stuck_at === "none")  
                end //if(flag_error == 0)
              end //if(ret_val == 2 || ret_val == 3 
              else
              //wrong number of arguments
              begin
                if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: WRONG VALUES ENTERED FOR FAULTY WORD OR FAULTY BIT OR STUCK_AT IN Fault_file_name ",$realtime); 
                flag_error = 1;
              end
           end //if(ret_val !== 0)
           else
           begin 
               if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
           end    
        end //for (i = 0; i< m
      end //begin: read_fault_file  
      $fclose (file_ptr);

      fcnt = t;
      
      //fault injection at time 0.
      task_insert_faults_in_memory;
  end // config_fault 
end
endtask


task WriteMemX;
begin

`ifdef slm
   $slm_ResetMemory(MemAddr, WordX);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = WordX;
   
`endif        
 task_insert_faults_in_memory;
end
endtask

task WriteMem0;
begin
`ifdef slm
   $slm_ResetMemory(MemAddr, Word0);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = Word0;
  
`endif 
   task_insert_faults_in_memory;
end
endtask


task WriteOutX;                
begin
   OutReg_data <= #0 WordX;
end
endtask


task Invalid_next_cycle_func;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_func = 1;
     `else 
       #0 next_cycle_corrupt_func = 0; 
     `endif  
   end 
end
endtask

task Invalid_next_cycle_dft;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_dft = 1;
     `else 
       #0 next_cycle_corrupt_dft = 0; 
     `endif  
  end
end
endtask

task Invalid_next_cycle_func_tim;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
   #0 next_cycle_corrupt_func <= 1;
  end 
end
endtask

task Invalid_next_cycle_dft_tim;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
  #0 next_cycle_corrupt_dft <= 1;
  end
end
endtask


task ScanOutX;                
begin
   
   dff_SCTRLO_SE.Q <= 1'bx;   
   dff_SDLO_SE.Q <= 1'bx; 
   dff_SDRO_SE.Q <= 1'bx; 
    
   
   SCTRLOint=X;
   SDLOint=X;
   SDROint=X;
    
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   SDLO_data<=1'bx;
   SDRO_data<=1'bx;
    
   `endif
end
endtask

task delScanOutX;                
begin
   delSCTRLO_data<=X;
   delSDLO_data<=X;
   delSDRO_data<=X;
    
end
endtask

task ScanChainX;                
begin
 scanreg_ctrl=1'bx; 
 scanreg_dl=1'bx; 
 scanreg_dr =1'bx; 
  
end
endtask

task mem_blocked;
begin
 
   WriteMemX;
   WriteOutX;
   ScanChainX;
   ScanOutX;//immediately;
   delScanOutX;//immediately
   `ifdef POWER_SEQUENCING_OFF
   `else
   reg_mem_block=1;
   `endif
   debug_level = 2'b11;
end
endtask

task corrupt_all;
begin
 
  WriteMemX;
  WriteOutX;
  ScanChainX;
  ScanOutX;
  delScanOutX;//immediately;
  OutReg_data = WordX; 
  delOutReg_data=WordX;
  
end
endtask

task WriteCycle;                  
input [Addr-1 : 0] Address;
reg [Bits-1:0] tempReg1;
reg [Bits-1:0] tempReg_slm;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;


reg repair_flag;

integer po,i,num,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;
begin

   tempReg1 = WordX;
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];

   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};
   
   if (ValidAddress === X )   begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
        WriteMemX;
        if (INITNint !== 0) begin
        `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
           #0 next_cycle_corrupt_func = 1;
       `else 
           #0 next_cycle_corrupt_func = 0; 
       `endif  
   end 

   end


   if (ValidAddress !== X && next_cycle_corrupt_func === 0  )
   begin
         if (red_en === 1 && ((Row_Add_cmp === repair_add) || (Row_Add_cmp === next_repair_add)) ) begin
             repair_flag = 1'b1;
             
             Bank_sel_integer = 0;
                     
             if (Row_Add_cmp === repair_add) begin
               Col_Add_integer  = Col_Add; 
             end
             else if (Row_Add_cmp === next_repair_add) begin
               Col_Add_integer  = Col_Add + mux; 
             end  
             RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
        end  

        if(repair_flag === 0 && ValidAddress === 1) begin
           `ifdef slm
              $slm_ReadMemoryS(MemAddr, Address, tempReg_slm);
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = Mem[Address];
            `endif
          end  
        else if(repair_flag === 1) begin
           `ifdef slm
//              $slm_ReadMemoryS(RedMemAddr, RedMem_address, tempReg_slm);
          
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = RedMem[RedMem_address];
            `endif
        end
        
        for (num=0;num<Bits;num=num+1) begin
             po=num;        
             if ( Dint [num] !== tempReg1 [po]) begin
                if (Mint[num] === 1'b0)
                   tempReg1[po] = Dint[num];
                else if (Mint[num] === 1'bX)
                   tempReg1[po] = 1'bx;
             end                
        end //for (num=0
            
         if(repair_flag === 0 ) begin    
            if(ValidAddress === 1) begin  
              `ifdef slm
                  tempReg_slm=tempReg1; 
                  $slm_WriteMemory(MemAddr, Address, tempReg_slm);
              `else
                   Mem[Address] = tempReg1;
              `endif
            end
            else begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address Out Of Range. ",$realtime);
            end        
         end
         else if (repair_flag === 1 ) begin
            `ifdef slm
                tempReg_slm=tempReg1; 
//                $slm_WriteMemory(RedMemAddr, RedMem_address, tempReg_slm);
            `else
                RedMem[RedMem_address] = tempReg1;
            `endif
         end
   end //if (ValidAddress !== X
   task_insert_faults_in_memory;
end
endtask 

task ReadCycle;
input [Addr-1 : 0] Address;

reg [Bits-1:0] MemData_tmp;
reg [Bits-1:0] MemData;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;

reg repair_flag;

integer a,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;

begin
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];
   
   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};

   

   if (ValidAddress !== X && next_cycle_corrupt_func === 0 ) begin   
       if(red_en === 1 && ( Row_Add_cmp === repair_add ||  Row_Add_cmp === next_repair_add )) begin
              repair_flag = 1;
              
              Bank_sel_integer = 0;
               
              if(Row_Add_cmp === repair_add) begin
                Col_Add_integer = Col_Add;
              end
              else if (Row_Add_cmp === next_repair_add) begin
                Col_Add_integer = Col_Add + mux; 
              end
              RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
       end

      if(repair_flag === 0) begin
          if(ValidAddress === 1) begin 
           `ifdef slm
              $slm_ReadMemory(MemAddr, Address, MemData);
           `else
              MemData = Mem[Address];
           `endif
          end
          else begin
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Address Out Of Range. Output Corrupted ",$realtime);
             MemData = WordX;
          end
     end
      else if(repair_flag === 1) begin
        `ifdef slm
//           $slm_ReadMemory(RedMemAddr, RedMem_address, MemData);
        `else
           MemData = RedMem[RedMem_address];
        `endif
      end
   end //if (ValidAddress)  
   
   if(ValidAddress === X)
   begin
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Illegal Value on Address Bus. Memory and Output Corrupted ",$realtime); 
         Invalid_next_cycle_func;
   end 
   
  if(ValidAddress !== X && next_cycle_corrupt_func === 0 )
   begin
   for (a = 0; a < Bits; a = a + 1)
   begin
      if (MemData[a] !== OutReg_data[a])
         OutReg_data[a] = WordX[a];
   end//for (a = 0; a <  
         OutReg_data <= MemData;
   end     
end
endtask



// SCAN CHAINS
supply0 gnd;
buf (A_int[0], Aint[0]);
buf (A_int[1], Aint[1]);
buf (A_int[2], Aint[2]);
buf (A_int[3], Aint[3]);
buf (A_int[4], Aint[4]);
buf (A_int[5], Aint[5]);                  //used for capturing
buf (A_int[6], gnd);
buf (A_int[7], gnd);
buf (A_int[8], gnd);
buf (A_int[9], gnd);
buf (A_int[10], gnd);
buf (A_int[11], gnd);
buf (A_int[12], gnd);
buf (A_int[13], gnd);
buf (A_int[14], gnd);   //used for capturing

buf (WEN_int, WENint);
buf (CSN_int, CSNint);
buf (IG_int, IGint);


// Scan flops



// CONTROL SCAN CHAIN
     ST_SPREG_LOLEAK_64x23m8_Tl_SCFF cntrl_scff_0 (.D(A_int[2]), .TI(SCTRLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[0]), .OUTX(scanreg_ctrl));

      
 ST_SPREG_LOLEAK_64x23m8_Tl_SCFF cntrl_scff_1 (.D(A_int[4]), .TI(scanreg_ctrl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[1]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m8_Tl_SCFF cntrl_scff_2 (.D(A_int[6]), .TI(scanreg_ctrl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[2]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m8_Tl_SCFF cntrl_scff_3 (.D(A_int[9]), .TI(scanreg_ctrl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[3]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m8_Tl_SCFF cntrl_scff_4 (.D(A_int[3]), .TI(scanreg_ctrl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[4]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m8_Tl_SCFF cntrl_scff_5 (.D(A_int[11]), .TI(scanreg_ctrl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[5]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m8_Tl_SCFF cntrl_scff_6 (.D(A_int[10]), .TI(scanreg_ctrl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[6]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m8_Tl_SCFF cntrl_scff_7 (.D(A_int[1]), .TI(scanreg_ctrl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[7]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m8_Tl_SCFF cntrl_scff_8 (.D(A_int[0]), .TI(scanreg_ctrl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[8]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m8_Tl_SCFF cntrl_scff_9 (.D(A_int[5]), .TI(scanreg_ctrl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[9]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m8_Tl_SCFF cntrl_scff_10 (.D(A_int[7]), .TI(scanreg_ctrl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[10]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m8_Tl_SCFF cntrl_scff_11 (.D(CSN_int), .TI(scanreg_ctrl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[11]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m8_Tl_SCFF cntrl_scff_12 (.D(A_int[8]), .TI(scanreg_ctrl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[12]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m8_Tl_SCFF cntrl_scff_13 (.D(WEN_int), .TI(scanreg_ctrl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[13]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x23m8_Tl_SCFF cntrl_scff_14 (.D(scanreg_ctrl_wire[14]), .TI(scanreg_ctrl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[14]), .OUTX(scanreg_ctrl));  

reg LP_CK_gate;

// Lock Up Latch
wire SCTRLO_temp;
 ST_SPREG_LOLEAK_64x23m8_Tl_lock_up_latch  dff_SCTRLO_SE (Latch_open, scanreg_ctrl_wire[14], SCTRLO_temp);

always @(SCTRLO_temp) begin
     SCTRLOint= SCTRLO_temp;
 `ifdef functional
 `else
 if (SCTRLOint !== SCTRLO_data) begin 
  if (SCTRLOint !==X)
   SCTRLO_data=1'bx;
   SCTRLO_data <= SCTRLOint;
 end 
 `endif
end  


// LEFT DATA SCAN CHAIN
     ST_SPREG_LOLEAK_64x23m8_Tl_SCFF ldata_scff_0 (.D(Dint[11]), .TI(SDLI), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[0]), .OUTX(scanreg_dl));
      
   
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF ldata_scff_1 (.D(Dint[10]), .TI(scanreg_dl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[1]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF ldata_scff_2 (.D(Dint[9]), .TI(scanreg_dl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[2]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF ldata_scff_3 (.D(Dint[8]), .TI(scanreg_dl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[3]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF ldata_scff_4 (.D(Dint[7]), .TI(scanreg_dl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[4]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF ldata_scff_5 (.D(Dint[6]), .TI(scanreg_dl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[5]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF ldata_scff_6 (.D(Dint[5]), .TI(scanreg_dl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[6]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF ldata_scff_7 (.D(Dint[4]), .TI(scanreg_dl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[7]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF ldata_scff_8 (.D(Dint[3]), .TI(scanreg_dl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[8]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF ldata_scff_9 (.D(Dint[2]), .TI(scanreg_dl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[9]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF ldata_scff_10 (.D(Dint[1]), .TI(scanreg_dl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[10]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF ldata_scff_11 (.D(Dint[0]), .TI(scanreg_dl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[11]), .OUTX(scanreg_dl));



// Lock Up Latch
wire SDLO_temp;
 ST_SPREG_LOLEAK_64x23m8_Tl_lock_up_latch  dff_SDLO_SE (Latch_open, scanreg_dl_wire[11], SDLO_temp);

always @(SDLO_temp) begin
     SDLOint= SDLO_temp;
 `ifdef functional
 `else
 if (SDLOint !== SDLO_data) begin 
  if (SDLOint !==X)
   SDLO_data=1'bx;
   SDLO_data <= SDLOint;
 end 
 `endif
end  






// RIGHT DATA SCAN CHAIN

     ST_SPREG_LOLEAK_64x23m8_Tl_SCFF rdata_scff_0 (.D(Dint[22]), .TI(SDRI), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[0]), .OUTX(scanreg_dr));
     
 
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF rdata_scff_1 (.D(Dint[21]), .TI(scanreg_dr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[1]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF rdata_scff_2 (.D(Dint[20]), .TI(scanreg_dr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[2]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF rdata_scff_3 (.D(Dint[19]), .TI(scanreg_dr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[3]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF rdata_scff_4 (.D(Dint[18]), .TI(scanreg_dr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[4]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF rdata_scff_5 (.D(Dint[17]), .TI(scanreg_dr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[5]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF rdata_scff_6 (.D(Dint[16]), .TI(scanreg_dr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[6]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF rdata_scff_7 (.D(Dint[15]), .TI(scanreg_dr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[7]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF rdata_scff_8 (.D(Dint[14]), .TI(scanreg_dr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[8]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF rdata_scff_9 (.D(Dint[13]), .TI(scanreg_dr_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[9]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x23m8_Tl_SCFF rdata_scff_10 (.D(Dint[12]), .TI(scanreg_dr_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[10]), .OUTX(scanreg_dr)); 


// Lock Up Latch
wire SDRO_temp;
 ST_SPREG_LOLEAK_64x23m8_Tl_lock_up_latch  dff_SDRO_SE (Latch_open, scanreg_dr_wire[10], SDRO_temp);


always @(SDRO_temp) begin
     SDROint= SDRO_temp;
 `ifdef functional
 `else
 if (SDROint !== SDRO_data) begin 
  if (SDROint !==X)
   SDRO_data=1'bx;
   SDRO_data <= SDROint;
 end 
 `endif
end






//


 //////// CAPTURE TASK //////
task scan_acquire;
begin
   if (supply_ok === 1) begin 
      if ( SEsys === 0 && ((LP_CK_gate === 0 && TBYPASSsys !== 1'bx)|| TBYPASSsys===0)) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
         
         Latch_open=1;
         

      end //if ( SEint === 0
   end//if(supply_ok 
end
endtask

task scan_shift;
begin
 if (supply_ok === 1) begin
   if (STDBYint === 0 && SLEEPint === 0) begin
      if (CKint_dft === X && INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0) begin
         ScanChainX;
         ScanOutX;
      end
      else if (CKint_dft === 1 && lastCK_dft === 0 ) begin
          //// SHIFT
        if (SEsys === 1) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
           
        //// SHIFT Ends
        end //if (SEsys === 1
        else if (SEsys === X) begin
            ScanChainX;
            ScanOutX;
            delScanOutX;
        end//if (SEint ==X
      
      end///if (CKint === 
    
      else if (CKint_dft === 0 && lastCK_dft === 1 ) begin
        Latch_open=1;
      end
    end  //if (STDByint === 0 && SLEEPint === 0
 end//if(supply_ok
end
endtask






// BEHAVIOURAL MODULE DESCRIPTION
// ================================

initial
begin
  // Define format for timing value
  $timeformat (-9, 3, " ns", 0);
  `ifdef slm
  $slm_RegisterMemory(MemAddr, Words, Bits);
  `endif   
   reg_mem_block=0;
   flag_mem_block=0;
  `ifdef functional
  `else
   TimingViol_data=0;
   TimingViol_mask=0;
   `endif
   decoding_start=0;
  
   //Parameter Assignment
   
   reg_Fault_file_name = Fault_file_name; 
   reg_ConfigFault     = ConfigFault;
   reg_MEM_INITIALIZE  = MEM_INITIALIZE;
   reg_BinaryInit      = BinaryInit;
   reg_InitFileName    = InitFileName;
   reg_Initn_reset_value = Initn_reset_value;
   reg_File_load_time    = File_load_time;

   time_fall_sleep=0;
   time_fall_PSWLARGEMP=0;
   time_fall_PSWLARGEMP_0=0;
   time_fall_PSWLARGEMA=0;
   time_fall_PSWLARGEMA_0=0;
   time_fall_PSWSMALLMP=0;
   time_fall_PSWSMALLMA=0;

   vddmp_rise_time=0;
   vddmp_fall_time=0;
   vddsmp_rise_time=0;
   vddsmp_fall_time=0;
   vddma_rise_time=0;
   vddma_fall_time=0;
   vddsma_rise_time=0;
   vddsma_fall_time=0;
   vddm_fall_time=0;  
   vddm_rise_time=0;  
   vddsm_fall_time=0; 
   vddsm_rise_time=0;

   next_cycle_corrupt_func=0;
   next_cycle_corrupt_dft=0;
   init_pulse_done = 0;
   power_up_done = 0;
   file_loaded=1;
   debug_level= 2'b01;
   message_status = "ONLY WARNINGS/ERRORS are Switched ON.For INFO also use debug_level=2'b00";
  `ifdef  NO_WARNING_MODE
     debug_level = 2'b11;
     message_status = "All Warning/Errors/Info Messages are Switched OFF";
  `endif  
  `ifdef  ONLY_ERROR_MODE
     debug_level = 2'b10;
     message_status = "All Warning/Info Messages are Switched OFF.Errors are switched on";
  `endif 
  `ifdef  ALL_MSG_MODE
     debug_level = 2'b00;
     message_status = "All Messages are Switched ON";
  `endif 
  
  `ifdef slm
     operating_mode = "SLM";
   `else
      `ifdef functional
         operating_mode = "FUNCTIONAL";
       `else
         operating_mode = "TIMING";
      `endif
   `endif   
  
  if (debug_level < 1) begin
  $display ("%m INFORMATION ");
  $display ("***************************************");
  $display ("The Model is Operating in %s MODE", operating_mode);
  $display ("%s", message_status);
  if(reg_ConfigFault)
  $display ("Configurable Fault Functionality is ON");   
  else
  $display ("Configurable Fault Functionality is OFF");   
  $display("Fault File used by the model Fault_File_Name=%s" ,reg_Fault_file_name);
  $display("Values of Config_fault used in model=%d" ,reg_ConfigFault);
  $display("Values of Mem_INITALIZE used in model=%d" ,reg_MEM_INITIALIZE);
  $display("Values of BinaryInit used in model=%d" ,reg_BinaryInit);
  $display("Values of InitFileName used in model=%s" ,reg_InitFileName);
  $display("Values of Initn_reset_value used in model=%d" ,reg_Initn_reset_value);
  $display("Values of File_load_time used in model=%t" ,reg_File_load_time);

  $display ("***************************************");
  end
     
  task_read_fault_file; 
   if(!INITNint) begin
    if(supply_ok ) begin 
      init_pulse_done = 1;
      power_up_done = 1;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif 
    end 
   end 
        
   lastCK_func = CKint_func;
   lastCK_dft = CKint_dft;

 `ifdef MEM_CONTENTS_SLEEP
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","w");
   $fclose(ptr);
 `endif 

   
end  // initial block ends



//+++++++++++++++++++++++++++++++ CONFIG FAULT IMPLEMETATION ENDS+++++++++++++++++++++++++++++++//
        




//INITN block starts
//================================
always @(INITNint  or supply_ok )
begin
 if (INITNint === 1'b0) begin
   if(supply_ok) begin
     init_pulse_done = 1;
     power_up_done = 1;
     lastCK_func=CKint_func;
     lastCK_dft=CKint_dft;
     next_cycle_corrupt_func = 0;
     next_cycle_corrupt_dft = 0;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif     
   end 
 end        

 if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && INITNint !== 1)
   begin
     ScanOutX;
     ScanChainX;
     delScanOutX;
   end  
         
 if (init_pulse_done === 0 && INITNint !== 0) begin
     if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) INFO: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
 end
 
end//always @(INITNint)


// Clock Generation 
//wire gated_clock;
//wire clock_gate_en;
//ST_SPREG_LOLEAK_64x23m8_Tl_lock_up_latch CK_SE_latch (!CK , SE, SE_latch_CK);
//and (clock_gate_en, ATP, TBYPASS, !SE_latch_CK);

//ST_SPREG_LOLEAK_64x23m8_Tl_lock_up_latch LP_latch (!CK , scanreg_ctrl_wire[14], LP_latch_CK);
//and (gated_clock,CK,!LP_latch_CK);
//assign CK_new= clock_gate_en ===0 ? CK : (clock_gate_en ===1 ? gated_clock: (CK===0) ? 0 :1'bx);


// Clock Generation Ends


// Functional CK block starts
//======================================
always @(CKint_func)
begin
   lastCK_func=CKreg_func;  
   CKreg_func=CKint_func;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
        if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
      if (CKreg_func === 1'bX || (CKreg_func === 1'b1 && lastCK_func === 1'bx)) begin
        if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
         
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
         Invalid_next_cycle_func;
        end
      end
      else if (CKreg_func === 1'b1 && lastCK_func === 1'b0 ) begin
        time_CK_func_rise=$realtime;
        MEMEN_prev = MEMEN_reg;
        MEMEN_reg = MEMEN;
        CSNreg = CSNint;
        IGreg = IGint;
        DEreg = DEint;
        SE_reg = SEsys;
        TBYPASS_reg = TBYPASSsys;
        ATPreg = ATPint;
        INITNreg = INITNint;
        SLEEPreg = SLEEPint;
        STDBYreg = STDBYint;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 

    `ifdef functional
    `else
        Mem_last=Mem[Aint];
    `endif 
        if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.INITN pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SLEEP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.STANDBY pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg === X && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.chip select  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg === X && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.IG pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg === X && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.Debug pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg === X && (SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.ATP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg === X && TBYPASS_reg !== 1) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SE pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg !== 1 && TBYPASS_reg === X) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.TBYPASS pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end

        else if ((INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0))) && WENint === X) begin
            // Uncertain write cycle
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: write enable going to X  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end 
        else if (next_cycle_corrupt_func === 1) begin
          next_cycle_corrupt_func = X;
        end
        else if (next_cycle_corrupt_func === 1'bx) begin
          next_cycle_corrupt_func = 0;
        end 
        
//        if (next_cycle_corrupt_func === 0 ) begin 
         
          /*---------------------- File initialization -----------------*/
          
          if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0)) && flag_mem_block === 1'b0) begin
                 Areg=Aint;
                 Dreg=Dint;
                 Mreg=Mint;
                 WENreg=WENint;     
             if (reg_MEM_INITIALIZE === 1'b1 && $realtime >= reg_File_load_time && file_loaded ) begin   
                `ifdef slm
                  if (reg_BinaryInit)
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_BIN");
                  else
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_HEX");
   
                `else
                  if (reg_BinaryInit)
                     $readmemb(reg_InitFileName, Mem, 0, Words-1);
                  else
                     $readmemh(reg_InitFileName, Mem, 0, Words-1);
                `endif
                 file_loaded = 0;
             end
   
             if (^Aint === X)
               ValidAddress = X;
             else if (Aint < Words)
               ValidAddress = 1;
             else    
               ValidAddress = 0;
   
             if(red_en === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Redundancy Enable is Invalid. Either RRAE is X or TRRAE is X",$realtime);
                ValidAddress = X; 
           end
           else if(red_en === 1'b1 && ^repair_add === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Repair Address is invalid.RRA is X",$realtime);
                ValidAddress = X;
           end
             
             if (ValidAddress)
               `ifdef slm
                   $slm_ReadMemoryS(MemAddr, Aint, Mem_temp);
               `else
                    Mem_temp = Mem[Aint];
               `endif
             else
                Mem_temp = WordX;  
          
     /*---------------------- Normal Read and Write -----------------*/
     
             if (WENint === 1) begin
               ReadCycle(Aint);
             end
       
             else if (WENint === 0) begin
               WriteCycle(Aint);
             end 
                
          
          end //  if (MEMEN === 1'b1 
       
//        end  // if (next_cycle_corrupt_func === 0
      
      end // if (CKint = 1   
   end // if (init_pulse_done === 1           
 end 
end // always @(CKint_func)
        
always @(MEMEN)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) && CKint_func === 1'bx) begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.clock pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
    Invalid_next_cycle_func;
  end
 end 
end

// DFT CK block starts
//======================================
always @(CKint_dft) 
begin
   lastCK_dft=CKreg_dft;
   CKreg_dft=CKint_dft;
   
   Latch_open=0;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
     if (CKreg_dft === 1'bX || (CKreg_dft === 1'b1 && lastCK_dft === 1'bx)) begin
       if (INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0 ) begin
        
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: DFT clock  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime); 
         Invalid_next_cycle_dft;
         if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
           WriteOutX;
         end
       end
     end 

     if(CKint_dft === 0 && lastCK_dft === 1) begin
      if(ATPreg === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
       if(SE_reg === 1'b1 && SEsys === 1'b0) begin
        if(TBYPASSint === 1'b1) begin   
    
       
       
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],
scanreg_dr_wire[10],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9],
scanreg_dl_wire[10], scanreg_dl_wire[scanlen_l-1]}; 
       


         for (i = 0; i < Bits; i = i + 1)
         begin
          if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
         end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
        end 
       end
      end
     end 
     
     else if (CKreg_dft === 1'b1 && lastCK_dft === 1'b0 ) begin
       SE_reg = SEsys;
       TBYPASS_reg = TBYPASSsys;
       ATPreg = ATPint;
       INITNreg = INITNint;
       SLEEPreg = SLEEPint;
       STDBYreg = STDBYint;
       MEMEN_dft_prev = MEMEN_dft_reg;
       MEMEN_dft_reg = MEMEN_dft;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 
       if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ) begin 
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
 //     else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys === X && TBYPASSsys !== 1) begin
///           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
//           Invalid_next_cycle_dft;
//        end       
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys === X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
        end 
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys !== 0 && LP_CK_gate===X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: LP FLOP Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           ScanChainX;
           ScanOutX;   
          if( TBYPASSint !== 0 && SEint !== 1) begin
            WriteOutX;
          end
          next_cycle_corrupt_dft=0;
        end        
       else if (next_cycle_corrupt_dft === 1'b1) begin 
         next_cycle_corrupt_dft = X;
       end 
       else if (next_cycle_corrupt_dft === 1'bx) begin
         next_cycle_corrupt_dft = 0;
       end
       
       if (next_cycle_corrupt_dft === 0 ) begin
         
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1 && flag_mem_block === 1'b0) begin
           
           if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0  && LP_CK_gate===0) begin
              OutReg_data_tbypass = Dint;
              for (i = 0; i < Bits; i = i + 1)
              begin
               if (OutReg_data_tbypass[i] !== OutReg_data[i])
                 OutReg_data[i] = WordX[i];
              end//for (i = 0; i < */ 
              OutReg_data <= OutReg_data_tbypass;
           end
           
             scan_acquire;
         end //MEMEN_dft == 1        
       end // if ( next_cycle_corrupt_dft
       
     end // if (CKint_dft === 1'b1
      //  if (next_cycle_corrupt_dft === 0 ) begin 
       if (SE_reg !== 0) begin
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1  && flag_mem_block === 1'b0) begin
           next_cycle_corrupt_dft = 0;
           if ( next_cycle_corrupt_func === 1) begin
	    next_cycle_corrupt_func = 0 ;
	   end	
           scan_shift;
         end
       end
     //end // if ( next_cycle_corrupt_dft    
     if ((!(TBYPASSsys!==0 && SEsys!==1 && LP_CK_gate!==0 ) && next_cycle_corrupt_dft === 0) || CKint_dft !==1) begin          
       CK_sc=INITNreg & !STDBYreg & !SLEEPreg & ATPreg & CKreg_dft ;
     end     
   end // if (init_pulse_done 
 end // if (supply_ok 
end // always @(CKint_dft)

always @(MEMEN_dft)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) && CKint_dft === 1'bx)  begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.MEMEN_dft and clock should not be X at this time instant. ScanChains and ScanOuts Corrupted ",$realtime); 
    Invalid_next_cycle_dft;
    
    if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
      WriteOutX;
    end
  end
  if ( MEMEN_dft !== 0 && TBYPASSsys !== 0 && SEsys !== 1) begin
     WriteOutX;
     OutReg_data = WordX; 
     delOutReg_data=WordX;
 end 
end
end //always @(MEMEN_dft

always @(TBYPASSsys or ATPint)
begin
   if(supply_ok === 1'b1) begin 
    if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0 && INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1) begin
      if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
    end  
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint === X && SEsys !== 1) ) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end 
end //always @(TBYPASSint





always @(SEsys)
begin
 if(supply_ok === 1'b1) begin 
  if(CKint_dft === 0 && ATPint === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
    if(SE_reg === 1'b1 && SEsys === 1'b0) begin
      if(TBYPASSsys === 1'b1) begin
  
     
         
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],
scanreg_dr_wire[10],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9],
scanreg_dl_wire[10], scanreg_dl_wire[scanlen_l-1]};
           
      


        for (i = 0; i < Bits; i = i + 1)
        begin
         if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
        end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
      end
    end
  end
  if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0) begin
      if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
  end 
  else if ((TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint === X && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end   
end

//assign output data
`ifdef functional        

   
always @(SDLOint)
#0.001 delSDLO_data<=SDLOint;

always @(SDROint)
#0.001 delSDRO_data<=SDROint;

 
always @(SCTRLOint)
#0.001 delSCTRLO_data<=SCTRLOint;


always @(OutReg_data)
   #0.001 delOutReg_data = OutReg_data;
`else
`endif

/***************************** Embeded switch functionality starts here ***********************************/





always @(STDBYint)
begin
  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0 && STDBYint !== 1'b0)
    begin
      ScanOutX;
      ScanChainX;
     delScanOutX;     
    end
  end
end



always @(SLEEPint)
begin


  if (SLEEPint !== 1'b1) begin
    time_fall_sleep = $realtime;
  end

  if (power_up_done === 0)
    begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
    end
  else begin
    if (SLEEPint === 1'b1 && lastSLEEP === 1'b0 ) begin 
      
    end
    else if (SLEEPint !== 1'b1 && lastSLEEP === 1'b1 && full_shutdown !== 1) begin 
      
      if (supply_ok !== 1 && ($realtime > 0)) begin
         if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID LOW_POWER) ERROR: ISOLATION signal removed from the memory but array and periphery supply is not completely switched on.Very High Current would be drawn by the memory. All further operations on memory are blocked",$realtime);
          WriteMemX;
          WriteOutX;
          ScanChainX;
          OutReg_data = WordX; 
          delOutReg_data=WordX;
          ScanOutX;//immediately;
          delScanOutX;//immediately;
          init_pulse_done = 0;
          power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            debug_level = 2'b11;
          `endif
          
      end        
      
       
    end   
    else if (SLEEPint === X && lastSLEEP === 1'b0 && full_shutdown !== 1'b1) begin 
     
    end 
  end  


  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && SLEEPint !== 0)
    begin
      ScanOutX;
      ScanChainX;
        delScanOutX;      
    end
  end

// if (init_pulse_done === 0)
//   begin
//     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
//   end
//
// else if ( SLEEPint !== 1 && (supply_ok !==1) ) begin
//    
//    WriteOutX;
//    OutReg_data = WordX; 
//    delOutReg_data=WordX;
//    ScanOutX;//immediately;
//    delScanOutX;//immediately;
//    ScanChainX;
//    WriteMemX;
//    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies with sleep/Power down signal being low.This scenario can lead to high dc currents and some reliability issues Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
// end

 print_sleep;    
 lastSLEEP=SLEEPint;
end

/********************************** Embeded switch functionality ends here *******************************/

task print_sleep;
begin
  if (SLEEPint === 1'b0) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been deasserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end  
  else if (SLEEPint === 1'b1) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been asserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_ACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif

  end        
  else begin
      if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) ERROR: SLEEP pin is at an invalid state.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INVALID in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end        
end
endtask





 

//// C28SOI non flip compiler power functionality 
always @(gndmreg )
begin
 if (power_up_done === 1 && $realtime > 0) begin    
    if(gndmreg !== 1'b0 ) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or gndsm is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
        corrupt_all;
        init_pulse_done = 0;
        power_up_done = 0;
     `ifdef NO_BLOCK_MEM
     `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of ground pins.Ground must be maintained at 0 Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime);
        debug_level = 2'b11;
     `endif   

    end   
 end

end




always @(vddmareg )
begin

if (vddmareg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddma(Array Supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 
    end
   end   
   else if (SLEEPint === 1) begin
    WriteMemX;
   end

end

if ((vddmareg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1 ) && $realtime > 0) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddm or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         corrupt_all;
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif

end


end

always @(vddmpreg )
begin
 if (vddmpreg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or vddsmp is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmp(Periphery Supply)/vddsmp(Substrate power supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 

    end
   end   
   else if (SLEEPint === 1) begin
    WriteOutX;
    ScanChainX;
    ScanOutX;
    delScanOutX;//immediately;
    OutReg_data = WordX; 
    delOutReg_data=WordX;
   end
 end

if( (vddmpreg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1'b1 )  && $realtime > 0) begin
         corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif
end
 
 
end


always @(vddmoreg)
begin
  if (power_up_done === 1 && $realtime > 0) begin   
      if (vddmoreg !== 1'b1)  begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin
           corrupt_all;
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
         end //if (vddmareg === 1'b1 

      else if (vddmareg === 1'b0 && vddmpreg === 1'b0   && SLEEPint === 1'b1 &&  $realtime > 0)
        begin 
            if((debug_level < 2) && ($realtime > 0)) $display("%m - %t WARNING: Illegal Value on power pin(s). Memory and Output Corrupted ", $realtime);
 
           corrupt_all;
        end //else if (vddmareg === 1'b 
     end   // if (vddmoreg !== 1'b1)
     else if (vddmoreg === 1'b1 && $realtime > 0 ) begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin     
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           corrupt_all;
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
        end        
     end // else if (vddmoreg === 1'b1
  end 
end // always @(vddmoreg)












always @(gndmreg) begin
 if (gndmreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 0. ",$realtime);
 end
 else if (gndmreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 1. ",$realtime);
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to invalid state. ",$realtime);
 end
end




 
always @(vddmareg) begin
 if (vddmareg === 0) begin 
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 0. ",$realtime);
  vddma_fall_time = $realtime;
 end
 else if (vddmareg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 1. ",$realtime);
  vddma_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to invalid state. ",$realtime);
  vddma_fall_time = $realtime;
 end 

 

end

always @(vddmpreg) begin
 if (vddmpreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 0. ",$realtime);
  vddmp_fall_time = $realtime;
 end
 else if (vddmpreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 1. ",$realtime);
  vddmp_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to invalid state. ",$realtime);
  vddmp_fall_time = $realtime;
 end

 
 
end



// end of C28SOI power functionality 
 


assign supply_ok          =  (vddmareg === 1'b1 && vddmpreg  === 1'b1  && gndmreg === 1'b0 && vddmoreg === 1'b1 ) ? 1'b1 : 1'b0;
assign core_supply_ok     =  (vddmoreg === 1'b1 && vddmareg === 1'b1 && gndmreg === 1'b0 ) ? 1'b1 : 1'b0;
assign peri_supply_ok     =  (vddmoreg === 1'b1 && vddmpreg === 1'b1 && gndmreg === 1'b0  ) ? 1'b1 : 1'b0;

assign full_shutdown = (vddmpreg === 1'b0 && vddmareg === 1'b0   ) ? 1'b1 : 1'b0 ;




`ifdef functional
`else


task WriteLocMskX_bwise;
   input [Addr-1 : 0] Address;
   input [Bits-1 : 0] Mask;

reg [Bits+Red_extrabit:0] tempReg1;
integer num1; 
begin
   tempReg1 = WordX;
   if (^Address !== X )
   begin
      tempReg1 = Mem[Address];
             
      for (j = 0;j< Bits; j=j+1) begin
         num1=j;
        if (Mask[j] === 1'bx)
            tempReg1[num1] = 1'bx;
      end
      Mem[Address] = tempReg1;
      task_insert_faults_in_memory;
   end//if (^Address !== X
   else begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      WriteMemX;
   end   
end
endtask


/****************Actions taken on timing violations*****************/

 always @(TimingViol_data)
// tds or tdh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  for (l = 0; l < Bits; l = l + 1) begin   
    if (CSWEMTBYPASS[l] !== 0) begin
     if((TimingViol_data[l] !== TimingViol_data_last[l])) begin


         Mreg[l] = 1'bx;
     end    
     WriteLocMskX_bwise(Areg,Mreg);
    end   
   end 
  end
    if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin
     scanreg_dl =1'bx; 
     scanreg_dr =1'bx; 
     SDLOint=X;
     SDROint=X;
     `ifdef functional
     `else
     SDLO_data<=1'bx;
     SDRO_data<=1'bx;
     `endif
    end
     TimingViol_data_last = TimingViol_data; 
end





always @(TimingViol_addr)
// tas or tah
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
      scanreg_ctrl=1'bx; 
      SCTRLOint=X;
      `ifdef functional
      `else
      SCTRLO_data<=1'bx;
      `endif
  end
end


always @(TimingViol_WEN)
//tws or twh
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WEN pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end 

always @(TimingViol_CSN )
// tps or tph 
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;

   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CSN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end

always @(TimingViol_tcycle )
//tcycle
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
   if (MEMEN !== 0 && MEMEN_prev !== 0) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckl )
// tckl 
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckh) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end


always @(TimingViol_tcycle_se )
//tcycle_se
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckl_se  )
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckh_se) begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tbist) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
   end
   if (TBYPASSint !== 1'b0) begin 
    WriteOutX;
   end 
   if (INITNreg !==0 && STDBYreg !== 1 && TBYPASS_reg !== 1 && SLEEPreg !== 1 && SE_reg !== 1 && IGreg !== 1 && DEreg !== 1) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBIST pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end






always @(TimingViol_tbypass)
//ttmck
begin
#0  
  WriteOutX;
  if (INITNreg !== 0 && SLEEPreg !== 1 && SE_reg !== 1 && STDBYreg !== 1 &&  DEreg !== 1) begin
   Invalid_next_cycle_dft_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
end



always @(TimingViol_sleep)
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_stdby)
begin
#0
  if (CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin 
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (ATPreg !== 0) begin 
   Invalid_next_cycle_dft_tim;
  end
end






always @(TimingViol_se) begin
#0
   if (TBYPASS_reg !== 0) begin 
    WriteOutX;
   end 
  if (TBYPASS_reg === 0) begin
     WriteOutX;
     WriteMemX;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE timing violation  Memory State Machine is corrupted. Output Corrupted ",$realtime); 
  end 
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
  end
end

always @(TimingViol_sctrli) begin
  scanreg_ctrl=1'bx; 
end


always @(TimingViol_sdli) begin
 scanreg_dl=1'bx; 
end

always @(TimingViol_sdri) begin
   scanreg_dr=1'bx;
end

 

always @(TimingViol_initnl) begin
init_pulse_done=0;
WriteOutX;
OutReg_data = WordX; 
delOutReg_data=WordX;
ScanOutX;
delScanOutX;
ScanChainX;
WriteMemX;
end

always @(TimingViol_initn) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end

always @(TimingViol_ig) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && INITNreg !== 0 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: IG pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   ScanChainX;
   ScanOutX;
   delScanOutX;       
  end
end

always @(TimingViol_atp) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin  
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_rm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^WMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: RM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
   end
end
 
always @(TimingViol_wm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^RMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);        
   end
end 


`endif


endmodule




module ST_SPREG_LOLEAK_64x23m8_Tl_lock_up_latch (EN,D,Q);
input EN,D;
output reg Q;

  always @ (EN or D) begin
    if (EN === 1) begin
       Q = D;
    end
    else if ((EN === 1'bz || EN === 1'bx  )&& D !== Q) begin
        Q=1'bx;
    end    
  end
endmodule

module ST_SPREG_LOLEAK_64x23m8_Tl_SCFF (D,TI,TE,CP,Q,OUTX);
input D,TI,TE,CP;
input OUTX;
output reg Q;
wire Dint;
assign Dint= (TE===1)?TI:(TE===0)?D:1'bx;

always @(posedge CP)
        begin
          if(Dint === 1'bZ || CP ===1'bx || OUTX === 1'bx)
          begin
                  Q = 1'bx;
          end
          else
          begin
                  Q = Dint;
          end        
        end
always @(posedge OUTX)
Q = 1'bx;
endmodule



`undef setup_time
`undef hold_time
`undef access_time
`undef retain_time
`undef cycle_time
`undef pulse_width_time
`undef initin_low_pulse


`delay_mode_path
`endcelldefine
`nosuppress_faults






/****************************************************************
--  Description         : Verilog Model 
--  ModelVersion        : 1.2
--  Date                : Apr, 2013
--  Changes Made by	: PS
--  Revision History    : 
 
****************************************************************/


/******************** START OF HEADER****************************
   This Header Gives Information about the parameters & options present in the Model
   
   words = 128
   bits  = 22
   mux   = 8 
   
   
   
   write_mask = no 
   
   margin_control = yes 
   
   
   Dft = Yes  

    ------------------------------------------------------------------------------------
     Signal Name             | Description       |             Port Mode        | Active When
                             |                   |          r    |  w   | rw    |
   ------------------------------------------------------------------------------------

    D 	        Data in                     na     x      na       -  
    IG    Input Gate Enable           x      x      na       High     
    ATP            ATPG Enable                 x      x      na       High     
    INITN                 INITN pin                   x      x      na       Low
    
    
     
    Q 	        Data out	            x      na     na       -
    A              Address                     x      x      na       high and low
    
    CK                Clock	                    x      x      na       posedge
    CSN          Chip Enable                 x      x      na       low
    
    RM         Read Margins                 x      x      na       High 
    SCTRLI         Scan Input (Control)
    SCTRLO        Scan Output (Control)
    SDLI         Scan Input (Data-Left)
    SDLO        Scan Output (Data-Left)
    SDRI         Scan Input (Data-Right)
    SDRO        Scan Output (Data-Right)
    SE          Scan Enable pin 
    STDBY              Standby pin                 x      x      na       High
    
    SLEEP                        Sleep pin                   x      x      na        High 
    
     
     
    TBIST          Bist Enable Pin 
    
    TBYPASS                      Memory Bypass                na     na     na        High
    
    TED        Bist Even Data pin
    TOD         Bist Odd Data Pin
     
    TA         Bist Read Address
    TCSN     Bist Read Chip Select
    
    TWEN    Bist Write Enable 
    WEN         Write Enable                na     x      na       Low 
    
    WM        Write Margins Code          x      x      na       -
     

******************** END OF HEADER ****************************/


//********************************************//
// ST_SPREG_LOLEAK_128x22m8_Tl Verilog Model                 //  
//********************************************//




`ifdef slm
        `define functional
`endif

`celldefine
`suppress_faults
  `ifdef functional
   `delay_mode_unit
  `else
   `delay_mode_path
  `endif

`define setup_time 0.0
`define hold_time 0.0
`define access_time 1.0
`define retain_time 0.9
`define cycle_time 0.0
`define pulse_width_time 0.0
`define initin_low_pulse 0.0



 






`timescale 1ns / 1ps


module ST_SPREG_LOLEAK_128x22m8_Tl (A,ATP,CK,CSN,D ,IG,INITN , Q ,RM    ,SCTRLI,SCTRLO,SDLI,SDLO,SDRI,SDRO,SE,SLEEP   , STDBY  ,TA,TBIST   ,TBYPASS ,TCSN,TED ,TOD   ,TWEN ,WEN,WM  );

 parameter
  Words = 128,
  Bits = 22,
  Addr = 7,
  mux = 8,
  repair_address_width = 4,
  write_margin_size = 2, 
  read_margin_size = 3; 

 //  INPUT OUTPUT PORTS DECLARATION DONE SEPARATELY FOR SPREG and ROM
 // ========================


        output [Bits-1 : 0] Q;
         
        output SCTRLO;
        input SE,SCTRLI;
        
        input [Addr-1 : 0] A;
        
        input [read_margin_size-1 : 0] RM;
        
         
        input CK,CSN,INITN,IG,ATP; 
        
        
        input [Addr-1 :0 ] TA;
input TBIST,TCSN ;
        
        input STDBY;
        
        input SLEEP; 
        
         
        
        
         
        output SDLO;
        output SDRO;
        
        
        
        
        input [Bits-1 : 0] D ;
	
          
         
        
        input [write_margin_size-1 : 0] WM;
        
        
        input TBYPASS;
        
        input WEN;
        
        
         
        input SDLI,SDRI  ; 
        
        
        
        //Bist inputs
        // ===========
        input TWEN,TED,TOD; 
        
        
        
        

        






    parameter
        Fault_file_name = "ST_SPREG_LOLEAK_128x22m8_Tl_faults.txt",
        `ifdef ConfigFault
        ConfigFault = 1,
        `else
        ConfigFault = 0,
        `endif
        max_faults = 130,
        
        MEM_INITIALIZE  = 1'b0,
        BinaryInit = 1'b0, 
        InitFileName = "ST_SPREG_LOLEAK_128x22m8_Tl.cde",
        Debug_mode = "all_warning_mode",
        File_load_time=0,
        Initn_reset_value={22{1'b0}},
        InstancePath = "ST_SPREG_LOLEAK_128x22m8_Tl";
    
    parameter
        
        bank = 1, 
        mux_bits=3,
        Red_extrabit=0,
        bank_bits = 0,
        RedWords = mux * 2 * bank,
        max_address_bits = 15 ,
        Rows = Words/mux;

  
    parameter 

     

        
           scanchains=3,    
          
        
        scanlen_ctrl=15,
        
        

      

        
        scanlen_r=(Bits)/2,
        
        scanlen_l=(Bits+1)/2 ; 
      
      

    parameter
        
        `ifdef functional  
            RW_assertions_en = 0,
        `endif
        WordX = {Bits{1'bx}},
        AddrX = {Addr{1'bx}},
        Word0 = {Bits{1'b0}},
        X = 1'bx;
   



//  WIRE DECLARATION RELATED TO POWER PINS
//  ======================================
	
        wire supply_ok, full_shutdown;
        
        wire core_supply_ok;
        wire peri_supply_ok;

        wire gndmint, gndsmint;
         
        
        wire vddmpint;
        wire vddmoint;
        wire vddmaint;
        wire vddsmpint;  
        wire vddsmaint;  
        
        

//  WIRE DECLARATION 
//  ==================
        wire [Bits-1 : 0] CSWEMTBYPASS;
        wire [Bits-1 : 0] Dint, Dsys;
        wire [Bits-1 : 0] Mint; 
        wire [22-1:0] Msys;
	wire [Addr-1 : 0] Aint;
        wire [Addr-1 : 0] Asys;

       


        wire [max_address_bits-1 : 0] A_int; 
                
	wire CKint_dft;
	wire CKint_func;
	wire CSNint;
        wire MEMEN;
        wire MEMEN_dft;
        wire TSE;

	wire WENint;
	wire WENsys;
        wire SLEEPint;
        wire STDBYint;
        wire SEint;
        wire SEsys;
        wire SCTRLIint;
        wire SDLIint;
        wire SDRIint;
        
        wire INITNint;
        wire TBYPASSint;
        wire TBYPASSsys;
        wire LSint; 
        wire HSint; 
        wire ATPint;
        wire DEint;
        
        wire [Addr-1 : 0] TAint;
        wire TBISTint;
        wire TBISTsys;
        wire TCSNint;
        wire TEDint;
        wire TODint;
        wire TEMint;
        wire TOMint;
        wire [Bits-1 : 0] TMint;
        wire [Bits-1 : 0] TDint;
        wire TWENint;
        wire IGint;
        wire IGbuf;
        wire CSNbuf;
        wire WENbuf;
        wire [read_margin_size-1:0] RMint;
        wire [write_margin_size-1:0] WMint;

        //Wires for scan chains
        //  ====================     
        wire [scanlen_ctrl -1:0]scanreg_ctrl_wire;
        wire [scanlen_l -1:0]  scanreg_dl_wire; 
        wire [scanlen_r -1:0]  scanreg_dr_wire; 
   
        wire [scanlen_l -1:0]  scanreg_ml_wire; 
        wire [scanlen_r -1:0]  scanreg_mr_wire; 


        wire [repair_address_width -1 : 0] RRAint;
        wire RRAEint;
        wire TRRAEint;    
        wire red_en;
        wire [repair_address_width -1 : 0] repair_add, next_repair_add;


//  REG DECLARATION
//  ====================     
        reg MEMEN_reg;
        reg MEMEN_prev;
        reg reg_mem_block;
        reg flag_mem_block;
        reg SCTRLIint_temp;
        reg SDLIint_temp;
        reg SDRIint_temp;
        reg SMLIint_temp;
        reg SMRIint_temp;

        //  REG DECLARATION
        //  ====================
        reg SCTRLOint;
        
        reg SDLOint,SDROint;
         
        
        reg next_cycle_corrupt_func;
        reg next_cycle_corrupt_dft;
        reg [Bits-1 : 0] delOutReg_data;//delayed Output Register
        reg [Bits-1 : 0] OutReg_data;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_tbypass;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_scan;   // Data Output registe
        reg [Bits-1 : 0] OutReg_rado_retained;   // register for retaining rado data when SLEEP --> 1
        reg delSCTRLO_data,SCTRLO_data;      // delayed Output Register
        reg delSDLO_data,SDLO_data;      // delayed Output Register
        reg delSDRO_data,SDRO_data;      // delayed Output Register
        
        
        // SCAN CHAINS register
        reg scanreg_ctrl; 
        reg scanreg_dl; 
        reg scanreg_dr; 
        
        
        reg CK_sc;
        reg Latch_open=0;
        reg lastCK_dft,CKreg_dft;
        reg lastCK_func,CKreg_func;
        reg lastSLEEP;
        reg lastPSWLARGEMP,lastPSWLARGEMA,lastPSWSMALLMP,lastPSWSMALLMA;
        reg CSNreg;
        reg init_pulse_done; //if == 1 then it implies that initb low pulse has been applied
        reg power_up_done; //if == 1 then it implies that power up has been done
        `ifdef slm
        `else
	      
             reg [Bits-1 : 0] Mem [Words-1 : 0];
             reg [Bits-1 : 0] RedMem [RedWords-1 : 0];
 
        `endif
        
	reg [Bits-1 :0] Mem_temp;
        reg [Bits-1 :0] Mem_slm; 
	reg ValidAddress;
	reg ValidDebugCode;
        reg decoding_start;
        reg file_loaded;
        reg [Bits-1 :0] Dreg;
        reg [Bits-1 :0] Mreg;
        reg WENreg;
        reg [Addr-1 :0] Areg;
        reg SE_reg;
        reg TBYPASS_reg;
        reg INITNreg;
        reg IGreg;
        reg DEreg;
        reg SLEEPreg;
        reg STDBYreg;
        reg ATPreg;
        reg MEMEN_dft_reg;
        reg MEMEN_dft_prev;
        reg RRMATCHreg;
        reg RRMATCHreg_last;//changes_made
        reg RRMATCHreg_glitch;
        reg [repair_address_width -1 : 0] repair_add_last;
        reg RRAEint_last;
        reg [Addr-mux_bits-1:0] row_add_temp;
        reg [Addr-mux_bits-bank_bits-1:0] row_add_cmp_temp;

       
        //parameter registers
        reg [2047:0] reg_Fault_file_name;
        reg reg_ConfigFault;
        reg reg_MEM_INITIALIZE;
        reg reg_BinaryInit;
        reg [2047:0] reg_InitFileName;
        reg [Bits -1 :0] reg_Initn_reset_value;
        time reg_File_load_time;

        //Power Supply Registers        
        reg vddmireg;
        reg vddmreg;
        reg vddsmreg;
        reg gndmreg;
        reg gndsmreg;   
        reg vddmpreg;
        reg vddmpireg;
        reg vddmareg;
        reg vddsmpreg;
        reg vddsmareg;
        reg vddmoreg;
        time vddmp_rise_time;
        time vddmp_fall_time;
        time vddsmp_rise_time;
        time vddsmp_fall_time;
        time vddma_rise_time;
        time vddma_fall_time;
        time vddsma_rise_time;
        time vddsma_fall_time;
        reg reg_check_rise;
        reg reg_check_fall;
        reg reg_check_rise_vddma;
        reg reg_check_fall_vddsma;
        reg  reg_check_rise_vddm, reg_check_fall_vddsm ;
        time vddm_fall_time,  vddm_rise_time,  vddsm_fall_time, vddsm_rise_time ;
  /* This register is used to force all warning messages 
  ** OFF during run time.
  ** It is a 2 bit register.
  ** USAGE :
  ** debug_level_off = 2'b00 -> ALL MESSAGES(INFO/WARNINGS/ERRORS) will be DISPLAYED 
  ** debug_level = 2'b01     -> ONLY WARNINGS/ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b10     -> ONLY ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b11     -> NO MESSAGES will be DISPLAYED.
  */ 
        reg [1:0] debug_level;
        reg [8*10: 0] operating_mode;
        reg [8*44: 0] message_status;

        integer i, k, j, l,m,q,w,r,s,num1,redcnt,n,num2,FirstHalf,Bfaileff,memcnt,ptr;
        integer decoder[Bits-1:0];
        `ifdef slm
           integer MemAddr;
        `endif


        //************************************************************
        //****** CONFIG FAULT IMPLEMENTATION VARIABLES*************** 
        //************************************************************ 

        integer file_ptr, ret_val;
        integer fault_word;
        integer fault_bit;
        integer fcnt, Fault_in_memory,faultnum,stop_loop,count;
        integer t;  
        integer FailureLocn [max_faults -1 :0];
        integer Failurebit [max_faults -1 :0];
        reg [100 : 0] stuck_at;
        reg [100 : 0] fault_array;
        reg [200 : 0] tempStr;
        reg [7:0] fault_char;
        reg [7:0] fault_char1; // 8 Bit File Pointer
        reg [Addr -1 : 0] std_fault_word;
        reg [Addr -1 : mux_bits] fault_row_add [max_faults -1 :0];
        reg [max_faults -1 :0] fault_repair_flag;
        reg [max_faults -1 :0] dont_insert_fault;
        reg [max_faults -1 :0] repair_flag;
        reg [100 : 0] array_stuck_at[max_faults -1 : 0] ;
        reg [100 : 0] mem_red_array_stuck_at[max_faults -1 : 0] ; 
        reg msgcnt;
        
       
        reg [Bits - 1: 0] stuck_at_0fault [max_faults -1 : 0];
        reg [Bits - 1: 0] stuck_at_1fault [max_faults -1 : 0];
        reg [Bits -1 : 0] stuck0;
        reg [Bits -1 : 0] stuck1;

        reg [Bits+Red_extrabit :0] Mem_last;
        

        `ifdef slm
        reg [Bits -1 : 0] slm_temp_data;
        `endif
        
        real time_CK_func_rise , time_RADCK_rise;
        real time_fall_sleep,time_fall_PSWLARGEMP,time_fall_PSWLARGEMP_0,time_fall_PSWLARGEMA,time_fall_PSWLARGEMA_0,time_fall_PSWSMALLMP,time_fall_PSWSMALLMA;
        integer flag_error;
        
//BUFFER INSTANTIATION
//=========================
       `ifdef functional
       
         buf (SCTRLO,delSCTRLO_data); 
         buf bufq [Bits-1:0] (Q,delOutReg_data);
      `else
       
         buf (SCTRLO,SCTRLO_data);
         buf bufq [Bits-1:0] (Q,OutReg_data);
      `endif
      
  
        buf (SEsys,SE);
	buf (SCTRLIint, SCTRLI);
   

	buf (CKint_func, CK);
	buf (CKint_dft, CK);
        buf bufaddr [Addr-1:0] (Asys,A);
        buf (INITNint,INITN);
        
        buf (LSint,1'b0); 
        buf (IGbuf,IG);
        buf (ATPint,ATP);

        buf bufTaddr [Addr-1 : 0] (TAint,TA);
        buf (TBISTsys,TBIST);
        buf (TCSNint,TCSN);

        buf (CSNsys,CSN);
        buf (STDBYint,STDBY );   
        
        buf (SLEEPint,SLEEP ); 

        buf bufrm [read_margin_size-1:0] (RMint, RM); 

        
        

        assign RRAEint = 1'b0;
        assign TRRAEint = 1'b0;
        assign repair_add = 0;
        assign next_repair_add = 0;
        assign red_en = 1'b0; 
        
        
        
        
        
        
        
        buf (PSWLARGEMPint,1'b0);
        buf (PSWSMALLMPint,1'b0); 
        buf (PSWLARGEMAint,1'b0);
        buf (PSWSMALLMAint,1'b0);   

      `ifdef functional
       
       
         buf (SDLO,delSDLO_data);
         buf (SDRO,delSDRO_data);
        
      `else
       
         buf (SDLO,SDLO_data);
         buf (SDRO,SDRO_data);
         
      `endif
       
         
       
        buf bufdata [Bits-1:0] (Dsys,D);
        
        
        assign Msys=22'b0; 
	

        
        buf (TBYPASSsys, TBYPASS);
        


        buf (WENsys,WEN);
	 
	buf (SDLIint, SDLI);
	buf (SDRIint, SDRI);
	 
        
        buf (HSint,1'b0); 

        
        buf (TEDint,TED);
        buf (TODint,TOD);
         
        buf (TWENint,TWEN);
        
        
        buf bufwm [write_margin_size-1:0] (WMint, WM); 
        



//      assign scanreg_ctrl_wire={scanreg_ctrl[scanlen_ctrl - 2:0],SCTRLIint};
//      assign scanreg_dl_wire={scanreg_dl[scanlen_l - 2:0],SDLIint};
//      assign scanreg_dr_wire={scanreg_dr[scanlen_r - 2:0],SDRIint};
      
        
      assign Aint   = (TBISTint === 1'b0 ) ? Asys : (TBISTint === 1'bx ) ? {Addr{1'bx}} : TAint;  

        
//        assign A_int = Aint;
	
        
                
        assign Dint[0] = (TBISTint === 1'b0) ? Dsys[0] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[1] = (TBISTint === 1'b0) ? Dsys[1] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[2] = (TBISTint === 1'b0) ? Dsys[2] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[3] = (TBISTint === 1'b0) ? Dsys[3] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[4] = (TBISTint === 1'b0) ? Dsys[4] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[5] = (TBISTint === 1'b0) ? Dsys[5] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[6] = (TBISTint === 1'b0) ? Dsys[6] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[7] = (TBISTint === 1'b0) ? Dsys[7] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[8] = (TBISTint === 1'b0) ? Dsys[8] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[9] = (TBISTint === 1'b0) ? Dsys[9] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[10] = (TBISTint === 1'b0) ? Dsys[10] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[11] = (TBISTint === 1'b0) ? Dsys[11] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[12] = (TBISTint === 1'b0) ? Dsys[12] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[13] = (TBISTint === 1'b0) ? Dsys[13] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[14] = (TBISTint === 1'b0) ? Dsys[14] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[15] = (TBISTint === 1'b0) ? Dsys[15] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[16] = (TBISTint === 1'b0) ? Dsys[16] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[17] = (TBISTint === 1'b0) ? Dsys[17] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[18] = (TBISTint === 1'b0) ? Dsys[18] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[19] = (TBISTint === 1'b0) ? Dsys[19] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[20] = (TBISTint === 1'b0) ? Dsys[20] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[21] = (TBISTint === 1'b0) ? Dsys[21] : (TBISTint === 1'b1) ? TODint : 1'bx;          
	 
        assign Mint = 22'b0;
         

        assign WENbuf = (TBISTint === 1'b0 ) ? WENsys : (TBISTint === 1'bx ) ? 1'bx : TWENint;  
        assign WENint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? WENbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[13] : (ATPint === 1'b0 ) ? WENsys : 1'bx ; 
        
        assign CSNbuf = (TBISTint === 1'b0 ) ? CSNsys : (TBISTint === 1'bx ) ? 1'bx : TCSNint;  
        assign CSNint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? CSNbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[11] : (ATPint === 1'b0 ) ? CSNsys : 1'bx ; 
        assign IGint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? IGbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[14] : (ATPint === 1'b0 ) ? IGbuf : 1'bx;

        
        assign DEint = (LSint === 1'bx || (LSint === 1'b0 && HSint === 1'bx) || ^RMint !== 1'b0 || ^WMint !== 1'b0 ) ? 1'bx : 1'b0;
        
     
     and (TBISTint, ATPint, TBISTsys);
     and (SEint, ATPint, SEsys);
     and (TBYPASSint, ATPint, TBYPASSsys);
     and (TSE,TBYPASSint,!SEsys);
     and (MEMEN,INITNint,!CSNint,!SLEEPint,!TBYPASSint,!SEint,!IGint,!DEint,!STDBYint );
     and (MEMEN_dft,INITNint, !SLEEPint, ATPint,!STDBYint);

 `ifdef functional
/*****************assertions added to optimize dynamic power consumption**********/

//psl a_M: assert always ({( RW_assertions_en);(MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1))  } |-> (stable(Msys))) @(posedge CK); 

//psl a_WEN: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(WENsys))) @(posedge CK); 

//psl a_A: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(Asys))) @(posedge CK); 

//psl a_D: assert always ({( RW_assertions_en);((MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1)) && TBYPASSint === 1'b0)  } |-> (stable(Dsys))) @(posedge CK); 

/**********************************************************************************************/
`endif       

     

         
reg vddmp,vddmo, vddma, vddsmp, vddsma, gndsm, gndm,  vddmpi ; 
 
initial 
begin

        vddmp = 1'b1 ; 
        vddmo = 1'b1 ;
        vddma = 1'b1 ;
        
        vddsmp = 1'b1 ;
        
        
         gndm = 1'b0 ;
          
end

        
         assign gndmint = (reg_mem_block === 0) ? gndm : 1'b1;
         
         
         
         
         assign vddmpint = vddmp;
         assign vddmoint = vddmo;
         assign vddmaint = vddma;
         
          
        
         

        //CPF Changes

        
                
        initial
        begin : cpfvddmp 
           vddmpreg = vddmpint;
        end

        always @(vddmpint) begin
           vddmpreg = vddmpint;
        end
        
        initial
        begin : cpfvddmo 
           vddmoreg = vddmoint;
        end

        always @(vddmoint) begin
           vddmoreg = vddmoint;
        end
        
        initial
        begin : cpfvddma 
           vddmareg = vddmaint;
        end

        always @(vddmaint) begin
           vddmareg = vddmaint;
        end

        
        
 
        initial
        begin : cpfgndm 
           gndmreg = gndmint;
        end

        always @(gndmint) begin
           gndmreg = gndmint;
        end

        
        



 `ifdef functional
  `else
  initial begin
    if (debug_level < 1) begin
     $display ("%m  INFORMATION");
     $display ("***************************************");
     $display ("The Model is Operating in TIMING MODE");
     $display ("Please make sure that SDF is properly annotated otherwise dummy values will be used");
     $display ("%s", message_status);
     $display ("***************************************");
    end
  end

//////////////////////////
 //REG DECLARATIONS
   //======================

   reg [Bits-1 : 0] TimingViol_data;
   reg  [Bits-1 : 0] TimingViol_mask;
   reg [Bits-1 : 0] TimingViol_data_last, TimingViol_mask_last;
	reg TimingViol_data_0;
	reg TimingViol_data_1;
	reg TimingViol_data_2;
	reg TimingViol_data_3;
	reg TimingViol_data_4;
	reg TimingViol_data_5;
	reg TimingViol_data_6;
	reg TimingViol_data_7;
	reg TimingViol_data_8;
	reg TimingViol_data_9;
	reg TimingViol_data_10;
	reg TimingViol_data_11;
	reg TimingViol_data_12;
	reg TimingViol_data_13;
	reg TimingViol_data_14;
	reg TimingViol_data_15;
	reg TimingViol_data_16;
	reg TimingViol_data_17;
	reg TimingViol_data_18;
	reg TimingViol_data_19;
	reg TimingViol_data_20;
	reg TimingViol_data_21;
 reg TimingViol_mask_0;
 reg TimingViol_mask_1;
 reg TimingViol_mask_2;
 reg TimingViol_mask_3;
 reg TimingViol_mask_4;
 reg TimingViol_mask_5;
 reg TimingViol_mask_6;
 reg TimingViol_mask_7;
 reg TimingViol_mask_8;
 reg TimingViol_mask_9;
 reg TimingViol_mask_10;
 reg TimingViol_mask_11;
 reg TimingViol_mask_12;
 reg TimingViol_mask_13;
 reg TimingViol_mask_14;
 reg TimingViol_mask_15;
 reg TimingViol_mask_16;
 reg TimingViol_mask_17;
 reg TimingViol_mask_18;
 reg TimingViol_mask_19;
 reg TimingViol_mask_20;
 reg TimingViol_mask_21;

   reg TimingViol_addr;
   reg TimingViol_CSN, TimingViol_WEN, TimingViol_tbypass;
   reg TimingViol_tckh, TimingViol_tckl, TimingViol_tcycle;
   reg TimingViol_tckh_se, TimingViol_tckl_se, TimingViol_tcycle_se;
   reg TimingViol_sctrli,TimingViol_sdli,TimingViol_sdri,TimingViol_se;
   reg TimingViol_smli,TimingViol_smri;
   reg TimingViol_sctrli_flag,TimingViol_sdli_flag,TimingViol_sdri_flag;
   reg TimingViol_smli_flag,TimingViol_smri_flag;
   reg TimingViol_initnl;
   reg TimingViol_initn;
   reg TimingViol_ls;
   reg TimingViol_hs;
   reg TimingViol_sleep;
   reg TimingViol_stdby;
   reg TimingViol_rm;
   reg TimingViol_wm;
   reg TimingViol_tbist,TimingViol_ig,TimingViol_atp,TimingViol_TED,TimingViol_TOD,TimingViol_TEM,TimingViol_TOM;
   reg TimingViolRRAE,TimingViolRRA;

   wire CSTBYPASSN,cond_sdf_tas,cond_sdf_tds,cond_sdf_tms,cond_sdf_tws,cond_sdf_tbas,cond_sdf_tbps,cond_sdf_tbws,cond_sdf_tbdes,cond_sdf_tbdos,cond_sdf_tbmes,cond_sdf_tbmos;
   wire SETB_EN,CSIG_EN,MEM_ACT,EN_ADM,CS_EN,CS_ADM,cond_sdf_tps,IG_EN,IG_ADM,cond_sdf_tigs,cond_sdf_taa,cond_sdf_taa_ls1,cond_sdf_taa_hs1,cond_tseq_tm;
   wire cond_sdf_tcycle,cond_sdf_tcycle_ls1,cond_sdf_tcycle_hs1,cond_sdf_tcycle_se,cond_sdf_tckl_se,cond_sdf_tsctrlis,cond_sdf_tsdlis,cond_sdf_tsdris,cond_sdf_tsmlis,cond_sdf_tsmris;
   wire cond_sdf_tckh_se,cond_sdf_taa_sctrlo_se,cond_sdf_taa_sdlo_se,cond_sdf_taa_sdro_se,cond_sdf_taa_smlo_se,cond_sdf_taa_smro_se,cond_sdf_tckl,cond_sdf_tckh;
   wire cond_sdf_ttms,cond_sdf_tbists,INITNandnotSLEEPandATPandnotSE,cond_sdf_taa_sctrlo,cond_sdf_taa_sdlo,cond_sdf_taa_sdro,cond_sdf_taa_smlo,cond_sdf_taa_smro;
   wire cond_sdf_taa_tm,cond_sdf_taa_tm_ls1, cond_sdf_taa_tm_hs1,cond_sdf_taa_tckq_tm,cond_sdf_taa_tseq_tm;

   wire CSWETBYPASSN;
   wire cond_sdf_tstdbys,cond_sdf_tsls,sleep_en,atp_csn_en;
   wire cond_sdf_tlss,cond_sdf_thss,cond_sdf_trms,cond_sdf_twms; 
   wire cond_sdf_tses,cond_sdf_tinitns;
   wire tby_se_en;
   wire rra_en;
   wire tbist_atp_en;
   wire rrae_en;
   wire tbist_rrae_en;
   wire cond_sdf_trraes;
   wire cond_sdf_ttrraes;
   wire cond_sdf_taa_trramatch;
   wire cond_sdf_ttrraematch;
   wire cond_sdf_tamatch;
   wire cond_sdf_ttamatch;
   wire cond_sdf_tatpmatch;
   wire cond_sdf_ttbistmatch;



 and (CSWEMTBYPASS[0], !Mreg[0], CSWETBYPASSN);
 and (CSWEMTBYPASS[1], !Mreg[1], CSWETBYPASSN);
 and (CSWEMTBYPASS[2], !Mreg[2], CSWETBYPASSN);
 and (CSWEMTBYPASS[3], !Mreg[3], CSWETBYPASSN);
 and (CSWEMTBYPASS[4], !Mreg[4], CSWETBYPASSN);
 and (CSWEMTBYPASS[5], !Mreg[5], CSWETBYPASSN);
 and (CSWEMTBYPASS[6], !Mreg[6], CSWETBYPASSN);
 and (CSWEMTBYPASS[7], !Mreg[7], CSWETBYPASSN);
 and (CSWEMTBYPASS[8], !Mreg[8], CSWETBYPASSN);
 and (CSWEMTBYPASS[9], !Mreg[9], CSWETBYPASSN);
 and (CSWEMTBYPASS[10], !Mreg[10], CSWETBYPASSN);
 and (CSWEMTBYPASS[11], !Mreg[11], CSWETBYPASSN);
 and (CSWEMTBYPASS[12], !Mreg[12], CSWETBYPASSN);
 and (CSWEMTBYPASS[13], !Mreg[13], CSWETBYPASSN);
 and (CSWEMTBYPASS[14], !Mreg[14], CSWETBYPASSN);
 and (CSWEMTBYPASS[15], !Mreg[15], CSWETBYPASSN);
 and (CSWEMTBYPASS[16], !Mreg[16], CSWETBYPASSN);
 and (CSWEMTBYPASS[17], !Mreg[17], CSWETBYPASSN);
 and (CSWEMTBYPASS[18], !Mreg[18], CSWETBYPASSN);
 and (CSWEMTBYPASS[19], !Mreg[19], CSWETBYPASSN);
 and (CSWEMTBYPASS[20], !Mreg[20], CSWETBYPASSN);
 and (CSWEMTBYPASS[21], !Mreg[21], CSWETBYPASSN);

and (atp_csn_en,!ATPint,!CSNint,!IGint);
or (sleep_en,atp_csn_en,ATPint);
or (SETB_EN,SEint,TBISTint);
and (ATP_SETB_EN,ATPint,SETB_EN); 
or (CSIG_EN,IGint,CSNint);
and (MEM_ACT,!ATPint,CSIG_EN);
or (EN_ADM,MEM_ACT,ATP_SETB_EN);
and (CS_EN,!ATPint,IGint);
or (CS_ADM,CS_EN,ATP_SETB_EN);
and (atp_ig_csn_en,!ATPint,!CSNint,!IGint);
and (atp_se_en,!SEsys,ATPint);
or (cycle_en,atp_ig_csn_en,atp_se_en);
and (atp_ig_csn_en_reg,!ATPreg,!CSNreg,!IGreg);
and (atp_se_en_reg,!SE_reg,ATPreg);
or (cycle_en_reg,atp_ig_csn_en,atp_se_en);
and (INITNandnotSLEEPandATPandnotSE,cond_gac,!SEsys,ATPint);
and (csn_ig_en,!IGint,!CSNint);
and (atp_tby_ls_en,atp_se_en,cond_ls_tby_en);
and (IG_EN,!ATPint,!CSNint);
or (IG_ADM,IG_EN,atp_se_en);
and (CSWETBYPASSN, !WENreg, 1'b1);



assign cond_sdf_tsls=((sleep_en && INITNint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tstdbys=((sleep_en && INITNint && !SLEEPint) !==0) ? 1:0;
assign cond_sdf_atps=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_gac=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tas=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tds=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tms=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tws=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tps=((cond_gac && !CS_ADM) !==0) ? 1:0;
assign cond_sdf_tcycle=((cond_gac && cycle_en && !LSint && !HSint) !==0) ? 1:0;  
assign cond_sdf_tcycle_ls1=((cond_gac && cycle_en && LSint) !==0) ? 1:0;
assign cond_sdf_tcycle_hs1=((cond_gac && cycle_en && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_tckh=((cond_gac && cycle_en_reg) !==0) ? 1:0;
assign cond_sdf_tckl=((cond_gac && cycle_en) !==0) ? 1:0;
assign cond_sdf_tcycle_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckl_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsctrlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckh_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_ttms=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_tbists=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_tckq_tm=((cond_gac && SE_reg && ATPreg && TBYPASSsys) !==0) ? 1:0;
assign cond_ls_en=((atp_ig_csn_en || atp_tby_ls_en) !==0) ? 1:0;
assign cond_sdf_tlss=((cond_ls_en && cond_gac) !==0) ? 1:0;
assign cond_sdf_thss=((cond_ls_en && cond_gac && !LSint) !==0) ? 1:0;
assign cond_sdf_trms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_twms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_tses=((cond_gac && ATPint) !==0) ? 1:0;
assign cond_sdf_tbas=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbps=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbws=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tigs=((cond_gac && IG_ADM) !==0) ? 1:0;
assign cond_sdf_taa=((MEMEN_reg && WENreg && !LSint && !HSint) !==0) ? 1:0; 
// assign cond_sdf_taa_tbypass_q = ((MEMEN_reg && ATPint && TBYPASSint) !== 1'b0) ? 1'b1 : 1'b0;
assign cond_sdf_taa_ls1=((MEMEN_reg && WENreg && LSint) !==0) ? 1:0; 
assign cond_sdf_taa_hs1=((MEMEN_reg && WENreg && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && !HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_ls1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && LSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_hs1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tseq_tm=((cond_gac && TBYPASSint) !==0) ? 1:0;
assign cond_sdf_tinitns =(( sleep_en && !STDBYint && !SLEEPint) !==0) ? 1:0;
assign cond_ls_tby_en=((TBYPASSsys || csn_ig_en) !==0) ? 1:0;



//specify block begins

specify
    specparam
    
         PATHPULSE$CK$Q = 0,
         PATHPULSE$CK$SCTRLO = 0,

         PATHPULSE$CK$SDLO = 0,
         PATHPULSE$CK$SDRO = 0,
        
         PATHPULSE$SE$Q = 0,
         
//         PATHPULSE$TBYPASS$Q = 0,


        
         
        
         tsls = `setup_time,
         tslh = `hold_time ,
         tstdbys = `setup_time,
         tstdbyh = `hold_time , 
	 

         
         tcycle = `cycle_time,
         
         
         tckh = `pulse_width_time,
         tckl = `pulse_width_time,
         tcycle_se = `cycle_time,
         tckh_se = `pulse_width_time,
         tckl_se = `pulse_width_time,
         
         ttms = `setup_time,
         ttmh = `hold_time ,
         tps = `setup_time,
         tph = `hold_time ,
         tws = `setup_time,
         twh = `hold_time ,
         tds = `setup_time,
         tdh = `hold_time , 
         tas = `setup_time,
         tah = `hold_time ,
         tses= `setup_time,
         tseh= `hold_time ,
         tsctrlis=`setup_time,
         tsctrlih=`hold_time ,
         tsdlis=`setup_time,
         tsdlih=`hold_time ,
         tsdris=`setup_time,
         tsdrih=`hold_time , 
         tbists=`setup_time,
         tbisth=`hold_time ,
         tbps=`setup_time,
         tbph=`hold_time ,
         tbws=`setup_time,
         tbwh=`hold_time ,
         tbdes=`setup_time,
         tbdeh=`hold_time ,
         tbdos=`setup_time,
         tbdoh=`hold_time ,
         
         tbas=`setup_time,
         tbah=`hold_time ,
         tinitnl=`initin_low_pulse,
         tinitns=`setup_time,
         tinitnh=`hold_time ,
         tatps=`setup_time,
         tatph=`hold_time ,
         tigs=`setup_time,
         tigh=`hold_time ,
         
         
         trms=`setup_time,
         trmh=`hold_time ,
         twms=`setup_time,
         twmh=`hold_time , 

/*************************************************************************************************/
           // taa_tbypass_q = `access_time,
           // th_tbypass_q  = `retain_time,
            taa =`access_time,
            th = `retain_time,

 


            taa_tm =`access_time,
            th_tm = `retain_time,

            
            taa_tseq_tm =`access_time,
            th_tseq_tm = `retain_time,
            taa_tckq_tm   = `access_time,
            th_tckq_tm    = `retain_time,
            taa_sctrlo=`access_time,
            th_sctrlo= `retain_time,
            taa_sdlo=`access_time,
            th_sdlo= `retain_time,
            taa_sdro=`access_time,
            th_sdro= `retain_time,
            
         
            taa_sctrlo_se=`access_time,
            th_sctrlo_se= `retain_time
,
            taa_sdlo_se=`access_time,
            th_sdlo_se= `retain_time,
            taa_sdro_se=`access_time,
            th_sdro_se= `retain_time
         ;  


        /*---------------------- Timing Checks ---------------------*/

	$setup(posedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[6], tah, TimingViol_addr);

	$setup(posedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(posedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(posedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(posedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(posedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(posedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(posedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(posedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(posedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(posedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(posedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(posedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(posedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(posedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(posedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(posedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(posedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(posedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(posedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(posedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(posedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(posedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$setup(negedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(negedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(negedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(negedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(negedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(negedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(negedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(negedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(negedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(negedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(negedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(negedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(negedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(negedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(negedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(negedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(negedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(negedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(negedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(negedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(negedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(negedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[21], tdh, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[21], tdh, TimingViol_data_21);

        



        $setup(posedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $setup(negedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, posedge WEN, twh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, negedge WEN, twh, TimingViol_WEN); 
        $setup(posedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$setup(negedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, posedge CSN, tph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, negedge CSN, tph, TimingViol_CSN);
        $period(posedge CK &&& cond_sdf_tcycle, tcycle, TimingViol_tcycle);  

        
        $width(posedge CK  &&& cond_sdf_tckh, tckh, 0, TimingViol_tckh);
        $width(negedge CK  &&& cond_sdf_tckl, tckl, 0, TimingViol_tckl);
        $period(posedge CK &&& cond_sdf_tcycle_se, tcycle_se, TimingViol_tcycle_se);
        $width(posedge CK  &&& cond_sdf_tckh_se, tckh_se, 0, TimingViol_tckh_se);
        $width(negedge CK  &&& cond_sdf_tckl_se, tckl_se, 0, TimingViol_tckl_se);

        
        $setup(posedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $setup(negedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $hold(posedge CK &&& cond_sdf_ttms, posedge TBYPASS, ttmh, TimingViol_tbypass); 
        $hold(posedge CK &&& cond_sdf_ttms, negedge TBYPASS, ttmh, TimingViol_tbypass); 
 



        
        $setup(posedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $setup(negedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $hold(posedge CK &&& cond_sdf_tsls, posedge SLEEP, tslh, TimingViol_sleep);        
        $hold(posedge CK &&& cond_sdf_tsls, negedge SLEEP, tslh, TimingViol_sleep);

        $setup(posedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $setup(negedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $hold(posedge CK &&& cond_sdf_tstdbys, posedge STDBY, tstdbyh, TimingViol_stdby);        
        $hold(posedge CK &&& cond_sdf_tstdbys, negedge STDBY, tstdbyh, TimingViol_stdby); 
        
        
        $setup (posedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
	$setup (negedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
        
        $hold (posedge CK &&& cond_sdf_tses, posedge SE ,tseh,TimingViol_se);
	$hold (posedge CK &&& cond_sdf_tses, negedge SE ,tseh,TimingViol_se);
        
        $setup(posedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis , tsctrlis, TimingViol_sctrli);
        $setup(negedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis, tsctrlis, TimingViol_sctrli);
        $hold(posedge CK &&& cond_sdf_tsctrlis , posedge SCTRLI, tsctrlih, TimingViol_sctrli);        
        $hold(posedge CK &&& cond_sdf_tsctrlis , negedge SCTRLI, tsctrlih, TimingViol_sctrli);

        $setup(posedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $setup(negedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $hold(posedge CK &&& cond_sdf_tsdlis, posedge SDLI, tsdlih, TimingViol_sdli);        
        $hold(posedge CK &&& cond_sdf_tsdlis, negedge SDLI, tsdlih, TimingViol_sdli);

        $setup(posedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $setup(negedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $hold(posedge CK &&& cond_sdf_tsdris, posedge SDRI, tsdrih, TimingViol_sdri);        
        $hold(posedge CK &&& cond_sdf_tsdris, negedge SDRI, tsdrih, TimingViol_sdri);
        
 
	
         
        $width(negedge INITN , tinitnl, 0, TimingViol_initnl);
        
        $setup(posedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        $setup(negedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        
        $hold (posedge CK &&& cond_sdf_tinitns,posedge INITN, tinitnh, TimingViol_initn);
        $hold (posedge CK &&& cond_sdf_tinitns,negedge INITN, tinitnh, TimingViol_initn);

        $setup(posedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $setup(negedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $hold(posedge CK &&& cond_sdf_atps, posedge ATP, tatph, TimingViol_atp);        
        $hold(posedge CK &&& cond_sdf_atps, negedge ATP, tatph, TimingViol_atp);
        
        $setup(posedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $setup(negedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $hold(posedge CK &&& cond_sdf_tigs, posedge IG, tigh, TimingViol_ig);        
        $hold(posedge CK &&& cond_sdf_tigs, negedge IG, tigh, TimingViol_ig);



         
$setup(posedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[2], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[2], trmh, TimingViol_rm); 

        
$setup(posedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(posedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[1], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[1], twmh, TimingViol_wm);
 
        
        $setup(posedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $setup(negedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $hold(posedge CK &&& cond_sdf_tbists, posedge TBIST, tbisth, TimingViol_tbist);        
        $hold(posedge CK &&& cond_sdf_tbists, negedge TBIST, tbisth, TimingViol_tbist);
        
        	$setup(posedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$setup(negedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[6], tbah, TimingViol_addr);
       	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[6], tbah, TimingViol_addr);

        $setup(posedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$setup(negedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, posedge TCSN, tbph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, negedge TCSN, tbph, TimingViol_CSN); 
       
        $setup(posedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $setup(negedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, posedge TWEN, tbwh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, negedge TWEN, tbwh, TimingViol_WEN);
       
       
        $setup(posedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $setup(negedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, posedge TED, tbdeh, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, negedge TED, tbdeh, TimingViol_TED);

        $setup(posedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $setup(negedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, posedge TOD, tbdoh, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, negedge TOD, tbdoh, TimingViol_TOD);

          


          

          /*-------------------- Propagation Delays ------------------*/
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa, taa, th, taa, th, taa);
                 

/* // //	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[0] +: OutReg_data[0])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[1] +: OutReg_data[1])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[2] +: OutReg_data[2])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[3] +: OutReg_data[3])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[4] +: OutReg_data[4])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[5] +: OutReg_data[5])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[6] +: OutReg_data[6])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[7] +: OutReg_data[7])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[8] +: OutReg_data[8])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[9] +: OutReg_data[9])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[10] +: OutReg_data[10])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[11] +: OutReg_data[11])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[12] +: OutReg_data[12])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[13] +: OutReg_data[13])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[14] +: OutReg_data[14])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[15] +: OutReg_data[15])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[16] +: OutReg_data[16])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[17] +: OutReg_data[17])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[18] +: OutReg_data[18])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[19] +: OutReg_data[19])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[20] +: OutReg_data[20])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[21] +: OutReg_data[21])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q); */ 








	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                





	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                 

	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[0] +: OutReg_data[0])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[1] +: OutReg_data[1])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[2] +: OutReg_data[2])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[3] +: OutReg_data[3])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[4] +: OutReg_data[4])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[5] +: OutReg_data[5])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[6] +: OutReg_data[6])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[7] +: OutReg_data[7])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[8] +: OutReg_data[8])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[9] +: OutReg_data[9])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[10] +: OutReg_data[10])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[11] +: OutReg_data[11])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[12] +: OutReg_data[12])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[13] +: OutReg_data[13])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[14] +: OutReg_data[14])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[15] +: OutReg_data[15])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[16] +: OutReg_data[16])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[17] +: OutReg_data[17])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[18] +: OutReg_data[18])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[19] +: OutReg_data[19])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[20] +: OutReg_data[20])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[21] +: OutReg_data[21])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                



if (cond_sdf_taa_sctrlo) 
        (posedge CK *> (SCTRLO :  SCTRLI)) = (taa_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo); 

if (cond_sdf_taa_sctrlo_se) 
        (negedge CK *> (SCTRLO : SCTRLI)) = (taa_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se); 
 

if (cond_sdf_taa_sdlo) 
        (posedge CK *> (SDLO :  SDLI)) = (taa_sdlo,taa_sdlo,th_sdlo,taa_sdlo,th_sdlo,taa_sdlo); 

if (cond_sdf_taa_sdlo_se) 
        (negedge CK *> (SDLO : SDLI)) = (taa_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se);

if (cond_sdf_taa_sdro) 
        (posedge CK *> (SDRO :  SDRI)) = (taa_sdro,taa_sdro,th_sdro,taa_sdro,th_sdro,taa_sdro); 

if (cond_sdf_taa_sdro_se) 
        (negedge CK *> (SDRO : SDRI)) = (taa_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se); 

  
     




endspecify //specify block ends






// conversion from registers to array elements for data setup violation notifiers

always @(TimingViol_data_0   or TimingViol_TED  )
begin
        TimingViol_data[0]=~TimingViol_data[0];   
end


always @(TimingViol_data_1   or TimingViol_TOD  )
begin
        TimingViol_data[1]=~TimingViol_data[1];   
end


always @(TimingViol_data_2   or TimingViol_TED  )
begin
        TimingViol_data[2]=~TimingViol_data[2];   
end


always @(TimingViol_data_3   or TimingViol_TOD  )
begin
        TimingViol_data[3]=~TimingViol_data[3];   
end


always @(TimingViol_data_4   or TimingViol_TED  )
begin
        TimingViol_data[4]=~TimingViol_data[4];   
end


always @(TimingViol_data_5   or TimingViol_TOD  )
begin
        TimingViol_data[5]=~TimingViol_data[5];   
end


always @(TimingViol_data_6   or TimingViol_TED  )
begin
        TimingViol_data[6]=~TimingViol_data[6];   
end


always @(TimingViol_data_7   or TimingViol_TOD  )
begin
        TimingViol_data[7]=~TimingViol_data[7];   
end


always @(TimingViol_data_8   or TimingViol_TED  )
begin
        TimingViol_data[8]=~TimingViol_data[8];   
end


always @(TimingViol_data_9   or TimingViol_TOD  )
begin
        TimingViol_data[9]=~TimingViol_data[9];   
end


always @(TimingViol_data_10   or TimingViol_TED  )
begin
        TimingViol_data[10]=~TimingViol_data[10];   
end


always @(TimingViol_data_11   or TimingViol_TOD  )
begin
        TimingViol_data[11]=~TimingViol_data[11];   
end


always @(TimingViol_data_12   or TimingViol_TED  )
begin
        TimingViol_data[12]=~TimingViol_data[12];   
end


always @(TimingViol_data_13   or TimingViol_TOD  )
begin
        TimingViol_data[13]=~TimingViol_data[13];   
end


always @(TimingViol_data_14   or TimingViol_TED  )
begin
        TimingViol_data[14]=~TimingViol_data[14];   
end


always @(TimingViol_data_15   or TimingViol_TOD  )
begin
        TimingViol_data[15]=~TimingViol_data[15];   
end


always @(TimingViol_data_16   or TimingViol_TED  )
begin
        TimingViol_data[16]=~TimingViol_data[16];   
end


always @(TimingViol_data_17   or TimingViol_TOD  )
begin
        TimingViol_data[17]=~TimingViol_data[17];   
end


always @(TimingViol_data_18   or TimingViol_TED  )
begin
        TimingViol_data[18]=~TimingViol_data[18];   
end


always @(TimingViol_data_19   or TimingViol_TOD  )
begin
        TimingViol_data[19]=~TimingViol_data[19];   
end


always @(TimingViol_data_20   or TimingViol_TED  )
begin
        TimingViol_data[20]=~TimingViol_data[20];   
end


always @(TimingViol_data_21   or TimingViol_TOD  )
begin
        TimingViol_data[21]=~TimingViol_data[21];   
end


`endif


// TASK DEFINITION DESCRIPTION
// ================================



task task_insert_faults_in_memory;
begin
   if (reg_ConfigFault)
   begin   
     for(i = 0;i< fcnt;i = i+ 1) begin
        if(mem_red_array_stuck_at[i] === "mem_array") begin
          if (array_stuck_at[i] === "sa0") begin
           `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data & stuck_at_0fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
          `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] & stuck_at_0fault[i];
          `endif
         end //if(array_stuck_at)
                                        
         if(array_stuck_at[i] === "sa1") begin
         `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data | stuck_at_1fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
         `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] | stuck_at_1fault[i]; 
         `endif
         end //if(array_stuck_at)
       end //if mem_red_array_stuck_at
    
    
     end    // end of for
   end  
end
endtask



task task_read_fault_file;
begin
/*  -----------Implemetation for config fault starts------*/
   msgcnt = X;
   t = 0;
   fault_repair_flag = {max_faults{1'b1}};
   repair_flag = {max_faults{1'b1}};
   if(reg_ConfigFault) 
   begin
      file_ptr = $fopen(reg_Fault_file_name , "r");
      if(file_ptr == 0)
      begin     
          if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: File cannot be opened ",$realtime);
      end        
      else                
      begin : read_fault_file
        t = 0;
        for (i = 0; i< max_faults; i= i + 1)
        begin
         
           stuck0 = {Bits{1'b1}};
           stuck1 = {Bits{1'b0}};
           fault_char1 = $fgetc (file_ptr);
           if (fault_char1 == 8'b11111111)
              disable read_fault_file;
           ret_val = $ungetc (fault_char1, file_ptr);
           ret_val = $fgets(tempStr, file_ptr);
           ret_val = $sscanf(tempStr, "%s %d %d %s",fault_array,fault_word, fault_bit, stuck_at) ;
           flag_error = 0; 
           if(ret_val !== 0)
           begin         
              if(ret_val == 3 || ret_val == 4)
              begin
                if(ret_val == 3)
                   stuck_at = "sa0";

                if(stuck_at !== "sa0" && stuck_at !== "sa1" && stuck_at !== "none")
                begin
                    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: Wrong value for stuck at in fault file ",$realtime);
                   flag_error = 1;
                end    
                      
                if(fault_word >= Words)
                begin
                   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Address out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                if(fault_bit >= Bits)
                begin  
                    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Faulty bit out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                
                        
                if(fault_array !== "mem_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array is not mem_array ",$realtime);
                  flag_error = 1;
                end

                if(fault_array === "red_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array can't be on redundancy array in non redundancy cut.",$realtime);
                  flag_error = 1;
                end

                
                

                if(flag_error == 0)
                //Correct Inputs
                begin
                   if(stuck_at === "none")
                   begin
                       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
                   end
                   else
                   //Adding the faults
                   begin
                      FailureLocn[t] = fault_word;
                      Failurebit[t]  = fault_bit ;
                      std_fault_word = fault_word;
                      fault_row_add[t] = std_fault_word[Addr-1:mux_bits];
                      mem_red_array_stuck_at[t] = fault_array;
                      fault_repair_flag[t] = 1'b0;
                      if (stuck_at === "sa0" )
                      begin
                         stuck0[fault_bit] = 1'b0;         
                         stuck_at_0fault[t] = stuck0;
                      end     
                      if (stuck_at === "sa1" )
                      begin
                         stuck1[fault_bit] = 1'b1;
                         stuck_at_1fault[t] = stuck1; 
                      end

                      array_stuck_at[t] = stuck_at;
                      t = t + 1;
                   end //if(stuck_at === "none")  
                end //if(flag_error == 0)
              end //if(ret_val == 2 || ret_val == 3 
              else
              //wrong number of arguments
              begin
                if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: WRONG VALUES ENTERED FOR FAULTY WORD OR FAULTY BIT OR STUCK_AT IN Fault_file_name ",$realtime); 
                flag_error = 1;
              end
           end //if(ret_val !== 0)
           else
           begin 
               if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
           end    
        end //for (i = 0; i< m
      end //begin: read_fault_file  
      $fclose (file_ptr);

      fcnt = t;
      
      //fault injection at time 0.
      task_insert_faults_in_memory;
  end // config_fault 
end
endtask


task WriteMemX;
begin

`ifdef slm
   $slm_ResetMemory(MemAddr, WordX);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = WordX;
   
`endif        
 task_insert_faults_in_memory;
end
endtask

task WriteMem0;
begin
`ifdef slm
   $slm_ResetMemory(MemAddr, Word0);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = Word0;
  
`endif 
   task_insert_faults_in_memory;
end
endtask


task WriteOutX;                
begin
   OutReg_data <= #0 WordX;
end
endtask


task Invalid_next_cycle_func;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_func = 1;
     `else 
       #0 next_cycle_corrupt_func = 0; 
     `endif  
   end 
end
endtask

task Invalid_next_cycle_dft;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_dft = 1;
     `else 
       #0 next_cycle_corrupt_dft = 0; 
     `endif  
  end
end
endtask

task Invalid_next_cycle_func_tim;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
   #0 next_cycle_corrupt_func <= 1;
  end 
end
endtask

task Invalid_next_cycle_dft_tim;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
  #0 next_cycle_corrupt_dft <= 1;
  end
end
endtask


task ScanOutX;                
begin
   
   dff_SCTRLO_SE.Q <= 1'bx;   
   dff_SDLO_SE.Q <= 1'bx; 
   dff_SDRO_SE.Q <= 1'bx; 
    
   
   SCTRLOint=X;
   SDLOint=X;
   SDROint=X;
    
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   SDLO_data<=1'bx;
   SDRO_data<=1'bx;
    
   `endif
end
endtask

task delScanOutX;                
begin
   delSCTRLO_data<=X;
   delSDLO_data<=X;
   delSDRO_data<=X;
    
end
endtask

task ScanChainX;                
begin
 scanreg_ctrl=1'bx; 
 scanreg_dl=1'bx; 
 scanreg_dr =1'bx; 
  
end
endtask

task mem_blocked;
begin
 
   WriteMemX;
   WriteOutX;
   ScanChainX;
   ScanOutX;//immediately;
   delScanOutX;//immediately
   `ifdef POWER_SEQUENCING_OFF
   `else
   reg_mem_block=1;
   `endif
   debug_level = 2'b11;
end
endtask

task corrupt_all;
begin
 
  WriteMemX;
  WriteOutX;
  ScanChainX;
  ScanOutX;
  delScanOutX;//immediately;
  OutReg_data = WordX; 
  delOutReg_data=WordX;
  
end
endtask

task WriteCycle;                  
input [Addr-1 : 0] Address;
reg [Bits-1:0] tempReg1;
reg [Bits-1:0] tempReg_slm;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;


reg repair_flag;

integer po,i,num,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;
begin

   tempReg1 = WordX;
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];

   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};
   
   if (ValidAddress === X )   begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
        WriteMemX;
        if (INITNint !== 0) begin
        `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
           #0 next_cycle_corrupt_func = 1;
       `else 
           #0 next_cycle_corrupt_func = 0; 
       `endif  
   end 

   end


   if (ValidAddress !== X && next_cycle_corrupt_func === 0  )
   begin
         if (red_en === 1 && ((Row_Add_cmp === repair_add) || (Row_Add_cmp === next_repair_add)) ) begin
             repair_flag = 1'b1;
             
             Bank_sel_integer = 0;
                     
             if (Row_Add_cmp === repair_add) begin
               Col_Add_integer  = Col_Add; 
             end
             else if (Row_Add_cmp === next_repair_add) begin
               Col_Add_integer  = Col_Add + mux; 
             end  
             RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
        end  

        if(repair_flag === 0 && ValidAddress === 1) begin
           `ifdef slm
              $slm_ReadMemoryS(MemAddr, Address, tempReg_slm);
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = Mem[Address];
            `endif
          end  
        else if(repair_flag === 1) begin
           `ifdef slm
//              $slm_ReadMemoryS(RedMemAddr, RedMem_address, tempReg_slm);
          
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = RedMem[RedMem_address];
            `endif
        end
        
        for (num=0;num<Bits;num=num+1) begin
             po=num;        
             if ( Dint [num] !== tempReg1 [po]) begin
                if (Mint[num] === 1'b0)
                   tempReg1[po] = Dint[num];
                else if (Mint[num] === 1'bX)
                   tempReg1[po] = 1'bx;
             end                
        end //for (num=0
            
         if(repair_flag === 0 ) begin    
            if(ValidAddress === 1) begin  
              `ifdef slm
                  tempReg_slm=tempReg1; 
                  $slm_WriteMemory(MemAddr, Address, tempReg_slm);
              `else
                   Mem[Address] = tempReg1;
              `endif
            end
            else begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address Out Of Range. ",$realtime);
            end        
         end
         else if (repair_flag === 1 ) begin
            `ifdef slm
                tempReg_slm=tempReg1; 
//                $slm_WriteMemory(RedMemAddr, RedMem_address, tempReg_slm);
            `else
                RedMem[RedMem_address] = tempReg1;
            `endif
         end
   end //if (ValidAddress !== X
   task_insert_faults_in_memory;
end
endtask 

task ReadCycle;
input [Addr-1 : 0] Address;

reg [Bits-1:0] MemData_tmp;
reg [Bits-1:0] MemData;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;

reg repair_flag;

integer a,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;

begin
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];
   
   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};

   

   if (ValidAddress !== X && next_cycle_corrupt_func === 0 ) begin   
       if(red_en === 1 && ( Row_Add_cmp === repair_add ||  Row_Add_cmp === next_repair_add )) begin
              repair_flag = 1;
              
              Bank_sel_integer = 0;
               
              if(Row_Add_cmp === repair_add) begin
                Col_Add_integer = Col_Add;
              end
              else if (Row_Add_cmp === next_repair_add) begin
                Col_Add_integer = Col_Add + mux; 
              end
              RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
       end

      if(repair_flag === 0) begin
          if(ValidAddress === 1) begin 
           `ifdef slm
              $slm_ReadMemory(MemAddr, Address, MemData);
           `else
              MemData = Mem[Address];
           `endif
          end
          else begin
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Address Out Of Range. Output Corrupted ",$realtime);
             MemData = WordX;
          end
     end
      else if(repair_flag === 1) begin
        `ifdef slm
//           $slm_ReadMemory(RedMemAddr, RedMem_address, MemData);
        `else
           MemData = RedMem[RedMem_address];
        `endif
      end
   end //if (ValidAddress)  
   
   if(ValidAddress === X)
   begin
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Illegal Value on Address Bus. Memory and Output Corrupted ",$realtime); 
         Invalid_next_cycle_func;
   end 
   
  if(ValidAddress !== X && next_cycle_corrupt_func === 0 )
   begin
   for (a = 0; a < Bits; a = a + 1)
   begin
      if (MemData[a] !== OutReg_data[a])
         OutReg_data[a] = WordX[a];
   end//for (a = 0; a <  
         OutReg_data <= MemData;
   end     
end
endtask



// SCAN CHAINS
supply0 gnd;
buf (A_int[0], Aint[0]);
buf (A_int[1], Aint[1]);
buf (A_int[2], Aint[2]);
buf (A_int[3], Aint[3]);
buf (A_int[4], Aint[4]);
buf (A_int[5], Aint[5]);
buf (A_int[6], Aint[6]);                  //used for capturing
buf (A_int[7], gnd);
buf (A_int[8], gnd);
buf (A_int[9], gnd);
buf (A_int[10], gnd);
buf (A_int[11], gnd);
buf (A_int[12], gnd);
buf (A_int[13], gnd);
buf (A_int[14], gnd);   //used for capturing

buf (WEN_int, WENint);
buf (CSN_int, CSNint);
buf (IG_int, IGint);


// Scan flops



// CONTROL SCAN CHAIN
     ST_SPREG_LOLEAK_128x22m8_Tl_SCFF cntrl_scff_0 (.D(A_int[2]), .TI(SCTRLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[0]), .OUTX(scanreg_ctrl));

      
 ST_SPREG_LOLEAK_128x22m8_Tl_SCFF cntrl_scff_1 (.D(A_int[4]), .TI(scanreg_ctrl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[1]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m8_Tl_SCFF cntrl_scff_2 (.D(A_int[6]), .TI(scanreg_ctrl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[2]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m8_Tl_SCFF cntrl_scff_3 (.D(A_int[9]), .TI(scanreg_ctrl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[3]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m8_Tl_SCFF cntrl_scff_4 (.D(A_int[3]), .TI(scanreg_ctrl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[4]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m8_Tl_SCFF cntrl_scff_5 (.D(A_int[11]), .TI(scanreg_ctrl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[5]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m8_Tl_SCFF cntrl_scff_6 (.D(A_int[10]), .TI(scanreg_ctrl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[6]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m8_Tl_SCFF cntrl_scff_7 (.D(A_int[1]), .TI(scanreg_ctrl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[7]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m8_Tl_SCFF cntrl_scff_8 (.D(A_int[0]), .TI(scanreg_ctrl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[8]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m8_Tl_SCFF cntrl_scff_9 (.D(A_int[5]), .TI(scanreg_ctrl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[9]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m8_Tl_SCFF cntrl_scff_10 (.D(A_int[7]), .TI(scanreg_ctrl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[10]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m8_Tl_SCFF cntrl_scff_11 (.D(CSN_int), .TI(scanreg_ctrl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[11]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m8_Tl_SCFF cntrl_scff_12 (.D(A_int[8]), .TI(scanreg_ctrl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[12]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m8_Tl_SCFF cntrl_scff_13 (.D(WEN_int), .TI(scanreg_ctrl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[13]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_128x22m8_Tl_SCFF cntrl_scff_14 (.D(scanreg_ctrl_wire[14]), .TI(scanreg_ctrl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[14]), .OUTX(scanreg_ctrl));  

reg LP_CK_gate;

// Lock Up Latch
wire SCTRLO_temp;
 ST_SPREG_LOLEAK_128x22m8_Tl_lock_up_latch  dff_SCTRLO_SE (Latch_open, scanreg_ctrl_wire[14], SCTRLO_temp);

always @(SCTRLO_temp) begin
     SCTRLOint= SCTRLO_temp;
 `ifdef functional
 `else
 if (SCTRLOint !== SCTRLO_data) begin 
  if (SCTRLOint !==X)
   SCTRLO_data=1'bx;
   SCTRLO_data <= SCTRLOint;
 end 
 `endif
end  


// LEFT DATA SCAN CHAIN
     ST_SPREG_LOLEAK_128x22m8_Tl_SCFF ldata_scff_0 (.D(Dint[10]), .TI(SDLI), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[0]), .OUTX(scanreg_dl));
      
   
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF ldata_scff_1 (.D(Dint[9]), .TI(scanreg_dl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[1]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF ldata_scff_2 (.D(Dint[8]), .TI(scanreg_dl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[2]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF ldata_scff_3 (.D(Dint[7]), .TI(scanreg_dl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[3]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF ldata_scff_4 (.D(Dint[6]), .TI(scanreg_dl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[4]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF ldata_scff_5 (.D(Dint[5]), .TI(scanreg_dl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[5]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF ldata_scff_6 (.D(Dint[4]), .TI(scanreg_dl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[6]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF ldata_scff_7 (.D(Dint[3]), .TI(scanreg_dl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[7]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF ldata_scff_8 (.D(Dint[2]), .TI(scanreg_dl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[8]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF ldata_scff_9 (.D(Dint[1]), .TI(scanreg_dl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[9]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF ldata_scff_10 (.D(Dint[0]), .TI(scanreg_dl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[10]), .OUTX(scanreg_dl));



// Lock Up Latch
wire SDLO_temp;
 ST_SPREG_LOLEAK_128x22m8_Tl_lock_up_latch  dff_SDLO_SE (Latch_open, scanreg_dl_wire[10], SDLO_temp);

always @(SDLO_temp) begin
     SDLOint= SDLO_temp;
 `ifdef functional
 `else
 if (SDLOint !== SDLO_data) begin 
  if (SDLOint !==X)
   SDLO_data=1'bx;
   SDLO_data <= SDLOint;
 end 
 `endif
end  






// RIGHT DATA SCAN CHAIN

     ST_SPREG_LOLEAK_128x22m8_Tl_SCFF rdata_scff_0 (.D(Dint[21]), .TI(SDRI), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[0]), .OUTX(scanreg_dr));
     
 
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF rdata_scff_1 (.D(Dint[20]), .TI(scanreg_dr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[1]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF rdata_scff_2 (.D(Dint[19]), .TI(scanreg_dr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[2]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF rdata_scff_3 (.D(Dint[18]), .TI(scanreg_dr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[3]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF rdata_scff_4 (.D(Dint[17]), .TI(scanreg_dr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[4]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF rdata_scff_5 (.D(Dint[16]), .TI(scanreg_dr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[5]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF rdata_scff_6 (.D(Dint[15]), .TI(scanreg_dr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[6]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF rdata_scff_7 (.D(Dint[14]), .TI(scanreg_dr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[7]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF rdata_scff_8 (.D(Dint[13]), .TI(scanreg_dr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[8]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF rdata_scff_9 (.D(Dint[12]), .TI(scanreg_dr_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[9]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_128x22m8_Tl_SCFF rdata_scff_10 (.D(Dint[11]), .TI(scanreg_dr_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[10]), .OUTX(scanreg_dr)); 


// Lock Up Latch
wire SDRO_temp;
 ST_SPREG_LOLEAK_128x22m8_Tl_lock_up_latch  dff_SDRO_SE (Latch_open, scanreg_dr_wire[10], SDRO_temp);


always @(SDRO_temp) begin
     SDROint= SDRO_temp;
 `ifdef functional
 `else
 if (SDROint !== SDRO_data) begin 
  if (SDROint !==X)
   SDRO_data=1'bx;
   SDRO_data <= SDROint;
 end 
 `endif
end






//


 //////// CAPTURE TASK //////
task scan_acquire;
begin
   if (supply_ok === 1) begin 
      if ( SEsys === 0 && ((LP_CK_gate === 0 && TBYPASSsys !== 1'bx)|| TBYPASSsys===0)) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
         
         Latch_open=1;
         

      end //if ( SEint === 0
   end//if(supply_ok 
end
endtask

task scan_shift;
begin
 if (supply_ok === 1) begin
   if (STDBYint === 0 && SLEEPint === 0) begin
      if (CKint_dft === X && INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0) begin
         ScanChainX;
         ScanOutX;
      end
      else if (CKint_dft === 1 && lastCK_dft === 0 ) begin
          //// SHIFT
        if (SEsys === 1) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
           
        //// SHIFT Ends
        end //if (SEsys === 1
        else if (SEsys === X) begin
            ScanChainX;
            ScanOutX;
            delScanOutX;
        end//if (SEint ==X
      
      end///if (CKint === 
    
      else if (CKint_dft === 0 && lastCK_dft === 1 ) begin
        Latch_open=1;
      end
    end  //if (STDByint === 0 && SLEEPint === 0
 end//if(supply_ok
end
endtask






// BEHAVIOURAL MODULE DESCRIPTION
// ================================

initial
begin
  // Define format for timing value
  $timeformat (-9, 3, " ns", 0);
  `ifdef slm
  $slm_RegisterMemory(MemAddr, Words, Bits);
  `endif   
   reg_mem_block=0;
   flag_mem_block=0;
  `ifdef functional
  `else
   TimingViol_data=0;
   TimingViol_mask=0;
   `endif
   decoding_start=0;
  
   //Parameter Assignment
   
   reg_Fault_file_name = Fault_file_name; 
   reg_ConfigFault     = ConfigFault;
   reg_MEM_INITIALIZE  = MEM_INITIALIZE;
   reg_BinaryInit      = BinaryInit;
   reg_InitFileName    = InitFileName;
   reg_Initn_reset_value = Initn_reset_value;
   reg_File_load_time    = File_load_time;

   time_fall_sleep=0;
   time_fall_PSWLARGEMP=0;
   time_fall_PSWLARGEMP_0=0;
   time_fall_PSWLARGEMA=0;
   time_fall_PSWLARGEMA_0=0;
   time_fall_PSWSMALLMP=0;
   time_fall_PSWSMALLMA=0;

   vddmp_rise_time=0;
   vddmp_fall_time=0;
   vddsmp_rise_time=0;
   vddsmp_fall_time=0;
   vddma_rise_time=0;
   vddma_fall_time=0;
   vddsma_rise_time=0;
   vddsma_fall_time=0;
   vddm_fall_time=0;  
   vddm_rise_time=0;  
   vddsm_fall_time=0; 
   vddsm_rise_time=0;

   next_cycle_corrupt_func=0;
   next_cycle_corrupt_dft=0;
   init_pulse_done = 0;
   power_up_done = 0;
   file_loaded=1;
   debug_level= 2'b01;
   message_status = "ONLY WARNINGS/ERRORS are Switched ON.For INFO also use debug_level=2'b00";
  `ifdef  NO_WARNING_MODE
     debug_level = 2'b11;
     message_status = "All Warning/Errors/Info Messages are Switched OFF";
  `endif  
  `ifdef  ONLY_ERROR_MODE
     debug_level = 2'b10;
     message_status = "All Warning/Info Messages are Switched OFF.Errors are switched on";
  `endif 
  `ifdef  ALL_MSG_MODE
     debug_level = 2'b00;
     message_status = "All Messages are Switched ON";
  `endif 
  
  `ifdef slm
     operating_mode = "SLM";
   `else
      `ifdef functional
         operating_mode = "FUNCTIONAL";
       `else
         operating_mode = "TIMING";
      `endif
   `endif   
  
  if (debug_level < 1) begin
  $display ("%m INFORMATION ");
  $display ("***************************************");
  $display ("The Model is Operating in %s MODE", operating_mode);
  $display ("%s", message_status);
  if(reg_ConfigFault)
  $display ("Configurable Fault Functionality is ON");   
  else
  $display ("Configurable Fault Functionality is OFF");   
  $display("Fault File used by the model Fault_File_Name=%s" ,reg_Fault_file_name);
  $display("Values of Config_fault used in model=%d" ,reg_ConfigFault);
  $display("Values of Mem_INITALIZE used in model=%d" ,reg_MEM_INITIALIZE);
  $display("Values of BinaryInit used in model=%d" ,reg_BinaryInit);
  $display("Values of InitFileName used in model=%s" ,reg_InitFileName);
  $display("Values of Initn_reset_value used in model=%d" ,reg_Initn_reset_value);
  $display("Values of File_load_time used in model=%t" ,reg_File_load_time);

  $display ("***************************************");
  end
     
  task_read_fault_file; 
   if(!INITNint) begin
    if(supply_ok ) begin 
      init_pulse_done = 1;
      power_up_done = 1;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif 
    end 
   end 
        
   lastCK_func = CKint_func;
   lastCK_dft = CKint_dft;

 `ifdef MEM_CONTENTS_SLEEP
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","w");
   $fclose(ptr);
 `endif 

   
end  // initial block ends



//+++++++++++++++++++++++++++++++ CONFIG FAULT IMPLEMETATION ENDS+++++++++++++++++++++++++++++++//
        




//INITN block starts
//================================
always @(INITNint  or supply_ok )
begin
 if (INITNint === 1'b0) begin
   if(supply_ok) begin
     init_pulse_done = 1;
     power_up_done = 1;
     lastCK_func=CKint_func;
     lastCK_dft=CKint_dft;
     next_cycle_corrupt_func = 0;
     next_cycle_corrupt_dft = 0;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif     
   end 
 end        

 if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && INITNint !== 1)
   begin
     ScanOutX;
     ScanChainX;
     delScanOutX;
   end  
         
 if (init_pulse_done === 0 && INITNint !== 0) begin
     if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) INFO: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
 end
 
end//always @(INITNint)


// Clock Generation 
//wire gated_clock;
//wire clock_gate_en;
//ST_SPREG_LOLEAK_128x22m8_Tl_lock_up_latch CK_SE_latch (!CK , SE, SE_latch_CK);
//and (clock_gate_en, ATP, TBYPASS, !SE_latch_CK);

//ST_SPREG_LOLEAK_128x22m8_Tl_lock_up_latch LP_latch (!CK , scanreg_ctrl_wire[14], LP_latch_CK);
//and (gated_clock,CK,!LP_latch_CK);
//assign CK_new= clock_gate_en ===0 ? CK : (clock_gate_en ===1 ? gated_clock: (CK===0) ? 0 :1'bx);


// Clock Generation Ends


// Functional CK block starts
//======================================
always @(CKint_func)
begin
   lastCK_func=CKreg_func;  
   CKreg_func=CKint_func;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
        if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
      if (CKreg_func === 1'bX || (CKreg_func === 1'b1 && lastCK_func === 1'bx)) begin
        if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
         
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
         Invalid_next_cycle_func;
        end
      end
      else if (CKreg_func === 1'b1 && lastCK_func === 1'b0 ) begin
        time_CK_func_rise=$realtime;
        MEMEN_prev = MEMEN_reg;
        MEMEN_reg = MEMEN;
        CSNreg = CSNint;
        IGreg = IGint;
        DEreg = DEint;
        SE_reg = SEsys;
        TBYPASS_reg = TBYPASSsys;
        ATPreg = ATPint;
        INITNreg = INITNint;
        SLEEPreg = SLEEPint;
        STDBYreg = STDBYint;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 

    `ifdef functional
    `else
        Mem_last=Mem[Aint];
    `endif 
        if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.INITN pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SLEEP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.STANDBY pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg === X && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.chip select  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg === X && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.IG pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg === X && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.Debug pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg === X && (SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.ATP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg === X && TBYPASS_reg !== 1) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SE pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg !== 1 && TBYPASS_reg === X) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.TBYPASS pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end

        else if ((INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0))) && WENint === X) begin
            // Uncertain write cycle
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: write enable going to X  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end 
        else if (next_cycle_corrupt_func === 1) begin
          next_cycle_corrupt_func = X;
        end
        else if (next_cycle_corrupt_func === 1'bx) begin
          next_cycle_corrupt_func = 0;
        end 
        
//        if (next_cycle_corrupt_func === 0 ) begin 
         
          /*---------------------- File initialization -----------------*/
          
          if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0)) && flag_mem_block === 1'b0) begin
                 Areg=Aint;
                 Dreg=Dint;
                 Mreg=Mint;
                 WENreg=WENint;     
             if (reg_MEM_INITIALIZE === 1'b1 && $realtime >= reg_File_load_time && file_loaded ) begin   
                `ifdef slm
                  if (reg_BinaryInit)
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_BIN");
                  else
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_HEX");
   
                `else
                  if (reg_BinaryInit)
                     $readmemb(reg_InitFileName, Mem, 0, Words-1);
                  else
                     $readmemh(reg_InitFileName, Mem, 0, Words-1);
                `endif
                 file_loaded = 0;
             end
   
             if (^Aint === X)
               ValidAddress = X;
             else if (Aint < Words)
               ValidAddress = 1;
             else    
               ValidAddress = 0;
   
             if(red_en === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Redundancy Enable is Invalid. Either RRAE is X or TRRAE is X",$realtime);
                ValidAddress = X; 
           end
           else if(red_en === 1'b1 && ^repair_add === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Repair Address is invalid.RRA is X",$realtime);
                ValidAddress = X;
           end
             
             if (ValidAddress)
               `ifdef slm
                   $slm_ReadMemoryS(MemAddr, Aint, Mem_temp);
               `else
                    Mem_temp = Mem[Aint];
               `endif
             else
                Mem_temp = WordX;  
          
     /*---------------------- Normal Read and Write -----------------*/
     
             if (WENint === 1) begin
               ReadCycle(Aint);
             end
       
             else if (WENint === 0) begin
               WriteCycle(Aint);
             end 
                
          
          end //  if (MEMEN === 1'b1 
       
//        end  // if (next_cycle_corrupt_func === 0
      
      end // if (CKint = 1   
   end // if (init_pulse_done === 1           
 end 
end // always @(CKint_func)
        
always @(MEMEN)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) && CKint_func === 1'bx) begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.clock pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
    Invalid_next_cycle_func;
  end
 end 
end

// DFT CK block starts
//======================================
always @(CKint_dft) 
begin
   lastCK_dft=CKreg_dft;
   CKreg_dft=CKint_dft;
   
   Latch_open=0;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
     if (CKreg_dft === 1'bX || (CKreg_dft === 1'b1 && lastCK_dft === 1'bx)) begin
       if (INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0 ) begin
        
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: DFT clock  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime); 
         Invalid_next_cycle_dft;
         if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
           WriteOutX;
         end
       end
     end 

     if(CKint_dft === 0 && lastCK_dft === 1) begin
      if(ATPreg === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
       if(SE_reg === 1'b1 && SEsys === 1'b0) begin
        if(TBYPASSint === 1'b1) begin   
    
       
       
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],
scanreg_dr_wire[10],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9], scanreg_dl_wire[scanlen_l-1]}; 
       


         for (i = 0; i < Bits; i = i + 1)
         begin
          if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
         end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
        end 
       end
      end
     end 
     
     else if (CKreg_dft === 1'b1 && lastCK_dft === 1'b0 ) begin
       SE_reg = SEsys;
       TBYPASS_reg = TBYPASSsys;
       ATPreg = ATPint;
       INITNreg = INITNint;
       SLEEPreg = SLEEPint;
       STDBYreg = STDBYint;
       MEMEN_dft_prev = MEMEN_dft_reg;
       MEMEN_dft_reg = MEMEN_dft;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 
       if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ) begin 
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
 //     else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys === X && TBYPASSsys !== 1) begin
///           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
//           Invalid_next_cycle_dft;
//        end       
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys === X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
        end 
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys !== 0 && LP_CK_gate===X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: LP FLOP Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           ScanChainX;
           ScanOutX;   
          if( TBYPASSint !== 0 && SEint !== 1) begin
            WriteOutX;
          end
          next_cycle_corrupt_dft=0;
        end        
       else if (next_cycle_corrupt_dft === 1'b1) begin 
         next_cycle_corrupt_dft = X;
       end 
       else if (next_cycle_corrupt_dft === 1'bx) begin
         next_cycle_corrupt_dft = 0;
       end
       
       if (next_cycle_corrupt_dft === 0 ) begin
         
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1 && flag_mem_block === 1'b0) begin
           
           if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0  && LP_CK_gate===0) begin
              OutReg_data_tbypass = Dint;
              for (i = 0; i < Bits; i = i + 1)
              begin
               if (OutReg_data_tbypass[i] !== OutReg_data[i])
                 OutReg_data[i] = WordX[i];
              end//for (i = 0; i < */ 
              OutReg_data <= OutReg_data_tbypass;
           end
           
             scan_acquire;
         end //MEMEN_dft == 1        
       end // if ( next_cycle_corrupt_dft
       
     end // if (CKint_dft === 1'b1
      //  if (next_cycle_corrupt_dft === 0 ) begin 
       if (SE_reg !== 0) begin
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1  && flag_mem_block === 1'b0) begin
           next_cycle_corrupt_dft = 0;
           if ( next_cycle_corrupt_func === 1) begin
	    next_cycle_corrupt_func = 0 ;
	   end	
           scan_shift;
         end
       end
     //end // if ( next_cycle_corrupt_dft    
     if ((!(TBYPASSsys!==0 && SEsys!==1 && LP_CK_gate!==0 ) && next_cycle_corrupt_dft === 0) || CKint_dft !==1) begin          
       CK_sc=INITNreg & !STDBYreg & !SLEEPreg & ATPreg & CKreg_dft ;
     end     
   end // if (init_pulse_done 
 end // if (supply_ok 
end // always @(CKint_dft)

always @(MEMEN_dft)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) && CKint_dft === 1'bx)  begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.MEMEN_dft and clock should not be X at this time instant. ScanChains and ScanOuts Corrupted ",$realtime); 
    Invalid_next_cycle_dft;
    
    if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
      WriteOutX;
    end
  end
  if ( MEMEN_dft !== 0 && TBYPASSsys !== 0 && SEsys !== 1) begin
     WriteOutX;
     OutReg_data = WordX; 
     delOutReg_data=WordX;
 end 
end
end //always @(MEMEN_dft

always @(TBYPASSsys or ATPint)
begin
   if(supply_ok === 1'b1) begin 
    if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0 && INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1) begin
      if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
    end  
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint === X && SEsys !== 1) ) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end 
end //always @(TBYPASSint





always @(SEsys)
begin
 if(supply_ok === 1'b1) begin 
  if(CKint_dft === 0 && ATPint === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
    if(SE_reg === 1'b1 && SEsys === 1'b0) begin
      if(TBYPASSsys === 1'b1) begin
  
     
         
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],
scanreg_dr_wire[10],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9], scanreg_dl_wire[scanlen_l-1]};
           
      


        for (i = 0; i < Bits; i = i + 1)
        begin
         if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
        end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
      end
    end
  end
  if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0) begin
      if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
  end 
  else if ((TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint === X && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end   
end

//assign output data
`ifdef functional        

   
always @(SDLOint)
#0.001 delSDLO_data<=SDLOint;

always @(SDROint)
#0.001 delSDRO_data<=SDROint;

 
always @(SCTRLOint)
#0.001 delSCTRLO_data<=SCTRLOint;


always @(OutReg_data)
   #0.001 delOutReg_data = OutReg_data;
`else
`endif

/***************************** Embeded switch functionality starts here ***********************************/





always @(STDBYint)
begin
  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0 && STDBYint !== 1'b0)
    begin
      ScanOutX;
      ScanChainX;
     delScanOutX;     
    end
  end
end



always @(SLEEPint)
begin


  if (SLEEPint !== 1'b1) begin
    time_fall_sleep = $realtime;
  end

  if (power_up_done === 0)
    begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
    end
  else begin
    if (SLEEPint === 1'b1 && lastSLEEP === 1'b0 ) begin 
      
    end
    else if (SLEEPint !== 1'b1 && lastSLEEP === 1'b1 && full_shutdown !== 1) begin 
      
      if (supply_ok !== 1 && ($realtime > 0)) begin
         if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID LOW_POWER) ERROR: ISOLATION signal removed from the memory but array and periphery supply is not completely switched on.Very High Current would be drawn by the memory. All further operations on memory are blocked",$realtime);
          WriteMemX;
          WriteOutX;
          ScanChainX;
          OutReg_data = WordX; 
          delOutReg_data=WordX;
          ScanOutX;//immediately;
          delScanOutX;//immediately;
          init_pulse_done = 0;
          power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            debug_level = 2'b11;
          `endif
          
      end        
      
       
    end   
    else if (SLEEPint === X && lastSLEEP === 1'b0 && full_shutdown !== 1'b1) begin 
     
    end 
  end  


  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && SLEEPint !== 0)
    begin
      ScanOutX;
      ScanChainX;
        delScanOutX;      
    end
  end

// if (init_pulse_done === 0)
//   begin
//     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
//   end
//
// else if ( SLEEPint !== 1 && (supply_ok !==1) ) begin
//    
//    WriteOutX;
//    OutReg_data = WordX; 
//    delOutReg_data=WordX;
//    ScanOutX;//immediately;
//    delScanOutX;//immediately;
//    ScanChainX;
//    WriteMemX;
//    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies with sleep/Power down signal being low.This scenario can lead to high dc currents and some reliability issues Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
// end

 print_sleep;    
 lastSLEEP=SLEEPint;
end

/********************************** Embeded switch functionality ends here *******************************/

task print_sleep;
begin
  if (SLEEPint === 1'b0) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been deasserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end  
  else if (SLEEPint === 1'b1) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been asserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_ACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif

  end        
  else begin
      if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) ERROR: SLEEP pin is at an invalid state.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INVALID in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end        
end
endtask





 

//// C28SOI non flip compiler power functionality 
always @(gndmreg )
begin
 if (power_up_done === 1 && $realtime > 0) begin    
    if(gndmreg !== 1'b0 ) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or gndsm is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
        corrupt_all;
        init_pulse_done = 0;
        power_up_done = 0;
     `ifdef NO_BLOCK_MEM
     `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of ground pins.Ground must be maintained at 0 Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime);
        debug_level = 2'b11;
     `endif   

    end   
 end

end




always @(vddmareg )
begin

if (vddmareg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddma(Array Supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 
    end
   end   
   else if (SLEEPint === 1) begin
    WriteMemX;
   end

end

if ((vddmareg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1 ) && $realtime > 0) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddm or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         corrupt_all;
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif

end


end

always @(vddmpreg )
begin
 if (vddmpreg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or vddsmp is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmp(Periphery Supply)/vddsmp(Substrate power supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 

    end
   end   
   else if (SLEEPint === 1) begin
    WriteOutX;
    ScanChainX;
    ScanOutX;
    delScanOutX;//immediately;
    OutReg_data = WordX; 
    delOutReg_data=WordX;
   end
 end

if( (vddmpreg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1'b1 )  && $realtime > 0) begin
         corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif
end
 
 
end


always @(vddmoreg)
begin
  if (power_up_done === 1 && $realtime > 0) begin   
      if (vddmoreg !== 1'b1)  begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin
           corrupt_all;
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
         end //if (vddmareg === 1'b1 

      else if (vddmareg === 1'b0 && vddmpreg === 1'b0   && SLEEPint === 1'b1 &&  $realtime > 0)
        begin 
            if((debug_level < 2) && ($realtime > 0)) $display("%m - %t WARNING: Illegal Value on power pin(s). Memory and Output Corrupted ", $realtime);
 
           corrupt_all;
        end //else if (vddmareg === 1'b 
     end   // if (vddmoreg !== 1'b1)
     else if (vddmoreg === 1'b1 && $realtime > 0 ) begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin     
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           corrupt_all;
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
        end        
     end // else if (vddmoreg === 1'b1
  end 
end // always @(vddmoreg)












always @(gndmreg) begin
 if (gndmreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 0. ",$realtime);
 end
 else if (gndmreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 1. ",$realtime);
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to invalid state. ",$realtime);
 end
end




 
always @(vddmareg) begin
 if (vddmareg === 0) begin 
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 0. ",$realtime);
  vddma_fall_time = $realtime;
 end
 else if (vddmareg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 1. ",$realtime);
  vddma_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to invalid state. ",$realtime);
  vddma_fall_time = $realtime;
 end 

 

end

always @(vddmpreg) begin
 if (vddmpreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 0. ",$realtime);
  vddmp_fall_time = $realtime;
 end
 else if (vddmpreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 1. ",$realtime);
  vddmp_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to invalid state. ",$realtime);
  vddmp_fall_time = $realtime;
 end

 
 
end



// end of C28SOI power functionality 
 


assign supply_ok          =  (vddmareg === 1'b1 && vddmpreg  === 1'b1  && gndmreg === 1'b0 && vddmoreg === 1'b1 ) ? 1'b1 : 1'b0;
assign core_supply_ok     =  (vddmoreg === 1'b1 && vddmareg === 1'b1 && gndmreg === 1'b0 ) ? 1'b1 : 1'b0;
assign peri_supply_ok     =  (vddmoreg === 1'b1 && vddmpreg === 1'b1 && gndmreg === 1'b0  ) ? 1'b1 : 1'b0;

assign full_shutdown = (vddmpreg === 1'b0 && vddmareg === 1'b0   ) ? 1'b1 : 1'b0 ;




`ifdef functional
`else


task WriteLocMskX_bwise;
   input [Addr-1 : 0] Address;
   input [Bits-1 : 0] Mask;

reg [Bits+Red_extrabit:0] tempReg1;
integer num1; 
begin
   tempReg1 = WordX;
   if (^Address !== X )
   begin
      tempReg1 = Mem[Address];
             
      for (j = 0;j< Bits; j=j+1) begin
         num1=j;
        if (Mask[j] === 1'bx)
            tempReg1[num1] = 1'bx;
      end
      Mem[Address] = tempReg1;
      task_insert_faults_in_memory;
   end//if (^Address !== X
   else begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      WriteMemX;
   end   
end
endtask


/****************Actions taken on timing violations*****************/

 always @(TimingViol_data)
// tds or tdh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  for (l = 0; l < Bits; l = l + 1) begin   
    if (CSWEMTBYPASS[l] !== 0) begin
     if((TimingViol_data[l] !== TimingViol_data_last[l])) begin


         Mreg[l] = 1'bx;
     end    
     WriteLocMskX_bwise(Areg,Mreg);
    end   
   end 
  end
    if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin
     scanreg_dl =1'bx; 
     scanreg_dr =1'bx; 
     SDLOint=X;
     SDROint=X;
     `ifdef functional
     `else
     SDLO_data<=1'bx;
     SDRO_data<=1'bx;
     `endif
    end
     TimingViol_data_last = TimingViol_data; 
end





always @(TimingViol_addr)
// tas or tah
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
      scanreg_ctrl=1'bx; 
      SCTRLOint=X;
      `ifdef functional
      `else
      SCTRLO_data<=1'bx;
      `endif
  end
end


always @(TimingViol_WEN)
//tws or twh
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WEN pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end 

always @(TimingViol_CSN )
// tps or tph 
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;

   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CSN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end

always @(TimingViol_tcycle )
//tcycle
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
   if (MEMEN !== 0 && MEMEN_prev !== 0) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckl )
// tckl 
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckh) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end


always @(TimingViol_tcycle_se )
//tcycle_se
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckl_se  )
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckh_se) begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tbist) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
   end
   if (TBYPASSint !== 1'b0) begin 
    WriteOutX;
   end 
   if (INITNreg !==0 && STDBYreg !== 1 && TBYPASS_reg !== 1 && SLEEPreg !== 1 && SE_reg !== 1 && IGreg !== 1 && DEreg !== 1) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBIST pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end






always @(TimingViol_tbypass)
//ttmck
begin
#0  
  WriteOutX;
  if (INITNreg !== 0 && SLEEPreg !== 1 && SE_reg !== 1 && STDBYreg !== 1 &&  DEreg !== 1) begin
   Invalid_next_cycle_dft_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
end



always @(TimingViol_sleep)
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_stdby)
begin
#0
  if (CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin 
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (ATPreg !== 0) begin 
   Invalid_next_cycle_dft_tim;
  end
end






always @(TimingViol_se) begin
#0
   if (TBYPASS_reg !== 0) begin 
    WriteOutX;
   end 
  if (TBYPASS_reg === 0) begin
     WriteOutX;
     WriteMemX;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE timing violation  Memory State Machine is corrupted. Output Corrupted ",$realtime); 
  end 
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
  end
end

always @(TimingViol_sctrli) begin
  scanreg_ctrl=1'bx; 
end


always @(TimingViol_sdli) begin
 scanreg_dl=1'bx; 
end

always @(TimingViol_sdri) begin
   scanreg_dr=1'bx;
end

 

always @(TimingViol_initnl) begin
init_pulse_done=0;
WriteOutX;
OutReg_data = WordX; 
delOutReg_data=WordX;
ScanOutX;
delScanOutX;
ScanChainX;
WriteMemX;
end

always @(TimingViol_initn) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end

always @(TimingViol_ig) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && INITNreg !== 0 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: IG pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   ScanChainX;
   ScanOutX;
   delScanOutX;       
  end
end

always @(TimingViol_atp) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin  
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_rm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^WMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: RM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
   end
end
 
always @(TimingViol_wm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^RMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);        
   end
end 


`endif


endmodule




module ST_SPREG_LOLEAK_128x22m8_Tl_lock_up_latch (EN,D,Q);
input EN,D;
output reg Q;

  always @ (EN or D) begin
    if (EN === 1) begin
       Q = D;
    end
    else if ((EN === 1'bz || EN === 1'bx  )&& D !== Q) begin
        Q=1'bx;
    end    
  end
endmodule

module ST_SPREG_LOLEAK_128x22m8_Tl_SCFF (D,TI,TE,CP,Q,OUTX);
input D,TI,TE,CP;
input OUTX;
output reg Q;
wire Dint;
assign Dint= (TE===1)?TI:(TE===0)?D:1'bx;

always @(posedge CP)
        begin
          if(Dint === 1'bZ || CP ===1'bx || OUTX === 1'bx)
          begin
                  Q = 1'bx;
          end
          else
          begin
                  Q = Dint;
          end        
        end
always @(posedge OUTX)
Q = 1'bx;
endmodule



`undef setup_time
`undef hold_time
`undef access_time
`undef retain_time
`undef cycle_time
`undef pulse_width_time
`undef initin_low_pulse


`delay_mode_path
`endcelldefine
`nosuppress_faults






/****************************************************************
--  Description         : Verilog Model 
--  ModelVersion        : 1.2
--  Date                : Apr, 2013
--  Changes Made by	: PS
--  Revision History    : 
 
****************************************************************/


/******************** START OF HEADER****************************
   This Header Gives Information about the parameters & options present in the Model
   
   words = 64
   bits  = 64
   mux   = 2 
   
   write_mask = yes 
   
   
   
   margin_control = yes 
   
   
   Dft = Yes  

    ------------------------------------------------------------------------------------
     Signal Name             | Description       |             Port Mode        | Active When
                             |                   |          r    |  w   | rw    |
   ------------------------------------------------------------------------------------

    D 	        Data in                     na     x      na       -  
    IG    Input Gate Enable           x      x      na       High     
    ATP            ATPG Enable                 x      x      na       High     
    INITN                 INITN pin                   x      x      na       Low
    
    
    
    M             Mask in                     na     x      na       High  
    Q 	        Data out	            x      na     na       -
    A              Address                     x      x      na       high and low
    
    CK                Clock	                    x      x      na       posedge
    CSN          Chip Enable                 x      x      na       low
    
    RM         Read Margins                 x      x      na       High 
    SCTRLI         Scan Input (Control)
    SCTRLO        Scan Output (Control)
    SDLI         Scan Input (Data-Left)
    SDLO        Scan Output (Data-Left)
    SDRI         Scan Input (Data-Right)
    SDRO        Scan Output (Data-Right)
    SE          Scan Enable pin 
    STDBY              Standby pin                 x      x      na       High
    
    SLEEP                        Sleep pin                   x      x      na        High 
    
     
    
    SMLI         Scan Input (Mask-Right)        
    SMLO        Scan Output (Mask-Left)
    SMRI         Scan Input (Mask-Left)
    SMRO        Scan Output (Mask-Right)  
    TBIST          Bist Enable Pin 
    
    TBYPASS                      Memory Bypass                na     na     na        High
    
    TED        Bist Even Data pin
    TOD         Bist Odd Data Pin
    
    TEM        Bist Even Mask pin
    TOM         Bist Odd Mask Pin  
    TA         Bist Read Address
    TCSN     Bist Read Chip Select
    
    TWEN    Bist Write Enable 
    WEN         Write Enable                na     x      na       Low 
    
    WM        Write Margins Code          x      x      na       -
     

******************** END OF HEADER ****************************/


//********************************************//
// ST_SPREG_LOLEAK_64x64m2_bTl Verilog Model                 //  
//********************************************//




`ifdef slm
        `define functional
`endif

`celldefine
`suppress_faults
  `ifdef functional
   `delay_mode_unit
  `else
   `delay_mode_path
  `endif

`define setup_time 0.0
`define hold_time 0.0
`define access_time 1.0
`define retain_time 0.9
`define cycle_time 0.0
`define pulse_width_time 0.0
`define initin_low_pulse 0.0



 






`timescale 1ns / 1ps


module ST_SPREG_LOLEAK_64x64m2_bTl (A,ATP,CK,CSN,D ,IG,INITN , M, Q ,RM    ,SCTRLI,SCTRLO,SDLI,SDLO,SDRI,SDRO,SE,SLEEP  ,SMLI,SMLO,SMRI,SMRO , STDBY  ,TA,TBIST   ,TBYPASS ,TCSN,TED ,TEM ,TOD  ,TOM  ,TWEN ,WEN,WM  );

 parameter
  Words = 64,
  Bits = 64,
  Addr = 6,
  mux = 2,
  repair_address_width = 5,
  write_margin_size = 2, 
  read_margin_size = 3; 

 //  INPUT OUTPUT PORTS DECLARATION DONE SEPARATELY FOR SPREG and ROM
 // ========================


        output [Bits-1 : 0] Q;
         
        output SCTRLO;
        input SE,SCTRLI;
        
        input [Addr-1 : 0] A;
        
        input [read_margin_size-1 : 0] RM;
        
         
        input CK,CSN,INITN,IG,ATP; 
        
        
        input [Addr-1 :0 ] TA;
input TBIST,TCSN ;
        
        input STDBY;
        
        input SLEEP; 
        
         
        
        
         
        output SDLO;
        output SDRO;
        
        output SMLO,SMRO;
        
        
        
        input [Bits-1 : 0] D ;
	
        
        input [63 :0] M;
         
         
        
        input [write_margin_size-1 : 0] WM;
        
        
        input TBYPASS;
        
        input WEN;
        
        
         
        input SDLI,SDRI ,SMLI,SMRI ; 
        
        
        
        //Bist inputs
        // ===========
        input TWEN,TED,TOD; 
        
        input TEM,TOM; 
        
        
        

        






    parameter
        Fault_file_name = "ST_SPREG_LOLEAK_64x64m2_bTl_faults.txt",
        `ifdef ConfigFault
        ConfigFault = 1,
        `else
        ConfigFault = 0,
        `endif
        max_faults = 66,
        
        MEM_INITIALIZE  = 1'b0,
        BinaryInit = 1'b0, 
        InitFileName = "ST_SPREG_LOLEAK_64x64m2_bTl.cde",
        Debug_mode = "all_warning_mode",
        File_load_time=0,
        Initn_reset_value={64{1'b0}},
        InstancePath = "ST_SPREG_LOLEAK_64x64m2_bTl";
    
    parameter
        
        bank = 1, 
        mux_bits=1,
        Red_extrabit=0,
        bank_bits = 0,
        RedWords = mux * 2 * bank,
        max_address_bits = 15 ,
        Rows = Words/mux;


        parameter mask_bits = 64;   
    parameter 

     

        
           scanchains=5,    
          
        
        scanlen_ctrl=15,
        
        

      

        
        
        scanlen_r=(2*(Bits/4)),
        
        scanlen_l=(Bits-(2*(Bits/4)))  ; 
      
      

    parameter
        
        `ifdef functional  
            RW_assertions_en = 0,
        `endif
        WordX = {Bits{1'bx}},
        AddrX = {Addr{1'bx}},
        Word0 = {Bits{1'b0}},
        X = 1'bx;
   



//  WIRE DECLARATION RELATED TO POWER PINS
//  ======================================
	
        wire supply_ok, full_shutdown;
        
        wire core_supply_ok;
        wire peri_supply_ok;

        wire gndmint, gndsmint;
         
        
        wire vddmpint;
        wire vddmoint;
        wire vddmaint;
        wire vddsmpint;  
        wire vddsmaint;  
        
        

//  WIRE DECLARATION 
//  ==================
        wire [Bits-1 : 0] CSWEMTBYPASS;
        wire [Bits-1 : 0] Dint, Dsys;
        wire [Bits-1 : 0] Mint; 
        wire [64-1:0] Msys;
	wire [Addr-1 : 0] Aint;
        wire [Addr-1 : 0] Asys;

       


        wire [max_address_bits-1 : 0] A_int; 
                
	wire CKint_dft;
	wire CKint_func;
	wire CSNint;
        wire MEMEN;
        wire MEMEN_dft;
        wire TSE;

	wire WENint;
	wire WENsys;
        wire SLEEPint;
        wire STDBYint;
        wire SEint;
        wire SEsys;
        wire SCTRLIint;
        wire SDLIint;
        wire SDRIint;
        
        wire SMLIint;
        wire SMRIint;
        
        wire INITNint;
        wire TBYPASSint;
        wire TBYPASSsys;
        wire LSint; 
        wire HSint; 
        wire ATPint;
        wire DEint;
        
        wire [Addr-1 : 0] TAint;
        wire TBISTint;
        wire TBISTsys;
        wire TCSNint;
        wire TEDint;
        wire TODint;
        wire TEMint;
        wire TOMint;
        wire [Bits-1 : 0] TMint;
        wire [Bits-1 : 0] TDint;
        wire TWENint;
        wire IGint;
        wire IGbuf;
        wire CSNbuf;
        wire WENbuf;
        wire [read_margin_size-1:0] RMint;
        wire [write_margin_size-1:0] WMint;

        //Wires for scan chains
        //  ====================     
        wire [scanlen_ctrl -1:0]scanreg_ctrl_wire;
        wire [scanlen_l -1:0]  scanreg_dl_wire; 
        wire [scanlen_r -1:0]  scanreg_dr_wire; 
   
        wire [scanlen_l -1:0]  scanreg_ml_wire; 
        wire [scanlen_r -1:0]  scanreg_mr_wire; 


        wire [repair_address_width -1 : 0] RRAint;
        wire RRAEint;
        wire TRRAEint;    
        wire red_en;
        wire [repair_address_width -1 : 0] repair_add, next_repair_add;


//  REG DECLARATION
//  ====================     
        reg MEMEN_reg;
        reg MEMEN_prev;
        reg reg_mem_block;
        reg flag_mem_block;
        reg SCTRLIint_temp;
        reg SDLIint_temp;
        reg SDRIint_temp;
        reg SMLIint_temp;
        reg SMRIint_temp;

        //  REG DECLARATION
        //  ====================
        reg SCTRLOint;
        
        reg SDLOint,SDROint;
        
        reg SMLOint,SMROint;   
        
        reg next_cycle_corrupt_func;
        reg next_cycle_corrupt_dft;
        reg [Bits-1 : 0] delOutReg_data;//delayed Output Register
        reg [Bits-1 : 0] OutReg_data;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_tbypass;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_scan;   // Data Output registe
        reg [Bits-1 : 0] OutReg_rado_retained;   // register for retaining rado data when SLEEP --> 1
        reg delSCTRLO_data,SCTRLO_data;      // delayed Output Register
        reg delSDLO_data,SDLO_data;      // delayed Output Register
        reg delSDRO_data,SDRO_data;      // delayed Output Register
        
        reg delSMLO_data,SMLO_data;      // delayed Output Register
        reg delSMRO_data,SMRO_data; 
        
        // SCAN CHAINS register
        reg scanreg_ctrl; 
        reg scanreg_dl; 
        reg scanreg_dr; 
         
        reg scanreg_ml; 
        reg scanreg_mr; 
        
        
        reg CK_sc;
        reg Latch_open=0;
        reg lastCK_dft,CKreg_dft;
        reg lastCK_func,CKreg_func;
        reg lastSLEEP;
        reg lastPSWLARGEMP,lastPSWLARGEMA,lastPSWSMALLMP,lastPSWSMALLMA;
        reg CSNreg;
        reg init_pulse_done; //if == 1 then it implies that initb low pulse has been applied
        reg power_up_done; //if == 1 then it implies that power up has been done
        `ifdef slm
        `else
	      
             reg [Bits-1 : 0] Mem [Words-1 : 0];
             reg [Bits-1 : 0] RedMem [RedWords-1 : 0];
 
        `endif
        
	reg [Bits-1 :0] Mem_temp;
        reg [Bits-1 :0] Mem_slm; 
	reg ValidAddress;
	reg ValidDebugCode;
        reg decoding_start;
        reg file_loaded;
        reg [Bits-1 :0] Dreg;
        reg [Bits-1 :0] Mreg;
        reg WENreg;
        reg [Addr-1 :0] Areg;
        reg SE_reg;
        reg TBYPASS_reg;
        reg INITNreg;
        reg IGreg;
        reg DEreg;
        reg SLEEPreg;
        reg STDBYreg;
        reg ATPreg;
        reg MEMEN_dft_reg;
        reg MEMEN_dft_prev;
        reg RRMATCHreg;
        reg RRMATCHreg_last;//changes_made
        reg RRMATCHreg_glitch;
        reg [repair_address_width -1 : 0] repair_add_last;
        reg RRAEint_last;
        reg [Addr-mux_bits-1:0] row_add_temp;
        reg [Addr-mux_bits-bank_bits-1:0] row_add_cmp_temp;

       
        //parameter registers
        reg [2047:0] reg_Fault_file_name;
        reg reg_ConfigFault;
        reg reg_MEM_INITIALIZE;
        reg reg_BinaryInit;
        reg [2047:0] reg_InitFileName;
        reg [Bits -1 :0] reg_Initn_reset_value;
        time reg_File_load_time;

        //Power Supply Registers        
        reg vddmireg;
        reg vddmreg;
        reg vddsmreg;
        reg gndmreg;
        reg gndsmreg;   
        reg vddmpreg;
        reg vddmpireg;
        reg vddmareg;
        reg vddsmpreg;
        reg vddsmareg;
        reg vddmoreg;
        time vddmp_rise_time;
        time vddmp_fall_time;
        time vddsmp_rise_time;
        time vddsmp_fall_time;
        time vddma_rise_time;
        time vddma_fall_time;
        time vddsma_rise_time;
        time vddsma_fall_time;
        reg reg_check_rise;
        reg reg_check_fall;
        reg reg_check_rise_vddma;
        reg reg_check_fall_vddsma;
        reg  reg_check_rise_vddm, reg_check_fall_vddsm ;
        time vddm_fall_time,  vddm_rise_time,  vddsm_fall_time, vddsm_rise_time ;
  /* This register is used to force all warning messages 
  ** OFF during run time.
  ** It is a 2 bit register.
  ** USAGE :
  ** debug_level_off = 2'b00 -> ALL MESSAGES(INFO/WARNINGS/ERRORS) will be DISPLAYED 
  ** debug_level = 2'b01     -> ONLY WARNINGS/ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b10     -> ONLY ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b11     -> NO MESSAGES will be DISPLAYED.
  */ 
        reg [1:0] debug_level;
        reg [8*10: 0] operating_mode;
        reg [8*44: 0] message_status;

        integer i, k, j, l,m,q,w,r,s,num1,redcnt,n,num2,FirstHalf,Bfaileff,memcnt,ptr;
        integer decoder[Bits-1:0];
        `ifdef slm
           integer MemAddr;
        `endif


        //************************************************************
        //****** CONFIG FAULT IMPLEMENTATION VARIABLES*************** 
        //************************************************************ 

        integer file_ptr, ret_val;
        integer fault_word;
        integer fault_bit;
        integer fcnt, Fault_in_memory,faultnum,stop_loop,count;
        integer t;  
        integer FailureLocn [max_faults -1 :0];
        integer Failurebit [max_faults -1 :0];
        reg [100 : 0] stuck_at;
        reg [100 : 0] fault_array;
        reg [200 : 0] tempStr;
        reg [7:0] fault_char;
        reg [7:0] fault_char1; // 8 Bit File Pointer
        reg [Addr -1 : 0] std_fault_word;
        reg [Addr -1 : mux_bits] fault_row_add [max_faults -1 :0];
        reg [max_faults -1 :0] fault_repair_flag;
        reg [max_faults -1 :0] dont_insert_fault;
        reg [max_faults -1 :0] repair_flag;
        reg [100 : 0] array_stuck_at[max_faults -1 : 0] ;
        reg [100 : 0] mem_red_array_stuck_at[max_faults -1 : 0] ; 
        reg msgcnt;
        
       
        reg [Bits - 1: 0] stuck_at_0fault [max_faults -1 : 0];
        reg [Bits - 1: 0] stuck_at_1fault [max_faults -1 : 0];
        reg [Bits -1 : 0] stuck0;
        reg [Bits -1 : 0] stuck1;

        reg [Bits+Red_extrabit :0] Mem_last;
        

        `ifdef slm
        reg [Bits -1 : 0] slm_temp_data;
        `endif
        
        real time_CK_func_rise , time_RADCK_rise;
        real time_fall_sleep,time_fall_PSWLARGEMP,time_fall_PSWLARGEMP_0,time_fall_PSWLARGEMA,time_fall_PSWLARGEMA_0,time_fall_PSWSMALLMP,time_fall_PSWSMALLMA;
        integer flag_error;
        
//BUFFER INSTANTIATION
//=========================
       `ifdef functional
       
         buf (SCTRLO,delSCTRLO_data); 
         buf bufq [Bits-1:0] (Q,delOutReg_data);
      `else
       
         buf (SCTRLO,SCTRLO_data);
         buf bufq [Bits-1:0] (Q,OutReg_data);
      `endif
      
  
        buf (SEsys,SE);
	buf (SCTRLIint, SCTRLI);
   

	buf (CKint_func, CK);
	buf (CKint_dft, CK);
        buf bufaddr [Addr-1:0] (Asys,A);
        buf (INITNint,INITN);
        
        buf (LSint,1'b0); 
        buf (IGbuf,IG);
        buf (ATPint,ATP);

        buf bufTaddr [Addr-1 : 0] (TAint,TA);
        buf (TBISTsys,TBIST);
        buf (TCSNint,TCSN);

        buf (CSNsys,CSN);
        buf (STDBYint,STDBY );   
        
        buf (SLEEPint,SLEEP ); 

        buf bufrm [read_margin_size-1:0] (RMint, RM); 

        
        

        assign RRAEint = 1'b0;
        assign TRRAEint = 1'b0;
        assign repair_add = 0;
        assign next_repair_add = 0;
        assign red_en = 1'b0; 
        
        
        
        
        
        
        
        buf (PSWLARGEMPint,1'b0);
        buf (PSWSMALLMPint,1'b0); 
        buf (PSWLARGEMAint,1'b0);
        buf (PSWSMALLMAint,1'b0);   

      `ifdef functional
       
       
         buf (SDLO,delSDLO_data);
         buf (SDRO,delSDRO_data);
         
         buf (SMLO,delSMLO_data);
         buf (SMRO,delSMRO_data);  
      `else
       
         buf (SDLO,SDLO_data);
         buf (SDRO,SDRO_data);
         
         buf (SMLO,SMLO_data);
         buf (SMRO,SMRO_data);  
      `endif
       
         
       
        buf bufdata [Bits-1:0] (Dsys,D);
        
        buf bufmask [64-1:0] (Msys,M);
        
	

        
        buf (TBYPASSsys, TBYPASS);
        


        buf (WENsys,WEN);
	 
	buf (SDLIint, SDLI);
	buf (SDRIint, SDRI);
	
        buf (SMLIint, SMLI);
	buf (SMRIint, SMRI);
	 
        
        buf (HSint,1'b0); 

        
        buf (TEDint,TED);
        buf (TODint,TOD);
         
        buf (TEMint,TEM);
        buf (TOMint,TOM); 
        buf (TWENint,TWEN);
        
        
        buf bufwm [write_margin_size-1:0] (WMint, WM); 
        



//      assign scanreg_ctrl_wire={scanreg_ctrl[scanlen_ctrl - 2:0],SCTRLIint};
//      assign scanreg_dl_wire={scanreg_dl[scanlen_l - 2:0],SDLIint};
//      assign scanreg_dr_wire={scanreg_dr[scanlen_r - 2:0],SDRIint};
      
//      assign scanreg_ml_wire={scanreg_ml[scanlen_l - 2:0],SMLIint};
//      assign scanreg_mr_wire={scanreg_mr[scanlen_r - 2:0],SMRIint}; 
        
      assign Aint   = (TBISTint === 1'b0 ) ? Asys : (TBISTint === 1'bx ) ? {Addr{1'bx}} : TAint;  

        
//        assign A_int = Aint;
	
        
                
        assign Dint[0] = (TBISTint === 1'b0) ? Dsys[0] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[1] = (TBISTint === 1'b0) ? Dsys[1] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[2] = (TBISTint === 1'b0) ? Dsys[2] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[3] = (TBISTint === 1'b0) ? Dsys[3] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[4] = (TBISTint === 1'b0) ? Dsys[4] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[5] = (TBISTint === 1'b0) ? Dsys[5] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[6] = (TBISTint === 1'b0) ? Dsys[6] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[7] = (TBISTint === 1'b0) ? Dsys[7] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[8] = (TBISTint === 1'b0) ? Dsys[8] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[9] = (TBISTint === 1'b0) ? Dsys[9] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[10] = (TBISTint === 1'b0) ? Dsys[10] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[11] = (TBISTint === 1'b0) ? Dsys[11] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[12] = (TBISTint === 1'b0) ? Dsys[12] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[13] = (TBISTint === 1'b0) ? Dsys[13] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[14] = (TBISTint === 1'b0) ? Dsys[14] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[15] = (TBISTint === 1'b0) ? Dsys[15] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[16] = (TBISTint === 1'b0) ? Dsys[16] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[17] = (TBISTint === 1'b0) ? Dsys[17] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[18] = (TBISTint === 1'b0) ? Dsys[18] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[19] = (TBISTint === 1'b0) ? Dsys[19] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[20] = (TBISTint === 1'b0) ? Dsys[20] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[21] = (TBISTint === 1'b0) ? Dsys[21] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[22] = (TBISTint === 1'b0) ? Dsys[22] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[23] = (TBISTint === 1'b0) ? Dsys[23] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[24] = (TBISTint === 1'b0) ? Dsys[24] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[25] = (TBISTint === 1'b0) ? Dsys[25] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[26] = (TBISTint === 1'b0) ? Dsys[26] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[27] = (TBISTint === 1'b0) ? Dsys[27] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[28] = (TBISTint === 1'b0) ? Dsys[28] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[29] = (TBISTint === 1'b0) ? Dsys[29] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[30] = (TBISTint === 1'b0) ? Dsys[30] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[31] = (TBISTint === 1'b0) ? Dsys[31] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[32] = (TBISTint === 1'b0) ? Dsys[32] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[33] = (TBISTint === 1'b0) ? Dsys[33] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[34] = (TBISTint === 1'b0) ? Dsys[34] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[35] = (TBISTint === 1'b0) ? Dsys[35] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[36] = (TBISTint === 1'b0) ? Dsys[36] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[37] = (TBISTint === 1'b0) ? Dsys[37] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[38] = (TBISTint === 1'b0) ? Dsys[38] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[39] = (TBISTint === 1'b0) ? Dsys[39] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[40] = (TBISTint === 1'b0) ? Dsys[40] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[41] = (TBISTint === 1'b0) ? Dsys[41] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[42] = (TBISTint === 1'b0) ? Dsys[42] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[43] = (TBISTint === 1'b0) ? Dsys[43] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[44] = (TBISTint === 1'b0) ? Dsys[44] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[45] = (TBISTint === 1'b0) ? Dsys[45] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[46] = (TBISTint === 1'b0) ? Dsys[46] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[47] = (TBISTint === 1'b0) ? Dsys[47] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[48] = (TBISTint === 1'b0) ? Dsys[48] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[49] = (TBISTint === 1'b0) ? Dsys[49] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[50] = (TBISTint === 1'b0) ? Dsys[50] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[51] = (TBISTint === 1'b0) ? Dsys[51] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[52] = (TBISTint === 1'b0) ? Dsys[52] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[53] = (TBISTint === 1'b0) ? Dsys[53] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[54] = (TBISTint === 1'b0) ? Dsys[54] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[55] = (TBISTint === 1'b0) ? Dsys[55] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[56] = (TBISTint === 1'b0) ? Dsys[56] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[57] = (TBISTint === 1'b0) ? Dsys[57] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[58] = (TBISTint === 1'b0) ? Dsys[58] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[59] = (TBISTint === 1'b0) ? Dsys[59] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[60] = (TBISTint === 1'b0) ? Dsys[60] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[61] = (TBISTint === 1'b0) ? Dsys[61] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[62] = (TBISTint === 1'b0) ? Dsys[62] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[63] = (TBISTint === 1'b0) ? Dsys[63] : (TBISTint === 1'b1) ? TODint : 1'bx;          
	
        
        assign Mint[0] = (TBISTint === 1'b0) ? Msys[0] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[1] = (TBISTint === 1'b0) ? Msys[1] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[2] = (TBISTint === 1'b0) ? Msys[2] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[3] = (TBISTint === 1'b0) ? Msys[3] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[4] = (TBISTint === 1'b0) ? Msys[4] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[5] = (TBISTint === 1'b0) ? Msys[5] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[6] = (TBISTint === 1'b0) ? Msys[6] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[7] = (TBISTint === 1'b0) ? Msys[7] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[8] = (TBISTint === 1'b0) ? Msys[8] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[9] = (TBISTint === 1'b0) ? Msys[9] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[10] = (TBISTint === 1'b0) ? Msys[10] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[11] = (TBISTint === 1'b0) ? Msys[11] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[12] = (TBISTint === 1'b0) ? Msys[12] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[13] = (TBISTint === 1'b0) ? Msys[13] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[14] = (TBISTint === 1'b0) ? Msys[14] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[15] = (TBISTint === 1'b0) ? Msys[15] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[16] = (TBISTint === 1'b0) ? Msys[16] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[17] = (TBISTint === 1'b0) ? Msys[17] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[18] = (TBISTint === 1'b0) ? Msys[18] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[19] = (TBISTint === 1'b0) ? Msys[19] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[20] = (TBISTint === 1'b0) ? Msys[20] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[21] = (TBISTint === 1'b0) ? Msys[21] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[22] = (TBISTint === 1'b0) ? Msys[22] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[23] = (TBISTint === 1'b0) ? Msys[23] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[24] = (TBISTint === 1'b0) ? Msys[24] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[25] = (TBISTint === 1'b0) ? Msys[25] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[26] = (TBISTint === 1'b0) ? Msys[26] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[27] = (TBISTint === 1'b0) ? Msys[27] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[28] = (TBISTint === 1'b0) ? Msys[28] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[29] = (TBISTint === 1'b0) ? Msys[29] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[30] = (TBISTint === 1'b0) ? Msys[30] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[31] = (TBISTint === 1'b0) ? Msys[31] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[32] = (TBISTint === 1'b0) ? Msys[32] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[33] = (TBISTint === 1'b0) ? Msys[33] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[34] = (TBISTint === 1'b0) ? Msys[34] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[35] = (TBISTint === 1'b0) ? Msys[35] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[36] = (TBISTint === 1'b0) ? Msys[36] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[37] = (TBISTint === 1'b0) ? Msys[37] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[38] = (TBISTint === 1'b0) ? Msys[38] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[39] = (TBISTint === 1'b0) ? Msys[39] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[40] = (TBISTint === 1'b0) ? Msys[40] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[41] = (TBISTint === 1'b0) ? Msys[41] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[42] = (TBISTint === 1'b0) ? Msys[42] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[43] = (TBISTint === 1'b0) ? Msys[43] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[44] = (TBISTint === 1'b0) ? Msys[44] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[45] = (TBISTint === 1'b0) ? Msys[45] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[46] = (TBISTint === 1'b0) ? Msys[46] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[47] = (TBISTint === 1'b0) ? Msys[47] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[48] = (TBISTint === 1'b0) ? Msys[48] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[49] = (TBISTint === 1'b0) ? Msys[49] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[50] = (TBISTint === 1'b0) ? Msys[50] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[51] = (TBISTint === 1'b0) ? Msys[51] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[52] = (TBISTint === 1'b0) ? Msys[52] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[53] = (TBISTint === 1'b0) ? Msys[53] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[54] = (TBISTint === 1'b0) ? Msys[54] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[55] = (TBISTint === 1'b0) ? Msys[55] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[56] = (TBISTint === 1'b0) ? Msys[56] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[57] = (TBISTint === 1'b0) ? Msys[57] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[58] = (TBISTint === 1'b0) ? Msys[58] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[59] = (TBISTint === 1'b0) ? Msys[59] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[60] = (TBISTint === 1'b0) ? Msys[60] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[61] = (TBISTint === 1'b0) ? Msys[61] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[62] = (TBISTint === 1'b0) ? Msys[62] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[63] = (TBISTint === 1'b0) ? Msys[63] : (TBISTint === 1'b1) ? TOMint : 1'bx;  
        

         

        assign WENbuf = (TBISTint === 1'b0 ) ? WENsys : (TBISTint === 1'bx ) ? 1'bx : TWENint;  
        assign WENint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? WENbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[13] : (ATPint === 1'b0 ) ? WENsys : 1'bx ; 
        
        assign CSNbuf = (TBISTint === 1'b0 ) ? CSNsys : (TBISTint === 1'bx ) ? 1'bx : TCSNint;  
        assign CSNint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? CSNbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[11] : (ATPint === 1'b0 ) ? CSNsys : 1'bx ; 
        assign IGint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? IGbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[14] : (ATPint === 1'b0 ) ? IGbuf : 1'bx;

        
        assign DEint = (LSint === 1'bx || (LSint === 1'b0 && HSint === 1'bx) || ^RMint !== 1'b0 || ^WMint !== 1'b0 ) ? 1'bx : 1'b0;
        
     
     and (TBISTint, ATPint, TBISTsys);
     and (SEint, ATPint, SEsys);
     and (TBYPASSint, ATPint, TBYPASSsys);
     and (TSE,TBYPASSint,!SEsys);
     and (MEMEN,INITNint,!CSNint,!SLEEPint,!TBYPASSint,!SEint,!IGint,!DEint,!STDBYint );
     and (MEMEN_dft,INITNint, !SLEEPint, ATPint,!STDBYint);

 `ifdef functional
/*****************assertions added to optimize dynamic power consumption**********/

//psl a_M: assert always ({( RW_assertions_en);(MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1))  } |-> (stable(Msys))) @(posedge CK); 

//psl a_WEN: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(WENsys))) @(posedge CK); 

//psl a_A: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(Asys))) @(posedge CK); 

//psl a_D: assert always ({( RW_assertions_en);((MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1)) && TBYPASSint === 1'b0)  } |-> (stable(Dsys))) @(posedge CK); 

/**********************************************************************************************/
`endif       

     

         
reg vddmp,vddmo, vddma, vddsmp, vddsma, gndsm, gndm,  vddmpi ; 
 
initial 
begin

        vddmp = 1'b1 ; 
        vddmo = 1'b1 ;
        vddma = 1'b1 ;
        
        vddsmp = 1'b1 ;
        
        
         gndm = 1'b0 ;
          
end

        
         assign gndmint = (reg_mem_block === 0) ? gndm : 1'b1;
         
         
         
         
         assign vddmpint = vddmp;
         assign vddmoint = vddmo;
         assign vddmaint = vddma;
         
          
        
         

        //CPF Changes

        
                
        initial
        begin : cpfvddmp 
           vddmpreg = vddmpint;
        end

        always @(vddmpint) begin
           vddmpreg = vddmpint;
        end
        
        initial
        begin : cpfvddmo 
           vddmoreg = vddmoint;
        end

        always @(vddmoint) begin
           vddmoreg = vddmoint;
        end
        
        initial
        begin : cpfvddma 
           vddmareg = vddmaint;
        end

        always @(vddmaint) begin
           vddmareg = vddmaint;
        end

        
        
 
        initial
        begin : cpfgndm 
           gndmreg = gndmint;
        end

        always @(gndmint) begin
           gndmreg = gndmint;
        end

        
        



 `ifdef functional
  `else
  initial begin
    if (debug_level < 1) begin
     $display ("%m  INFORMATION");
     $display ("***************************************");
     $display ("The Model is Operating in TIMING MODE");
     $display ("Please make sure that SDF is properly annotated otherwise dummy values will be used");
     $display ("%s", message_status);
     $display ("***************************************");
    end
  end

//////////////////////////
 //REG DECLARATIONS
   //======================

   reg [Bits-1 : 0] TimingViol_data;
   reg  [Bits-1 : 0] TimingViol_mask;
   reg [Bits-1 : 0] TimingViol_data_last, TimingViol_mask_last;
	reg TimingViol_data_0;
	reg TimingViol_data_1;
	reg TimingViol_data_2;
	reg TimingViol_data_3;
	reg TimingViol_data_4;
	reg TimingViol_data_5;
	reg TimingViol_data_6;
	reg TimingViol_data_7;
	reg TimingViol_data_8;
	reg TimingViol_data_9;
	reg TimingViol_data_10;
	reg TimingViol_data_11;
	reg TimingViol_data_12;
	reg TimingViol_data_13;
	reg TimingViol_data_14;
	reg TimingViol_data_15;
	reg TimingViol_data_16;
	reg TimingViol_data_17;
	reg TimingViol_data_18;
	reg TimingViol_data_19;
	reg TimingViol_data_20;
	reg TimingViol_data_21;
	reg TimingViol_data_22;
	reg TimingViol_data_23;
	reg TimingViol_data_24;
	reg TimingViol_data_25;
	reg TimingViol_data_26;
	reg TimingViol_data_27;
	reg TimingViol_data_28;
	reg TimingViol_data_29;
	reg TimingViol_data_30;
	reg TimingViol_data_31;
	reg TimingViol_data_32;
	reg TimingViol_data_33;
	reg TimingViol_data_34;
	reg TimingViol_data_35;
	reg TimingViol_data_36;
	reg TimingViol_data_37;
	reg TimingViol_data_38;
	reg TimingViol_data_39;
	reg TimingViol_data_40;
	reg TimingViol_data_41;
	reg TimingViol_data_42;
	reg TimingViol_data_43;
	reg TimingViol_data_44;
	reg TimingViol_data_45;
	reg TimingViol_data_46;
	reg TimingViol_data_47;
	reg TimingViol_data_48;
	reg TimingViol_data_49;
	reg TimingViol_data_50;
	reg TimingViol_data_51;
	reg TimingViol_data_52;
	reg TimingViol_data_53;
	reg TimingViol_data_54;
	reg TimingViol_data_55;
	reg TimingViol_data_56;
	reg TimingViol_data_57;
	reg TimingViol_data_58;
	reg TimingViol_data_59;
	reg TimingViol_data_60;
	reg TimingViol_data_61;
	reg TimingViol_data_62;
	reg TimingViol_data_63;
 reg TimingViol_mask_0;
 reg TimingViol_mask_1;
 reg TimingViol_mask_2;
 reg TimingViol_mask_3;
 reg TimingViol_mask_4;
 reg TimingViol_mask_5;
 reg TimingViol_mask_6;
 reg TimingViol_mask_7;
 reg TimingViol_mask_8;
 reg TimingViol_mask_9;
 reg TimingViol_mask_10;
 reg TimingViol_mask_11;
 reg TimingViol_mask_12;
 reg TimingViol_mask_13;
 reg TimingViol_mask_14;
 reg TimingViol_mask_15;
 reg TimingViol_mask_16;
 reg TimingViol_mask_17;
 reg TimingViol_mask_18;
 reg TimingViol_mask_19;
 reg TimingViol_mask_20;
 reg TimingViol_mask_21;
 reg TimingViol_mask_22;
 reg TimingViol_mask_23;
 reg TimingViol_mask_24;
 reg TimingViol_mask_25;
 reg TimingViol_mask_26;
 reg TimingViol_mask_27;
 reg TimingViol_mask_28;
 reg TimingViol_mask_29;
 reg TimingViol_mask_30;
 reg TimingViol_mask_31;
 reg TimingViol_mask_32;
 reg TimingViol_mask_33;
 reg TimingViol_mask_34;
 reg TimingViol_mask_35;
 reg TimingViol_mask_36;
 reg TimingViol_mask_37;
 reg TimingViol_mask_38;
 reg TimingViol_mask_39;
 reg TimingViol_mask_40;
 reg TimingViol_mask_41;
 reg TimingViol_mask_42;
 reg TimingViol_mask_43;
 reg TimingViol_mask_44;
 reg TimingViol_mask_45;
 reg TimingViol_mask_46;
 reg TimingViol_mask_47;
 reg TimingViol_mask_48;
 reg TimingViol_mask_49;
 reg TimingViol_mask_50;
 reg TimingViol_mask_51;
 reg TimingViol_mask_52;
 reg TimingViol_mask_53;
 reg TimingViol_mask_54;
 reg TimingViol_mask_55;
 reg TimingViol_mask_56;
 reg TimingViol_mask_57;
 reg TimingViol_mask_58;
 reg TimingViol_mask_59;
 reg TimingViol_mask_60;
 reg TimingViol_mask_61;
 reg TimingViol_mask_62;
 reg TimingViol_mask_63;

   reg TimingViol_addr;
   reg TimingViol_CSN, TimingViol_WEN, TimingViol_tbypass;
   reg TimingViol_tckh, TimingViol_tckl, TimingViol_tcycle;
   reg TimingViol_tckh_se, TimingViol_tckl_se, TimingViol_tcycle_se;
   reg TimingViol_sctrli,TimingViol_sdli,TimingViol_sdri,TimingViol_se;
   reg TimingViol_smli,TimingViol_smri;
   reg TimingViol_sctrli_flag,TimingViol_sdli_flag,TimingViol_sdri_flag;
   reg TimingViol_smli_flag,TimingViol_smri_flag;
   reg TimingViol_initnl;
   reg TimingViol_initn;
   reg TimingViol_ls;
   reg TimingViol_hs;
   reg TimingViol_sleep;
   reg TimingViol_stdby;
   reg TimingViol_rm;
   reg TimingViol_wm;
   reg TimingViol_tbist,TimingViol_ig,TimingViol_atp,TimingViol_TED,TimingViol_TOD,TimingViol_TEM,TimingViol_TOM;
   reg TimingViolRRAE,TimingViolRRA;

   wire CSTBYPASSN,cond_sdf_tas,cond_sdf_tds,cond_sdf_tms,cond_sdf_tws,cond_sdf_tbas,cond_sdf_tbps,cond_sdf_tbws,cond_sdf_tbdes,cond_sdf_tbdos,cond_sdf_tbmes,cond_sdf_tbmos;
   wire SETB_EN,CSIG_EN,MEM_ACT,EN_ADM,CS_EN,CS_ADM,cond_sdf_tps,IG_EN,IG_ADM,cond_sdf_tigs,cond_sdf_taa,cond_sdf_taa_ls1,cond_sdf_taa_hs1,cond_tseq_tm;
   wire cond_sdf_tcycle,cond_sdf_tcycle_ls1,cond_sdf_tcycle_hs1,cond_sdf_tcycle_se,cond_sdf_tckl_se,cond_sdf_tsctrlis,cond_sdf_tsdlis,cond_sdf_tsdris,cond_sdf_tsmlis,cond_sdf_tsmris;
   wire cond_sdf_tckh_se,cond_sdf_taa_sctrlo_se,cond_sdf_taa_sdlo_se,cond_sdf_taa_sdro_se,cond_sdf_taa_smlo_se,cond_sdf_taa_smro_se,cond_sdf_tckl,cond_sdf_tckh;
   wire cond_sdf_ttms,cond_sdf_tbists,INITNandnotSLEEPandATPandnotSE,cond_sdf_taa_sctrlo,cond_sdf_taa_sdlo,cond_sdf_taa_sdro,cond_sdf_taa_smlo,cond_sdf_taa_smro;
   wire cond_sdf_taa_tm,cond_sdf_taa_tm_ls1, cond_sdf_taa_tm_hs1,cond_sdf_taa_tckq_tm,cond_sdf_taa_tseq_tm;

   wire CSWETBYPASSN;
   wire cond_sdf_tstdbys,cond_sdf_tsls,sleep_en,atp_csn_en;
   wire cond_sdf_tlss,cond_sdf_thss,cond_sdf_trms,cond_sdf_twms; 
   wire cond_sdf_tses,cond_sdf_tinitns;
   wire tby_se_en;
   wire rra_en;
   wire tbist_atp_en;
   wire rrae_en;
   wire tbist_rrae_en;
   wire cond_sdf_trraes;
   wire cond_sdf_ttrraes;
   wire cond_sdf_taa_trramatch;
   wire cond_sdf_ttrraematch;
   wire cond_sdf_tamatch;
   wire cond_sdf_ttamatch;
   wire cond_sdf_tatpmatch;
   wire cond_sdf_ttbistmatch;



 and (CSWEMTBYPASS[0], !Mreg[0], CSWETBYPASSN);
 and (CSWEMTBYPASS[1], !Mreg[1], CSWETBYPASSN);
 and (CSWEMTBYPASS[2], !Mreg[2], CSWETBYPASSN);
 and (CSWEMTBYPASS[3], !Mreg[3], CSWETBYPASSN);
 and (CSWEMTBYPASS[4], !Mreg[4], CSWETBYPASSN);
 and (CSWEMTBYPASS[5], !Mreg[5], CSWETBYPASSN);
 and (CSWEMTBYPASS[6], !Mreg[6], CSWETBYPASSN);
 and (CSWEMTBYPASS[7], !Mreg[7], CSWETBYPASSN);
 and (CSWEMTBYPASS[8], !Mreg[8], CSWETBYPASSN);
 and (CSWEMTBYPASS[9], !Mreg[9], CSWETBYPASSN);
 and (CSWEMTBYPASS[10], !Mreg[10], CSWETBYPASSN);
 and (CSWEMTBYPASS[11], !Mreg[11], CSWETBYPASSN);
 and (CSWEMTBYPASS[12], !Mreg[12], CSWETBYPASSN);
 and (CSWEMTBYPASS[13], !Mreg[13], CSWETBYPASSN);
 and (CSWEMTBYPASS[14], !Mreg[14], CSWETBYPASSN);
 and (CSWEMTBYPASS[15], !Mreg[15], CSWETBYPASSN);
 and (CSWEMTBYPASS[16], !Mreg[16], CSWETBYPASSN);
 and (CSWEMTBYPASS[17], !Mreg[17], CSWETBYPASSN);
 and (CSWEMTBYPASS[18], !Mreg[18], CSWETBYPASSN);
 and (CSWEMTBYPASS[19], !Mreg[19], CSWETBYPASSN);
 and (CSWEMTBYPASS[20], !Mreg[20], CSWETBYPASSN);
 and (CSWEMTBYPASS[21], !Mreg[21], CSWETBYPASSN);
 and (CSWEMTBYPASS[22], !Mreg[22], CSWETBYPASSN);
 and (CSWEMTBYPASS[23], !Mreg[23], CSWETBYPASSN);
 and (CSWEMTBYPASS[24], !Mreg[24], CSWETBYPASSN);
 and (CSWEMTBYPASS[25], !Mreg[25], CSWETBYPASSN);
 and (CSWEMTBYPASS[26], !Mreg[26], CSWETBYPASSN);
 and (CSWEMTBYPASS[27], !Mreg[27], CSWETBYPASSN);
 and (CSWEMTBYPASS[28], !Mreg[28], CSWETBYPASSN);
 and (CSWEMTBYPASS[29], !Mreg[29], CSWETBYPASSN);
 and (CSWEMTBYPASS[30], !Mreg[30], CSWETBYPASSN);
 and (CSWEMTBYPASS[31], !Mreg[31], CSWETBYPASSN);
 and (CSWEMTBYPASS[32], !Mreg[32], CSWETBYPASSN);
 and (CSWEMTBYPASS[33], !Mreg[33], CSWETBYPASSN);
 and (CSWEMTBYPASS[34], !Mreg[34], CSWETBYPASSN);
 and (CSWEMTBYPASS[35], !Mreg[35], CSWETBYPASSN);
 and (CSWEMTBYPASS[36], !Mreg[36], CSWETBYPASSN);
 and (CSWEMTBYPASS[37], !Mreg[37], CSWETBYPASSN);
 and (CSWEMTBYPASS[38], !Mreg[38], CSWETBYPASSN);
 and (CSWEMTBYPASS[39], !Mreg[39], CSWETBYPASSN);
 and (CSWEMTBYPASS[40], !Mreg[40], CSWETBYPASSN);
 and (CSWEMTBYPASS[41], !Mreg[41], CSWETBYPASSN);
 and (CSWEMTBYPASS[42], !Mreg[42], CSWETBYPASSN);
 and (CSWEMTBYPASS[43], !Mreg[43], CSWETBYPASSN);
 and (CSWEMTBYPASS[44], !Mreg[44], CSWETBYPASSN);
 and (CSWEMTBYPASS[45], !Mreg[45], CSWETBYPASSN);
 and (CSWEMTBYPASS[46], !Mreg[46], CSWETBYPASSN);
 and (CSWEMTBYPASS[47], !Mreg[47], CSWETBYPASSN);
 and (CSWEMTBYPASS[48], !Mreg[48], CSWETBYPASSN);
 and (CSWEMTBYPASS[49], !Mreg[49], CSWETBYPASSN);
 and (CSWEMTBYPASS[50], !Mreg[50], CSWETBYPASSN);
 and (CSWEMTBYPASS[51], !Mreg[51], CSWETBYPASSN);
 and (CSWEMTBYPASS[52], !Mreg[52], CSWETBYPASSN);
 and (CSWEMTBYPASS[53], !Mreg[53], CSWETBYPASSN);
 and (CSWEMTBYPASS[54], !Mreg[54], CSWETBYPASSN);
 and (CSWEMTBYPASS[55], !Mreg[55], CSWETBYPASSN);
 and (CSWEMTBYPASS[56], !Mreg[56], CSWETBYPASSN);
 and (CSWEMTBYPASS[57], !Mreg[57], CSWETBYPASSN);
 and (CSWEMTBYPASS[58], !Mreg[58], CSWETBYPASSN);
 and (CSWEMTBYPASS[59], !Mreg[59], CSWETBYPASSN);
 and (CSWEMTBYPASS[60], !Mreg[60], CSWETBYPASSN);
 and (CSWEMTBYPASS[61], !Mreg[61], CSWETBYPASSN);
 and (CSWEMTBYPASS[62], !Mreg[62], CSWETBYPASSN);
 and (CSWEMTBYPASS[63], !Mreg[63], CSWETBYPASSN);

and (atp_csn_en,!ATPint,!CSNint,!IGint);
or (sleep_en,atp_csn_en,ATPint);
or (SETB_EN,SEint,TBISTint);
and (ATP_SETB_EN,ATPint,SETB_EN); 
or (CSIG_EN,IGint,CSNint);
and (MEM_ACT,!ATPint,CSIG_EN);
or (EN_ADM,MEM_ACT,ATP_SETB_EN);
and (CS_EN,!ATPint,IGint);
or (CS_ADM,CS_EN,ATP_SETB_EN);
and (atp_ig_csn_en,!ATPint,!CSNint,!IGint);
and (atp_se_en,!SEsys,ATPint);
or (cycle_en,atp_ig_csn_en,atp_se_en);
and (atp_ig_csn_en_reg,!ATPreg,!CSNreg,!IGreg);
and (atp_se_en_reg,!SE_reg,ATPreg);
or (cycle_en_reg,atp_ig_csn_en,atp_se_en);
and (INITNandnotSLEEPandATPandnotSE,cond_gac,!SEsys,ATPint);
and (csn_ig_en,!IGint,!CSNint);
and (atp_tby_ls_en,atp_se_en,cond_ls_tby_en);
and (IG_EN,!ATPint,!CSNint);
or (IG_ADM,IG_EN,atp_se_en);
and (CSWETBYPASSN, !WENreg, 1'b1);



assign cond_sdf_tsls=((sleep_en && INITNint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tstdbys=((sleep_en && INITNint && !SLEEPint) !==0) ? 1:0;
assign cond_sdf_atps=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_gac=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tas=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tds=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tms=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tws=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tps=((cond_gac && !CS_ADM) !==0) ? 1:0;
assign cond_sdf_tcycle=((cond_gac && cycle_en && !LSint && !HSint) !==0) ? 1:0;  
assign cond_sdf_tcycle_ls1=((cond_gac && cycle_en && LSint) !==0) ? 1:0;
assign cond_sdf_tcycle_hs1=((cond_gac && cycle_en && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_tckh=((cond_gac && cycle_en_reg) !==0) ? 1:0;
assign cond_sdf_tckl=((cond_gac && cycle_en) !==0) ? 1:0;
assign cond_sdf_tcycle_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckl_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsctrlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckh_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_ttms=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_tbists=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_tckq_tm=((cond_gac && SE_reg && ATPreg && TBYPASSsys) !==0) ? 1:0;
assign cond_ls_en=((atp_ig_csn_en || atp_tby_ls_en) !==0) ? 1:0;
assign cond_sdf_tlss=((cond_ls_en && cond_gac) !==0) ? 1:0;
assign cond_sdf_thss=((cond_ls_en && cond_gac && !LSint) !==0) ? 1:0;
assign cond_sdf_trms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_twms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_tses=((cond_gac && ATPint) !==0) ? 1:0;
assign cond_sdf_tbas=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbps=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbws=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tigs=((cond_gac && IG_ADM) !==0) ? 1:0;
assign cond_sdf_taa=((MEMEN_reg && WENreg && !LSint && !HSint) !==0) ? 1:0; 
// assign cond_sdf_taa_tbypass_q = ((MEMEN_reg && ATPint && TBYPASSint) !== 1'b0) ? 1'b1 : 1'b0;
assign cond_sdf_taa_ls1=((MEMEN_reg && WENreg && LSint) !==0) ? 1:0; 
assign cond_sdf_taa_hs1=((MEMEN_reg && WENreg && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && !HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_ls1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && LSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_hs1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tseq_tm=((cond_gac && TBYPASSint) !==0) ? 1:0;
assign cond_sdf_tinitns =(( sleep_en && !STDBYint && !SLEEPint) !==0) ? 1:0;
assign cond_ls_tby_en=((TBYPASSsys || csn_ig_en) !==0) ? 1:0;



//specify block begins

specify
    specparam
    
         PATHPULSE$CK$Q = 0,
         PATHPULSE$CK$SCTRLO = 0,

         PATHPULSE$CK$SDLO = 0,
         PATHPULSE$CK$SDRO = 0,
        
         PATHPULSE$CK$SMLO = 0,
         PATHPULSE$CK$SMRO = 0,
         PATHPULSE$SE$Q = 0,
         
//         PATHPULSE$TBYPASS$Q = 0,


        
         
        
         tsls = `setup_time,
         tslh = `hold_time ,
         tstdbys = `setup_time,
         tstdbyh = `hold_time , 
	 

        
         tms = `setup_time,
         tmh = `hold_time , 
         tsmlis=`setup_time,
         tsmlih=`hold_time ,
         tsmris=`setup_time,
         tsmrih=`hold_time , 
         tcycle = `cycle_time,
         
         
         tckh = `pulse_width_time,
         tckl = `pulse_width_time,
         tcycle_se = `cycle_time,
         tckh_se = `pulse_width_time,
         tckl_se = `pulse_width_time,
         
         ttms = `setup_time,
         ttmh = `hold_time ,
         tps = `setup_time,
         tph = `hold_time ,
         tws = `setup_time,
         twh = `hold_time ,
         tds = `setup_time,
         tdh = `hold_time , 
         tas = `setup_time,
         tah = `hold_time ,
         tses= `setup_time,
         tseh= `hold_time ,
         tsctrlis=`setup_time,
         tsctrlih=`hold_time ,
         tsdlis=`setup_time,
         tsdlih=`hold_time ,
         tsdris=`setup_time,
         tsdrih=`hold_time , 
         tbists=`setup_time,
         tbisth=`hold_time ,
         tbps=`setup_time,
         tbph=`hold_time ,
         tbws=`setup_time,
         tbwh=`hold_time ,
         tbdes=`setup_time,
         tbdeh=`hold_time ,
         tbdos=`setup_time,
         tbdoh=`hold_time ,
        
         tbmes=`setup_time,
         tbmeh=`hold_time ,
         tbmos=`setup_time,
         tbmoh=`hold_time ,  
         tbas=`setup_time,
         tbah=`hold_time ,
         tinitnl=`initin_low_pulse,
         tinitns=`setup_time,
         tinitnh=`hold_time ,
         tatps=`setup_time,
         tatph=`hold_time ,
         tigs=`setup_time,
         tigh=`hold_time ,
         
         
         trms=`setup_time,
         trmh=`hold_time ,
         twms=`setup_time,
         twmh=`hold_time , 

/*************************************************************************************************/
           // taa_tbypass_q = `access_time,
           // th_tbypass_q  = `retain_time,
            taa =`access_time,
            th = `retain_time,

 


            taa_tm =`access_time,
            th_tm = `retain_time,

            
            taa_tseq_tm =`access_time,
            th_tseq_tm = `retain_time,
            taa_tckq_tm   = `access_time,
            th_tckq_tm    = `retain_time,
            taa_sctrlo=`access_time,
            th_sctrlo= `retain_time,
            taa_sdlo=`access_time,
            th_sdlo= `retain_time,
            taa_sdro=`access_time,
            th_sdro= `retain_time,
            
        
            taa_smlo=`access_time,
            th_smlo= `retain_time,
            taa_smro=`access_time,
            th_smro= `retain_time, 
            taa_sctrlo_se=`access_time,
            th_sctrlo_se= `retain_time
,
            taa_sdlo_se=`access_time,
            th_sdlo_se= `retain_time,
            taa_sdro_se=`access_time,
            th_sdro_se= `retain_time
        ,
            taa_smlo_se=`access_time,
            th_smlo_se= `retain_time,
            taa_smro_se=`access_time,
            th_smro_se= `retain_time;   


        /*---------------------- Timing Checks ---------------------*/

	$setup(posedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[5], tah, TimingViol_addr);

	$setup(posedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(posedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(posedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(posedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(posedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(posedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(posedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(posedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(posedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(posedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(posedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(posedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(posedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(posedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(posedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(posedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(posedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(posedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(posedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(posedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(posedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(posedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$setup(posedge D[22], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_22);
	$setup(posedge D[23], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_23);
	$setup(posedge D[24], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_24);
	$setup(posedge D[25], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_25);
	$setup(posedge D[26], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_26);
	$setup(posedge D[27], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_27);
	$setup(posedge D[28], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_28);
	$setup(posedge D[29], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_29);
	$setup(posedge D[30], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_30);
	$setup(posedge D[31], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_31);
	$setup(posedge D[32], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_32);
	$setup(posedge D[33], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_33);
	$setup(posedge D[34], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_34);
	$setup(posedge D[35], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_35);
	$setup(posedge D[36], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_36);
	$setup(posedge D[37], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_37);
	$setup(posedge D[38], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_38);
	$setup(posedge D[39], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_39);
	$setup(posedge D[40], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_40);
	$setup(posedge D[41], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_41);
	$setup(posedge D[42], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_42);
	$setup(posedge D[43], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_43);
	$setup(posedge D[44], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_44);
	$setup(posedge D[45], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_45);
	$setup(posedge D[46], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_46);
	$setup(posedge D[47], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_47);
	$setup(posedge D[48], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_48);
	$setup(posedge D[49], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_49);
	$setup(posedge D[50], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_50);
	$setup(posedge D[51], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_51);
	$setup(posedge D[52], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_52);
	$setup(posedge D[53], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_53);
	$setup(posedge D[54], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_54);
	$setup(posedge D[55], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_55);
	$setup(posedge D[56], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_56);
	$setup(posedge D[57], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_57);
	$setup(posedge D[58], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_58);
	$setup(posedge D[59], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_59);
	$setup(posedge D[60], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_60);
	$setup(posedge D[61], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_61);
	$setup(posedge D[62], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_62);
	$setup(posedge D[63], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_63);
	$setup(negedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(negedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(negedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(negedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(negedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(negedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(negedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(negedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(negedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(negedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(negedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(negedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(negedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(negedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(negedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(negedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(negedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(negedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(negedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(negedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(negedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(negedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$setup(negedge D[22], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_22);
	$setup(negedge D[23], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_23);
	$setup(negedge D[24], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_24);
	$setup(negedge D[25], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_25);
	$setup(negedge D[26], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_26);
	$setup(negedge D[27], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_27);
	$setup(negedge D[28], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_28);
	$setup(negedge D[29], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_29);
	$setup(negedge D[30], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_30);
	$setup(negedge D[31], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_31);
	$setup(negedge D[32], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_32);
	$setup(negedge D[33], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_33);
	$setup(negedge D[34], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_34);
	$setup(negedge D[35], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_35);
	$setup(negedge D[36], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_36);
	$setup(negedge D[37], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_37);
	$setup(negedge D[38], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_38);
	$setup(negedge D[39], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_39);
	$setup(negedge D[40], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_40);
	$setup(negedge D[41], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_41);
	$setup(negedge D[42], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_42);
	$setup(negedge D[43], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_43);
	$setup(negedge D[44], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_44);
	$setup(negedge D[45], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_45);
	$setup(negedge D[46], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_46);
	$setup(negedge D[47], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_47);
	$setup(negedge D[48], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_48);
	$setup(negedge D[49], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_49);
	$setup(negedge D[50], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_50);
	$setup(negedge D[51], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_51);
	$setup(negedge D[52], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_52);
	$setup(negedge D[53], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_53);
	$setup(negedge D[54], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_54);
	$setup(negedge D[55], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_55);
	$setup(negedge D[56], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_56);
	$setup(negedge D[57], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_57);
	$setup(negedge D[58], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_58);
	$setup(negedge D[59], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_59);
	$setup(negedge D[60], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_60);
	$setup(negedge D[61], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_61);
	$setup(negedge D[62], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_62);
	$setup(negedge D[63], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_63);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[21], tdh, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[22], tdh, TimingViol_data_22);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[23], tdh, TimingViol_data_23);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[24], tdh, TimingViol_data_24);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[25], tdh, TimingViol_data_25);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[26], tdh, TimingViol_data_26);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[27], tdh, TimingViol_data_27);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[28], tdh, TimingViol_data_28);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[29], tdh, TimingViol_data_29);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[30], tdh, TimingViol_data_30);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[31], tdh, TimingViol_data_31);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[32], tdh, TimingViol_data_32);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[33], tdh, TimingViol_data_33);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[34], tdh, TimingViol_data_34);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[35], tdh, TimingViol_data_35);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[36], tdh, TimingViol_data_36);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[37], tdh, TimingViol_data_37);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[38], tdh, TimingViol_data_38);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[39], tdh, TimingViol_data_39);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[40], tdh, TimingViol_data_40);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[41], tdh, TimingViol_data_41);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[42], tdh, TimingViol_data_42);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[43], tdh, TimingViol_data_43);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[44], tdh, TimingViol_data_44);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[45], tdh, TimingViol_data_45);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[46], tdh, TimingViol_data_46);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[47], tdh, TimingViol_data_47);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[48], tdh, TimingViol_data_48);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[49], tdh, TimingViol_data_49);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[50], tdh, TimingViol_data_50);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[51], tdh, TimingViol_data_51);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[52], tdh, TimingViol_data_52);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[53], tdh, TimingViol_data_53);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[54], tdh, TimingViol_data_54);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[55], tdh, TimingViol_data_55);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[56], tdh, TimingViol_data_56);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[57], tdh, TimingViol_data_57);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[58], tdh, TimingViol_data_58);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[59], tdh, TimingViol_data_59);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[60], tdh, TimingViol_data_60);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[61], tdh, TimingViol_data_61);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[62], tdh, TimingViol_data_62);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[63], tdh, TimingViol_data_63);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[21], tdh, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[22], tdh, TimingViol_data_22);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[23], tdh, TimingViol_data_23);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[24], tdh, TimingViol_data_24);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[25], tdh, TimingViol_data_25);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[26], tdh, TimingViol_data_26);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[27], tdh, TimingViol_data_27);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[28], tdh, TimingViol_data_28);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[29], tdh, TimingViol_data_29);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[30], tdh, TimingViol_data_30);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[31], tdh, TimingViol_data_31);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[32], tdh, TimingViol_data_32);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[33], tdh, TimingViol_data_33);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[34], tdh, TimingViol_data_34);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[35], tdh, TimingViol_data_35);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[36], tdh, TimingViol_data_36);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[37], tdh, TimingViol_data_37);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[38], tdh, TimingViol_data_38);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[39], tdh, TimingViol_data_39);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[40], tdh, TimingViol_data_40);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[41], tdh, TimingViol_data_41);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[42], tdh, TimingViol_data_42);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[43], tdh, TimingViol_data_43);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[44], tdh, TimingViol_data_44);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[45], tdh, TimingViol_data_45);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[46], tdh, TimingViol_data_46);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[47], tdh, TimingViol_data_47);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[48], tdh, TimingViol_data_48);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[49], tdh, TimingViol_data_49);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[50], tdh, TimingViol_data_50);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[51], tdh, TimingViol_data_51);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[52], tdh, TimingViol_data_52);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[53], tdh, TimingViol_data_53);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[54], tdh, TimingViol_data_54);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[55], tdh, TimingViol_data_55);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[56], tdh, TimingViol_data_56);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[57], tdh, TimingViol_data_57);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[58], tdh, TimingViol_data_58);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[59], tdh, TimingViol_data_59);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[60], tdh, TimingViol_data_60);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[61], tdh, TimingViol_data_61);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[62], tdh, TimingViol_data_62);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[63], tdh, TimingViol_data_63);

     $setup(posedge M[0], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_0);
	$setup(negedge M[0], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_0);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[0], tmh, TimingViol_mask_0);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[0], tmh, TimingViol_mask_0);
     $setup(posedge M[1], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_1);
	$setup(negedge M[1], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_1);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[1], tmh, TimingViol_mask_1);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[1], tmh, TimingViol_mask_1);
     $setup(posedge M[2], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_2);
	$setup(negedge M[2], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_2);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[2], tmh, TimingViol_mask_2);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[2], tmh, TimingViol_mask_2);
     $setup(posedge M[3], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_3);
	$setup(negedge M[3], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_3);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[3], tmh, TimingViol_mask_3);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[3], tmh, TimingViol_mask_3);
     $setup(posedge M[4], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_4);
	$setup(negedge M[4], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_4);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[4], tmh, TimingViol_mask_4);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[4], tmh, TimingViol_mask_4);
     $setup(posedge M[5], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_5);
	$setup(negedge M[5], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_5);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[5], tmh, TimingViol_mask_5);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[5], tmh, TimingViol_mask_5);
     $setup(posedge M[6], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_6);
	$setup(negedge M[6], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_6);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[6], tmh, TimingViol_mask_6);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[6], tmh, TimingViol_mask_6);
     $setup(posedge M[7], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_7);
	$setup(negedge M[7], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_7);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[7], tmh, TimingViol_mask_7);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[7], tmh, TimingViol_mask_7);
     $setup(posedge M[8], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_8);
	$setup(negedge M[8], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_8);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[8], tmh, TimingViol_mask_8);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[8], tmh, TimingViol_mask_8);
     $setup(posedge M[9], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_9);
	$setup(negedge M[9], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_9);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[9], tmh, TimingViol_mask_9);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[9], tmh, TimingViol_mask_9);
     $setup(posedge M[10], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_10);
	$setup(negedge M[10], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_10);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[10], tmh, TimingViol_mask_10);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[10], tmh, TimingViol_mask_10);
     $setup(posedge M[11], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_11);
	$setup(negedge M[11], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_11);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[11], tmh, TimingViol_mask_11);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[11], tmh, TimingViol_mask_11);
     $setup(posedge M[12], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_12);
	$setup(negedge M[12], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_12);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[12], tmh, TimingViol_mask_12);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[12], tmh, TimingViol_mask_12);
     $setup(posedge M[13], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_13);
	$setup(negedge M[13], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_13);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[13], tmh, TimingViol_mask_13);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[13], tmh, TimingViol_mask_13);
     $setup(posedge M[14], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_14);
	$setup(negedge M[14], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_14);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[14], tmh, TimingViol_mask_14);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[14], tmh, TimingViol_mask_14);
     $setup(posedge M[15], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_15);
	$setup(negedge M[15], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_15);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[15], tmh, TimingViol_mask_15);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[15], tmh, TimingViol_mask_15);
     $setup(posedge M[16], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_16);
	$setup(negedge M[16], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_16);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[16], tmh, TimingViol_mask_16);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[16], tmh, TimingViol_mask_16);
     $setup(posedge M[17], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_17);
	$setup(negedge M[17], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_17);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[17], tmh, TimingViol_mask_17);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[17], tmh, TimingViol_mask_17);
     $setup(posedge M[18], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_18);
	$setup(negedge M[18], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_18);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[18], tmh, TimingViol_mask_18);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[18], tmh, TimingViol_mask_18);
     $setup(posedge M[19], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_19);
	$setup(negedge M[19], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_19);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[19], tmh, TimingViol_mask_19);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[19], tmh, TimingViol_mask_19);
     $setup(posedge M[20], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_20);
	$setup(negedge M[20], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_20);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[20], tmh, TimingViol_mask_20);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[20], tmh, TimingViol_mask_20);
     $setup(posedge M[21], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_21);
	$setup(negedge M[21], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_21);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[21], tmh, TimingViol_mask_21);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[21], tmh, TimingViol_mask_21);
     $setup(posedge M[22], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_22);
	$setup(negedge M[22], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_22);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[22], tmh, TimingViol_mask_22);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[22], tmh, TimingViol_mask_22);
     $setup(posedge M[23], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_23);
	$setup(negedge M[23], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_23);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[23], tmh, TimingViol_mask_23);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[23], tmh, TimingViol_mask_23);
     $setup(posedge M[24], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_24);
	$setup(negedge M[24], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_24);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[24], tmh, TimingViol_mask_24);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[24], tmh, TimingViol_mask_24);
     $setup(posedge M[25], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_25);
	$setup(negedge M[25], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_25);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[25], tmh, TimingViol_mask_25);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[25], tmh, TimingViol_mask_25);
     $setup(posedge M[26], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_26);
	$setup(negedge M[26], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_26);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[26], tmh, TimingViol_mask_26);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[26], tmh, TimingViol_mask_26);
     $setup(posedge M[27], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_27);
	$setup(negedge M[27], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_27);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[27], tmh, TimingViol_mask_27);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[27], tmh, TimingViol_mask_27);
     $setup(posedge M[28], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_28);
	$setup(negedge M[28], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_28);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[28], tmh, TimingViol_mask_28);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[28], tmh, TimingViol_mask_28);
     $setup(posedge M[29], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_29);
	$setup(negedge M[29], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_29);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[29], tmh, TimingViol_mask_29);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[29], tmh, TimingViol_mask_29);
     $setup(posedge M[30], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_30);
	$setup(negedge M[30], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_30);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[30], tmh, TimingViol_mask_30);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[30], tmh, TimingViol_mask_30);
     $setup(posedge M[31], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_31);
	$setup(negedge M[31], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_31);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[31], tmh, TimingViol_mask_31);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[31], tmh, TimingViol_mask_31);
     $setup(posedge M[32], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_32);
	$setup(negedge M[32], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_32);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[32], tmh, TimingViol_mask_32);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[32], tmh, TimingViol_mask_32);
     $setup(posedge M[33], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_33);
	$setup(negedge M[33], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_33);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[33], tmh, TimingViol_mask_33);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[33], tmh, TimingViol_mask_33);
     $setup(posedge M[34], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_34);
	$setup(negedge M[34], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_34);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[34], tmh, TimingViol_mask_34);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[34], tmh, TimingViol_mask_34);
     $setup(posedge M[35], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_35);
	$setup(negedge M[35], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_35);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[35], tmh, TimingViol_mask_35);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[35], tmh, TimingViol_mask_35);
     $setup(posedge M[36], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_36);
	$setup(negedge M[36], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_36);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[36], tmh, TimingViol_mask_36);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[36], tmh, TimingViol_mask_36);
     $setup(posedge M[37], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_37);
	$setup(negedge M[37], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_37);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[37], tmh, TimingViol_mask_37);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[37], tmh, TimingViol_mask_37);
     $setup(posedge M[38], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_38);
	$setup(negedge M[38], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_38);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[38], tmh, TimingViol_mask_38);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[38], tmh, TimingViol_mask_38);
     $setup(posedge M[39], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_39);
	$setup(negedge M[39], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_39);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[39], tmh, TimingViol_mask_39);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[39], tmh, TimingViol_mask_39);
     $setup(posedge M[40], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_40);
	$setup(negedge M[40], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_40);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[40], tmh, TimingViol_mask_40);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[40], tmh, TimingViol_mask_40);
     $setup(posedge M[41], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_41);
	$setup(negedge M[41], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_41);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[41], tmh, TimingViol_mask_41);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[41], tmh, TimingViol_mask_41);
     $setup(posedge M[42], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_42);
	$setup(negedge M[42], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_42);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[42], tmh, TimingViol_mask_42);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[42], tmh, TimingViol_mask_42);
     $setup(posedge M[43], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_43);
	$setup(negedge M[43], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_43);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[43], tmh, TimingViol_mask_43);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[43], tmh, TimingViol_mask_43);
     $setup(posedge M[44], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_44);
	$setup(negedge M[44], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_44);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[44], tmh, TimingViol_mask_44);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[44], tmh, TimingViol_mask_44);
     $setup(posedge M[45], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_45);
	$setup(negedge M[45], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_45);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[45], tmh, TimingViol_mask_45);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[45], tmh, TimingViol_mask_45);
     $setup(posedge M[46], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_46);
	$setup(negedge M[46], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_46);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[46], tmh, TimingViol_mask_46);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[46], tmh, TimingViol_mask_46);
     $setup(posedge M[47], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_47);
	$setup(negedge M[47], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_47);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[47], tmh, TimingViol_mask_47);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[47], tmh, TimingViol_mask_47);
     $setup(posedge M[48], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_48);
	$setup(negedge M[48], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_48);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[48], tmh, TimingViol_mask_48);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[48], tmh, TimingViol_mask_48);
     $setup(posedge M[49], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_49);
	$setup(negedge M[49], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_49);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[49], tmh, TimingViol_mask_49);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[49], tmh, TimingViol_mask_49);
     $setup(posedge M[50], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_50);
	$setup(negedge M[50], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_50);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[50], tmh, TimingViol_mask_50);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[50], tmh, TimingViol_mask_50);
     $setup(posedge M[51], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_51);
	$setup(negedge M[51], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_51);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[51], tmh, TimingViol_mask_51);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[51], tmh, TimingViol_mask_51);
     $setup(posedge M[52], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_52);
	$setup(negedge M[52], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_52);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[52], tmh, TimingViol_mask_52);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[52], tmh, TimingViol_mask_52);
     $setup(posedge M[53], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_53);
	$setup(negedge M[53], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_53);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[53], tmh, TimingViol_mask_53);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[53], tmh, TimingViol_mask_53);
     $setup(posedge M[54], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_54);
	$setup(negedge M[54], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_54);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[54], tmh, TimingViol_mask_54);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[54], tmh, TimingViol_mask_54);
     $setup(posedge M[55], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_55);
	$setup(negedge M[55], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_55);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[55], tmh, TimingViol_mask_55);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[55], tmh, TimingViol_mask_55);
     $setup(posedge M[56], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_56);
	$setup(negedge M[56], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_56);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[56], tmh, TimingViol_mask_56);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[56], tmh, TimingViol_mask_56);
     $setup(posedge M[57], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_57);
	$setup(negedge M[57], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_57);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[57], tmh, TimingViol_mask_57);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[57], tmh, TimingViol_mask_57);
     $setup(posedge M[58], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_58);
	$setup(negedge M[58], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_58);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[58], tmh, TimingViol_mask_58);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[58], tmh, TimingViol_mask_58);
     $setup(posedge M[59], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_59);
	$setup(negedge M[59], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_59);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[59], tmh, TimingViol_mask_59);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[59], tmh, TimingViol_mask_59);
     $setup(posedge M[60], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_60);
	$setup(negedge M[60], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_60);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[60], tmh, TimingViol_mask_60);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[60], tmh, TimingViol_mask_60);
     $setup(posedge M[61], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_61);
	$setup(negedge M[61], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_61);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[61], tmh, TimingViol_mask_61);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[61], tmh, TimingViol_mask_61);
     $setup(posedge M[62], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_62);
	$setup(negedge M[62], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_62);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[62], tmh, TimingViol_mask_62);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[62], tmh, TimingViol_mask_62);
     $setup(posedge M[63], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_63);
	$setup(negedge M[63], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_63);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[63], tmh, TimingViol_mask_63);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[63], tmh, TimingViol_mask_63);


        $setup(posedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $setup(negedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, posedge WEN, twh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, negedge WEN, twh, TimingViol_WEN); 
        $setup(posedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$setup(negedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, posedge CSN, tph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, negedge CSN, tph, TimingViol_CSN);
        $period(posedge CK &&& cond_sdf_tcycle, tcycle, TimingViol_tcycle);  

        
        $width(posedge CK  &&& cond_sdf_tckh, tckh, 0, TimingViol_tckh);
        $width(negedge CK  &&& cond_sdf_tckl, tckl, 0, TimingViol_tckl);
        $period(posedge CK &&& cond_sdf_tcycle_se, tcycle_se, TimingViol_tcycle_se);
        $width(posedge CK  &&& cond_sdf_tckh_se, tckh_se, 0, TimingViol_tckh_se);
        $width(negedge CK  &&& cond_sdf_tckl_se, tckl_se, 0, TimingViol_tckl_se);

        
        $setup(posedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $setup(negedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $hold(posedge CK &&& cond_sdf_ttms, posedge TBYPASS, ttmh, TimingViol_tbypass); 
        $hold(posedge CK &&& cond_sdf_ttms, negedge TBYPASS, ttmh, TimingViol_tbypass); 
 



        
        $setup(posedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $setup(negedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $hold(posedge CK &&& cond_sdf_tsls, posedge SLEEP, tslh, TimingViol_sleep);        
        $hold(posedge CK &&& cond_sdf_tsls, negedge SLEEP, tslh, TimingViol_sleep);

        $setup(posedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $setup(negedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $hold(posedge CK &&& cond_sdf_tstdbys, posedge STDBY, tstdbyh, TimingViol_stdby);        
        $hold(posedge CK &&& cond_sdf_tstdbys, negedge STDBY, tstdbyh, TimingViol_stdby); 
        
        
        $setup (posedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
	$setup (negedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
        
        $hold (posedge CK &&& cond_sdf_tses, posedge SE ,tseh,TimingViol_se);
	$hold (posedge CK &&& cond_sdf_tses, negedge SE ,tseh,TimingViol_se);
        
        $setup(posedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis , tsctrlis, TimingViol_sctrli);
        $setup(negedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis, tsctrlis, TimingViol_sctrli);
        $hold(posedge CK &&& cond_sdf_tsctrlis , posedge SCTRLI, tsctrlih, TimingViol_sctrli);        
        $hold(posedge CK &&& cond_sdf_tsctrlis , negedge SCTRLI, tsctrlih, TimingViol_sctrli);

        $setup(posedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $setup(negedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $hold(posedge CK &&& cond_sdf_tsdlis, posedge SDLI, tsdlih, TimingViol_sdli);        
        $hold(posedge CK &&& cond_sdf_tsdlis, negedge SDLI, tsdlih, TimingViol_sdli);

        $setup(posedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $setup(negedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $hold(posedge CK &&& cond_sdf_tsdris, posedge SDRI, tsdrih, TimingViol_sdri);        
        $hold(posedge CK &&& cond_sdf_tsdris, negedge SDRI, tsdrih, TimingViol_sdri);
        
 
        $setup(posedge SMLI, posedge CK &&& cond_sdf_tsmlis, tsmlis, TimingViol_smli);
        $setup(negedge SMLI, posedge CK &&& cond_sdf_tsmlis, tsmlis, TimingViol_smli);
        $hold(posedge CK &&& cond_sdf_tsmlis, posedge SMLI, tsmlih, TimingViol_smli);        
        $hold(posedge CK &&& cond_sdf_tsmlis, negedge SMLI, tsmlih, TimingViol_smli);

        $setup(posedge SMRI, posedge CK &&& cond_sdf_tsmris, tsmris, TimingViol_smri);
        $setup(negedge SMRI, posedge CK &&& cond_sdf_tsmris, tsmris, TimingViol_smri);
        $hold(posedge CK &&& cond_sdf_tsmris, posedge SMRI, tsmrih, TimingViol_smri);        
        $hold(posedge CK &&& cond_sdf_tsmris, negedge SMRI, tsmrih, TimingViol_smri);
	
         
        $width(negedge INITN , tinitnl, 0, TimingViol_initnl);
        
        $setup(posedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        $setup(negedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        
        $hold (posedge CK &&& cond_sdf_tinitns,posedge INITN, tinitnh, TimingViol_initn);
        $hold (posedge CK &&& cond_sdf_tinitns,negedge INITN, tinitnh, TimingViol_initn);

        $setup(posedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $setup(negedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $hold(posedge CK &&& cond_sdf_atps, posedge ATP, tatph, TimingViol_atp);        
        $hold(posedge CK &&& cond_sdf_atps, negedge ATP, tatph, TimingViol_atp);
        
        $setup(posedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $setup(negedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $hold(posedge CK &&& cond_sdf_tigs, posedge IG, tigh, TimingViol_ig);        
        $hold(posedge CK &&& cond_sdf_tigs, negedge IG, tigh, TimingViol_ig);



         
$setup(posedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[2], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[2], trmh, TimingViol_rm); 

        
$setup(posedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(posedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[1], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[1], twmh, TimingViol_wm);
 
        
        $setup(posedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $setup(negedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $hold(posedge CK &&& cond_sdf_tbists, posedge TBIST, tbisth, TimingViol_tbist);        
        $hold(posedge CK &&& cond_sdf_tbists, negedge TBIST, tbisth, TimingViol_tbist);
        
        	$setup(posedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$setup(negedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[5], tbah, TimingViol_addr);
       	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[5], tbah, TimingViol_addr);

        $setup(posedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$setup(negedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, posedge TCSN, tbph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, negedge TCSN, tbph, TimingViol_CSN); 
       
        $setup(posedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $setup(negedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, posedge TWEN, tbwh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, negedge TWEN, tbwh, TimingViol_WEN);
       
       
        $setup(posedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $setup(negedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, posedge TED, tbdeh, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, negedge TED, tbdeh, TimingViol_TED);

        $setup(posedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $setup(negedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, posedge TOD, tbdoh, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, negedge TOD, tbdoh, TimingViol_TOD);

        $setup(posedge TEM, posedge CK &&& cond_sdf_tbmes, tbmes, TimingViol_TEM);
        $setup(negedge TEM, posedge CK &&& cond_sdf_tbmes, tbmes, TimingViol_TEM);
        $hold(posedge CK &&& cond_sdf_tbmes, posedge TEM, tbmeh, TimingViol_TEM);
        $hold(posedge CK &&& cond_sdf_tbmes, negedge TEM, tbmeh, TimingViol_TEM);

        $setup(posedge TOM, posedge CK &&& cond_sdf_tbmos, tbmos, TimingViol_TOM);
        $setup(negedge TOM, posedge CK &&& cond_sdf_tbmos, tbmos, TimingViol_TOM);
        $hold(posedge CK &&& cond_sdf_tbmos, posedge TOM, tbmoh, TimingViol_TOM);
        $hold(posedge CK &&& cond_sdf_tbmos, negedge TOM, tbmoh, TimingViol_TOM);
       
          


          

          /*-------------------- Propagation Delays ------------------*/
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[22] +: OutReg_data[22])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[23] +: OutReg_data[23])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[24] +: OutReg_data[24])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[25] +: OutReg_data[25])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[26] +: OutReg_data[26])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[27] +: OutReg_data[27])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[28] +: OutReg_data[28])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[29] +: OutReg_data[29])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[30] +: OutReg_data[30])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[31] +: OutReg_data[31])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[32] +: OutReg_data[32])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[33] +: OutReg_data[33])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[34] +: OutReg_data[34])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[35] +: OutReg_data[35])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[36] +: OutReg_data[36])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[37] +: OutReg_data[37])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[38] +: OutReg_data[38])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[39] +: OutReg_data[39])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[40] +: OutReg_data[40])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[41] +: OutReg_data[41])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[42] +: OutReg_data[42])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[43] +: OutReg_data[43])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[44] +: OutReg_data[44])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[45] +: OutReg_data[45])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[46] +: OutReg_data[46])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[47] +: OutReg_data[47])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[48] +: OutReg_data[48])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[49] +: OutReg_data[49])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[50] +: OutReg_data[50])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[51] +: OutReg_data[51])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[52] +: OutReg_data[52])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[53] +: OutReg_data[53])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[54] +: OutReg_data[54])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[55] +: OutReg_data[55])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[56] +: OutReg_data[56])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[57] +: OutReg_data[57])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[58] +: OutReg_data[58])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[59] +: OutReg_data[59])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[60] +: OutReg_data[60])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[61] +: OutReg_data[61])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[62] +: OutReg_data[62])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[63] +: OutReg_data[63])) = (taa, taa, th, taa, th, taa);
                 

/* // //	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[0] +: OutReg_data[0])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[1] +: OutReg_data[1])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[2] +: OutReg_data[2])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[3] +: OutReg_data[3])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[4] +: OutReg_data[4])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[5] +: OutReg_data[5])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[6] +: OutReg_data[6])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[7] +: OutReg_data[7])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[8] +: OutReg_data[8])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[9] +: OutReg_data[9])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[10] +: OutReg_data[10])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[11] +: OutReg_data[11])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[12] +: OutReg_data[12])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[13] +: OutReg_data[13])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[14] +: OutReg_data[14])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[15] +: OutReg_data[15])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[16] +: OutReg_data[16])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[17] +: OutReg_data[17])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[18] +: OutReg_data[18])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[19] +: OutReg_data[19])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[20] +: OutReg_data[20])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[21] +: OutReg_data[21])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[22] +: OutReg_data[22])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[23] +: OutReg_data[23])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[24] +: OutReg_data[24])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[25] +: OutReg_data[25])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[26] +: OutReg_data[26])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[27] +: OutReg_data[27])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[28] +: OutReg_data[28])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[29] +: OutReg_data[29])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[30] +: OutReg_data[30])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[31] +: OutReg_data[31])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[32] +: OutReg_data[32])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[33] +: OutReg_data[33])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[34] +: OutReg_data[34])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[35] +: OutReg_data[35])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[36] +: OutReg_data[36])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[37] +: OutReg_data[37])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[38] +: OutReg_data[38])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[39] +: OutReg_data[39])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[40] +: OutReg_data[40])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[41] +: OutReg_data[41])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[42] +: OutReg_data[42])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[43] +: OutReg_data[43])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[44] +: OutReg_data[44])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[45] +: OutReg_data[45])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[46] +: OutReg_data[46])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[47] +: OutReg_data[47])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[48] +: OutReg_data[48])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[49] +: OutReg_data[49])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[50] +: OutReg_data[50])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[51] +: OutReg_data[51])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[52] +: OutReg_data[52])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[53] +: OutReg_data[53])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[54] +: OutReg_data[54])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[55] +: OutReg_data[55])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[56] +: OutReg_data[56])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[57] +: OutReg_data[57])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[58] +: OutReg_data[58])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[59] +: OutReg_data[59])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[60] +: OutReg_data[60])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[61] +: OutReg_data[61])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[62] +: OutReg_data[62])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[63] +: OutReg_data[63])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q); */ 








	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[22] +: OutReg_data[22])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[23] +: OutReg_data[23])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[24] +: OutReg_data[24])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[25] +: OutReg_data[25])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[26] +: OutReg_data[26])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[27] +: OutReg_data[27])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[28] +: OutReg_data[28])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[29] +: OutReg_data[29])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[30] +: OutReg_data[30])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[31] +: OutReg_data[31])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[32] +: OutReg_data[32])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[33] +: OutReg_data[33])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[34] +: OutReg_data[34])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[35] +: OutReg_data[35])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[36] +: OutReg_data[36])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[37] +: OutReg_data[37])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[38] +: OutReg_data[38])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[39] +: OutReg_data[39])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[40] +: OutReg_data[40])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[41] +: OutReg_data[41])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[42] +: OutReg_data[42])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[43] +: OutReg_data[43])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[44] +: OutReg_data[44])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[45] +: OutReg_data[45])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[46] +: OutReg_data[46])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[47] +: OutReg_data[47])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[48] +: OutReg_data[48])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[49] +: OutReg_data[49])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[50] +: OutReg_data[50])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[51] +: OutReg_data[51])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[52] +: OutReg_data[52])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[53] +: OutReg_data[53])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[54] +: OutReg_data[54])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[55] +: OutReg_data[55])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[56] +: OutReg_data[56])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[57] +: OutReg_data[57])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[58] +: OutReg_data[58])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[59] +: OutReg_data[59])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[60] +: OutReg_data[60])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[61] +: OutReg_data[61])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[62] +: OutReg_data[62])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[63] +: OutReg_data[63])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                





	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[22] +: OutReg_data[22])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[22] +: OutReg_data[22])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[23] +: OutReg_data[23])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[23] +: OutReg_data[23])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[24] +: OutReg_data[24])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[24] +: OutReg_data[24])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[25] +: OutReg_data[25])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[25] +: OutReg_data[25])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[26] +: OutReg_data[26])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[26] +: OutReg_data[26])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[27] +: OutReg_data[27])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[27] +: OutReg_data[27])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[28] +: OutReg_data[28])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[28] +: OutReg_data[28])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[29] +: OutReg_data[29])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[29] +: OutReg_data[29])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[30] +: OutReg_data[30])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[30] +: OutReg_data[30])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[31] +: OutReg_data[31])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[31] +: OutReg_data[31])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[32] +: OutReg_data[32])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[32] +: OutReg_data[32])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[33] +: OutReg_data[33])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[33] +: OutReg_data[33])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[34] +: OutReg_data[34])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[34] +: OutReg_data[34])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[35] +: OutReg_data[35])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[35] +: OutReg_data[35])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[36] +: OutReg_data[36])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[36] +: OutReg_data[36])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[37] +: OutReg_data[37])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[37] +: OutReg_data[37])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[38] +: OutReg_data[38])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[38] +: OutReg_data[38])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[39] +: OutReg_data[39])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[39] +: OutReg_data[39])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[40] +: OutReg_data[40])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[40] +: OutReg_data[40])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[41] +: OutReg_data[41])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[41] +: OutReg_data[41])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[42] +: OutReg_data[42])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[42] +: OutReg_data[42])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[43] +: OutReg_data[43])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[43] +: OutReg_data[43])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[44] +: OutReg_data[44])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[44] +: OutReg_data[44])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[45] +: OutReg_data[45])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[45] +: OutReg_data[45])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[46] +: OutReg_data[46])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[46] +: OutReg_data[46])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[47] +: OutReg_data[47])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[47] +: OutReg_data[47])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[48] +: OutReg_data[48])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[48] +: OutReg_data[48])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[49] +: OutReg_data[49])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[49] +: OutReg_data[49])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[50] +: OutReg_data[50])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[50] +: OutReg_data[50])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[51] +: OutReg_data[51])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[51] +: OutReg_data[51])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[52] +: OutReg_data[52])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[52] +: OutReg_data[52])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[53] +: OutReg_data[53])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[53] +: OutReg_data[53])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[54] +: OutReg_data[54])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[54] +: OutReg_data[54])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[55] +: OutReg_data[55])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[55] +: OutReg_data[55])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[56] +: OutReg_data[56])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[56] +: OutReg_data[56])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[57] +: OutReg_data[57])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[57] +: OutReg_data[57])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[58] +: OutReg_data[58])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[58] +: OutReg_data[58])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[59] +: OutReg_data[59])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[59] +: OutReg_data[59])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[60] +: OutReg_data[60])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[60] +: OutReg_data[60])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[61] +: OutReg_data[61])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[61] +: OutReg_data[61])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[62] +: OutReg_data[62])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[62] +: OutReg_data[62])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[63] +: OutReg_data[63])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[63] +: OutReg_data[63])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                 

	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[0] +: OutReg_data[0])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[1] +: OutReg_data[1])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[2] +: OutReg_data[2])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[3] +: OutReg_data[3])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[4] +: OutReg_data[4])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[5] +: OutReg_data[5])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[6] +: OutReg_data[6])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[7] +: OutReg_data[7])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[8] +: OutReg_data[8])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[9] +: OutReg_data[9])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[10] +: OutReg_data[10])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[11] +: OutReg_data[11])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[12] +: OutReg_data[12])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[13] +: OutReg_data[13])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[14] +: OutReg_data[14])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[15] +: OutReg_data[15])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[16] +: OutReg_data[16])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[17] +: OutReg_data[17])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[18] +: OutReg_data[18])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[19] +: OutReg_data[19])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[20] +: OutReg_data[20])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[21] +: OutReg_data[21])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[22] +: OutReg_data[22])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[23] +: OutReg_data[23])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[24] +: OutReg_data[24])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[25] +: OutReg_data[25])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[26] +: OutReg_data[26])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[27] +: OutReg_data[27])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[28] +: OutReg_data[28])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[29] +: OutReg_data[29])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[30] +: OutReg_data[30])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[31] +: OutReg_data[31])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[32] +: OutReg_data[32])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[33] +: OutReg_data[33])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[34] +: OutReg_data[34])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[35] +: OutReg_data[35])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[36] +: OutReg_data[36])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[37] +: OutReg_data[37])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[38] +: OutReg_data[38])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[39] +: OutReg_data[39])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[40] +: OutReg_data[40])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[41] +: OutReg_data[41])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[42] +: OutReg_data[42])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[43] +: OutReg_data[43])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[44] +: OutReg_data[44])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[45] +: OutReg_data[45])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[46] +: OutReg_data[46])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[47] +: OutReg_data[47])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[48] +: OutReg_data[48])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[49] +: OutReg_data[49])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[50] +: OutReg_data[50])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[51] +: OutReg_data[51])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[52] +: OutReg_data[52])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[53] +: OutReg_data[53])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[54] +: OutReg_data[54])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[55] +: OutReg_data[55])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[56] +: OutReg_data[56])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[57] +: OutReg_data[57])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[58] +: OutReg_data[58])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[59] +: OutReg_data[59])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[60] +: OutReg_data[60])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[61] +: OutReg_data[61])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[62] +: OutReg_data[62])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[63] +: OutReg_data[63])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                



if (cond_sdf_taa_sctrlo) 
        (posedge CK *> (SCTRLO :  SCTRLI)) = (taa_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo); 

if (cond_sdf_taa_sctrlo_se) 
        (negedge CK *> (SCTRLO : SCTRLI)) = (taa_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se); 
 

if (cond_sdf_taa_sdlo) 
        (posedge CK *> (SDLO :  SDLI)) = (taa_sdlo,taa_sdlo,th_sdlo,taa_sdlo,th_sdlo,taa_sdlo); 

if (cond_sdf_taa_sdlo_se) 
        (negedge CK *> (SDLO : SDLI)) = (taa_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se);

if (cond_sdf_taa_sdro) 
        (posedge CK *> (SDRO :  SDRI)) = (taa_sdro,taa_sdro,th_sdro,taa_sdro,th_sdro,taa_sdro); 

if (cond_sdf_taa_sdro_se) 
        (negedge CK *> (SDRO : SDRI)) = (taa_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se); 


if (cond_sdf_taa_smlo) 
        (posedge CK *> (SMLO :  SMLI)) = (taa_smlo,taa_smlo,th_smlo,taa_smlo,th_smlo,taa_smlo); 

if (cond_sdf_taa_smlo_se) 
        (negedge CK *> (SMLO : SMLI)) = (taa_smlo_se,taa_smlo_se,th_smlo_se,taa_smlo_se,th_smlo_se,taa_smlo_se);

if (cond_sdf_taa_smro) 
        (posedge CK *> (SMRO :  SMRI)) = (taa_smro,taa_smro,th_smro,taa_smro,th_smro,taa_smro);

if (cond_sdf_taa_smro_se) 
        (negedge CK *> (SMRO : SMRI)) = (taa_smro_se,taa_smro_se,th_smro_se,taa_smro_se,th_smro_se,taa_smro_se);

  
     




endspecify //specify block ends


// conversion from registers to array elements for mask setup violation notifiers 
   
always @(TimingViol_mask_0   or TimingViol_TEM   )
begin
          TimingViol_mask[0]=~TimingViol_mask[0]; 
end

   
always @(TimingViol_mask_1   or TimingViol_TOM   )
begin
          TimingViol_mask[1]=~TimingViol_mask[1]; 
end

   
always @(TimingViol_mask_2   or TimingViol_TEM   )
begin
          TimingViol_mask[2]=~TimingViol_mask[2]; 
end

   
always @(TimingViol_mask_3   or TimingViol_TOM   )
begin
          TimingViol_mask[3]=~TimingViol_mask[3]; 
end

   
always @(TimingViol_mask_4   or TimingViol_TEM   )
begin
          TimingViol_mask[4]=~TimingViol_mask[4]; 
end

   
always @(TimingViol_mask_5   or TimingViol_TOM   )
begin
          TimingViol_mask[5]=~TimingViol_mask[5]; 
end

   
always @(TimingViol_mask_6   or TimingViol_TEM   )
begin
          TimingViol_mask[6]=~TimingViol_mask[6]; 
end

   
always @(TimingViol_mask_7   or TimingViol_TOM   )
begin
          TimingViol_mask[7]=~TimingViol_mask[7]; 
end

   
always @(TimingViol_mask_8   or TimingViol_TEM   )
begin
          TimingViol_mask[8]=~TimingViol_mask[8]; 
end

   
always @(TimingViol_mask_9   or TimingViol_TOM   )
begin
          TimingViol_mask[9]=~TimingViol_mask[9]; 
end

   
always @(TimingViol_mask_10   or TimingViol_TEM   )
begin
          TimingViol_mask[10]=~TimingViol_mask[10]; 
end

   
always @(TimingViol_mask_11   or TimingViol_TOM   )
begin
          TimingViol_mask[11]=~TimingViol_mask[11]; 
end

   
always @(TimingViol_mask_12   or TimingViol_TEM   )
begin
          TimingViol_mask[12]=~TimingViol_mask[12]; 
end

   
always @(TimingViol_mask_13   or TimingViol_TOM   )
begin
          TimingViol_mask[13]=~TimingViol_mask[13]; 
end

   
always @(TimingViol_mask_14   or TimingViol_TEM   )
begin
          TimingViol_mask[14]=~TimingViol_mask[14]; 
end

   
always @(TimingViol_mask_15   or TimingViol_TOM   )
begin
          TimingViol_mask[15]=~TimingViol_mask[15]; 
end

   
always @(TimingViol_mask_16   or TimingViol_TEM   )
begin
          TimingViol_mask[16]=~TimingViol_mask[16]; 
end

   
always @(TimingViol_mask_17   or TimingViol_TOM   )
begin
          TimingViol_mask[17]=~TimingViol_mask[17]; 
end

   
always @(TimingViol_mask_18   or TimingViol_TEM   )
begin
          TimingViol_mask[18]=~TimingViol_mask[18]; 
end

   
always @(TimingViol_mask_19   or TimingViol_TOM   )
begin
          TimingViol_mask[19]=~TimingViol_mask[19]; 
end

   
always @(TimingViol_mask_20   or TimingViol_TEM   )
begin
          TimingViol_mask[20]=~TimingViol_mask[20]; 
end

   
always @(TimingViol_mask_21   or TimingViol_TOM   )
begin
          TimingViol_mask[21]=~TimingViol_mask[21]; 
end

   
always @(TimingViol_mask_22   or TimingViol_TEM   )
begin
          TimingViol_mask[22]=~TimingViol_mask[22]; 
end

   
always @(TimingViol_mask_23   or TimingViol_TOM   )
begin
          TimingViol_mask[23]=~TimingViol_mask[23]; 
end

   
always @(TimingViol_mask_24   or TimingViol_TEM   )
begin
          TimingViol_mask[24]=~TimingViol_mask[24]; 
end

   
always @(TimingViol_mask_25   or TimingViol_TOM   )
begin
          TimingViol_mask[25]=~TimingViol_mask[25]; 
end

   
always @(TimingViol_mask_26   or TimingViol_TEM   )
begin
          TimingViol_mask[26]=~TimingViol_mask[26]; 
end

   
always @(TimingViol_mask_27   or TimingViol_TOM   )
begin
          TimingViol_mask[27]=~TimingViol_mask[27]; 
end

   
always @(TimingViol_mask_28   or TimingViol_TEM   )
begin
          TimingViol_mask[28]=~TimingViol_mask[28]; 
end

   
always @(TimingViol_mask_29   or TimingViol_TOM   )
begin
          TimingViol_mask[29]=~TimingViol_mask[29]; 
end

   
always @(TimingViol_mask_30   or TimingViol_TEM   )
begin
          TimingViol_mask[30]=~TimingViol_mask[30]; 
end

   
always @(TimingViol_mask_31   or TimingViol_TOM   )
begin
          TimingViol_mask[31]=~TimingViol_mask[31]; 
end

   
always @(TimingViol_mask_32   or TimingViol_TEM   )
begin
          TimingViol_mask[32]=~TimingViol_mask[32]; 
end

   
always @(TimingViol_mask_33   or TimingViol_TOM   )
begin
          TimingViol_mask[33]=~TimingViol_mask[33]; 
end

   
always @(TimingViol_mask_34   or TimingViol_TEM   )
begin
          TimingViol_mask[34]=~TimingViol_mask[34]; 
end

   
always @(TimingViol_mask_35   or TimingViol_TOM   )
begin
          TimingViol_mask[35]=~TimingViol_mask[35]; 
end

   
always @(TimingViol_mask_36   or TimingViol_TEM   )
begin
          TimingViol_mask[36]=~TimingViol_mask[36]; 
end

   
always @(TimingViol_mask_37   or TimingViol_TOM   )
begin
          TimingViol_mask[37]=~TimingViol_mask[37]; 
end

   
always @(TimingViol_mask_38   or TimingViol_TEM   )
begin
          TimingViol_mask[38]=~TimingViol_mask[38]; 
end

   
always @(TimingViol_mask_39   or TimingViol_TOM   )
begin
          TimingViol_mask[39]=~TimingViol_mask[39]; 
end

   
always @(TimingViol_mask_40   or TimingViol_TEM   )
begin
          TimingViol_mask[40]=~TimingViol_mask[40]; 
end

   
always @(TimingViol_mask_41   or TimingViol_TOM   )
begin
          TimingViol_mask[41]=~TimingViol_mask[41]; 
end

   
always @(TimingViol_mask_42   or TimingViol_TEM   )
begin
          TimingViol_mask[42]=~TimingViol_mask[42]; 
end

   
always @(TimingViol_mask_43   or TimingViol_TOM   )
begin
          TimingViol_mask[43]=~TimingViol_mask[43]; 
end

   
always @(TimingViol_mask_44   or TimingViol_TEM   )
begin
          TimingViol_mask[44]=~TimingViol_mask[44]; 
end

   
always @(TimingViol_mask_45   or TimingViol_TOM   )
begin
          TimingViol_mask[45]=~TimingViol_mask[45]; 
end

   
always @(TimingViol_mask_46   or TimingViol_TEM   )
begin
          TimingViol_mask[46]=~TimingViol_mask[46]; 
end

   
always @(TimingViol_mask_47   or TimingViol_TOM   )
begin
          TimingViol_mask[47]=~TimingViol_mask[47]; 
end

   
always @(TimingViol_mask_48   or TimingViol_TEM   )
begin
          TimingViol_mask[48]=~TimingViol_mask[48]; 
end

   
always @(TimingViol_mask_49   or TimingViol_TOM   )
begin
          TimingViol_mask[49]=~TimingViol_mask[49]; 
end

   
always @(TimingViol_mask_50   or TimingViol_TEM   )
begin
          TimingViol_mask[50]=~TimingViol_mask[50]; 
end

   
always @(TimingViol_mask_51   or TimingViol_TOM   )
begin
          TimingViol_mask[51]=~TimingViol_mask[51]; 
end

   
always @(TimingViol_mask_52   or TimingViol_TEM   )
begin
          TimingViol_mask[52]=~TimingViol_mask[52]; 
end

   
always @(TimingViol_mask_53   or TimingViol_TOM   )
begin
          TimingViol_mask[53]=~TimingViol_mask[53]; 
end

   
always @(TimingViol_mask_54   or TimingViol_TEM   )
begin
          TimingViol_mask[54]=~TimingViol_mask[54]; 
end

   
always @(TimingViol_mask_55   or TimingViol_TOM   )
begin
          TimingViol_mask[55]=~TimingViol_mask[55]; 
end

   
always @(TimingViol_mask_56   or TimingViol_TEM   )
begin
          TimingViol_mask[56]=~TimingViol_mask[56]; 
end

   
always @(TimingViol_mask_57   or TimingViol_TOM   )
begin
          TimingViol_mask[57]=~TimingViol_mask[57]; 
end

   
always @(TimingViol_mask_58   or TimingViol_TEM   )
begin
          TimingViol_mask[58]=~TimingViol_mask[58]; 
end

   
always @(TimingViol_mask_59   or TimingViol_TOM   )
begin
          TimingViol_mask[59]=~TimingViol_mask[59]; 
end

   
always @(TimingViol_mask_60   or TimingViol_TEM   )
begin
          TimingViol_mask[60]=~TimingViol_mask[60]; 
end

   
always @(TimingViol_mask_61   or TimingViol_TOM   )
begin
          TimingViol_mask[61]=~TimingViol_mask[61]; 
end

   
always @(TimingViol_mask_62   or TimingViol_TEM   )
begin
          TimingViol_mask[62]=~TimingViol_mask[62]; 
end

   
always @(TimingViol_mask_63   or TimingViol_TOM   )
begin
          TimingViol_mask[63]=~TimingViol_mask[63]; 
end






// conversion from registers to array elements for data setup violation notifiers

always @(TimingViol_data_0   or TimingViol_TED  )
begin
        TimingViol_data[0]=~TimingViol_data[0];   
end


always @(TimingViol_data_1   or TimingViol_TOD  )
begin
        TimingViol_data[1]=~TimingViol_data[1];   
end


always @(TimingViol_data_2   or TimingViol_TED  )
begin
        TimingViol_data[2]=~TimingViol_data[2];   
end


always @(TimingViol_data_3   or TimingViol_TOD  )
begin
        TimingViol_data[3]=~TimingViol_data[3];   
end


always @(TimingViol_data_4   or TimingViol_TED  )
begin
        TimingViol_data[4]=~TimingViol_data[4];   
end


always @(TimingViol_data_5   or TimingViol_TOD  )
begin
        TimingViol_data[5]=~TimingViol_data[5];   
end


always @(TimingViol_data_6   or TimingViol_TED  )
begin
        TimingViol_data[6]=~TimingViol_data[6];   
end


always @(TimingViol_data_7   or TimingViol_TOD  )
begin
        TimingViol_data[7]=~TimingViol_data[7];   
end


always @(TimingViol_data_8   or TimingViol_TED  )
begin
        TimingViol_data[8]=~TimingViol_data[8];   
end


always @(TimingViol_data_9   or TimingViol_TOD  )
begin
        TimingViol_data[9]=~TimingViol_data[9];   
end


always @(TimingViol_data_10   or TimingViol_TED  )
begin
        TimingViol_data[10]=~TimingViol_data[10];   
end


always @(TimingViol_data_11   or TimingViol_TOD  )
begin
        TimingViol_data[11]=~TimingViol_data[11];   
end


always @(TimingViol_data_12   or TimingViol_TED  )
begin
        TimingViol_data[12]=~TimingViol_data[12];   
end


always @(TimingViol_data_13   or TimingViol_TOD  )
begin
        TimingViol_data[13]=~TimingViol_data[13];   
end


always @(TimingViol_data_14   or TimingViol_TED  )
begin
        TimingViol_data[14]=~TimingViol_data[14];   
end


always @(TimingViol_data_15   or TimingViol_TOD  )
begin
        TimingViol_data[15]=~TimingViol_data[15];   
end


always @(TimingViol_data_16   or TimingViol_TED  )
begin
        TimingViol_data[16]=~TimingViol_data[16];   
end


always @(TimingViol_data_17   or TimingViol_TOD  )
begin
        TimingViol_data[17]=~TimingViol_data[17];   
end


always @(TimingViol_data_18   or TimingViol_TED  )
begin
        TimingViol_data[18]=~TimingViol_data[18];   
end


always @(TimingViol_data_19   or TimingViol_TOD  )
begin
        TimingViol_data[19]=~TimingViol_data[19];   
end


always @(TimingViol_data_20   or TimingViol_TED  )
begin
        TimingViol_data[20]=~TimingViol_data[20];   
end


always @(TimingViol_data_21   or TimingViol_TOD  )
begin
        TimingViol_data[21]=~TimingViol_data[21];   
end


always @(TimingViol_data_22   or TimingViol_TED  )
begin
        TimingViol_data[22]=~TimingViol_data[22];   
end


always @(TimingViol_data_23   or TimingViol_TOD  )
begin
        TimingViol_data[23]=~TimingViol_data[23];   
end


always @(TimingViol_data_24   or TimingViol_TED  )
begin
        TimingViol_data[24]=~TimingViol_data[24];   
end


always @(TimingViol_data_25   or TimingViol_TOD  )
begin
        TimingViol_data[25]=~TimingViol_data[25];   
end


always @(TimingViol_data_26   or TimingViol_TED  )
begin
        TimingViol_data[26]=~TimingViol_data[26];   
end


always @(TimingViol_data_27   or TimingViol_TOD  )
begin
        TimingViol_data[27]=~TimingViol_data[27];   
end


always @(TimingViol_data_28   or TimingViol_TED  )
begin
        TimingViol_data[28]=~TimingViol_data[28];   
end


always @(TimingViol_data_29   or TimingViol_TOD  )
begin
        TimingViol_data[29]=~TimingViol_data[29];   
end


always @(TimingViol_data_30   or TimingViol_TED  )
begin
        TimingViol_data[30]=~TimingViol_data[30];   
end


always @(TimingViol_data_31   or TimingViol_TOD  )
begin
        TimingViol_data[31]=~TimingViol_data[31];   
end


always @(TimingViol_data_32   or TimingViol_TED  )
begin
        TimingViol_data[32]=~TimingViol_data[32];   
end


always @(TimingViol_data_33   or TimingViol_TOD  )
begin
        TimingViol_data[33]=~TimingViol_data[33];   
end


always @(TimingViol_data_34   or TimingViol_TED  )
begin
        TimingViol_data[34]=~TimingViol_data[34];   
end


always @(TimingViol_data_35   or TimingViol_TOD  )
begin
        TimingViol_data[35]=~TimingViol_data[35];   
end


always @(TimingViol_data_36   or TimingViol_TED  )
begin
        TimingViol_data[36]=~TimingViol_data[36];   
end


always @(TimingViol_data_37   or TimingViol_TOD  )
begin
        TimingViol_data[37]=~TimingViol_data[37];   
end


always @(TimingViol_data_38   or TimingViol_TED  )
begin
        TimingViol_data[38]=~TimingViol_data[38];   
end


always @(TimingViol_data_39   or TimingViol_TOD  )
begin
        TimingViol_data[39]=~TimingViol_data[39];   
end


always @(TimingViol_data_40   or TimingViol_TED  )
begin
        TimingViol_data[40]=~TimingViol_data[40];   
end


always @(TimingViol_data_41   or TimingViol_TOD  )
begin
        TimingViol_data[41]=~TimingViol_data[41];   
end


always @(TimingViol_data_42   or TimingViol_TED  )
begin
        TimingViol_data[42]=~TimingViol_data[42];   
end


always @(TimingViol_data_43   or TimingViol_TOD  )
begin
        TimingViol_data[43]=~TimingViol_data[43];   
end


always @(TimingViol_data_44   or TimingViol_TED  )
begin
        TimingViol_data[44]=~TimingViol_data[44];   
end


always @(TimingViol_data_45   or TimingViol_TOD  )
begin
        TimingViol_data[45]=~TimingViol_data[45];   
end


always @(TimingViol_data_46   or TimingViol_TED  )
begin
        TimingViol_data[46]=~TimingViol_data[46];   
end


always @(TimingViol_data_47   or TimingViol_TOD  )
begin
        TimingViol_data[47]=~TimingViol_data[47];   
end


always @(TimingViol_data_48   or TimingViol_TED  )
begin
        TimingViol_data[48]=~TimingViol_data[48];   
end


always @(TimingViol_data_49   or TimingViol_TOD  )
begin
        TimingViol_data[49]=~TimingViol_data[49];   
end


always @(TimingViol_data_50   or TimingViol_TED  )
begin
        TimingViol_data[50]=~TimingViol_data[50];   
end


always @(TimingViol_data_51   or TimingViol_TOD  )
begin
        TimingViol_data[51]=~TimingViol_data[51];   
end


always @(TimingViol_data_52   or TimingViol_TED  )
begin
        TimingViol_data[52]=~TimingViol_data[52];   
end


always @(TimingViol_data_53   or TimingViol_TOD  )
begin
        TimingViol_data[53]=~TimingViol_data[53];   
end


always @(TimingViol_data_54   or TimingViol_TED  )
begin
        TimingViol_data[54]=~TimingViol_data[54];   
end


always @(TimingViol_data_55   or TimingViol_TOD  )
begin
        TimingViol_data[55]=~TimingViol_data[55];   
end


always @(TimingViol_data_56   or TimingViol_TED  )
begin
        TimingViol_data[56]=~TimingViol_data[56];   
end


always @(TimingViol_data_57   or TimingViol_TOD  )
begin
        TimingViol_data[57]=~TimingViol_data[57];   
end


always @(TimingViol_data_58   or TimingViol_TED  )
begin
        TimingViol_data[58]=~TimingViol_data[58];   
end


always @(TimingViol_data_59   or TimingViol_TOD  )
begin
        TimingViol_data[59]=~TimingViol_data[59];   
end


always @(TimingViol_data_60   or TimingViol_TED  )
begin
        TimingViol_data[60]=~TimingViol_data[60];   
end


always @(TimingViol_data_61   or TimingViol_TOD  )
begin
        TimingViol_data[61]=~TimingViol_data[61];   
end


always @(TimingViol_data_62   or TimingViol_TED  )
begin
        TimingViol_data[62]=~TimingViol_data[62];   
end


always @(TimingViol_data_63   or TimingViol_TOD  )
begin
        TimingViol_data[63]=~TimingViol_data[63];   
end


`endif


// TASK DEFINITION DESCRIPTION
// ================================



task task_insert_faults_in_memory;
begin
   if (reg_ConfigFault)
   begin   
     for(i = 0;i< fcnt;i = i+ 1) begin
        if(mem_red_array_stuck_at[i] === "mem_array") begin
          if (array_stuck_at[i] === "sa0") begin
           `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data & stuck_at_0fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
          `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] & stuck_at_0fault[i];
          `endif
         end //if(array_stuck_at)
                                        
         if(array_stuck_at[i] === "sa1") begin
         `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data | stuck_at_1fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
         `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] | stuck_at_1fault[i]; 
         `endif
         end //if(array_stuck_at)
       end //if mem_red_array_stuck_at
    
    
     end    // end of for
   end  
end
endtask



task task_read_fault_file;
begin
/*  -----------Implemetation for config fault starts------*/
   msgcnt = X;
   t = 0;
   fault_repair_flag = {max_faults{1'b1}};
   repair_flag = {max_faults{1'b1}};
   if(reg_ConfigFault) 
   begin
      file_ptr = $fopen(reg_Fault_file_name , "r");
      if(file_ptr == 0)
      begin     
          if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: File cannot be opened ",$realtime);
      end        
      else                
      begin : read_fault_file
        t = 0;
        for (i = 0; i< max_faults; i= i + 1)
        begin
         
           stuck0 = {Bits{1'b1}};
           stuck1 = {Bits{1'b0}};
           fault_char1 = $fgetc (file_ptr);
           if (fault_char1 == 8'b11111111)
              disable read_fault_file;
           ret_val = $ungetc (fault_char1, file_ptr);
           ret_val = $fgets(tempStr, file_ptr);
           ret_val = $sscanf(tempStr, "%s %d %d %s",fault_array,fault_word, fault_bit, stuck_at) ;
           flag_error = 0; 
           if(ret_val !== 0)
           begin         
              if(ret_val == 3 || ret_val == 4)
              begin
                if(ret_val == 3)
                   stuck_at = "sa0";

                if(stuck_at !== "sa0" && stuck_at !== "sa1" && stuck_at !== "none")
                begin
                    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: Wrong value for stuck at in fault file ",$realtime);
                   flag_error = 1;
                end    
                      
                if(fault_word >= Words)
                begin
                   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Address out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                if(fault_bit >= Bits)
                begin  
                    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Faulty bit out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                
                        
                if(fault_array !== "mem_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array is not mem_array ",$realtime);
                  flag_error = 1;
                end

                if(fault_array === "red_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array can't be on redundancy array in non redundancy cut.",$realtime);
                  flag_error = 1;
                end

                
                

                if(flag_error == 0)
                //Correct Inputs
                begin
                   if(stuck_at === "none")
                   begin
                       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
                   end
                   else
                   //Adding the faults
                   begin
                      FailureLocn[t] = fault_word;
                      Failurebit[t]  = fault_bit ;
                      std_fault_word = fault_word;
                      fault_row_add[t] = std_fault_word[Addr-1:mux_bits];
                      mem_red_array_stuck_at[t] = fault_array;
                      fault_repair_flag[t] = 1'b0;
                      if (stuck_at === "sa0" )
                      begin
                         stuck0[fault_bit] = 1'b0;         
                         stuck_at_0fault[t] = stuck0;
                      end     
                      if (stuck_at === "sa1" )
                      begin
                         stuck1[fault_bit] = 1'b1;
                         stuck_at_1fault[t] = stuck1; 
                      end

                      array_stuck_at[t] = stuck_at;
                      t = t + 1;
                   end //if(stuck_at === "none")  
                end //if(flag_error == 0)
              end //if(ret_val == 2 || ret_val == 3 
              else
              //wrong number of arguments
              begin
                if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: WRONG VALUES ENTERED FOR FAULTY WORD OR FAULTY BIT OR STUCK_AT IN Fault_file_name ",$realtime); 
                flag_error = 1;
              end
           end //if(ret_val !== 0)
           else
           begin 
               if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
           end    
        end //for (i = 0; i< m
      end //begin: read_fault_file  
      $fclose (file_ptr);

      fcnt = t;
      
      //fault injection at time 0.
      task_insert_faults_in_memory;
  end // config_fault 
end
endtask


task WriteMemX;
begin

`ifdef slm
   $slm_ResetMemory(MemAddr, WordX);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = WordX;
   
`endif        
 task_insert_faults_in_memory;
end
endtask

task WriteMem0;
begin
`ifdef slm
   $slm_ResetMemory(MemAddr, Word0);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = Word0;
  
`endif 
   task_insert_faults_in_memory;
end
endtask


task WriteOutX;                
begin
   OutReg_data <= #0 WordX;
end
endtask


task Invalid_next_cycle_func;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_func = 1;
     `else 
       #0 next_cycle_corrupt_func = 0; 
     `endif  
   end 
end
endtask

task Invalid_next_cycle_dft;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_dft = 1;
     `else 
       #0 next_cycle_corrupt_dft = 0; 
     `endif  
  end
end
endtask

task Invalid_next_cycle_func_tim;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
   #0 next_cycle_corrupt_func <= 1;
  end 
end
endtask

task Invalid_next_cycle_dft_tim;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
  #0 next_cycle_corrupt_dft <= 1;
  end
end
endtask


task ScanOutX;                
begin
   
   dff_SCTRLO_SE.Q <= 1'bx;   
   dff_SDLO_SE.Q <= 1'bx; 
   dff_SDRO_SE.Q <= 1'bx; 
   
   dff_SMLO_SE.Q <= 1'bx; 
   dff_SMRO_SE.Q <= 1'bx; 
   
   SCTRLOint=X;
   SDLOint=X;
   SDROint=X;
   
   SMLOint=X;
   SMROint=X;
    
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   SDLO_data<=1'bx;
   SDRO_data<=1'bx;
   
   SMLO_data<=1'bx;
   SMRO_data<=1'bx; 
   `endif
end
endtask

task delScanOutX;                
begin
   delSCTRLO_data<=X;
   delSDLO_data<=X;
   delSDRO_data<=X;
   
   delSMLO_data<=X;
   delSMRO_data<=X;
    
end
endtask

task ScanChainX;                
begin
 scanreg_ctrl=1'bx; 
 scanreg_dl=1'bx; 
 scanreg_dr =1'bx; 
 
 scanreg_ml =1'bx; 
 scanreg_mr=1'bx; 
  
end
endtask

task mem_blocked;
begin
 
   WriteMemX;
   WriteOutX;
   ScanChainX;
   ScanOutX;//immediately;
   delScanOutX;//immediately
   `ifdef POWER_SEQUENCING_OFF
   `else
   reg_mem_block=1;
   `endif
   debug_level = 2'b11;
end
endtask

task corrupt_all;
begin
 
  WriteMemX;
  WriteOutX;
  ScanChainX;
  ScanOutX;
  delScanOutX;//immediately;
  OutReg_data = WordX; 
  delOutReg_data=WordX;
  
end
endtask

task WriteCycle;                  
input [Addr-1 : 0] Address;
reg [Bits-1:0] tempReg1;
reg [Bits-1:0] tempReg_slm;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;


reg repair_flag;

integer po,i,num,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;
begin

   tempReg1 = WordX;
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];

   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};
   
   if (ValidAddress === X )   begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
        WriteMemX;
        if (INITNint !== 0) begin
        `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
           #0 next_cycle_corrupt_func = 1;
       `else 
           #0 next_cycle_corrupt_func = 0; 
       `endif  
   end 

   end


   if (ValidAddress !== X && next_cycle_corrupt_func === 0  )
   begin
         if (red_en === 1 && ((Row_Add_cmp === repair_add) || (Row_Add_cmp === next_repair_add)) ) begin
             repair_flag = 1'b1;
             
             Bank_sel_integer = 0;
                     
             if (Row_Add_cmp === repair_add) begin
               Col_Add_integer  = Col_Add; 
             end
             else if (Row_Add_cmp === next_repair_add) begin
               Col_Add_integer  = Col_Add + mux; 
             end  
             RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
        end  

        if(repair_flag === 0 && ValidAddress === 1) begin
           `ifdef slm
              $slm_ReadMemoryS(MemAddr, Address, tempReg_slm);
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = Mem[Address];
            `endif
          end  
        else if(repair_flag === 1) begin
           `ifdef slm
//              $slm_ReadMemoryS(RedMemAddr, RedMem_address, tempReg_slm);
          
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = RedMem[RedMem_address];
            `endif
        end
        
        for (num=0;num<Bits;num=num+1) begin
             po=num;        
             if ( Dint [num] !== tempReg1 [po]) begin
                if (Mint[num] === 1'b0)
                   tempReg1[po] = Dint[num];
                else if (Mint[num] === 1'bX)
                   tempReg1[po] = 1'bx;
             end                
        end //for (num=0
            
         if(repair_flag === 0 ) begin    
            if(ValidAddress === 1) begin  
              `ifdef slm
                  tempReg_slm=tempReg1; 
                  $slm_WriteMemory(MemAddr, Address, tempReg_slm);
              `else
                   Mem[Address] = tempReg1;
              `endif
            end
            else begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address Out Of Range. ",$realtime);
            end        
         end
         else if (repair_flag === 1 ) begin
            `ifdef slm
                tempReg_slm=tempReg1; 
//                $slm_WriteMemory(RedMemAddr, RedMem_address, tempReg_slm);
            `else
                RedMem[RedMem_address] = tempReg1;
            `endif
         end
   end //if (ValidAddress !== X
   task_insert_faults_in_memory;
end
endtask 

task ReadCycle;
input [Addr-1 : 0] Address;

reg [Bits-1:0] MemData_tmp;
reg [Bits-1:0] MemData;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;

reg repair_flag;

integer a,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;

begin
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];
   
   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};

   

   if (ValidAddress !== X && next_cycle_corrupt_func === 0 ) begin   
       if(red_en === 1 && ( Row_Add_cmp === repair_add ||  Row_Add_cmp === next_repair_add )) begin
              repair_flag = 1;
              
              Bank_sel_integer = 0;
               
              if(Row_Add_cmp === repair_add) begin
                Col_Add_integer = Col_Add;
              end
              else if (Row_Add_cmp === next_repair_add) begin
                Col_Add_integer = Col_Add + mux; 
              end
              RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
       end

      if(repair_flag === 0) begin
          if(ValidAddress === 1) begin 
           `ifdef slm
              $slm_ReadMemory(MemAddr, Address, MemData);
           `else
              MemData = Mem[Address];
           `endif
          end
          else begin
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Address Out Of Range. Output Corrupted ",$realtime);
             MemData = WordX;
          end
     end
      else if(repair_flag === 1) begin
        `ifdef slm
//           $slm_ReadMemory(RedMemAddr, RedMem_address, MemData);
        `else
           MemData = RedMem[RedMem_address];
        `endif
      end
   end //if (ValidAddress)  
   
   if(ValidAddress === X)
   begin
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Illegal Value on Address Bus. Memory and Output Corrupted ",$realtime); 
         Invalid_next_cycle_func;
   end 
   
  if(ValidAddress !== X && next_cycle_corrupt_func === 0 )
   begin
   for (a = 0; a < Bits; a = a + 1)
   begin
      if (MemData[a] !== OutReg_data[a])
         OutReg_data[a] = WordX[a];
   end//for (a = 0; a <  
         OutReg_data <= MemData;
   end     
end
endtask



// SCAN CHAINS
supply0 gnd;
buf (A_int[0], Aint[0]);
buf (A_int[1], Aint[1]);
buf (A_int[2], Aint[2]);
buf (A_int[3], Aint[3]);
buf (A_int[4], Aint[4]);
buf (A_int[5], Aint[5]);                  //used for capturing
buf (A_int[6], gnd);
buf (A_int[7], gnd);
buf (A_int[8], gnd);
buf (A_int[9], gnd);
buf (A_int[10], gnd);
buf (A_int[11], gnd);
buf (A_int[12], gnd);
buf (A_int[13], gnd);
buf (A_int[14], gnd);   //used for capturing

buf (WEN_int, WENint);
buf (CSN_int, CSNint);
buf (IG_int, IGint);


// Scan flops



// CONTROL SCAN CHAIN
     ST_SPREG_LOLEAK_64x64m2_bTl_SCFF cntrl_scff_0 (.D(1'b0), .TI(SCTRLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[0]), .OUTX(scanreg_ctrl));

      
 ST_SPREG_LOLEAK_64x64m2_bTl_SCFF cntrl_scff_1 (.D(A_int[2]), .TI(scanreg_ctrl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[1]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m2_bTl_SCFF cntrl_scff_2 (.D(A_int[4]), .TI(scanreg_ctrl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[2]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m2_bTl_SCFF cntrl_scff_3 (.D(A_int[7]), .TI(scanreg_ctrl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[3]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m2_bTl_SCFF cntrl_scff_4 (.D(A_int[1]), .TI(scanreg_ctrl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[4]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m2_bTl_SCFF cntrl_scff_5 (.D(A_int[9]), .TI(scanreg_ctrl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[5]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m2_bTl_SCFF cntrl_scff_6 (.D(A_int[8]), .TI(scanreg_ctrl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[6]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m2_bTl_SCFF cntrl_scff_7 (.D(1'b0), .TI(scanreg_ctrl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[7]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m2_bTl_SCFF cntrl_scff_8 (.D(A_int[0]), .TI(scanreg_ctrl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[8]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m2_bTl_SCFF cntrl_scff_9 (.D(A_int[3]), .TI(scanreg_ctrl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[9]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m2_bTl_SCFF cntrl_scff_10 (.D(A_int[5]), .TI(scanreg_ctrl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[10]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m2_bTl_SCFF cntrl_scff_11 (.D(CSN_int), .TI(scanreg_ctrl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[11]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m2_bTl_SCFF cntrl_scff_12 (.D(A_int[6]), .TI(scanreg_ctrl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[12]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m2_bTl_SCFF cntrl_scff_13 (.D(WEN_int), .TI(scanreg_ctrl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[13]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m2_bTl_SCFF cntrl_scff_14 (.D(scanreg_ctrl_wire[14]), .TI(scanreg_ctrl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[14]), .OUTX(scanreg_ctrl));  

reg LP_CK_gate;

// Lock Up Latch
wire SCTRLO_temp;
 ST_SPREG_LOLEAK_64x64m2_bTl_lock_up_latch  dff_SCTRLO_SE (Latch_open, scanreg_ctrl_wire[14], SCTRLO_temp);

always @(SCTRLO_temp) begin
     SCTRLOint= SCTRLO_temp;
 `ifdef functional
 `else
 if (SCTRLOint !== SCTRLO_data) begin 
  if (SCTRLOint !==X)
   SCTRLO_data=1'bx;
   SCTRLO_data <= SCTRLOint;
 end 
 `endif
end  


// LEFT DATA SCAN CHAIN
     ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_0 (.D(Dint[31]), .TI(SDLI), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[0]), .OUTX(scanreg_dl));
      
   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_1 (.D(Dint[30]), .TI(scanreg_dl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[1]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_2 (.D(Dint[29]), .TI(scanreg_dl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[2]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_3 (.D(Dint[28]), .TI(scanreg_dl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[3]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_4 (.D(Dint[27]), .TI(scanreg_dl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[4]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_5 (.D(Dint[26]), .TI(scanreg_dl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[5]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_6 (.D(Dint[25]), .TI(scanreg_dl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[6]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_7 (.D(Dint[24]), .TI(scanreg_dl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[7]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_8 (.D(Dint[23]), .TI(scanreg_dl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[8]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_9 (.D(Dint[22]), .TI(scanreg_dl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[9]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_10 (.D(Dint[21]), .TI(scanreg_dl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[10]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_11 (.D(Dint[20]), .TI(scanreg_dl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[11]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_12 (.D(Dint[19]), .TI(scanreg_dl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[12]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_13 (.D(Dint[18]), .TI(scanreg_dl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[13]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_14 (.D(Dint[17]), .TI(scanreg_dl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[14]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_15 (.D(Dint[16]), .TI(scanreg_dl_wire[14]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[15]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_16 (.D(Dint[15]), .TI(scanreg_dl_wire[15]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[16]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_17 (.D(Dint[14]), .TI(scanreg_dl_wire[16]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[17]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_18 (.D(Dint[13]), .TI(scanreg_dl_wire[17]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[18]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_19 (.D(Dint[12]), .TI(scanreg_dl_wire[18]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[19]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_20 (.D(Dint[11]), .TI(scanreg_dl_wire[19]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[20]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_21 (.D(Dint[10]), .TI(scanreg_dl_wire[20]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[21]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_22 (.D(Dint[9]), .TI(scanreg_dl_wire[21]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[22]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_23 (.D(Dint[8]), .TI(scanreg_dl_wire[22]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[23]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_24 (.D(Dint[7]), .TI(scanreg_dl_wire[23]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[24]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_25 (.D(Dint[6]), .TI(scanreg_dl_wire[24]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[25]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_26 (.D(Dint[5]), .TI(scanreg_dl_wire[25]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[26]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_27 (.D(Dint[4]), .TI(scanreg_dl_wire[26]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[27]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_28 (.D(Dint[3]), .TI(scanreg_dl_wire[27]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[28]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_29 (.D(Dint[2]), .TI(scanreg_dl_wire[28]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[29]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_30 (.D(Dint[1]), .TI(scanreg_dl_wire[29]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[30]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF ldata_scff_31 (.D(Dint[0]), .TI(scanreg_dl_wire[30]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[31]), .OUTX(scanreg_dl));



// Lock Up Latch
wire SDLO_temp;
 ST_SPREG_LOLEAK_64x64m2_bTl_lock_up_latch  dff_SDLO_SE (Latch_open, scanreg_dl_wire[31], SDLO_temp);

always @(SDLO_temp) begin
     SDLOint= SDLO_temp;
 `ifdef functional
 `else
 if (SDLOint !== SDLO_data) begin 
  if (SDLOint !==X)
   SDLO_data=1'bx;
   SDLO_data <= SDLOint;
 end 
 `endif
end  






// RIGHT DATA SCAN CHAIN

     ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_0 (.D(Dint[63]), .TI(SDRI), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[0]), .OUTX(scanreg_dr));
     
 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_1 (.D(Dint[62]), .TI(scanreg_dr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[1]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_2 (.D(Dint[61]), .TI(scanreg_dr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[2]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_3 (.D(Dint[60]), .TI(scanreg_dr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[3]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_4 (.D(Dint[59]), .TI(scanreg_dr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[4]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_5 (.D(Dint[58]), .TI(scanreg_dr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[5]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_6 (.D(Dint[57]), .TI(scanreg_dr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[6]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_7 (.D(Dint[56]), .TI(scanreg_dr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[7]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_8 (.D(Dint[55]), .TI(scanreg_dr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[8]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_9 (.D(Dint[54]), .TI(scanreg_dr_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[9]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_10 (.D(Dint[53]), .TI(scanreg_dr_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[10]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_11 (.D(Dint[52]), .TI(scanreg_dr_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[11]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_12 (.D(Dint[51]), .TI(scanreg_dr_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[12]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_13 (.D(Dint[50]), .TI(scanreg_dr_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[13]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_14 (.D(Dint[49]), .TI(scanreg_dr_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[14]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_15 (.D(Dint[48]), .TI(scanreg_dr_wire[14]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[15]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_16 (.D(Dint[47]), .TI(scanreg_dr_wire[15]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[16]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_17 (.D(Dint[46]), .TI(scanreg_dr_wire[16]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[17]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_18 (.D(Dint[45]), .TI(scanreg_dr_wire[17]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[18]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_19 (.D(Dint[44]), .TI(scanreg_dr_wire[18]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[19]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_20 (.D(Dint[43]), .TI(scanreg_dr_wire[19]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[20]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_21 (.D(Dint[42]), .TI(scanreg_dr_wire[20]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[21]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_22 (.D(Dint[41]), .TI(scanreg_dr_wire[21]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[22]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_23 (.D(Dint[40]), .TI(scanreg_dr_wire[22]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[23]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_24 (.D(Dint[39]), .TI(scanreg_dr_wire[23]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[24]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_25 (.D(Dint[38]), .TI(scanreg_dr_wire[24]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[25]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_26 (.D(Dint[37]), .TI(scanreg_dr_wire[25]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[26]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_27 (.D(Dint[36]), .TI(scanreg_dr_wire[26]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[27]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_28 (.D(Dint[35]), .TI(scanreg_dr_wire[27]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[28]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_29 (.D(Dint[34]), .TI(scanreg_dr_wire[28]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[29]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_30 (.D(Dint[33]), .TI(scanreg_dr_wire[29]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[30]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rdata_scff_31 (.D(Dint[32]), .TI(scanreg_dr_wire[30]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[31]), .OUTX(scanreg_dr)); 


// Lock Up Latch
wire SDRO_temp;
 ST_SPREG_LOLEAK_64x64m2_bTl_lock_up_latch  dff_SDRO_SE (Latch_open, scanreg_dr_wire[31], SDRO_temp);


always @(SDRO_temp) begin
     SDROint= SDRO_temp;
 `ifdef functional
 `else
 if (SDROint !== SDRO_data) begin 
  if (SDROint !==X)
   SDRO_data=1'bx;
   SDRO_data <= SDROint;
 end 
 `endif
end




// LEFT MASK SCAN CHAIN
     ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_0 (.D(Mint[31]), .TI(SMLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[0]), .OUTX(scanreg_ml));
     


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_1 (.D(Mint[30]), .TI(scanreg_ml_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[1]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_2 (.D(Mint[29]), .TI(scanreg_ml_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[2]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_3 (.D(Mint[28]), .TI(scanreg_ml_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[3]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_4 (.D(Mint[27]), .TI(scanreg_ml_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[4]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_5 (.D(Mint[26]), .TI(scanreg_ml_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[5]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_6 (.D(Mint[25]), .TI(scanreg_ml_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[6]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_7 (.D(Mint[24]), .TI(scanreg_ml_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[7]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_8 (.D(Mint[23]), .TI(scanreg_ml_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[8]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_9 (.D(Mint[22]), .TI(scanreg_ml_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[9]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_10 (.D(Mint[21]), .TI(scanreg_ml_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[10]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_11 (.D(Mint[20]), .TI(scanreg_ml_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[11]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_12 (.D(Mint[19]), .TI(scanreg_ml_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[12]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_13 (.D(Mint[18]), .TI(scanreg_ml_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[13]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_14 (.D(Mint[17]), .TI(scanreg_ml_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[14]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_15 (.D(Mint[16]), .TI(scanreg_ml_wire[14]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[15]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_16 (.D(Mint[15]), .TI(scanreg_ml_wire[15]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[16]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_17 (.D(Mint[14]), .TI(scanreg_ml_wire[16]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[17]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_18 (.D(Mint[13]), .TI(scanreg_ml_wire[17]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[18]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_19 (.D(Mint[12]), .TI(scanreg_ml_wire[18]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[19]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_20 (.D(Mint[11]), .TI(scanreg_ml_wire[19]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[20]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_21 (.D(Mint[10]), .TI(scanreg_ml_wire[20]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[21]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_22 (.D(Mint[9]), .TI(scanreg_ml_wire[21]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[22]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_23 (.D(Mint[8]), .TI(scanreg_ml_wire[22]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[23]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_24 (.D(Mint[7]), .TI(scanreg_ml_wire[23]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[24]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_25 (.D(Mint[6]), .TI(scanreg_ml_wire[24]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[25]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_26 (.D(Mint[5]), .TI(scanreg_ml_wire[25]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[26]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_27 (.D(Mint[4]), .TI(scanreg_ml_wire[26]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[27]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_28 (.D(Mint[3]), .TI(scanreg_ml_wire[27]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[28]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_29 (.D(Mint[2]), .TI(scanreg_ml_wire[28]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[29]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_30 (.D(Mint[1]), .TI(scanreg_ml_wire[29]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[30]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m2_bTl_SCFF lmask_scff_31 (.D(Mint[0]), .TI(scanreg_ml_wire[30]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[31]), .OUTX(scanreg_ml));  
        

// Lock Up Latch
wire SMLO_temp;
 ST_SPREG_LOLEAK_64x64m2_bTl_lock_up_latch  dff_SMLO_SE (Latch_open, scanreg_ml_wire[31], SMLO_temp);

always @(SMLO_temp) begin
     SMLOint= SMLO_temp;
 `ifdef functional
 `else
 if (SMLOint !== SMLO_data) begin 
  if (SMLOint !==X)
   SMLO_data=1'bx;
   SMLO_data <= SMLOint;
 end 
 `endif
end  






// RIGHT MASK SCAN CHAIN

     ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_0 (.D(Mint[63]), .TI(SMRI), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[0]), .OUTX(scanreg_mr));
     
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_1 (.D(Mint[62]), .TI(scanreg_mr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[1]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_2 (.D(Mint[61]), .TI(scanreg_mr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[2]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_3 (.D(Mint[60]), .TI(scanreg_mr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[3]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_4 (.D(Mint[59]), .TI(scanreg_mr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[4]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_5 (.D(Mint[58]), .TI(scanreg_mr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[5]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_6 (.D(Mint[57]), .TI(scanreg_mr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[6]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_7 (.D(Mint[56]), .TI(scanreg_mr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[7]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_8 (.D(Mint[55]), .TI(scanreg_mr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[8]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_9 (.D(Mint[54]), .TI(scanreg_mr_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[9]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_10 (.D(Mint[53]), .TI(scanreg_mr_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[10]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_11 (.D(Mint[52]), .TI(scanreg_mr_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[11]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_12 (.D(Mint[51]), .TI(scanreg_mr_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[12]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_13 (.D(Mint[50]), .TI(scanreg_mr_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[13]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_14 (.D(Mint[49]), .TI(scanreg_mr_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[14]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_15 (.D(Mint[48]), .TI(scanreg_mr_wire[14]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[15]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_16 (.D(Mint[47]), .TI(scanreg_mr_wire[15]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[16]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_17 (.D(Mint[46]), .TI(scanreg_mr_wire[16]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[17]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_18 (.D(Mint[45]), .TI(scanreg_mr_wire[17]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[18]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_19 (.D(Mint[44]), .TI(scanreg_mr_wire[18]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[19]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_20 (.D(Mint[43]), .TI(scanreg_mr_wire[19]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[20]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_21 (.D(Mint[42]), .TI(scanreg_mr_wire[20]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[21]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_22 (.D(Mint[41]), .TI(scanreg_mr_wire[21]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[22]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_23 (.D(Mint[40]), .TI(scanreg_mr_wire[22]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[23]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_24 (.D(Mint[39]), .TI(scanreg_mr_wire[23]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[24]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_25 (.D(Mint[38]), .TI(scanreg_mr_wire[24]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[25]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_26 (.D(Mint[37]), .TI(scanreg_mr_wire[25]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[26]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_27 (.D(Mint[36]), .TI(scanreg_mr_wire[26]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[27]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_28 (.D(Mint[35]), .TI(scanreg_mr_wire[27]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[28]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_29 (.D(Mint[34]), .TI(scanreg_mr_wire[28]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[29]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_30 (.D(Mint[33]), .TI(scanreg_mr_wire[29]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[30]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m2_bTl_SCFF rmask_scff_31 (.D(Mint[32]), .TI(scanreg_mr_wire[30]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[31]), .OUTX(scanreg_mr));    

// Lock Up Latch
wire SMRO_temp;
 ST_SPREG_LOLEAK_64x64m2_bTl_lock_up_latch  dff_SMRO_SE (Latch_open, scanreg_mr_wire[31], SMRO_temp);


always @(SMRO_temp) begin
     SMROint= SMRO_temp;
 `ifdef functional
 `else
 if (SMROint !== SMRO_data) begin 
  if (SMROint !==X)
   SMRO_data=1'bx;
   SMRO_data <= SMROint;
 end 
 `endif
end





//


 //////// CAPTURE TASK //////
task scan_acquire;
begin
   if (supply_ok === 1) begin 
      if ( SEsys === 0 && ((LP_CK_gate === 0 && TBYPASSsys !== 1'bx)|| TBYPASSsys===0)) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;

         scanreg_mr=1'b0;
         scanreg_ml=1'b0;
                    
         Latch_open=1;
         

      end //if ( SEint === 0
   end//if(supply_ok 
end
endtask

task scan_shift;
begin
 if (supply_ok === 1) begin
   if (STDBYint === 0 && SLEEPint === 0) begin
      if (CKint_dft === X && INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0) begin
         ScanChainX;
         ScanOutX;
      end
      else if (CKint_dft === 1 && lastCK_dft === 0 ) begin
          //// SHIFT
        if (SEsys === 1) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
           
          scanreg_mr=1'b0;
         scanreg_ml=1'b0;
           
        //// SHIFT Ends
        end //if (SEsys === 1
        else if (SEsys === X) begin
            ScanChainX;
            ScanOutX;
            delScanOutX;
        end//if (SEint ==X
      
      end///if (CKint === 
    
      else if (CKint_dft === 0 && lastCK_dft === 1 ) begin
        Latch_open=1;
      end
    end  //if (STDByint === 0 && SLEEPint === 0
 end//if(supply_ok
end
endtask






// BEHAVIOURAL MODULE DESCRIPTION
// ================================

initial
begin
  // Define format for timing value
  $timeformat (-9, 3, " ns", 0);
  `ifdef slm
  $slm_RegisterMemory(MemAddr, Words, Bits);
  `endif   
   reg_mem_block=0;
   flag_mem_block=0;
  `ifdef functional
  `else
   TimingViol_data=0;
   TimingViol_mask=0;
   `endif
   decoding_start=0;
  
   //Parameter Assignment
   
   reg_Fault_file_name = Fault_file_name; 
   reg_ConfigFault     = ConfigFault;
   reg_MEM_INITIALIZE  = MEM_INITIALIZE;
   reg_BinaryInit      = BinaryInit;
   reg_InitFileName    = InitFileName;
   reg_Initn_reset_value = Initn_reset_value;
   reg_File_load_time    = File_load_time;

   time_fall_sleep=0;
   time_fall_PSWLARGEMP=0;
   time_fall_PSWLARGEMP_0=0;
   time_fall_PSWLARGEMA=0;
   time_fall_PSWLARGEMA_0=0;
   time_fall_PSWSMALLMP=0;
   time_fall_PSWSMALLMA=0;

   vddmp_rise_time=0;
   vddmp_fall_time=0;
   vddsmp_rise_time=0;
   vddsmp_fall_time=0;
   vddma_rise_time=0;
   vddma_fall_time=0;
   vddsma_rise_time=0;
   vddsma_fall_time=0;
   vddm_fall_time=0;  
   vddm_rise_time=0;  
   vddsm_fall_time=0; 
   vddsm_rise_time=0;

   next_cycle_corrupt_func=0;
   next_cycle_corrupt_dft=0;
   init_pulse_done = 0;
   power_up_done = 0;
   file_loaded=1;
   debug_level= 2'b01;
   message_status = "ONLY WARNINGS/ERRORS are Switched ON.For INFO also use debug_level=2'b00";
  `ifdef  NO_WARNING_MODE
     debug_level = 2'b11;
     message_status = "All Warning/Errors/Info Messages are Switched OFF";
  `endif  
  `ifdef  ONLY_ERROR_MODE
     debug_level = 2'b10;
     message_status = "All Warning/Info Messages are Switched OFF.Errors are switched on";
  `endif 
  `ifdef  ALL_MSG_MODE
     debug_level = 2'b00;
     message_status = "All Messages are Switched ON";
  `endif 
  
  `ifdef slm
     operating_mode = "SLM";
   `else
      `ifdef functional
         operating_mode = "FUNCTIONAL";
       `else
         operating_mode = "TIMING";
      `endif
   `endif   
  
  if (debug_level < 1) begin
  $display ("%m INFORMATION ");
  $display ("***************************************");
  $display ("The Model is Operating in %s MODE", operating_mode);
  $display ("%s", message_status);
  if(reg_ConfigFault)
  $display ("Configurable Fault Functionality is ON");   
  else
  $display ("Configurable Fault Functionality is OFF");   
  $display("Fault File used by the model Fault_File_Name=%s" ,reg_Fault_file_name);
  $display("Values of Config_fault used in model=%d" ,reg_ConfigFault);
  $display("Values of Mem_INITALIZE used in model=%d" ,reg_MEM_INITIALIZE);
  $display("Values of BinaryInit used in model=%d" ,reg_BinaryInit);
  $display("Values of InitFileName used in model=%s" ,reg_InitFileName);
  $display("Values of Initn_reset_value used in model=%d" ,reg_Initn_reset_value);
  $display("Values of File_load_time used in model=%t" ,reg_File_load_time);

  $display ("***************************************");
  end
     
  task_read_fault_file; 
   if(!INITNint) begin
    if(supply_ok ) begin 
      init_pulse_done = 1;
      power_up_done = 1;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif 
    end 
   end 
        
   lastCK_func = CKint_func;
   lastCK_dft = CKint_dft;

 `ifdef MEM_CONTENTS_SLEEP
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","w");
   $fclose(ptr);
 `endif 

   
end  // initial block ends



//+++++++++++++++++++++++++++++++ CONFIG FAULT IMPLEMETATION ENDS+++++++++++++++++++++++++++++++//
        




//INITN block starts
//================================
always @(INITNint  or supply_ok )
begin
 if (INITNint === 1'b0) begin
   if(supply_ok) begin
     init_pulse_done = 1;
     power_up_done = 1;
     lastCK_func=CKint_func;
     lastCK_dft=CKint_dft;
     next_cycle_corrupt_func = 0;
     next_cycle_corrupt_dft = 0;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif     
   end 
 end        

 if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && INITNint !== 1)
   begin
     ScanOutX;
     ScanChainX;
     delScanOutX;
   end  
         
 if (init_pulse_done === 0 && INITNint !== 0) begin
     if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) INFO: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
 end
 
end//always @(INITNint)


// Clock Generation 
//wire gated_clock;
//wire clock_gate_en;
//ST_SPREG_LOLEAK_64x64m2_bTl_lock_up_latch CK_SE_latch (!CK , SE, SE_latch_CK);
//and (clock_gate_en, ATP, TBYPASS, !SE_latch_CK);

//ST_SPREG_LOLEAK_64x64m2_bTl_lock_up_latch LP_latch (!CK , scanreg_ctrl_wire[14], LP_latch_CK);
//and (gated_clock,CK,!LP_latch_CK);
//assign CK_new= clock_gate_en ===0 ? CK : (clock_gate_en ===1 ? gated_clock: (CK===0) ? 0 :1'bx);


// Clock Generation Ends


// Functional CK block starts
//======================================
always @(CKint_func)
begin
   lastCK_func=CKreg_func;  
   CKreg_func=CKint_func;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
        if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
      if (CKreg_func === 1'bX || (CKreg_func === 1'b1 && lastCK_func === 1'bx)) begin
        if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
         
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
         Invalid_next_cycle_func;
        end
      end
      else if (CKreg_func === 1'b1 && lastCK_func === 1'b0 ) begin
        time_CK_func_rise=$realtime;
        MEMEN_prev = MEMEN_reg;
        MEMEN_reg = MEMEN;
        CSNreg = CSNint;
        IGreg = IGint;
        DEreg = DEint;
        SE_reg = SEsys;
        TBYPASS_reg = TBYPASSsys;
        ATPreg = ATPint;
        INITNreg = INITNint;
        SLEEPreg = SLEEPint;
        STDBYreg = STDBYint;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 

    `ifdef functional
    `else
        Mem_last=Mem[Aint];
    `endif 
        if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.INITN pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SLEEP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.STANDBY pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg === X && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.chip select  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg === X && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.IG pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg === X && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.Debug pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg === X && (SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.ATP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg === X && TBYPASS_reg !== 1) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SE pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg !== 1 && TBYPASS_reg === X) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.TBYPASS pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end

        else if ((INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0))) && WENint === X) begin
            // Uncertain write cycle
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: write enable going to X  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end 
        else if (next_cycle_corrupt_func === 1) begin
          next_cycle_corrupt_func = X;
        end
        else if (next_cycle_corrupt_func === 1'bx) begin
          next_cycle_corrupt_func = 0;
        end 
        
//        if (next_cycle_corrupt_func === 0 ) begin 
         
          /*---------------------- File initialization -----------------*/
          
          if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0)) && flag_mem_block === 1'b0) begin
                 Areg=Aint;
                 Dreg=Dint;
                 Mreg=Mint;
                 WENreg=WENint;     
             if (reg_MEM_INITIALIZE === 1'b1 && $realtime >= reg_File_load_time && file_loaded ) begin   
                `ifdef slm
                  if (reg_BinaryInit)
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_BIN");
                  else
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_HEX");
   
                `else
                  if (reg_BinaryInit)
                     $readmemb(reg_InitFileName, Mem, 0, Words-1);
                  else
                     $readmemh(reg_InitFileName, Mem, 0, Words-1);
                `endif
                 file_loaded = 0;
             end
   
             if (^Aint === X)
               ValidAddress = X;
             else if (Aint < Words)
               ValidAddress = 1;
             else    
               ValidAddress = 0;
   
             if(red_en === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Redundancy Enable is Invalid. Either RRAE is X or TRRAE is X",$realtime);
                ValidAddress = X; 
           end
           else if(red_en === 1'b1 && ^repair_add === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Repair Address is invalid.RRA is X",$realtime);
                ValidAddress = X;
           end
             
             if (ValidAddress)
               `ifdef slm
                   $slm_ReadMemoryS(MemAddr, Aint, Mem_temp);
               `else
                    Mem_temp = Mem[Aint];
               `endif
             else
                Mem_temp = WordX;  
          
     /*---------------------- Normal Read and Write -----------------*/
     
             if (WENint === 1) begin
               ReadCycle(Aint);
             end
       
             else if (WENint === 0) begin
               WriteCycle(Aint);
             end 
                
          
          end //  if (MEMEN === 1'b1 
       
//        end  // if (next_cycle_corrupt_func === 0
      
      end // if (CKint = 1   
   end // if (init_pulse_done === 1           
 end 
end // always @(CKint_func)
        
always @(MEMEN)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) && CKint_func === 1'bx) begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.clock pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
    Invalid_next_cycle_func;
  end
 end 
end

// DFT CK block starts
//======================================
always @(CKint_dft) 
begin
   lastCK_dft=CKreg_dft;
   CKreg_dft=CKint_dft;
   
   Latch_open=0;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
     if (CKreg_dft === 1'bX || (CKreg_dft === 1'b1 && lastCK_dft === 1'bx)) begin
       if (INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0 ) begin
        
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: DFT clock  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime); 
         Invalid_next_cycle_dft;
         if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
           WriteOutX;
         end
       end
     end 

     if(CKint_dft === 0 && lastCK_dft === 1) begin
      if(ATPreg === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
       if(SE_reg === 1'b1 && SEsys === 1'b0) begin
        if(TBYPASSint === 1'b1) begin   
            
            
    OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],
scanreg_dr_wire[10],
scanreg_dr_wire[11],
scanreg_dr_wire[12],
scanreg_dr_wire[13],
scanreg_dr_wire[14],
scanreg_dr_wire[15],
scanreg_dr_wire[16],
scanreg_dr_wire[17],
scanreg_dr_wire[18],
scanreg_dr_wire[19],
scanreg_dr_wire[20],
scanreg_dr_wire[21],
scanreg_dr_wire[22],
scanreg_dr_wire[23],
scanreg_dr_wire[24],
scanreg_dr_wire[25],
scanreg_dr_wire[26],
scanreg_dr_wire[27],
scanreg_dr_wire[28],
scanreg_dr_wire[29],
scanreg_dr_wire[30],
scanreg_dr_wire[31],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9],
scanreg_dl_wire[10],
scanreg_dl_wire[11],
scanreg_dl_wire[12],
scanreg_dl_wire[13],
scanreg_dl_wire[14],
scanreg_dl_wire[15],
scanreg_dl_wire[16],
scanreg_dl_wire[17],
scanreg_dl_wire[18],
scanreg_dl_wire[19],
scanreg_dl_wire[20],
scanreg_dl_wire[21],
scanreg_dl_wire[22],
scanreg_dl_wire[23],
scanreg_dl_wire[24],
scanreg_dl_wire[25],
scanreg_dl_wire[26],
scanreg_dl_wire[27],
scanreg_dl_wire[28],
scanreg_dl_wire[29],
scanreg_dl_wire[30], scanreg_dl_wire[scanlen_l-1]}; 
 
         for (i = 0; i < Bits; i = i + 1)
         begin
          if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
         end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
        end 
       end
      end
     end 
     
     else if (CKreg_dft === 1'b1 && lastCK_dft === 1'b0 ) begin
       SE_reg = SEsys;
       TBYPASS_reg = TBYPASSsys;
       ATPreg = ATPint;
       INITNreg = INITNint;
       SLEEPreg = SLEEPint;
       STDBYreg = STDBYint;
       MEMEN_dft_prev = MEMEN_dft_reg;
       MEMEN_dft_reg = MEMEN_dft;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 
       if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ) begin 
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
 //     else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys === X && TBYPASSsys !== 1) begin
///           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
//           Invalid_next_cycle_dft;
//        end       
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys === X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
        end 
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys !== 0 && LP_CK_gate===X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: LP FLOP Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           ScanChainX;
           ScanOutX;   
          if( TBYPASSint !== 0 && SEint !== 1) begin
            WriteOutX;
          end
          next_cycle_corrupt_dft=0;
        end        
       else if (next_cycle_corrupt_dft === 1'b1) begin 
         next_cycle_corrupt_dft = X;
       end 
       else if (next_cycle_corrupt_dft === 1'bx) begin
         next_cycle_corrupt_dft = 0;
       end
       
       if (next_cycle_corrupt_dft === 0 ) begin
         
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1 && flag_mem_block === 1'b0) begin
           
           if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0  && LP_CK_gate===0) begin
              OutReg_data_tbypass = Dint;
              for (i = 0; i < Bits; i = i + 1)
              begin
               if (OutReg_data_tbypass[i] !== OutReg_data[i])
                 OutReg_data[i] = WordX[i];
              end//for (i = 0; i < */ 
              OutReg_data <= OutReg_data_tbypass;
           end
           
             scan_acquire;
         end //MEMEN_dft == 1        
       end // if ( next_cycle_corrupt_dft
       
     end // if (CKint_dft === 1'b1
      //  if (next_cycle_corrupt_dft === 0 ) begin 
       if (SE_reg !== 0) begin
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1  && flag_mem_block === 1'b0) begin
           next_cycle_corrupt_dft = 0;
           if ( next_cycle_corrupt_func === 1) begin
	    next_cycle_corrupt_func = 0 ;
	   end	
           scan_shift;
         end
       end
     //end // if ( next_cycle_corrupt_dft    
     if ((!(TBYPASSsys!==0 && SEsys!==1 && LP_CK_gate!==0 ) && next_cycle_corrupt_dft === 0) || CKint_dft !==1) begin          
       CK_sc=INITNreg & !STDBYreg & !SLEEPreg & ATPreg & CKreg_dft ;
     end     
   end // if (init_pulse_done 
 end // if (supply_ok 
end // always @(CKint_dft)

always @(MEMEN_dft)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) && CKint_dft === 1'bx)  begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.MEMEN_dft and clock should not be X at this time instant. ScanChains and ScanOuts Corrupted ",$realtime); 
    Invalid_next_cycle_dft;
    
    if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
      WriteOutX;
    end
  end
  if ( MEMEN_dft !== 0 && TBYPASSsys !== 0 && SEsys !== 1) begin
     WriteOutX;
     OutReg_data = WordX; 
     delOutReg_data=WordX;
 end 
end
end //always @(MEMEN_dft

always @(TBYPASSsys or ATPint)
begin
   if(supply_ok === 1'b1) begin 
    if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0 && INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1) begin
      if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
    end  
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint === X && SEsys !== 1) ) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end 
end //always @(TBYPASSint





always @(SEsys)
begin
 if(supply_ok === 1'b1) begin 
  if(CKint_dft === 0 && ATPint === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
    if(SE_reg === 1'b1 && SEsys === 1'b0) begin
      if(TBYPASSsys === 1'b1) begin
          
          
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],
scanreg_dr_wire[10],
scanreg_dr_wire[11],
scanreg_dr_wire[12],
scanreg_dr_wire[13],
scanreg_dr_wire[14],
scanreg_dr_wire[15],
scanreg_dr_wire[16],
scanreg_dr_wire[17],
scanreg_dr_wire[18],
scanreg_dr_wire[19],
scanreg_dr_wire[20],
scanreg_dr_wire[21],
scanreg_dr_wire[22],
scanreg_dr_wire[23],
scanreg_dr_wire[24],
scanreg_dr_wire[25],
scanreg_dr_wire[26],
scanreg_dr_wire[27],
scanreg_dr_wire[28],
scanreg_dr_wire[29],
scanreg_dr_wire[30],
scanreg_dr_wire[31],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9],
scanreg_dl_wire[10],
scanreg_dl_wire[11],
scanreg_dl_wire[12],
scanreg_dl_wire[13],
scanreg_dl_wire[14],
scanreg_dl_wire[15],
scanreg_dl_wire[16],
scanreg_dl_wire[17],
scanreg_dl_wire[18],
scanreg_dl_wire[19],
scanreg_dl_wire[20],
scanreg_dl_wire[21],
scanreg_dl_wire[22],
scanreg_dl_wire[23],
scanreg_dl_wire[24],
scanreg_dl_wire[25],
scanreg_dl_wire[26],
scanreg_dl_wire[27],
scanreg_dl_wire[28],
scanreg_dl_wire[29],
scanreg_dl_wire[30], scanreg_dl_wire[scanlen_l-1]};  


        for (i = 0; i < Bits; i = i + 1)
        begin
         if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
        end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
      end
    end
  end
  if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0) begin
      if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
  end 
  else if ((TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint === X && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end   
end

//assign output data
`ifdef functional        

   
always @(SDLOint)
#0.001 delSDLO_data<=SDLOint;

always @(SDROint)
#0.001 delSDRO_data<=SDROint;


always @(SMLOint)
#0.001 delSMLO_data<=SMLOint;

always @(SMROint)
#0.001 delSMRO_data<=SMROint;
 
always @(SCTRLOint)
#0.001 delSCTRLO_data<=SCTRLOint;


always @(OutReg_data)
   #0.001 delOutReg_data = OutReg_data;
`else
`endif

/***************************** Embeded switch functionality starts here ***********************************/





always @(STDBYint)
begin
  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0 && STDBYint !== 1'b0)
    begin
      ScanOutX;
      ScanChainX;
     delScanOutX;     
    end
  end
end



always @(SLEEPint)
begin


  if (SLEEPint !== 1'b1) begin
    time_fall_sleep = $realtime;
  end

  if (power_up_done === 0)
    begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
    end
  else begin
    if (SLEEPint === 1'b1 && lastSLEEP === 1'b0 ) begin 
      
    end
    else if (SLEEPint !== 1'b1 && lastSLEEP === 1'b1 && full_shutdown !== 1) begin 
      
      if (supply_ok !== 1 && ($realtime > 0)) begin
         if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID LOW_POWER) ERROR: ISOLATION signal removed from the memory but array and periphery supply is not completely switched on.Very High Current would be drawn by the memory. All further operations on memory are blocked",$realtime);
          WriteMemX;
          WriteOutX;
          ScanChainX;
          OutReg_data = WordX; 
          delOutReg_data=WordX;
          ScanOutX;//immediately;
          delScanOutX;//immediately;
          init_pulse_done = 0;
          power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            debug_level = 2'b11;
          `endif
          
      end        
      
       
    end   
    else if (SLEEPint === X && lastSLEEP === 1'b0 && full_shutdown !== 1'b1) begin 
     
    end 
  end  


  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && SLEEPint !== 0)
    begin
      ScanOutX;
      ScanChainX;
        delScanOutX;      
    end
  end

// if (init_pulse_done === 0)
//   begin
//     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
//   end
//
// else if ( SLEEPint !== 1 && (supply_ok !==1) ) begin
//    
//    WriteOutX;
//    OutReg_data = WordX; 
//    delOutReg_data=WordX;
//    ScanOutX;//immediately;
//    delScanOutX;//immediately;
//    ScanChainX;
//    WriteMemX;
//    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies with sleep/Power down signal being low.This scenario can lead to high dc currents and some reliability issues Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
// end

 print_sleep;    
 lastSLEEP=SLEEPint;
end

/********************************** Embeded switch functionality ends here *******************************/

task print_sleep;
begin
  if (SLEEPint === 1'b0) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been deasserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end  
  else if (SLEEPint === 1'b1) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been asserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_ACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif

  end        
  else begin
      if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) ERROR: SLEEP pin is at an invalid state.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INVALID in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end        
end
endtask





 

//// C28SOI non flip compiler power functionality 
always @(gndmreg )
begin
 if (power_up_done === 1 && $realtime > 0) begin    
    if(gndmreg !== 1'b0 ) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or gndsm is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
        corrupt_all;
        init_pulse_done = 0;
        power_up_done = 0;
     `ifdef NO_BLOCK_MEM
     `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of ground pins.Ground must be maintained at 0 Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime);
        debug_level = 2'b11;
     `endif   

    end   
 end

end




always @(vddmareg )
begin

if (vddmareg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddma(Array Supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 
    end
   end   
   else if (SLEEPint === 1) begin
    WriteMemX;
   end

end

if ((vddmareg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1 ) && $realtime > 0) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddm or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         corrupt_all;
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif

end


end

always @(vddmpreg )
begin
 if (vddmpreg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or vddsmp is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmp(Periphery Supply)/vddsmp(Substrate power supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 

    end
   end   
   else if (SLEEPint === 1) begin
    WriteOutX;
    ScanChainX;
    ScanOutX;
    delScanOutX;//immediately;
    OutReg_data = WordX; 
    delOutReg_data=WordX;
   end
 end

if( (vddmpreg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1'b1 )  && $realtime > 0) begin
         corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif
end
 
 
end


always @(vddmoreg)
begin
  if (power_up_done === 1 && $realtime > 0) begin   
      if (vddmoreg !== 1'b1)  begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin
           corrupt_all;
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
         end //if (vddmareg === 1'b1 

      else if (vddmareg === 1'b0 && vddmpreg === 1'b0   && SLEEPint === 1'b1 &&  $realtime > 0)
        begin 
            if((debug_level < 2) && ($realtime > 0)) $display("%m - %t WARNING: Illegal Value on power pin(s). Memory and Output Corrupted ", $realtime);
 
           corrupt_all;
        end //else if (vddmareg === 1'b 
     end   // if (vddmoreg !== 1'b1)
     else if (vddmoreg === 1'b1 && $realtime > 0 ) begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin     
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           corrupt_all;
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
        end        
     end // else if (vddmoreg === 1'b1
  end 
end // always @(vddmoreg)












always @(gndmreg) begin
 if (gndmreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 0. ",$realtime);
 end
 else if (gndmreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 1. ",$realtime);
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to invalid state. ",$realtime);
 end
end




 
always @(vddmareg) begin
 if (vddmareg === 0) begin 
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 0. ",$realtime);
  vddma_fall_time = $realtime;
 end
 else if (vddmareg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 1. ",$realtime);
  vddma_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to invalid state. ",$realtime);
  vddma_fall_time = $realtime;
 end 

 

end

always @(vddmpreg) begin
 if (vddmpreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 0. ",$realtime);
  vddmp_fall_time = $realtime;
 end
 else if (vddmpreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 1. ",$realtime);
  vddmp_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to invalid state. ",$realtime);
  vddmp_fall_time = $realtime;
 end

 
 
end



// end of C28SOI power functionality 
 


assign supply_ok          =  (vddmareg === 1'b1 && vddmpreg  === 1'b1  && gndmreg === 1'b0 && vddmoreg === 1'b1 ) ? 1'b1 : 1'b0;
assign core_supply_ok     =  (vddmoreg === 1'b1 && vddmareg === 1'b1 && gndmreg === 1'b0 ) ? 1'b1 : 1'b0;
assign peri_supply_ok     =  (vddmoreg === 1'b1 && vddmpreg === 1'b1 && gndmreg === 1'b0  ) ? 1'b1 : 1'b0;

assign full_shutdown = (vddmpreg === 1'b0 && vddmareg === 1'b0   ) ? 1'b1 : 1'b0 ;




`ifdef functional
`else


task WriteLocMskX_bwise;
   input [Addr-1 : 0] Address;
   input [Bits-1 : 0] Mask;

reg [Bits+Red_extrabit:0] tempReg1;
integer num1; 
begin
   tempReg1 = WordX;
   if (^Address !== X )
   begin
      tempReg1 = Mem[Address];
             
      for (j = 0;j< Bits; j=j+1) begin
         num1=j;
        if (Mask[j] === 1'bx)
            tempReg1[num1] = 1'bx;
      end
      Mem[Address] = tempReg1;
      task_insert_faults_in_memory;
   end//if (^Address !== X
   else begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      WriteMemX;
   end   
end
endtask


/****************Actions taken on timing violations*****************/

 always @(TimingViol_data)
// tds or tdh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  for (l = 0; l < Bits; l = l + 1) begin   
    if (CSWEMTBYPASS[l] !== 0) begin
     if((TimingViol_data[l] !== TimingViol_data_last[l])) begin


         Mreg[l] = 1'bx;
     end    
     WriteLocMskX_bwise(Areg,Mreg);
    end   
   end 
  end
    if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin
     scanreg_dl =1'bx; 
     scanreg_dr =1'bx; 
     SDLOint=X;
     SDROint=X;
     `ifdef functional
     `else
     SDLO_data<=1'bx;
     SDRO_data<=1'bx;
     `endif
    end
     TimingViol_data_last = TimingViol_data; 
end



always @(TimingViol_mask)
// tms or tmh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  if(CSWETBYPASSN !== 0) begin
   for (i = 0; i < Bits; i = i+1) begin   
      if ( (TimingViol_mask_last[i] !== TimingViol_mask[i])) begin
         Mem[Areg][i]=Mem_last[i];
         if (Dint[i] !== Mem[Areg][i]) begin
          Mreg[i] = 1'bx;
         end
      end   
   end      
   WriteLocMskX_bwise(Areg, Mreg);
   end      
  end
  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
  scanreg_ml =1'bx; 
  scanreg_mr =1'bx; 
  SMLOint=X;
  SMROint=X; 
  `ifdef functional
  `else
  SMLO_data<=1'bx;
  SMRO_data<=1'bx;
  `endif
  end

  TimingViol_mask_last = TimingViol_mask; 
 end 


always @(TimingViol_addr)
// tas or tah
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
      scanreg_ctrl=1'bx; 
      SCTRLOint=X;
      `ifdef functional
      `else
      SCTRLO_data<=1'bx;
      `endif
  end
end


always @(TimingViol_WEN)
//tws or twh
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WEN pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end 

always @(TimingViol_CSN )
// tps or tph 
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;

   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CSN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end

always @(TimingViol_tcycle )
//tcycle
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
   if (MEMEN !== 0 && MEMEN_prev !== 0) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckl )
// tckl 
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckh) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end


always @(TimingViol_tcycle_se )
//tcycle_se
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckl_se  )
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckh_se) begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tbist) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
   end
   if (TBYPASSint !== 1'b0) begin 
    WriteOutX;
   end 
   if (INITNreg !==0 && STDBYreg !== 1 && TBYPASS_reg !== 1 && SLEEPreg !== 1 && SE_reg !== 1 && IGreg !== 1 && DEreg !== 1) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBIST pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end






always @(TimingViol_tbypass)
//ttmck
begin
#0  
  WriteOutX;
  if (INITNreg !== 0 && SLEEPreg !== 1 && SE_reg !== 1 && STDBYreg !== 1 &&  DEreg !== 1) begin
   Invalid_next_cycle_dft_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
end



always @(TimingViol_sleep)
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_stdby)
begin
#0
  if (CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin 
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (ATPreg !== 0) begin 
   Invalid_next_cycle_dft_tim;
  end
end






always @(TimingViol_se) begin
#0
   if (TBYPASS_reg !== 0) begin 
    WriteOutX;
   end 
  if (TBYPASS_reg === 0) begin
     WriteOutX;
     WriteMemX;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE timing violation  Memory State Machine is corrupted. Output Corrupted ",$realtime); 
  end 
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
  end
end

always @(TimingViol_sctrli) begin
  scanreg_ctrl=1'bx; 
end


always @(TimingViol_sdli) begin
 scanreg_dl=1'bx; 
end

always @(TimingViol_sdri) begin
   scanreg_dr=1'bx;
end


always @(TimingViol_smli) begin
    scanreg_ml=1'bx;
    end

always @(TimingViol_smri) begin
    scanreg_mr=1'bx;
end
 

always @(TimingViol_initnl) begin
init_pulse_done=0;
WriteOutX;
OutReg_data = WordX; 
delOutReg_data=WordX;
ScanOutX;
delScanOutX;
ScanChainX;
WriteMemX;
end

always @(TimingViol_initn) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end

always @(TimingViol_ig) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && INITNreg !== 0 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: IG pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   ScanChainX;
   ScanOutX;
   delScanOutX;       
  end
end

always @(TimingViol_atp) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin  
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_rm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^WMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: RM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
   end
end
 
always @(TimingViol_wm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^RMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);        
   end
end 


`endif


endmodule




module ST_SPREG_LOLEAK_64x64m2_bTl_lock_up_latch (EN,D,Q);
input EN,D;
output reg Q;

  always @ (EN or D) begin
    if (EN === 1) begin
       Q = D;
    end
    else if ((EN === 1'bz || EN === 1'bx  )&& D !== Q) begin
        Q=1'bx;
    end    
  end
endmodule

module ST_SPREG_LOLEAK_64x64m2_bTl_SCFF (D,TI,TE,CP,Q,OUTX);
input D,TI,TE,CP;
input OUTX;
output reg Q;
wire Dint;
assign Dint= (TE===1)?TI:(TE===0)?D:1'bx;

always @(posedge CP)
        begin
          if(Dint === 1'bZ || CP ===1'bx || OUTX === 1'bx)
          begin
                  Q = 1'bx;
          end
          else
          begin
                  Q = Dint;
          end        
        end
always @(posedge OUTX)
Q = 1'bx;
endmodule



`undef setup_time
`undef hold_time
`undef access_time
`undef retain_time
`undef cycle_time
`undef pulse_width_time
`undef initin_low_pulse


`delay_mode_path
`endcelldefine
`nosuppress_faults






/****************************************************************
--  Description         : Verilog Model 
--  ModelVersion        : 1.2
--  Date                : Apr, 2013
--  Changes Made by	: PS
--  Revision History    : 
 
****************************************************************/


/******************** START OF HEADER****************************
   This Header Gives Information about the parameters & options present in the Model
   
   words = 256
   bits  = 21
   mux   = 8 
   
   
   
   write_mask = no 
   
   margin_control = yes 
   
   
   Dft = Yes  

    ------------------------------------------------------------------------------------
     Signal Name             | Description       |             Port Mode        | Active When
                             |                   |          r    |  w   | rw    |
   ------------------------------------------------------------------------------------

    D 	        Data in                     na     x      na       -  
    IG    Input Gate Enable           x      x      na       High     
    ATP            ATPG Enable                 x      x      na       High     
    INITN                 INITN pin                   x      x      na       Low
    
    
     
    Q 	        Data out	            x      na     na       -
    A              Address                     x      x      na       high and low
    
    CK                Clock	                    x      x      na       posedge
    CSN          Chip Enable                 x      x      na       low
    
    RM         Read Margins                 x      x      na       High 
    SCTRLI         Scan Input (Control)
    SCTRLO        Scan Output (Control)
    SDLI         Scan Input (Data-Left)
    SDLO        Scan Output (Data-Left)
    SDRI         Scan Input (Data-Right)
    SDRO        Scan Output (Data-Right)
    SE          Scan Enable pin 
    STDBY              Standby pin                 x      x      na       High
    
    SLEEP                        Sleep pin                   x      x      na        High 
    
     
     
    TBIST          Bist Enable Pin 
    
    TBYPASS                      Memory Bypass                na     na     na        High
    
    TED        Bist Even Data pin
    TOD         Bist Odd Data Pin
     
    TA         Bist Read Address
    TCSN     Bist Read Chip Select
    
    TWEN    Bist Write Enable 
    WEN         Write Enable                na     x      na       Low 
    
    WM        Write Margins Code          x      x      na       -
     

******************** END OF HEADER ****************************/


//********************************************//
// ST_SPREG_LOLEAK_256x21m8_Tl Verilog Model                 //  
//********************************************//




`ifdef slm
        `define functional
`endif

`celldefine
`suppress_faults
  `ifdef functional
   `delay_mode_unit
  `else
   `delay_mode_path
  `endif

`define setup_time 0.0
`define hold_time 0.0
`define access_time 1.0
`define retain_time 0.9
`define cycle_time 0.0
`define pulse_width_time 0.0
`define initin_low_pulse 0.0



 






`timescale 1ns / 1ps


module ST_SPREG_LOLEAK_256x21m8_Tl (A,ATP,CK,CSN,D ,IG,INITN , Q ,RM    ,SCTRLI,SCTRLO,SDLI,SDLO,SDRI,SDRO,SE,SLEEP   , STDBY  ,TA,TBIST   ,TBYPASS ,TCSN,TED ,TOD   ,TWEN ,WEN,WM  );

 parameter
  Words = 256,
  Bits = 21,
  Addr = 8,
  mux = 8,
  repair_address_width = 5,
  write_margin_size = 2, 
  read_margin_size = 3; 

 //  INPUT OUTPUT PORTS DECLARATION DONE SEPARATELY FOR SPREG and ROM
 // ========================


        output [Bits-1 : 0] Q;
         
        output SCTRLO;
        input SE,SCTRLI;
        
        input [Addr-1 : 0] A;
        
        input [read_margin_size-1 : 0] RM;
        
         
        input CK,CSN,INITN,IG,ATP; 
        
        
        input [Addr-1 :0 ] TA;
input TBIST,TCSN ;
        
        input STDBY;
        
        input SLEEP; 
        
         
        
        
         
        output SDLO;
        output SDRO;
        
        
        
        
        input [Bits-1 : 0] D ;
	
          
         
        
        input [write_margin_size-1 : 0] WM;
        
        
        input TBYPASS;
        
        input WEN;
        
        
         
        input SDLI,SDRI  ; 
        
        
        
        //Bist inputs
        // ===========
        input TWEN,TED,TOD; 
        
        
        
        

        






    parameter
        Fault_file_name = "ST_SPREG_LOLEAK_256x21m8_Tl_faults.txt",
        `ifdef ConfigFault
        ConfigFault = 1,
        `else
        ConfigFault = 0,
        `endif
        max_faults = 258,
        
        MEM_INITIALIZE  = 1'b0,
        BinaryInit = 1'b0, 
        InitFileName = "ST_SPREG_LOLEAK_256x21m8_Tl.cde",
        Debug_mode = "all_warning_mode",
        File_load_time=0,
        Initn_reset_value={21{1'b0}},
        InstancePath = "ST_SPREG_LOLEAK_256x21m8_Tl";
    
    parameter
        
        bank = 1, 
        mux_bits=3,
        Red_extrabit=0,
        bank_bits = 0,
        RedWords = mux * 2 * bank,
        max_address_bits = 15 ,
        Rows = Words/mux;

  
    parameter 

     

        
           scanchains=3,    
          
        
        scanlen_ctrl=15,
        
        

      

        
        scanlen_r=(Bits)/2,
        
        scanlen_l=(Bits+1)/2 ; 
      
      

    parameter
        
        `ifdef functional  
            RW_assertions_en = 0,
        `endif
        WordX = {Bits{1'bx}},
        AddrX = {Addr{1'bx}},
        Word0 = {Bits{1'b0}},
        X = 1'bx;
   



//  WIRE DECLARATION RELATED TO POWER PINS
//  ======================================
	
        wire supply_ok, full_shutdown;
        
        wire core_supply_ok;
        wire peri_supply_ok;

        wire gndmint, gndsmint;
         
        
        wire vddmpint;
        wire vddmoint;
        wire vddmaint;
        wire vddsmpint;  
        wire vddsmaint;  
        
        

//  WIRE DECLARATION 
//  ==================
        wire [Bits-1 : 0] CSWEMTBYPASS;
        wire [Bits-1 : 0] Dint, Dsys;
        wire [Bits-1 : 0] Mint; 
        wire [21-1:0] Msys;
	wire [Addr-1 : 0] Aint;
        wire [Addr-1 : 0] Asys;

       


        wire [max_address_bits-1 : 0] A_int; 
                
	wire CKint_dft;
	wire CKint_func;
	wire CSNint;
        wire MEMEN;
        wire MEMEN_dft;
        wire TSE;

	wire WENint;
	wire WENsys;
        wire SLEEPint;
        wire STDBYint;
        wire SEint;
        wire SEsys;
        wire SCTRLIint;
        wire SDLIint;
        wire SDRIint;
        
        wire INITNint;
        wire TBYPASSint;
        wire TBYPASSsys;
        wire LSint; 
        wire HSint; 
        wire ATPint;
        wire DEint;
        
        wire [Addr-1 : 0] TAint;
        wire TBISTint;
        wire TBISTsys;
        wire TCSNint;
        wire TEDint;
        wire TODint;
        wire TEMint;
        wire TOMint;
        wire [Bits-1 : 0] TMint;
        wire [Bits-1 : 0] TDint;
        wire TWENint;
        wire IGint;
        wire IGbuf;
        wire CSNbuf;
        wire WENbuf;
        wire [read_margin_size-1:0] RMint;
        wire [write_margin_size-1:0] WMint;

        //Wires for scan chains
        //  ====================     
        wire [scanlen_ctrl -1:0]scanreg_ctrl_wire;
        wire [scanlen_l -1:0]  scanreg_dl_wire; 
        wire [scanlen_r -1:0]  scanreg_dr_wire; 
   
        wire [scanlen_l -1:0]  scanreg_ml_wire; 
        wire [scanlen_r -1:0]  scanreg_mr_wire; 


        wire [repair_address_width -1 : 0] RRAint;
        wire RRAEint;
        wire TRRAEint;    
        wire red_en;
        wire [repair_address_width -1 : 0] repair_add, next_repair_add;


//  REG DECLARATION
//  ====================     
        reg MEMEN_reg;
        reg MEMEN_prev;
        reg reg_mem_block;
        reg flag_mem_block;
        reg SCTRLIint_temp;
        reg SDLIint_temp;
        reg SDRIint_temp;
        reg SMLIint_temp;
        reg SMRIint_temp;

        //  REG DECLARATION
        //  ====================
        reg SCTRLOint;
        
        reg SDLOint,SDROint;
         
        
        reg next_cycle_corrupt_func;
        reg next_cycle_corrupt_dft;
        reg [Bits-1 : 0] delOutReg_data;//delayed Output Register
        reg [Bits-1 : 0] OutReg_data;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_tbypass;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_scan;   // Data Output registe
        reg [Bits-1 : 0] OutReg_rado_retained;   // register for retaining rado data when SLEEP --> 1
        reg delSCTRLO_data,SCTRLO_data;      // delayed Output Register
        reg delSDLO_data,SDLO_data;      // delayed Output Register
        reg delSDRO_data,SDRO_data;      // delayed Output Register
        
        
        // SCAN CHAINS register
        reg scanreg_ctrl; 
        reg scanreg_dl; 
        reg scanreg_dr; 
        
        
        reg CK_sc;
        reg Latch_open=0;
        reg lastCK_dft,CKreg_dft;
        reg lastCK_func,CKreg_func;
        reg lastSLEEP;
        reg lastPSWLARGEMP,lastPSWLARGEMA,lastPSWSMALLMP,lastPSWSMALLMA;
        reg CSNreg;
        reg init_pulse_done; //if == 1 then it implies that initb low pulse has been applied
        reg power_up_done; //if == 1 then it implies that power up has been done
        `ifdef slm
        `else
	      
             reg [Bits-1 : 0] Mem [Words-1 : 0];
             reg [Bits-1 : 0] RedMem [RedWords-1 : 0];
 
        `endif
        
	reg [Bits-1 :0] Mem_temp;
        reg [Bits-1 :0] Mem_slm; 
	reg ValidAddress;
	reg ValidDebugCode;
        reg decoding_start;
        reg file_loaded;
        reg [Bits-1 :0] Dreg;
        reg [Bits-1 :0] Mreg;
        reg WENreg;
        reg [Addr-1 :0] Areg;
        reg SE_reg;
        reg TBYPASS_reg;
        reg INITNreg;
        reg IGreg;
        reg DEreg;
        reg SLEEPreg;
        reg STDBYreg;
        reg ATPreg;
        reg MEMEN_dft_reg;
        reg MEMEN_dft_prev;
        reg RRMATCHreg;
        reg RRMATCHreg_last;//changes_made
        reg RRMATCHreg_glitch;
        reg [repair_address_width -1 : 0] repair_add_last;
        reg RRAEint_last;
        reg [Addr-mux_bits-1:0] row_add_temp;
        reg [Addr-mux_bits-bank_bits-1:0] row_add_cmp_temp;

       
        //parameter registers
        reg [2047:0] reg_Fault_file_name;
        reg reg_ConfigFault;
        reg reg_MEM_INITIALIZE;
        reg reg_BinaryInit;
        reg [2047:0] reg_InitFileName;
        reg [Bits -1 :0] reg_Initn_reset_value;
        time reg_File_load_time;

        //Power Supply Registers        
        reg vddmireg;
        reg vddmreg;
        reg vddsmreg;
        reg gndmreg;
        reg gndsmreg;   
        reg vddmpreg;
        reg vddmpireg;
        reg vddmareg;
        reg vddsmpreg;
        reg vddsmareg;
        reg vddmoreg;
        time vddmp_rise_time;
        time vddmp_fall_time;
        time vddsmp_rise_time;
        time vddsmp_fall_time;
        time vddma_rise_time;
        time vddma_fall_time;
        time vddsma_rise_time;
        time vddsma_fall_time;
        reg reg_check_rise;
        reg reg_check_fall;
        reg reg_check_rise_vddma;
        reg reg_check_fall_vddsma;
        reg  reg_check_rise_vddm, reg_check_fall_vddsm ;
        time vddm_fall_time,  vddm_rise_time,  vddsm_fall_time, vddsm_rise_time ;
  /* This register is used to force all warning messages 
  ** OFF during run time.
  ** It is a 2 bit register.
  ** USAGE :
  ** debug_level_off = 2'b00 -> ALL MESSAGES(INFO/WARNINGS/ERRORS) will be DISPLAYED 
  ** debug_level = 2'b01     -> ONLY WARNINGS/ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b10     -> ONLY ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b11     -> NO MESSAGES will be DISPLAYED.
  */ 
        reg [1:0] debug_level;
        reg [8*10: 0] operating_mode;
        reg [8*44: 0] message_status;

        integer i, k, j, l,m,q,w,r,s,num1,redcnt,n,num2,FirstHalf,Bfaileff,memcnt,ptr;
        integer decoder[Bits-1:0];
        `ifdef slm
           integer MemAddr;
        `endif


        //************************************************************
        //****** CONFIG FAULT IMPLEMENTATION VARIABLES*************** 
        //************************************************************ 

        integer file_ptr, ret_val;
        integer fault_word;
        integer fault_bit;
        integer fcnt, Fault_in_memory,faultnum,stop_loop,count;
        integer t;  
        integer FailureLocn [max_faults -1 :0];
        integer Failurebit [max_faults -1 :0];
        reg [100 : 0] stuck_at;
        reg [100 : 0] fault_array;
        reg [200 : 0] tempStr;
        reg [7:0] fault_char;
        reg [7:0] fault_char1; // 8 Bit File Pointer
        reg [Addr -1 : 0] std_fault_word;
        reg [Addr -1 : mux_bits] fault_row_add [max_faults -1 :0];
        reg [max_faults -1 :0] fault_repair_flag;
        reg [max_faults -1 :0] dont_insert_fault;
        reg [max_faults -1 :0] repair_flag;
        reg [100 : 0] array_stuck_at[max_faults -1 : 0] ;
        reg [100 : 0] mem_red_array_stuck_at[max_faults -1 : 0] ; 
        reg msgcnt;
        
       
        reg [Bits - 1: 0] stuck_at_0fault [max_faults -1 : 0];
        reg [Bits - 1: 0] stuck_at_1fault [max_faults -1 : 0];
        reg [Bits -1 : 0] stuck0;
        reg [Bits -1 : 0] stuck1;

        reg [Bits+Red_extrabit :0] Mem_last;
        

        `ifdef slm
        reg [Bits -1 : 0] slm_temp_data;
        `endif
        
        real time_CK_func_rise , time_RADCK_rise;
        real time_fall_sleep,time_fall_PSWLARGEMP,time_fall_PSWLARGEMP_0,time_fall_PSWLARGEMA,time_fall_PSWLARGEMA_0,time_fall_PSWSMALLMP,time_fall_PSWSMALLMA;
        integer flag_error;
        
//BUFFER INSTANTIATION
//=========================
       `ifdef functional
       
         buf (SCTRLO,delSCTRLO_data); 
         buf bufq [Bits-1:0] (Q,delOutReg_data);
      `else
       
         buf (SCTRLO,SCTRLO_data);
         buf bufq [Bits-1:0] (Q,OutReg_data);
      `endif
      
  
        buf (SEsys,SE);
	buf (SCTRLIint, SCTRLI);
   

	buf (CKint_func, CK);
	buf (CKint_dft, CK);
        buf bufaddr [Addr-1:0] (Asys,A);
        buf (INITNint,INITN);
        
        buf (LSint,1'b0); 
        buf (IGbuf,IG);
        buf (ATPint,ATP);

        buf bufTaddr [Addr-1 : 0] (TAint,TA);
        buf (TBISTsys,TBIST);
        buf (TCSNint,TCSN);

        buf (CSNsys,CSN);
        buf (STDBYint,STDBY );   
        
        buf (SLEEPint,SLEEP ); 

        buf bufrm [read_margin_size-1:0] (RMint, RM); 

        
        

        assign RRAEint = 1'b0;
        assign TRRAEint = 1'b0;
        assign repair_add = 0;
        assign next_repair_add = 0;
        assign red_en = 1'b0; 
        
        
        
        
        
        
        
        buf (PSWLARGEMPint,1'b0);
        buf (PSWSMALLMPint,1'b0); 
        buf (PSWLARGEMAint,1'b0);
        buf (PSWSMALLMAint,1'b0);   

      `ifdef functional
       
       
         buf (SDLO,delSDLO_data);
         buf (SDRO,delSDRO_data);
        
      `else
       
         buf (SDLO,SDLO_data);
         buf (SDRO,SDRO_data);
         
      `endif
       
         
       
        buf bufdata [Bits-1:0] (Dsys,D);
        
        
        assign Msys=21'b0; 
	

        
        buf (TBYPASSsys, TBYPASS);
        


        buf (WENsys,WEN);
	 
	buf (SDLIint, SDLI);
	buf (SDRIint, SDRI);
	 
        
        buf (HSint,1'b0); 

        
        buf (TEDint,TED);
        buf (TODint,TOD);
         
        buf (TWENint,TWEN);
        
        
        buf bufwm [write_margin_size-1:0] (WMint, WM); 
        



//      assign scanreg_ctrl_wire={scanreg_ctrl[scanlen_ctrl - 2:0],SCTRLIint};
//      assign scanreg_dl_wire={scanreg_dl[scanlen_l - 2:0],SDLIint};
//      assign scanreg_dr_wire={scanreg_dr[scanlen_r - 2:0],SDRIint};
      
        
      assign Aint   = (TBISTint === 1'b0 ) ? Asys : (TBISTint === 1'bx ) ? {Addr{1'bx}} : TAint;  

        
//        assign A_int = Aint;
	
        
                
        assign Dint[0] = (TBISTint === 1'b0) ? Dsys[0] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[1] = (TBISTint === 1'b0) ? Dsys[1] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[2] = (TBISTint === 1'b0) ? Dsys[2] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[3] = (TBISTint === 1'b0) ? Dsys[3] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[4] = (TBISTint === 1'b0) ? Dsys[4] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[5] = (TBISTint === 1'b0) ? Dsys[5] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[6] = (TBISTint === 1'b0) ? Dsys[6] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[7] = (TBISTint === 1'b0) ? Dsys[7] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[8] = (TBISTint === 1'b0) ? Dsys[8] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[9] = (TBISTint === 1'b0) ? Dsys[9] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[10] = (TBISTint === 1'b0) ? Dsys[10] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[11] = (TBISTint === 1'b0) ? Dsys[11] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[12] = (TBISTint === 1'b0) ? Dsys[12] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[13] = (TBISTint === 1'b0) ? Dsys[13] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[14] = (TBISTint === 1'b0) ? Dsys[14] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[15] = (TBISTint === 1'b0) ? Dsys[15] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[16] = (TBISTint === 1'b0) ? Dsys[16] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[17] = (TBISTint === 1'b0) ? Dsys[17] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[18] = (TBISTint === 1'b0) ? Dsys[18] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[19] = (TBISTint === 1'b0) ? Dsys[19] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[20] = (TBISTint === 1'b0) ? Dsys[20] : (TBISTint === 1'b1) ? TEDint : 1'bx;          
	 
        assign Mint = 21'b0;
         

        assign WENbuf = (TBISTint === 1'b0 ) ? WENsys : (TBISTint === 1'bx ) ? 1'bx : TWENint;  
        assign WENint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? WENbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[13] : (ATPint === 1'b0 ) ? WENsys : 1'bx ; 
        
        assign CSNbuf = (TBISTint === 1'b0 ) ? CSNsys : (TBISTint === 1'bx ) ? 1'bx : TCSNint;  
        assign CSNint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? CSNbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[11] : (ATPint === 1'b0 ) ? CSNsys : 1'bx ; 
        assign IGint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? IGbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[14] : (ATPint === 1'b0 ) ? IGbuf : 1'bx;

        
        assign DEint = (LSint === 1'bx || (LSint === 1'b0 && HSint === 1'bx) || ^RMint !== 1'b0 || ^WMint !== 1'b0 ) ? 1'bx : 1'b0;
        
     
     and (TBISTint, ATPint, TBISTsys);
     and (SEint, ATPint, SEsys);
     and (TBYPASSint, ATPint, TBYPASSsys);
     and (TSE,TBYPASSint,!SEsys);
     and (MEMEN,INITNint,!CSNint,!SLEEPint,!TBYPASSint,!SEint,!IGint,!DEint,!STDBYint );
     and (MEMEN_dft,INITNint, !SLEEPint, ATPint,!STDBYint);

 `ifdef functional
/*****************assertions added to optimize dynamic power consumption**********/

//psl a_M: assert always ({( RW_assertions_en);(MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1))  } |-> (stable(Msys))) @(posedge CK); 

//psl a_WEN: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(WENsys))) @(posedge CK); 

//psl a_A: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(Asys))) @(posedge CK); 

//psl a_D: assert always ({( RW_assertions_en);((MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1)) && TBYPASSint === 1'b0)  } |-> (stable(Dsys))) @(posedge CK); 

/**********************************************************************************************/
`endif       

     

         
reg vddmp,vddmo, vddma, vddsmp, vddsma, gndsm, gndm,  vddmpi ; 
 
initial 
begin

        vddmp = 1'b1 ; 
        vddmo = 1'b1 ;
        vddma = 1'b1 ;
        
        vddsmp = 1'b1 ;
        
        
         gndm = 1'b0 ;
          
end

        
         assign gndmint = (reg_mem_block === 0) ? gndm : 1'b1;
         
         
         
         
         assign vddmpint = vddmp;
         assign vddmoint = vddmo;
         assign vddmaint = vddma;
         
          
        
         

        //CPF Changes

        
                
        initial
        begin : cpfvddmp 
           vddmpreg = vddmpint;
        end

        always @(vddmpint) begin
           vddmpreg = vddmpint;
        end
        
        initial
        begin : cpfvddmo 
           vddmoreg = vddmoint;
        end

        always @(vddmoint) begin
           vddmoreg = vddmoint;
        end
        
        initial
        begin : cpfvddma 
           vddmareg = vddmaint;
        end

        always @(vddmaint) begin
           vddmareg = vddmaint;
        end

        
        
 
        initial
        begin : cpfgndm 
           gndmreg = gndmint;
        end

        always @(gndmint) begin
           gndmreg = gndmint;
        end

        
        



 `ifdef functional
  `else
  initial begin
    if (debug_level < 1) begin
     $display ("%m  INFORMATION");
     $display ("***************************************");
     $display ("The Model is Operating in TIMING MODE");
     $display ("Please make sure that SDF is properly annotated otherwise dummy values will be used");
     $display ("%s", message_status);
     $display ("***************************************");
    end
  end

//////////////////////////
 //REG DECLARATIONS
   //======================

   reg [Bits-1 : 0] TimingViol_data;
   reg  [Bits-1 : 0] TimingViol_mask;
   reg [Bits-1 : 0] TimingViol_data_last, TimingViol_mask_last;
	reg TimingViol_data_0;
	reg TimingViol_data_1;
	reg TimingViol_data_2;
	reg TimingViol_data_3;
	reg TimingViol_data_4;
	reg TimingViol_data_5;
	reg TimingViol_data_6;
	reg TimingViol_data_7;
	reg TimingViol_data_8;
	reg TimingViol_data_9;
	reg TimingViol_data_10;
	reg TimingViol_data_11;
	reg TimingViol_data_12;
	reg TimingViol_data_13;
	reg TimingViol_data_14;
	reg TimingViol_data_15;
	reg TimingViol_data_16;
	reg TimingViol_data_17;
	reg TimingViol_data_18;
	reg TimingViol_data_19;
	reg TimingViol_data_20;
 reg TimingViol_mask_0;
 reg TimingViol_mask_1;
 reg TimingViol_mask_2;
 reg TimingViol_mask_3;
 reg TimingViol_mask_4;
 reg TimingViol_mask_5;
 reg TimingViol_mask_6;
 reg TimingViol_mask_7;
 reg TimingViol_mask_8;
 reg TimingViol_mask_9;
 reg TimingViol_mask_10;
 reg TimingViol_mask_11;
 reg TimingViol_mask_12;
 reg TimingViol_mask_13;
 reg TimingViol_mask_14;
 reg TimingViol_mask_15;
 reg TimingViol_mask_16;
 reg TimingViol_mask_17;
 reg TimingViol_mask_18;
 reg TimingViol_mask_19;
 reg TimingViol_mask_20;

   reg TimingViol_addr;
   reg TimingViol_CSN, TimingViol_WEN, TimingViol_tbypass;
   reg TimingViol_tckh, TimingViol_tckl, TimingViol_tcycle;
   reg TimingViol_tckh_se, TimingViol_tckl_se, TimingViol_tcycle_se;
   reg TimingViol_sctrli,TimingViol_sdli,TimingViol_sdri,TimingViol_se;
   reg TimingViol_smli,TimingViol_smri;
   reg TimingViol_sctrli_flag,TimingViol_sdli_flag,TimingViol_sdri_flag;
   reg TimingViol_smli_flag,TimingViol_smri_flag;
   reg TimingViol_initnl;
   reg TimingViol_initn;
   reg TimingViol_ls;
   reg TimingViol_hs;
   reg TimingViol_sleep;
   reg TimingViol_stdby;
   reg TimingViol_rm;
   reg TimingViol_wm;
   reg TimingViol_tbist,TimingViol_ig,TimingViol_atp,TimingViol_TED,TimingViol_TOD,TimingViol_TEM,TimingViol_TOM;
   reg TimingViolRRAE,TimingViolRRA;

   wire CSTBYPASSN,cond_sdf_tas,cond_sdf_tds,cond_sdf_tms,cond_sdf_tws,cond_sdf_tbas,cond_sdf_tbps,cond_sdf_tbws,cond_sdf_tbdes,cond_sdf_tbdos,cond_sdf_tbmes,cond_sdf_tbmos;
   wire SETB_EN,CSIG_EN,MEM_ACT,EN_ADM,CS_EN,CS_ADM,cond_sdf_tps,IG_EN,IG_ADM,cond_sdf_tigs,cond_sdf_taa,cond_sdf_taa_ls1,cond_sdf_taa_hs1,cond_tseq_tm;
   wire cond_sdf_tcycle,cond_sdf_tcycle_ls1,cond_sdf_tcycle_hs1,cond_sdf_tcycle_se,cond_sdf_tckl_se,cond_sdf_tsctrlis,cond_sdf_tsdlis,cond_sdf_tsdris,cond_sdf_tsmlis,cond_sdf_tsmris;
   wire cond_sdf_tckh_se,cond_sdf_taa_sctrlo_se,cond_sdf_taa_sdlo_se,cond_sdf_taa_sdro_se,cond_sdf_taa_smlo_se,cond_sdf_taa_smro_se,cond_sdf_tckl,cond_sdf_tckh;
   wire cond_sdf_ttms,cond_sdf_tbists,INITNandnotSLEEPandATPandnotSE,cond_sdf_taa_sctrlo,cond_sdf_taa_sdlo,cond_sdf_taa_sdro,cond_sdf_taa_smlo,cond_sdf_taa_smro;
   wire cond_sdf_taa_tm,cond_sdf_taa_tm_ls1, cond_sdf_taa_tm_hs1,cond_sdf_taa_tckq_tm,cond_sdf_taa_tseq_tm;

   wire CSWETBYPASSN;
   wire cond_sdf_tstdbys,cond_sdf_tsls,sleep_en,atp_csn_en;
   wire cond_sdf_tlss,cond_sdf_thss,cond_sdf_trms,cond_sdf_twms; 
   wire cond_sdf_tses,cond_sdf_tinitns;
   wire tby_se_en;
   wire rra_en;
   wire tbist_atp_en;
   wire rrae_en;
   wire tbist_rrae_en;
   wire cond_sdf_trraes;
   wire cond_sdf_ttrraes;
   wire cond_sdf_taa_trramatch;
   wire cond_sdf_ttrraematch;
   wire cond_sdf_tamatch;
   wire cond_sdf_ttamatch;
   wire cond_sdf_tatpmatch;
   wire cond_sdf_ttbistmatch;



 and (CSWEMTBYPASS[0], !Mreg[0], CSWETBYPASSN);
 and (CSWEMTBYPASS[1], !Mreg[1], CSWETBYPASSN);
 and (CSWEMTBYPASS[2], !Mreg[2], CSWETBYPASSN);
 and (CSWEMTBYPASS[3], !Mreg[3], CSWETBYPASSN);
 and (CSWEMTBYPASS[4], !Mreg[4], CSWETBYPASSN);
 and (CSWEMTBYPASS[5], !Mreg[5], CSWETBYPASSN);
 and (CSWEMTBYPASS[6], !Mreg[6], CSWETBYPASSN);
 and (CSWEMTBYPASS[7], !Mreg[7], CSWETBYPASSN);
 and (CSWEMTBYPASS[8], !Mreg[8], CSWETBYPASSN);
 and (CSWEMTBYPASS[9], !Mreg[9], CSWETBYPASSN);
 and (CSWEMTBYPASS[10], !Mreg[10], CSWETBYPASSN);
 and (CSWEMTBYPASS[11], !Mreg[11], CSWETBYPASSN);
 and (CSWEMTBYPASS[12], !Mreg[12], CSWETBYPASSN);
 and (CSWEMTBYPASS[13], !Mreg[13], CSWETBYPASSN);
 and (CSWEMTBYPASS[14], !Mreg[14], CSWETBYPASSN);
 and (CSWEMTBYPASS[15], !Mreg[15], CSWETBYPASSN);
 and (CSWEMTBYPASS[16], !Mreg[16], CSWETBYPASSN);
 and (CSWEMTBYPASS[17], !Mreg[17], CSWETBYPASSN);
 and (CSWEMTBYPASS[18], !Mreg[18], CSWETBYPASSN);
 and (CSWEMTBYPASS[19], !Mreg[19], CSWETBYPASSN);
 and (CSWEMTBYPASS[20], !Mreg[20], CSWETBYPASSN);

and (atp_csn_en,!ATPint,!CSNint,!IGint);
or (sleep_en,atp_csn_en,ATPint);
or (SETB_EN,SEint,TBISTint);
and (ATP_SETB_EN,ATPint,SETB_EN); 
or (CSIG_EN,IGint,CSNint);
and (MEM_ACT,!ATPint,CSIG_EN);
or (EN_ADM,MEM_ACT,ATP_SETB_EN);
and (CS_EN,!ATPint,IGint);
or (CS_ADM,CS_EN,ATP_SETB_EN);
and (atp_ig_csn_en,!ATPint,!CSNint,!IGint);
and (atp_se_en,!SEsys,ATPint);
or (cycle_en,atp_ig_csn_en,atp_se_en);
and (atp_ig_csn_en_reg,!ATPreg,!CSNreg,!IGreg);
and (atp_se_en_reg,!SE_reg,ATPreg);
or (cycle_en_reg,atp_ig_csn_en,atp_se_en);
and (INITNandnotSLEEPandATPandnotSE,cond_gac,!SEsys,ATPint);
and (csn_ig_en,!IGint,!CSNint);
and (atp_tby_ls_en,atp_se_en,cond_ls_tby_en);
and (IG_EN,!ATPint,!CSNint);
or (IG_ADM,IG_EN,atp_se_en);
and (CSWETBYPASSN, !WENreg, 1'b1);



assign cond_sdf_tsls=((sleep_en && INITNint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tstdbys=((sleep_en && INITNint && !SLEEPint) !==0) ? 1:0;
assign cond_sdf_atps=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_gac=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tas=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tds=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tms=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tws=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tps=((cond_gac && !CS_ADM) !==0) ? 1:0;
assign cond_sdf_tcycle=((cond_gac && cycle_en && !LSint && !HSint) !==0) ? 1:0;  
assign cond_sdf_tcycle_ls1=((cond_gac && cycle_en && LSint) !==0) ? 1:0;
assign cond_sdf_tcycle_hs1=((cond_gac && cycle_en && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_tckh=((cond_gac && cycle_en_reg) !==0) ? 1:0;
assign cond_sdf_tckl=((cond_gac && cycle_en) !==0) ? 1:0;
assign cond_sdf_tcycle_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckl_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsctrlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckh_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_ttms=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_tbists=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_tckq_tm=((cond_gac && SE_reg && ATPreg && TBYPASSsys) !==0) ? 1:0;
assign cond_ls_en=((atp_ig_csn_en || atp_tby_ls_en) !==0) ? 1:0;
assign cond_sdf_tlss=((cond_ls_en && cond_gac) !==0) ? 1:0;
assign cond_sdf_thss=((cond_ls_en && cond_gac && !LSint) !==0) ? 1:0;
assign cond_sdf_trms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_twms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_tses=((cond_gac && ATPint) !==0) ? 1:0;
assign cond_sdf_tbas=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbps=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbws=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tigs=((cond_gac && IG_ADM) !==0) ? 1:0;
assign cond_sdf_taa=((MEMEN_reg && WENreg && !LSint && !HSint) !==0) ? 1:0; 
// assign cond_sdf_taa_tbypass_q = ((MEMEN_reg && ATPint && TBYPASSint) !== 1'b0) ? 1'b1 : 1'b0;
assign cond_sdf_taa_ls1=((MEMEN_reg && WENreg && LSint) !==0) ? 1:0; 
assign cond_sdf_taa_hs1=((MEMEN_reg && WENreg && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && !HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_ls1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && LSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_hs1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tseq_tm=((cond_gac && TBYPASSint) !==0) ? 1:0;
assign cond_sdf_tinitns =(( sleep_en && !STDBYint && !SLEEPint) !==0) ? 1:0;
assign cond_ls_tby_en=((TBYPASSsys || csn_ig_en) !==0) ? 1:0;



//specify block begins

specify
    specparam
    
         PATHPULSE$CK$Q = 0,
         PATHPULSE$CK$SCTRLO = 0,

         PATHPULSE$CK$SDLO = 0,
         PATHPULSE$CK$SDRO = 0,
        
         PATHPULSE$SE$Q = 0,
         
//         PATHPULSE$TBYPASS$Q = 0,


        
         
        
         tsls = `setup_time,
         tslh = `hold_time ,
         tstdbys = `setup_time,
         tstdbyh = `hold_time , 
	 

         
         tcycle = `cycle_time,
         
         
         tckh = `pulse_width_time,
         tckl = `pulse_width_time,
         tcycle_se = `cycle_time,
         tckh_se = `pulse_width_time,
         tckl_se = `pulse_width_time,
         
         ttms = `setup_time,
         ttmh = `hold_time ,
         tps = `setup_time,
         tph = `hold_time ,
         tws = `setup_time,
         twh = `hold_time ,
         tds = `setup_time,
         tdh = `hold_time , 
         tas = `setup_time,
         tah = `hold_time ,
         tses= `setup_time,
         tseh= `hold_time ,
         tsctrlis=`setup_time,
         tsctrlih=`hold_time ,
         tsdlis=`setup_time,
         tsdlih=`hold_time ,
         tsdris=`setup_time,
         tsdrih=`hold_time , 
         tbists=`setup_time,
         tbisth=`hold_time ,
         tbps=`setup_time,
         tbph=`hold_time ,
         tbws=`setup_time,
         tbwh=`hold_time ,
         tbdes=`setup_time,
         tbdeh=`hold_time ,
         tbdos=`setup_time,
         tbdoh=`hold_time ,
         
         tbas=`setup_time,
         tbah=`hold_time ,
         tinitnl=`initin_low_pulse,
         tinitns=`setup_time,
         tinitnh=`hold_time ,
         tatps=`setup_time,
         tatph=`hold_time ,
         tigs=`setup_time,
         tigh=`hold_time ,
         
         
         trms=`setup_time,
         trmh=`hold_time ,
         twms=`setup_time,
         twmh=`hold_time , 

/*************************************************************************************************/
           // taa_tbypass_q = `access_time,
           // th_tbypass_q  = `retain_time,
            taa =`access_time,
            th = `retain_time,

 


            taa_tm =`access_time,
            th_tm = `retain_time,

            
            taa_tseq_tm =`access_time,
            th_tseq_tm = `retain_time,
            taa_tckq_tm   = `access_time,
            th_tckq_tm    = `retain_time,
            taa_sctrlo=`access_time,
            th_sctrlo= `retain_time,
            taa_sdlo=`access_time,
            th_sdlo= `retain_time,
            taa_sdro=`access_time,
            th_sdro= `retain_time,
            
         
            taa_sctrlo_se=`access_time,
            th_sctrlo_se= `retain_time
,
            taa_sdlo_se=`access_time,
            th_sdlo_se= `retain_time,
            taa_sdro_se=`access_time,
            th_sdro_se= `retain_time
         ;  


        /*---------------------- Timing Checks ---------------------*/

	$setup(posedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[7], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[7], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[7], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[7], tah, TimingViol_addr);

	$setup(posedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(posedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(posedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(posedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(posedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(posedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(posedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(posedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(posedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(posedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(posedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(posedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(posedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(posedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(posedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(posedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(posedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(posedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(posedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(posedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(posedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(negedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(negedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(negedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(negedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(negedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(negedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(negedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(negedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(negedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(negedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(negedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(negedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(negedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(negedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(negedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(negedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(negedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(negedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(negedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(negedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(negedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[20], tdh, TimingViol_data_20);

        



        $setup(posedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $setup(negedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, posedge WEN, twh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, negedge WEN, twh, TimingViol_WEN); 
        $setup(posedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$setup(negedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, posedge CSN, tph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, negedge CSN, tph, TimingViol_CSN);
        $period(posedge CK &&& cond_sdf_tcycle, tcycle, TimingViol_tcycle);  

        
        $width(posedge CK  &&& cond_sdf_tckh, tckh, 0, TimingViol_tckh);
        $width(negedge CK  &&& cond_sdf_tckl, tckl, 0, TimingViol_tckl);
        $period(posedge CK &&& cond_sdf_tcycle_se, tcycle_se, TimingViol_tcycle_se);
        $width(posedge CK  &&& cond_sdf_tckh_se, tckh_se, 0, TimingViol_tckh_se);
        $width(negedge CK  &&& cond_sdf_tckl_se, tckl_se, 0, TimingViol_tckl_se);

        
        $setup(posedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $setup(negedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $hold(posedge CK &&& cond_sdf_ttms, posedge TBYPASS, ttmh, TimingViol_tbypass); 
        $hold(posedge CK &&& cond_sdf_ttms, negedge TBYPASS, ttmh, TimingViol_tbypass); 
 



        
        $setup(posedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $setup(negedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $hold(posedge CK &&& cond_sdf_tsls, posedge SLEEP, tslh, TimingViol_sleep);        
        $hold(posedge CK &&& cond_sdf_tsls, negedge SLEEP, tslh, TimingViol_sleep);

        $setup(posedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $setup(negedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $hold(posedge CK &&& cond_sdf_tstdbys, posedge STDBY, tstdbyh, TimingViol_stdby);        
        $hold(posedge CK &&& cond_sdf_tstdbys, negedge STDBY, tstdbyh, TimingViol_stdby); 
        
        
        $setup (posedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
	$setup (negedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
        
        $hold (posedge CK &&& cond_sdf_tses, posedge SE ,tseh,TimingViol_se);
	$hold (posedge CK &&& cond_sdf_tses, negedge SE ,tseh,TimingViol_se);
        
        $setup(posedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis , tsctrlis, TimingViol_sctrli);
        $setup(negedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis, tsctrlis, TimingViol_sctrli);
        $hold(posedge CK &&& cond_sdf_tsctrlis , posedge SCTRLI, tsctrlih, TimingViol_sctrli);        
        $hold(posedge CK &&& cond_sdf_tsctrlis , negedge SCTRLI, tsctrlih, TimingViol_sctrli);

        $setup(posedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $setup(negedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $hold(posedge CK &&& cond_sdf_tsdlis, posedge SDLI, tsdlih, TimingViol_sdli);        
        $hold(posedge CK &&& cond_sdf_tsdlis, negedge SDLI, tsdlih, TimingViol_sdli);

        $setup(posedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $setup(negedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $hold(posedge CK &&& cond_sdf_tsdris, posedge SDRI, tsdrih, TimingViol_sdri);        
        $hold(posedge CK &&& cond_sdf_tsdris, negedge SDRI, tsdrih, TimingViol_sdri);
        
 
	
         
        $width(negedge INITN , tinitnl, 0, TimingViol_initnl);
        
        $setup(posedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        $setup(negedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        
        $hold (posedge CK &&& cond_sdf_tinitns,posedge INITN, tinitnh, TimingViol_initn);
        $hold (posedge CK &&& cond_sdf_tinitns,negedge INITN, tinitnh, TimingViol_initn);

        $setup(posedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $setup(negedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $hold(posedge CK &&& cond_sdf_atps, posedge ATP, tatph, TimingViol_atp);        
        $hold(posedge CK &&& cond_sdf_atps, negedge ATP, tatph, TimingViol_atp);
        
        $setup(posedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $setup(negedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $hold(posedge CK &&& cond_sdf_tigs, posedge IG, tigh, TimingViol_ig);        
        $hold(posedge CK &&& cond_sdf_tigs, negedge IG, tigh, TimingViol_ig);



         
$setup(posedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[2], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[2], trmh, TimingViol_rm); 

        
$setup(posedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(posedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[1], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[1], twmh, TimingViol_wm);
 
        
        $setup(posedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $setup(negedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $hold(posedge CK &&& cond_sdf_tbists, posedge TBIST, tbisth, TimingViol_tbist);        
        $hold(posedge CK &&& cond_sdf_tbists, negedge TBIST, tbisth, TimingViol_tbist);
        
        	$setup(posedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[7], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$setup(negedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[7], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[6], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[7], tbah, TimingViol_addr);
       	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[6], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[7], tbah, TimingViol_addr);

        $setup(posedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$setup(negedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, posedge TCSN, tbph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, negedge TCSN, tbph, TimingViol_CSN); 
       
        $setup(posedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $setup(negedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, posedge TWEN, tbwh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, negedge TWEN, tbwh, TimingViol_WEN);
       
       
        $setup(posedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $setup(negedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, posedge TED, tbdeh, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, negedge TED, tbdeh, TimingViol_TED);

        $setup(posedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $setup(negedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, posedge TOD, tbdoh, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, negedge TOD, tbdoh, TimingViol_TOD);

          


          

          /*-------------------- Propagation Delays ------------------*/
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa, taa, th, taa, th, taa);
                 

/* // //	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[0] +: OutReg_data[0])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[1] +: OutReg_data[1])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[2] +: OutReg_data[2])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[3] +: OutReg_data[3])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[4] +: OutReg_data[4])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[5] +: OutReg_data[5])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[6] +: OutReg_data[6])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[7] +: OutReg_data[7])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[8] +: OutReg_data[8])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[9] +: OutReg_data[9])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[10] +: OutReg_data[10])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[11] +: OutReg_data[11])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[12] +: OutReg_data[12])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[13] +: OutReg_data[13])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[14] +: OutReg_data[14])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[15] +: OutReg_data[15])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[16] +: OutReg_data[16])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[17] +: OutReg_data[17])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[18] +: OutReg_data[18])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[19] +: OutReg_data[19])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[20] +: OutReg_data[20])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q); */ 








	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                





	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                 

	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[0] +: OutReg_data[0])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[1] +: OutReg_data[1])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[2] +: OutReg_data[2])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[3] +: OutReg_data[3])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[4] +: OutReg_data[4])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[5] +: OutReg_data[5])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[6] +: OutReg_data[6])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[7] +: OutReg_data[7])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[8] +: OutReg_data[8])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[9] +: OutReg_data[9])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[10] +: OutReg_data[10])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[11] +: OutReg_data[11])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[12] +: OutReg_data[12])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[13] +: OutReg_data[13])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[14] +: OutReg_data[14])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[15] +: OutReg_data[15])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[16] +: OutReg_data[16])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[17] +: OutReg_data[17])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[18] +: OutReg_data[18])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[19] +: OutReg_data[19])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[20] +: OutReg_data[20])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                



if (cond_sdf_taa_sctrlo) 
        (posedge CK *> (SCTRLO :  SCTRLI)) = (taa_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo); 

if (cond_sdf_taa_sctrlo_se) 
        (negedge CK *> (SCTRLO : SCTRLI)) = (taa_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se); 
 

if (cond_sdf_taa_sdlo) 
        (posedge CK *> (SDLO :  SDLI)) = (taa_sdlo,taa_sdlo,th_sdlo,taa_sdlo,th_sdlo,taa_sdlo); 

if (cond_sdf_taa_sdlo_se) 
        (negedge CK *> (SDLO : SDLI)) = (taa_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se);

if (cond_sdf_taa_sdro) 
        (posedge CK *> (SDRO :  SDRI)) = (taa_sdro,taa_sdro,th_sdro,taa_sdro,th_sdro,taa_sdro); 

if (cond_sdf_taa_sdro_se) 
        (negedge CK *> (SDRO : SDRI)) = (taa_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se); 

  
     




endspecify //specify block ends






// conversion from registers to array elements for data setup violation notifiers

always @(TimingViol_data_0   or TimingViol_TED  )
begin
        TimingViol_data[0]=~TimingViol_data[0];   
end


always @(TimingViol_data_1   or TimingViol_TOD  )
begin
        TimingViol_data[1]=~TimingViol_data[1];   
end


always @(TimingViol_data_2   or TimingViol_TED  )
begin
        TimingViol_data[2]=~TimingViol_data[2];   
end


always @(TimingViol_data_3   or TimingViol_TOD  )
begin
        TimingViol_data[3]=~TimingViol_data[3];   
end


always @(TimingViol_data_4   or TimingViol_TED  )
begin
        TimingViol_data[4]=~TimingViol_data[4];   
end


always @(TimingViol_data_5   or TimingViol_TOD  )
begin
        TimingViol_data[5]=~TimingViol_data[5];   
end


always @(TimingViol_data_6   or TimingViol_TED  )
begin
        TimingViol_data[6]=~TimingViol_data[6];   
end


always @(TimingViol_data_7   or TimingViol_TOD  )
begin
        TimingViol_data[7]=~TimingViol_data[7];   
end


always @(TimingViol_data_8   or TimingViol_TED  )
begin
        TimingViol_data[8]=~TimingViol_data[8];   
end


always @(TimingViol_data_9   or TimingViol_TOD  )
begin
        TimingViol_data[9]=~TimingViol_data[9];   
end


always @(TimingViol_data_10   or TimingViol_TED  )
begin
        TimingViol_data[10]=~TimingViol_data[10];   
end


always @(TimingViol_data_11   or TimingViol_TOD  )
begin
        TimingViol_data[11]=~TimingViol_data[11];   
end


always @(TimingViol_data_12   or TimingViol_TED  )
begin
        TimingViol_data[12]=~TimingViol_data[12];   
end


always @(TimingViol_data_13   or TimingViol_TOD  )
begin
        TimingViol_data[13]=~TimingViol_data[13];   
end


always @(TimingViol_data_14   or TimingViol_TED  )
begin
        TimingViol_data[14]=~TimingViol_data[14];   
end


always @(TimingViol_data_15   or TimingViol_TOD  )
begin
        TimingViol_data[15]=~TimingViol_data[15];   
end


always @(TimingViol_data_16   or TimingViol_TED  )
begin
        TimingViol_data[16]=~TimingViol_data[16];   
end


always @(TimingViol_data_17   or TimingViol_TOD  )
begin
        TimingViol_data[17]=~TimingViol_data[17];   
end


always @(TimingViol_data_18   or TimingViol_TED  )
begin
        TimingViol_data[18]=~TimingViol_data[18];   
end


always @(TimingViol_data_19   or TimingViol_TOD  )
begin
        TimingViol_data[19]=~TimingViol_data[19];   
end


always @(TimingViol_data_20   or TimingViol_TED  )
begin
        TimingViol_data[20]=~TimingViol_data[20];   
end


`endif


// TASK DEFINITION DESCRIPTION
// ================================



task task_insert_faults_in_memory;
begin
   if (reg_ConfigFault)
   begin   
     for(i = 0;i< fcnt;i = i+ 1) begin
        if(mem_red_array_stuck_at[i] === "mem_array") begin
          if (array_stuck_at[i] === "sa0") begin
           `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data & stuck_at_0fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
          `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] & stuck_at_0fault[i];
          `endif
         end //if(array_stuck_at)
                                        
         if(array_stuck_at[i] === "sa1") begin
         `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data | stuck_at_1fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
         `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] | stuck_at_1fault[i]; 
         `endif
         end //if(array_stuck_at)
       end //if mem_red_array_stuck_at
    
    
     end    // end of for
   end  
end
endtask



task task_read_fault_file;
begin
/*  -----------Implemetation for config fault starts------*/
   msgcnt = X;
   t = 0;
   fault_repair_flag = {max_faults{1'b1}};
   repair_flag = {max_faults{1'b1}};
   if(reg_ConfigFault) 
   begin
      file_ptr = $fopen(reg_Fault_file_name , "r");
      if(file_ptr == 0)
      begin     
          if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: File cannot be opened ",$realtime);
      end        
      else                
      begin : read_fault_file
        t = 0;
        for (i = 0; i< max_faults; i= i + 1)
        begin
         
           stuck0 = {Bits{1'b1}};
           stuck1 = {Bits{1'b0}};
           fault_char1 = $fgetc (file_ptr);
           if (fault_char1 == 8'b11111111)
              disable read_fault_file;
           ret_val = $ungetc (fault_char1, file_ptr);
           ret_val = $fgets(tempStr, file_ptr);
           ret_val = $sscanf(tempStr, "%s %d %d %s",fault_array,fault_word, fault_bit, stuck_at) ;
           flag_error = 0; 
           if(ret_val !== 0)
           begin         
              if(ret_val == 3 || ret_val == 4)
              begin
                if(ret_val == 3)
                   stuck_at = "sa0";

                if(stuck_at !== "sa0" && stuck_at !== "sa1" && stuck_at !== "none")
                begin
                    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: Wrong value for stuck at in fault file ",$realtime);
                   flag_error = 1;
                end    
                      
                if(fault_word >= Words)
                begin
                   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Address out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                if(fault_bit >= Bits)
                begin  
                    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Faulty bit out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                
                        
                if(fault_array !== "mem_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array is not mem_array ",$realtime);
                  flag_error = 1;
                end

                if(fault_array === "red_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array can't be on redundancy array in non redundancy cut.",$realtime);
                  flag_error = 1;
                end

                
                

                if(flag_error == 0)
                //Correct Inputs
                begin
                   if(stuck_at === "none")
                   begin
                       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
                   end
                   else
                   //Adding the faults
                   begin
                      FailureLocn[t] = fault_word;
                      Failurebit[t]  = fault_bit ;
                      std_fault_word = fault_word;
                      fault_row_add[t] = std_fault_word[Addr-1:mux_bits];
                      mem_red_array_stuck_at[t] = fault_array;
                      fault_repair_flag[t] = 1'b0;
                      if (stuck_at === "sa0" )
                      begin
                         stuck0[fault_bit] = 1'b0;         
                         stuck_at_0fault[t] = stuck0;
                      end     
                      if (stuck_at === "sa1" )
                      begin
                         stuck1[fault_bit] = 1'b1;
                         stuck_at_1fault[t] = stuck1; 
                      end

                      array_stuck_at[t] = stuck_at;
                      t = t + 1;
                   end //if(stuck_at === "none")  
                end //if(flag_error == 0)
              end //if(ret_val == 2 || ret_val == 3 
              else
              //wrong number of arguments
              begin
                if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: WRONG VALUES ENTERED FOR FAULTY WORD OR FAULTY BIT OR STUCK_AT IN Fault_file_name ",$realtime); 
                flag_error = 1;
              end
           end //if(ret_val !== 0)
           else
           begin 
               if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
           end    
        end //for (i = 0; i< m
      end //begin: read_fault_file  
      $fclose (file_ptr);

      fcnt = t;
      
      //fault injection at time 0.
      task_insert_faults_in_memory;
  end // config_fault 
end
endtask


task WriteMemX;
begin

`ifdef slm
   $slm_ResetMemory(MemAddr, WordX);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = WordX;
   
`endif        
 task_insert_faults_in_memory;
end
endtask

task WriteMem0;
begin
`ifdef slm
   $slm_ResetMemory(MemAddr, Word0);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = Word0;
  
`endif 
   task_insert_faults_in_memory;
end
endtask


task WriteOutX;                
begin
   OutReg_data <= #0 WordX;
end
endtask


task Invalid_next_cycle_func;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_func = 1;
     `else 
       #0 next_cycle_corrupt_func = 0; 
     `endif  
   end 
end
endtask

task Invalid_next_cycle_dft;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_dft = 1;
     `else 
       #0 next_cycle_corrupt_dft = 0; 
     `endif  
  end
end
endtask

task Invalid_next_cycle_func_tim;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
   #0 next_cycle_corrupt_func <= 1;
  end 
end
endtask

task Invalid_next_cycle_dft_tim;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
  #0 next_cycle_corrupt_dft <= 1;
  end
end
endtask


task ScanOutX;                
begin
   
   dff_SCTRLO_SE.Q <= 1'bx;   
   dff_SDLO_SE.Q <= 1'bx; 
   dff_SDRO_SE.Q <= 1'bx; 
    
   
   SCTRLOint=X;
   SDLOint=X;
   SDROint=X;
    
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   SDLO_data<=1'bx;
   SDRO_data<=1'bx;
    
   `endif
end
endtask

task delScanOutX;                
begin
   delSCTRLO_data<=X;
   delSDLO_data<=X;
   delSDRO_data<=X;
    
end
endtask

task ScanChainX;                
begin
 scanreg_ctrl=1'bx; 
 scanreg_dl=1'bx; 
 scanreg_dr =1'bx; 
  
end
endtask

task mem_blocked;
begin
 
   WriteMemX;
   WriteOutX;
   ScanChainX;
   ScanOutX;//immediately;
   delScanOutX;//immediately
   `ifdef POWER_SEQUENCING_OFF
   `else
   reg_mem_block=1;
   `endif
   debug_level = 2'b11;
end
endtask

task corrupt_all;
begin
 
  WriteMemX;
  WriteOutX;
  ScanChainX;
  ScanOutX;
  delScanOutX;//immediately;
  OutReg_data = WordX; 
  delOutReg_data=WordX;
  
end
endtask

task WriteCycle;                  
input [Addr-1 : 0] Address;
reg [Bits-1:0] tempReg1;
reg [Bits-1:0] tempReg_slm;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;


reg repair_flag;

integer po,i,num,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;
begin

   tempReg1 = WordX;
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];

   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};
   
   if (ValidAddress === X )   begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
        WriteMemX;
        if (INITNint !== 0) begin
        `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
           #0 next_cycle_corrupt_func = 1;
       `else 
           #0 next_cycle_corrupt_func = 0; 
       `endif  
   end 

   end


   if (ValidAddress !== X && next_cycle_corrupt_func === 0  )
   begin
         if (red_en === 1 && ((Row_Add_cmp === repair_add) || (Row_Add_cmp === next_repair_add)) ) begin
             repair_flag = 1'b1;
             
             Bank_sel_integer = 0;
                     
             if (Row_Add_cmp === repair_add) begin
               Col_Add_integer  = Col_Add; 
             end
             else if (Row_Add_cmp === next_repair_add) begin
               Col_Add_integer  = Col_Add + mux; 
             end  
             RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
        end  

        if(repair_flag === 0 && ValidAddress === 1) begin
           `ifdef slm
              $slm_ReadMemoryS(MemAddr, Address, tempReg_slm);
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = Mem[Address];
            `endif
          end  
        else if(repair_flag === 1) begin
           `ifdef slm
//              $slm_ReadMemoryS(RedMemAddr, RedMem_address, tempReg_slm);
          
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = RedMem[RedMem_address];
            `endif
        end
        
        for (num=0;num<Bits;num=num+1) begin
             po=num;        
             if ( Dint [num] !== tempReg1 [po]) begin
                if (Mint[num] === 1'b0)
                   tempReg1[po] = Dint[num];
                else if (Mint[num] === 1'bX)
                   tempReg1[po] = 1'bx;
             end                
        end //for (num=0
            
         if(repair_flag === 0 ) begin    
            if(ValidAddress === 1) begin  
              `ifdef slm
                  tempReg_slm=tempReg1; 
                  $slm_WriteMemory(MemAddr, Address, tempReg_slm);
              `else
                   Mem[Address] = tempReg1;
              `endif
            end
            else begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address Out Of Range. ",$realtime);
            end        
         end
         else if (repair_flag === 1 ) begin
            `ifdef slm
                tempReg_slm=tempReg1; 
//                $slm_WriteMemory(RedMemAddr, RedMem_address, tempReg_slm);
            `else
                RedMem[RedMem_address] = tempReg1;
            `endif
         end
   end //if (ValidAddress !== X
   task_insert_faults_in_memory;
end
endtask 

task ReadCycle;
input [Addr-1 : 0] Address;

reg [Bits-1:0] MemData_tmp;
reg [Bits-1:0] MemData;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;

reg repair_flag;

integer a,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;

begin
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];
   
   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};

   

   if (ValidAddress !== X && next_cycle_corrupt_func === 0 ) begin   
       if(red_en === 1 && ( Row_Add_cmp === repair_add ||  Row_Add_cmp === next_repair_add )) begin
              repair_flag = 1;
              
              Bank_sel_integer = 0;
               
              if(Row_Add_cmp === repair_add) begin
                Col_Add_integer = Col_Add;
              end
              else if (Row_Add_cmp === next_repair_add) begin
                Col_Add_integer = Col_Add + mux; 
              end
              RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
       end

      if(repair_flag === 0) begin
          if(ValidAddress === 1) begin 
           `ifdef slm
              $slm_ReadMemory(MemAddr, Address, MemData);
           `else
              MemData = Mem[Address];
           `endif
          end
          else begin
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Address Out Of Range. Output Corrupted ",$realtime);
             MemData = WordX;
          end
     end
      else if(repair_flag === 1) begin
        `ifdef slm
//           $slm_ReadMemory(RedMemAddr, RedMem_address, MemData);
        `else
           MemData = RedMem[RedMem_address];
        `endif
      end
   end //if (ValidAddress)  
   
   if(ValidAddress === X)
   begin
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Illegal Value on Address Bus. Memory and Output Corrupted ",$realtime); 
         Invalid_next_cycle_func;
   end 
   
  if(ValidAddress !== X && next_cycle_corrupt_func === 0 )
   begin
   for (a = 0; a < Bits; a = a + 1)
   begin
      if (MemData[a] !== OutReg_data[a])
         OutReg_data[a] = WordX[a];
   end//for (a = 0; a <  
         OutReg_data <= MemData;
   end     
end
endtask



// SCAN CHAINS
supply0 gnd;
buf (A_int[0], Aint[0]);
buf (A_int[1], Aint[1]);
buf (A_int[2], Aint[2]);
buf (A_int[3], Aint[3]);
buf (A_int[4], Aint[4]);
buf (A_int[5], Aint[5]);
buf (A_int[6], Aint[6]);
buf (A_int[7], Aint[7]);                  //used for capturing
buf (A_int[8], gnd);
buf (A_int[9], gnd);
buf (A_int[10], gnd);
buf (A_int[11], gnd);
buf (A_int[12], gnd);
buf (A_int[13], gnd);
buf (A_int[14], gnd);   //used for capturing

buf (WEN_int, WENint);
buf (CSN_int, CSNint);
buf (IG_int, IGint);


// Scan flops



// CONTROL SCAN CHAIN
     ST_SPREG_LOLEAK_256x21m8_Tl_SCFF cntrl_scff_0 (.D(A_int[2]), .TI(SCTRLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[0]), .OUTX(scanreg_ctrl));

      
 ST_SPREG_LOLEAK_256x21m8_Tl_SCFF cntrl_scff_1 (.D(A_int[4]), .TI(scanreg_ctrl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[1]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m8_Tl_SCFF cntrl_scff_2 (.D(A_int[6]), .TI(scanreg_ctrl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[2]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m8_Tl_SCFF cntrl_scff_3 (.D(A_int[9]), .TI(scanreg_ctrl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[3]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m8_Tl_SCFF cntrl_scff_4 (.D(A_int[3]), .TI(scanreg_ctrl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[4]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m8_Tl_SCFF cntrl_scff_5 (.D(A_int[11]), .TI(scanreg_ctrl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[5]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m8_Tl_SCFF cntrl_scff_6 (.D(A_int[10]), .TI(scanreg_ctrl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[6]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m8_Tl_SCFF cntrl_scff_7 (.D(A_int[1]), .TI(scanreg_ctrl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[7]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m8_Tl_SCFF cntrl_scff_8 (.D(A_int[0]), .TI(scanreg_ctrl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[8]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m8_Tl_SCFF cntrl_scff_9 (.D(A_int[5]), .TI(scanreg_ctrl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[9]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m8_Tl_SCFF cntrl_scff_10 (.D(A_int[7]), .TI(scanreg_ctrl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[10]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m8_Tl_SCFF cntrl_scff_11 (.D(CSN_int), .TI(scanreg_ctrl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[11]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m8_Tl_SCFF cntrl_scff_12 (.D(A_int[8]), .TI(scanreg_ctrl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[12]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m8_Tl_SCFF cntrl_scff_13 (.D(WEN_int), .TI(scanreg_ctrl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[13]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_256x21m8_Tl_SCFF cntrl_scff_14 (.D(scanreg_ctrl_wire[14]), .TI(scanreg_ctrl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[14]), .OUTX(scanreg_ctrl));  

reg LP_CK_gate;

// Lock Up Latch
wire SCTRLO_temp;
 ST_SPREG_LOLEAK_256x21m8_Tl_lock_up_latch  dff_SCTRLO_SE (Latch_open, scanreg_ctrl_wire[14], SCTRLO_temp);

always @(SCTRLO_temp) begin
     SCTRLOint= SCTRLO_temp;
 `ifdef functional
 `else
 if (SCTRLOint !== SCTRLO_data) begin 
  if (SCTRLOint !==X)
   SCTRLO_data=1'bx;
   SCTRLO_data <= SCTRLOint;
 end 
 `endif
end  


// LEFT DATA SCAN CHAIN
     ST_SPREG_LOLEAK_256x21m8_Tl_SCFF ldata_scff_0 (.D(Dint[10]), .TI(SDLI), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[0]), .OUTX(scanreg_dl));
      
   
 
        ST_SPREG_LOLEAK_256x21m8_Tl_SCFF ldata_scff_1 (.D(Dint[9]), .TI(scanreg_dl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[1]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m8_Tl_SCFF ldata_scff_2 (.D(Dint[8]), .TI(scanreg_dl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[2]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m8_Tl_SCFF ldata_scff_3 (.D(Dint[7]), .TI(scanreg_dl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[3]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m8_Tl_SCFF ldata_scff_4 (.D(Dint[6]), .TI(scanreg_dl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[4]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m8_Tl_SCFF ldata_scff_5 (.D(Dint[5]), .TI(scanreg_dl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[5]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m8_Tl_SCFF ldata_scff_6 (.D(Dint[4]), .TI(scanreg_dl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[6]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m8_Tl_SCFF ldata_scff_7 (.D(Dint[3]), .TI(scanreg_dl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[7]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m8_Tl_SCFF ldata_scff_8 (.D(Dint[2]), .TI(scanreg_dl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[8]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m8_Tl_SCFF ldata_scff_9 (.D(Dint[1]), .TI(scanreg_dl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[9]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_256x21m8_Tl_SCFF ldata_scff_10 (.D(Dint[0]), .TI(scanreg_dl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[10]), .OUTX(scanreg_dl));



// Lock Up Latch
wire SDLO_temp;
 ST_SPREG_LOLEAK_256x21m8_Tl_lock_up_latch  dff_SDLO_SE (Latch_open, scanreg_dl_wire[10], SDLO_temp);

always @(SDLO_temp) begin
     SDLOint= SDLO_temp;
 `ifdef functional
 `else
 if (SDLOint !== SDLO_data) begin 
  if (SDLOint !==X)
   SDLO_data=1'bx;
   SDLO_data <= SDLOint;
 end 
 `endif
end  






// RIGHT DATA SCAN CHAIN

     ST_SPREG_LOLEAK_256x21m8_Tl_SCFF rdata_scff_0 (.D(Dint[20]), .TI(SDRI), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[0]), .OUTX(scanreg_dr));
     
 
 
        ST_SPREG_LOLEAK_256x21m8_Tl_SCFF rdata_scff_1 (.D(Dint[19]), .TI(scanreg_dr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[1]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m8_Tl_SCFF rdata_scff_2 (.D(Dint[18]), .TI(scanreg_dr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[2]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m8_Tl_SCFF rdata_scff_3 (.D(Dint[17]), .TI(scanreg_dr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[3]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m8_Tl_SCFF rdata_scff_4 (.D(Dint[16]), .TI(scanreg_dr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[4]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m8_Tl_SCFF rdata_scff_5 (.D(Dint[15]), .TI(scanreg_dr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[5]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m8_Tl_SCFF rdata_scff_6 (.D(Dint[14]), .TI(scanreg_dr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[6]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m8_Tl_SCFF rdata_scff_7 (.D(Dint[13]), .TI(scanreg_dr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[7]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m8_Tl_SCFF rdata_scff_8 (.D(Dint[12]), .TI(scanreg_dr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[8]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_256x21m8_Tl_SCFF rdata_scff_9 (.D(Dint[11]), .TI(scanreg_dr_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[9]), .OUTX(scanreg_dr)); 


// Lock Up Latch
wire SDRO_temp;
 ST_SPREG_LOLEAK_256x21m8_Tl_lock_up_latch  dff_SDRO_SE (Latch_open, scanreg_dr_wire[9], SDRO_temp);


always @(SDRO_temp) begin
     SDROint= SDRO_temp;
 `ifdef functional
 `else
 if (SDROint !== SDRO_data) begin 
  if (SDROint !==X)
   SDRO_data=1'bx;
   SDRO_data <= SDROint;
 end 
 `endif
end






//


 //////// CAPTURE TASK //////
task scan_acquire;
begin
   if (supply_ok === 1) begin 
      if ( SEsys === 0 && ((LP_CK_gate === 0 && TBYPASSsys !== 1'bx)|| TBYPASSsys===0)) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
         
         Latch_open=1;
         

      end //if ( SEint === 0
   end//if(supply_ok 
end
endtask

task scan_shift;
begin
 if (supply_ok === 1) begin
   if (STDBYint === 0 && SLEEPint === 0) begin
      if (CKint_dft === X && INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0) begin
         ScanChainX;
         ScanOutX;
      end
      else if (CKint_dft === 1 && lastCK_dft === 0 ) begin
          //// SHIFT
        if (SEsys === 1) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
           
        //// SHIFT Ends
        end //if (SEsys === 1
        else if (SEsys === X) begin
            ScanChainX;
            ScanOutX;
            delScanOutX;
        end//if (SEint ==X
      
      end///if (CKint === 
    
      else if (CKint_dft === 0 && lastCK_dft === 1 ) begin
        Latch_open=1;
      end
    end  //if (STDByint === 0 && SLEEPint === 0
 end//if(supply_ok
end
endtask






// BEHAVIOURAL MODULE DESCRIPTION
// ================================

initial
begin
  // Define format for timing value
  $timeformat (-9, 3, " ns", 0);
  `ifdef slm
  $slm_RegisterMemory(MemAddr, Words, Bits);
  `endif   
   reg_mem_block=0;
   flag_mem_block=0;
  `ifdef functional
  `else
   TimingViol_data=0;
   TimingViol_mask=0;
   `endif
   decoding_start=0;
  
   //Parameter Assignment
   
   reg_Fault_file_name = Fault_file_name; 
   reg_ConfigFault     = ConfigFault;
   reg_MEM_INITIALIZE  = MEM_INITIALIZE;
   reg_BinaryInit      = BinaryInit;
   reg_InitFileName    = InitFileName;
   reg_Initn_reset_value = Initn_reset_value;
   reg_File_load_time    = File_load_time;

   time_fall_sleep=0;
   time_fall_PSWLARGEMP=0;
   time_fall_PSWLARGEMP_0=0;
   time_fall_PSWLARGEMA=0;
   time_fall_PSWLARGEMA_0=0;
   time_fall_PSWSMALLMP=0;
   time_fall_PSWSMALLMA=0;

   vddmp_rise_time=0;
   vddmp_fall_time=0;
   vddsmp_rise_time=0;
   vddsmp_fall_time=0;
   vddma_rise_time=0;
   vddma_fall_time=0;
   vddsma_rise_time=0;
   vddsma_fall_time=0;
   vddm_fall_time=0;  
   vddm_rise_time=0;  
   vddsm_fall_time=0; 
   vddsm_rise_time=0;

   next_cycle_corrupt_func=0;
   next_cycle_corrupt_dft=0;
   init_pulse_done = 0;
   power_up_done = 0;
   file_loaded=1;
   debug_level= 2'b01;
   message_status = "ONLY WARNINGS/ERRORS are Switched ON.For INFO also use debug_level=2'b00";
  `ifdef  NO_WARNING_MODE
     debug_level = 2'b11;
     message_status = "All Warning/Errors/Info Messages are Switched OFF";
  `endif  
  `ifdef  ONLY_ERROR_MODE
     debug_level = 2'b10;
     message_status = "All Warning/Info Messages are Switched OFF.Errors are switched on";
  `endif 
  `ifdef  ALL_MSG_MODE
     debug_level = 2'b00;
     message_status = "All Messages are Switched ON";
  `endif 
  
  `ifdef slm
     operating_mode = "SLM";
   `else
      `ifdef functional
         operating_mode = "FUNCTIONAL";
       `else
         operating_mode = "TIMING";
      `endif
   `endif   
  
  if (debug_level < 1) begin
  $display ("%m INFORMATION ");
  $display ("***************************************");
  $display ("The Model is Operating in %s MODE", operating_mode);
  $display ("%s", message_status);
  if(reg_ConfigFault)
  $display ("Configurable Fault Functionality is ON");   
  else
  $display ("Configurable Fault Functionality is OFF");   
  $display("Fault File used by the model Fault_File_Name=%s" ,reg_Fault_file_name);
  $display("Values of Config_fault used in model=%d" ,reg_ConfigFault);
  $display("Values of Mem_INITALIZE used in model=%d" ,reg_MEM_INITIALIZE);
  $display("Values of BinaryInit used in model=%d" ,reg_BinaryInit);
  $display("Values of InitFileName used in model=%s" ,reg_InitFileName);
  $display("Values of Initn_reset_value used in model=%d" ,reg_Initn_reset_value);
  $display("Values of File_load_time used in model=%t" ,reg_File_load_time);

  $display ("***************************************");
  end
     
  task_read_fault_file; 
   if(!INITNint) begin
    if(supply_ok ) begin 
      init_pulse_done = 1;
      power_up_done = 1;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif 
    end 
   end 
        
   lastCK_func = CKint_func;
   lastCK_dft = CKint_dft;

 `ifdef MEM_CONTENTS_SLEEP
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","w");
   $fclose(ptr);
 `endif 

   
end  // initial block ends



//+++++++++++++++++++++++++++++++ CONFIG FAULT IMPLEMETATION ENDS+++++++++++++++++++++++++++++++//
        




//INITN block starts
//================================
always @(INITNint  or supply_ok )
begin
 if (INITNint === 1'b0) begin
   if(supply_ok) begin
     init_pulse_done = 1;
     power_up_done = 1;
     lastCK_func=CKint_func;
     lastCK_dft=CKint_dft;
     next_cycle_corrupt_func = 0;
     next_cycle_corrupt_dft = 0;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif     
   end 
 end        

 if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && INITNint !== 1)
   begin
     ScanOutX;
     ScanChainX;
     delScanOutX;
   end  
         
 if (init_pulse_done === 0 && INITNint !== 0) begin
     if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) INFO: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
 end
 
end//always @(INITNint)


// Clock Generation 
//wire gated_clock;
//wire clock_gate_en;
//ST_SPREG_LOLEAK_256x21m8_Tl_lock_up_latch CK_SE_latch (!CK , SE, SE_latch_CK);
//and (clock_gate_en, ATP, TBYPASS, !SE_latch_CK);

//ST_SPREG_LOLEAK_256x21m8_Tl_lock_up_latch LP_latch (!CK , scanreg_ctrl_wire[14], LP_latch_CK);
//and (gated_clock,CK,!LP_latch_CK);
//assign CK_new= clock_gate_en ===0 ? CK : (clock_gate_en ===1 ? gated_clock: (CK===0) ? 0 :1'bx);


// Clock Generation Ends


// Functional CK block starts
//======================================
always @(CKint_func)
begin
   lastCK_func=CKreg_func;  
   CKreg_func=CKint_func;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
        if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
      if (CKreg_func === 1'bX || (CKreg_func === 1'b1 && lastCK_func === 1'bx)) begin
        if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
         
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
         Invalid_next_cycle_func;
        end
      end
      else if (CKreg_func === 1'b1 && lastCK_func === 1'b0 ) begin
        time_CK_func_rise=$realtime;
        MEMEN_prev = MEMEN_reg;
        MEMEN_reg = MEMEN;
        CSNreg = CSNint;
        IGreg = IGint;
        DEreg = DEint;
        SE_reg = SEsys;
        TBYPASS_reg = TBYPASSsys;
        ATPreg = ATPint;
        INITNreg = INITNint;
        SLEEPreg = SLEEPint;
        STDBYreg = STDBYint;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 

    `ifdef functional
    `else
        Mem_last=Mem[Aint];
    `endif 
        if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.INITN pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SLEEP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.STANDBY pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg === X && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.chip select  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg === X && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.IG pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg === X && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.Debug pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg === X && (SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.ATP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg === X && TBYPASS_reg !== 1) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SE pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg !== 1 && TBYPASS_reg === X) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.TBYPASS pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end

        else if ((INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0))) && WENint === X) begin
            // Uncertain write cycle
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: write enable going to X  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end 
        else if (next_cycle_corrupt_func === 1) begin
          next_cycle_corrupt_func = X;
        end
        else if (next_cycle_corrupt_func === 1'bx) begin
          next_cycle_corrupt_func = 0;
        end 
        
//        if (next_cycle_corrupt_func === 0 ) begin 
         
          /*---------------------- File initialization -----------------*/
          
          if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0)) && flag_mem_block === 1'b0) begin
                 Areg=Aint;
                 Dreg=Dint;
                 Mreg=Mint;
                 WENreg=WENint;     
             if (reg_MEM_INITIALIZE === 1'b1 && $realtime >= reg_File_load_time && file_loaded ) begin   
                `ifdef slm
                  if (reg_BinaryInit)
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_BIN");
                  else
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_HEX");
   
                `else
                  if (reg_BinaryInit)
                     $readmemb(reg_InitFileName, Mem, 0, Words-1);
                  else
                     $readmemh(reg_InitFileName, Mem, 0, Words-1);
                `endif
                 file_loaded = 0;
             end
   
             if (^Aint === X)
               ValidAddress = X;
             else if (Aint < Words)
               ValidAddress = 1;
             else    
               ValidAddress = 0;
   
             if(red_en === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Redundancy Enable is Invalid. Either RRAE is X or TRRAE is X",$realtime);
                ValidAddress = X; 
           end
           else if(red_en === 1'b1 && ^repair_add === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Repair Address is invalid.RRA is X",$realtime);
                ValidAddress = X;
           end
             
             if (ValidAddress)
               `ifdef slm
                   $slm_ReadMemoryS(MemAddr, Aint, Mem_temp);
               `else
                    Mem_temp = Mem[Aint];
               `endif
             else
                Mem_temp = WordX;  
          
     /*---------------------- Normal Read and Write -----------------*/
     
             if (WENint === 1) begin
               ReadCycle(Aint);
             end
       
             else if (WENint === 0) begin
               WriteCycle(Aint);
             end 
                
          
          end //  if (MEMEN === 1'b1 
       
//        end  // if (next_cycle_corrupt_func === 0
      
      end // if (CKint = 1   
   end // if (init_pulse_done === 1           
 end 
end // always @(CKint_func)
        
always @(MEMEN)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) && CKint_func === 1'bx) begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.clock pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
    Invalid_next_cycle_func;
  end
 end 
end

// DFT CK block starts
//======================================
always @(CKint_dft) 
begin
   lastCK_dft=CKreg_dft;
   CKreg_dft=CKint_dft;
   
   Latch_open=0;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
     if (CKreg_dft === 1'bX || (CKreg_dft === 1'b1 && lastCK_dft === 1'bx)) begin
       if (INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0 ) begin
        
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: DFT clock  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime); 
         Invalid_next_cycle_dft;
         if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
           WriteOutX;
         end
       end
     end 

     if(CKint_dft === 0 && lastCK_dft === 1) begin
      if(ATPreg === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
       if(SE_reg === 1'b1 && SEsys === 1'b0) begin
        if(TBYPASSint === 1'b1) begin   
    
       
       
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9], scanreg_dl_wire[scanlen_l-1]}; 
       


         for (i = 0; i < Bits; i = i + 1)
         begin
          if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
         end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
        end 
       end
      end
     end 
     
     else if (CKreg_dft === 1'b1 && lastCK_dft === 1'b0 ) begin
       SE_reg = SEsys;
       TBYPASS_reg = TBYPASSsys;
       ATPreg = ATPint;
       INITNreg = INITNint;
       SLEEPreg = SLEEPint;
       STDBYreg = STDBYint;
       MEMEN_dft_prev = MEMEN_dft_reg;
       MEMEN_dft_reg = MEMEN_dft;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 
       if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ) begin 
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
 //     else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys === X && TBYPASSsys !== 1) begin
///           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
//           Invalid_next_cycle_dft;
//        end       
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys === X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
        end 
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys !== 0 && LP_CK_gate===X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: LP FLOP Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           ScanChainX;
           ScanOutX;   
          if( TBYPASSint !== 0 && SEint !== 1) begin
            WriteOutX;
          end
          next_cycle_corrupt_dft=0;
        end        
       else if (next_cycle_corrupt_dft === 1'b1) begin 
         next_cycle_corrupt_dft = X;
       end 
       else if (next_cycle_corrupt_dft === 1'bx) begin
         next_cycle_corrupt_dft = 0;
       end
       
       if (next_cycle_corrupt_dft === 0 ) begin
         
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1 && flag_mem_block === 1'b0) begin
           
           if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0  && LP_CK_gate===0) begin
              OutReg_data_tbypass = Dint;
              for (i = 0; i < Bits; i = i + 1)
              begin
               if (OutReg_data_tbypass[i] !== OutReg_data[i])
                 OutReg_data[i] = WordX[i];
              end//for (i = 0; i < */ 
              OutReg_data <= OutReg_data_tbypass;
           end
           
             scan_acquire;
         end //MEMEN_dft == 1        
       end // if ( next_cycle_corrupt_dft
       
     end // if (CKint_dft === 1'b1
      //  if (next_cycle_corrupt_dft === 0 ) begin 
       if (SE_reg !== 0) begin
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1  && flag_mem_block === 1'b0) begin
           next_cycle_corrupt_dft = 0;
           if ( next_cycle_corrupt_func === 1) begin
	    next_cycle_corrupt_func = 0 ;
	   end	
           scan_shift;
         end
       end
     //end // if ( next_cycle_corrupt_dft    
     if ((!(TBYPASSsys!==0 && SEsys!==1 && LP_CK_gate!==0 ) && next_cycle_corrupt_dft === 0) || CKint_dft !==1) begin          
       CK_sc=INITNreg & !STDBYreg & !SLEEPreg & ATPreg & CKreg_dft ;
     end     
   end // if (init_pulse_done 
 end // if (supply_ok 
end // always @(CKint_dft)

always @(MEMEN_dft)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) && CKint_dft === 1'bx)  begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.MEMEN_dft and clock should not be X at this time instant. ScanChains and ScanOuts Corrupted ",$realtime); 
    Invalid_next_cycle_dft;
    
    if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
      WriteOutX;
    end
  end
  if ( MEMEN_dft !== 0 && TBYPASSsys !== 0 && SEsys !== 1) begin
     WriteOutX;
     OutReg_data = WordX; 
     delOutReg_data=WordX;
 end 
end
end //always @(MEMEN_dft

always @(TBYPASSsys or ATPint)
begin
   if(supply_ok === 1'b1) begin 
    if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0 && INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1) begin
      if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
    end  
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint === X && SEsys !== 1) ) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end 
end //always @(TBYPASSint





always @(SEsys)
begin
 if(supply_ok === 1'b1) begin 
  if(CKint_dft === 0 && ATPint === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
    if(SE_reg === 1'b1 && SEsys === 1'b0) begin
      if(TBYPASSsys === 1'b1) begin
  
     
         
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9], scanreg_dl_wire[scanlen_l-1]};
           
      


        for (i = 0; i < Bits; i = i + 1)
        begin
         if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
        end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
      end
    end
  end
  if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0) begin
      if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
  end 
  else if ((TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint === X && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end   
end

//assign output data
`ifdef functional        

   
always @(SDLOint)
#0.001 delSDLO_data<=SDLOint;

always @(SDROint)
#0.001 delSDRO_data<=SDROint;

 
always @(SCTRLOint)
#0.001 delSCTRLO_data<=SCTRLOint;


always @(OutReg_data)
   #0.001 delOutReg_data = OutReg_data;
`else
`endif

/***************************** Embeded switch functionality starts here ***********************************/





always @(STDBYint)
begin
  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0 && STDBYint !== 1'b0)
    begin
      ScanOutX;
      ScanChainX;
     delScanOutX;     
    end
  end
end



always @(SLEEPint)
begin


  if (SLEEPint !== 1'b1) begin
    time_fall_sleep = $realtime;
  end

  if (power_up_done === 0)
    begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
    end
  else begin
    if (SLEEPint === 1'b1 && lastSLEEP === 1'b0 ) begin 
      
    end
    else if (SLEEPint !== 1'b1 && lastSLEEP === 1'b1 && full_shutdown !== 1) begin 
      
      if (supply_ok !== 1 && ($realtime > 0)) begin
         if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID LOW_POWER) ERROR: ISOLATION signal removed from the memory but array and periphery supply is not completely switched on.Very High Current would be drawn by the memory. All further operations on memory are blocked",$realtime);
          WriteMemX;
          WriteOutX;
          ScanChainX;
          OutReg_data = WordX; 
          delOutReg_data=WordX;
          ScanOutX;//immediately;
          delScanOutX;//immediately;
          init_pulse_done = 0;
          power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            debug_level = 2'b11;
          `endif
          
      end        
      
       
    end   
    else if (SLEEPint === X && lastSLEEP === 1'b0 && full_shutdown !== 1'b1) begin 
     
    end 
  end  


  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && SLEEPint !== 0)
    begin
      ScanOutX;
      ScanChainX;
        delScanOutX;      
    end
  end

// if (init_pulse_done === 0)
//   begin
//     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
//   end
//
// else if ( SLEEPint !== 1 && (supply_ok !==1) ) begin
//    
//    WriteOutX;
//    OutReg_data = WordX; 
//    delOutReg_data=WordX;
//    ScanOutX;//immediately;
//    delScanOutX;//immediately;
//    ScanChainX;
//    WriteMemX;
//    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies with sleep/Power down signal being low.This scenario can lead to high dc currents and some reliability issues Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
// end

 print_sleep;    
 lastSLEEP=SLEEPint;
end

/********************************** Embeded switch functionality ends here *******************************/

task print_sleep;
begin
  if (SLEEPint === 1'b0) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been deasserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end  
  else if (SLEEPint === 1'b1) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been asserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_ACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif

  end        
  else begin
      if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) ERROR: SLEEP pin is at an invalid state.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INVALID in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end        
end
endtask





 

//// C28SOI non flip compiler power functionality 
always @(gndmreg )
begin
 if (power_up_done === 1 && $realtime > 0) begin    
    if(gndmreg !== 1'b0 ) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or gndsm is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
        corrupt_all;
        init_pulse_done = 0;
        power_up_done = 0;
     `ifdef NO_BLOCK_MEM
     `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of ground pins.Ground must be maintained at 0 Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime);
        debug_level = 2'b11;
     `endif   

    end   
 end

end




always @(vddmareg )
begin

if (vddmareg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddma(Array Supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 
    end
   end   
   else if (SLEEPint === 1) begin
    WriteMemX;
   end

end

if ((vddmareg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1 ) && $realtime > 0) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddm or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         corrupt_all;
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif

end


end

always @(vddmpreg )
begin
 if (vddmpreg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or vddsmp is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmp(Periphery Supply)/vddsmp(Substrate power supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 

    end
   end   
   else if (SLEEPint === 1) begin
    WriteOutX;
    ScanChainX;
    ScanOutX;
    delScanOutX;//immediately;
    OutReg_data = WordX; 
    delOutReg_data=WordX;
   end
 end

if( (vddmpreg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1'b1 )  && $realtime > 0) begin
         corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif
end
 
 
end


always @(vddmoreg)
begin
  if (power_up_done === 1 && $realtime > 0) begin   
      if (vddmoreg !== 1'b1)  begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin
           corrupt_all;
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
         end //if (vddmareg === 1'b1 

      else if (vddmareg === 1'b0 && vddmpreg === 1'b0   && SLEEPint === 1'b1 &&  $realtime > 0)
        begin 
            if((debug_level < 2) && ($realtime > 0)) $display("%m - %t WARNING: Illegal Value on power pin(s). Memory and Output Corrupted ", $realtime);
 
           corrupt_all;
        end //else if (vddmareg === 1'b 
     end   // if (vddmoreg !== 1'b1)
     else if (vddmoreg === 1'b1 && $realtime > 0 ) begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin     
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           corrupt_all;
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
        end        
     end // else if (vddmoreg === 1'b1
  end 
end // always @(vddmoreg)












always @(gndmreg) begin
 if (gndmreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 0. ",$realtime);
 end
 else if (gndmreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 1. ",$realtime);
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to invalid state. ",$realtime);
 end
end




 
always @(vddmareg) begin
 if (vddmareg === 0) begin 
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 0. ",$realtime);
  vddma_fall_time = $realtime;
 end
 else if (vddmareg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 1. ",$realtime);
  vddma_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to invalid state. ",$realtime);
  vddma_fall_time = $realtime;
 end 

 

end

always @(vddmpreg) begin
 if (vddmpreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 0. ",$realtime);
  vddmp_fall_time = $realtime;
 end
 else if (vddmpreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 1. ",$realtime);
  vddmp_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to invalid state. ",$realtime);
  vddmp_fall_time = $realtime;
 end

 
 
end



// end of C28SOI power functionality 
 


assign supply_ok          =  (vddmareg === 1'b1 && vddmpreg  === 1'b1  && gndmreg === 1'b0 && vddmoreg === 1'b1 ) ? 1'b1 : 1'b0;
assign core_supply_ok     =  (vddmoreg === 1'b1 && vddmareg === 1'b1 && gndmreg === 1'b0 ) ? 1'b1 : 1'b0;
assign peri_supply_ok     =  (vddmoreg === 1'b1 && vddmpreg === 1'b1 && gndmreg === 1'b0  ) ? 1'b1 : 1'b0;

assign full_shutdown = (vddmpreg === 1'b0 && vddmareg === 1'b0   ) ? 1'b1 : 1'b0 ;




`ifdef functional
`else


task WriteLocMskX_bwise;
   input [Addr-1 : 0] Address;
   input [Bits-1 : 0] Mask;

reg [Bits+Red_extrabit:0] tempReg1;
integer num1; 
begin
   tempReg1 = WordX;
   if (^Address !== X )
   begin
      tempReg1 = Mem[Address];
             
      for (j = 0;j< Bits; j=j+1) begin
         num1=j;
        if (Mask[j] === 1'bx)
            tempReg1[num1] = 1'bx;
      end
      Mem[Address] = tempReg1;
      task_insert_faults_in_memory;
   end//if (^Address !== X
   else begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      WriteMemX;
   end   
end
endtask


/****************Actions taken on timing violations*****************/

 always @(TimingViol_data)
// tds or tdh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  for (l = 0; l < Bits; l = l + 1) begin   
    if (CSWEMTBYPASS[l] !== 0) begin
     if((TimingViol_data[l] !== TimingViol_data_last[l])) begin


         Mreg[l] = 1'bx;
     end    
     WriteLocMskX_bwise(Areg,Mreg);
    end   
   end 
  end
    if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin
     scanreg_dl =1'bx; 
     scanreg_dr =1'bx; 
     SDLOint=X;
     SDROint=X;
     `ifdef functional
     `else
     SDLO_data<=1'bx;
     SDRO_data<=1'bx;
     `endif
    end
     TimingViol_data_last = TimingViol_data; 
end





always @(TimingViol_addr)
// tas or tah
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
      scanreg_ctrl=1'bx; 
      SCTRLOint=X;
      `ifdef functional
      `else
      SCTRLO_data<=1'bx;
      `endif
  end
end


always @(TimingViol_WEN)
//tws or twh
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WEN pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end 

always @(TimingViol_CSN )
// tps or tph 
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;

   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CSN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end

always @(TimingViol_tcycle )
//tcycle
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
   if (MEMEN !== 0 && MEMEN_prev !== 0) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckl )
// tckl 
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckh) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end


always @(TimingViol_tcycle_se )
//tcycle_se
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckl_se  )
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckh_se) begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tbist) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
   end
   if (TBYPASSint !== 1'b0) begin 
    WriteOutX;
   end 
   if (INITNreg !==0 && STDBYreg !== 1 && TBYPASS_reg !== 1 && SLEEPreg !== 1 && SE_reg !== 1 && IGreg !== 1 && DEreg !== 1) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBIST pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end






always @(TimingViol_tbypass)
//ttmck
begin
#0  
  WriteOutX;
  if (INITNreg !== 0 && SLEEPreg !== 1 && SE_reg !== 1 && STDBYreg !== 1 &&  DEreg !== 1) begin
   Invalid_next_cycle_dft_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
end



always @(TimingViol_sleep)
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_stdby)
begin
#0
  if (CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin 
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (ATPreg !== 0) begin 
   Invalid_next_cycle_dft_tim;
  end
end






always @(TimingViol_se) begin
#0
   if (TBYPASS_reg !== 0) begin 
    WriteOutX;
   end 
  if (TBYPASS_reg === 0) begin
     WriteOutX;
     WriteMemX;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE timing violation  Memory State Machine is corrupted. Output Corrupted ",$realtime); 
  end 
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
  end
end

always @(TimingViol_sctrli) begin
  scanreg_ctrl=1'bx; 
end


always @(TimingViol_sdli) begin
 scanreg_dl=1'bx; 
end

always @(TimingViol_sdri) begin
   scanreg_dr=1'bx;
end

 

always @(TimingViol_initnl) begin
init_pulse_done=0;
WriteOutX;
OutReg_data = WordX; 
delOutReg_data=WordX;
ScanOutX;
delScanOutX;
ScanChainX;
WriteMemX;
end

always @(TimingViol_initn) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end

always @(TimingViol_ig) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && INITNreg !== 0 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: IG pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   ScanChainX;
   ScanOutX;
   delScanOutX;       
  end
end

always @(TimingViol_atp) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin  
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_rm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^WMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: RM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
   end
end
 
always @(TimingViol_wm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^RMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);        
   end
end 


`endif


endmodule




module ST_SPREG_LOLEAK_256x21m8_Tl_lock_up_latch (EN,D,Q);
input EN,D;
output reg Q;

  always @ (EN or D) begin
    if (EN === 1) begin
       Q = D;
    end
    else if ((EN === 1'bz || EN === 1'bx  )&& D !== Q) begin
        Q=1'bx;
    end    
  end
endmodule

module ST_SPREG_LOLEAK_256x21m8_Tl_SCFF (D,TI,TE,CP,Q,OUTX);
input D,TI,TE,CP;
input OUTX;
output reg Q;
wire Dint;
assign Dint= (TE===1)?TI:(TE===0)?D:1'bx;

always @(posedge CP)
        begin
          if(Dint === 1'bZ || CP ===1'bx || OUTX === 1'bx)
          begin
                  Q = 1'bx;
          end
          else
          begin
                  Q = Dint;
          end        
        end
always @(posedge OUTX)
Q = 1'bx;
endmodule



`undef setup_time
`undef hold_time
`undef access_time
`undef retain_time
`undef cycle_time
`undef pulse_width_time
`undef initin_low_pulse


`delay_mode_path
`endcelldefine
`nosuppress_faults






/****************************************************************
--  Description         : Verilog Model 
--  ModelVersion        : 1.2
--  Date                : Apr, 2013
--  Changes Made by	: PS
--  Revision History    : 
 
****************************************************************/


/******************** START OF HEADER****************************
   This Header Gives Information about the parameters & options present in the Model
   
   words = 64
   bits  = 64
   mux   = 4 
   
   write_mask = yes 
   
   
   
   margin_control = yes 
   
   
   Dft = Yes  

    ------------------------------------------------------------------------------------
     Signal Name             | Description       |             Port Mode        | Active When
                             |                   |          r    |  w   | rw    |
   ------------------------------------------------------------------------------------

    D 	        Data in                     na     x      na       -  
    IG    Input Gate Enable           x      x      na       High     
    ATP            ATPG Enable                 x      x      na       High     
    INITN                 INITN pin                   x      x      na       Low
    
    
    
    M             Mask in                     na     x      na       High  
    Q 	        Data out	            x      na     na       -
    A              Address                     x      x      na       high and low
    
    CK                Clock	                    x      x      na       posedge
    CSN          Chip Enable                 x      x      na       low
    
    RM         Read Margins                 x      x      na       High 
    SCTRLI         Scan Input (Control)
    SCTRLO        Scan Output (Control)
    SDLI         Scan Input (Data-Left)
    SDLO        Scan Output (Data-Left)
    SDRI         Scan Input (Data-Right)
    SDRO        Scan Output (Data-Right)
    SE          Scan Enable pin 
    STDBY              Standby pin                 x      x      na       High
    
    SLEEP                        Sleep pin                   x      x      na        High 
    
     
    
    SMLI         Scan Input (Mask-Right)        
    SMLO        Scan Output (Mask-Left)
    SMRI         Scan Input (Mask-Left)
    SMRO        Scan Output (Mask-Right)  
    TBIST          Bist Enable Pin 
    
    TBYPASS                      Memory Bypass                na     na     na        High
    
    TED        Bist Even Data pin
    TOD         Bist Odd Data Pin
    
    TEM        Bist Even Mask pin
    TOM         Bist Odd Mask Pin  
    TA         Bist Read Address
    TCSN     Bist Read Chip Select
    
    TWEN    Bist Write Enable 
    WEN         Write Enable                na     x      na       Low 
    
    WM        Write Margins Code          x      x      na       -
     

******************** END OF HEADER ****************************/


//********************************************//
// ST_SPREG_LOLEAK_64x64m4_bTl Verilog Model                 //  
//********************************************//




`ifdef slm
        `define functional
`endif

`celldefine
`suppress_faults
  `ifdef functional
   `delay_mode_unit
  `else
   `delay_mode_path
  `endif

`define setup_time 0.0
`define hold_time 0.0
`define access_time 1.0
`define retain_time 0.9
`define cycle_time 0.0
`define pulse_width_time 0.0
`define initin_low_pulse 0.0



 






`timescale 1ns / 1ps


module ST_SPREG_LOLEAK_64x64m4_bTl (A,ATP,CK,CSN,D ,IG,INITN , M, Q ,RM    ,SCTRLI,SCTRLO,SDLI,SDLO,SDRI,SDRO,SE,SLEEP  ,SMLI,SMLO,SMRI,SMRO , STDBY  ,TA,TBIST   ,TBYPASS ,TCSN,TED ,TEM ,TOD  ,TOM  ,TWEN ,WEN,WM  );

 parameter
  Words = 64,
  Bits = 64,
  Addr = 6,
  mux = 4,
  repair_address_width = 4,
  write_margin_size = 2, 
  read_margin_size = 3; 

 //  INPUT OUTPUT PORTS DECLARATION DONE SEPARATELY FOR SPREG and ROM
 // ========================


        output [Bits-1 : 0] Q;
         
        output SCTRLO;
        input SE,SCTRLI;
        
        input [Addr-1 : 0] A;
        
        input [read_margin_size-1 : 0] RM;
        
         
        input CK,CSN,INITN,IG,ATP; 
        
        
        input [Addr-1 :0 ] TA;
input TBIST,TCSN ;
        
        input STDBY;
        
        input SLEEP; 
        
         
        
        
         
        output SDLO;
        output SDRO;
        
        output SMLO,SMRO;
        
        
        
        input [Bits-1 : 0] D ;
	
        
        input [63 :0] M;
         
         
        
        input [write_margin_size-1 : 0] WM;
        
        
        input TBYPASS;
        
        input WEN;
        
        
         
        input SDLI,SDRI ,SMLI,SMRI ; 
        
        
        
        //Bist inputs
        // ===========
        input TWEN,TED,TOD; 
        
        input TEM,TOM; 
        
        
        

        






    parameter
        Fault_file_name = "ST_SPREG_LOLEAK_64x64m4_bTl_faults.txt",
        `ifdef ConfigFault
        ConfigFault = 1,
        `else
        ConfigFault = 0,
        `endif
        max_faults = 66,
        
        MEM_INITIALIZE  = 1'b0,
        BinaryInit = 1'b0, 
        InitFileName = "ST_SPREG_LOLEAK_64x64m4_bTl.cde",
        Debug_mode = "all_warning_mode",
        File_load_time=0,
        Initn_reset_value={64{1'b0}},
        InstancePath = "ST_SPREG_LOLEAK_64x64m4_bTl";
    
    parameter
        
        bank = 1, 
        mux_bits=2,
        Red_extrabit=0,
        bank_bits = 0,
        RedWords = mux * 2 * bank,
        max_address_bits = 15 ,
        Rows = Words/mux;


        parameter mask_bits = 64;   
    parameter 

     

        
           scanchains=5,    
          
        
        scanlen_ctrl=15,
        
        

      

        
        scanlen_r=(Bits)/2,
        
        scanlen_l=(Bits+1)/2 ; 
      
      

    parameter
        
        `ifdef functional  
            RW_assertions_en = 0,
        `endif
        WordX = {Bits{1'bx}},
        AddrX = {Addr{1'bx}},
        Word0 = {Bits{1'b0}},
        X = 1'bx;
   



//  WIRE DECLARATION RELATED TO POWER PINS
//  ======================================
	
        wire supply_ok, full_shutdown;
        
        wire core_supply_ok;
        wire peri_supply_ok;

        wire gndmint, gndsmint;
         
        
        wire vddmpint;
        wire vddmoint;
        wire vddmaint;
        wire vddsmpint;  
        wire vddsmaint;  
        
        

//  WIRE DECLARATION 
//  ==================
        wire [Bits-1 : 0] CSWEMTBYPASS;
        wire [Bits-1 : 0] Dint, Dsys;
        wire [Bits-1 : 0] Mint; 
        wire [64-1:0] Msys;
	wire [Addr-1 : 0] Aint;
        wire [Addr-1 : 0] Asys;

       


        wire [max_address_bits-1 : 0] A_int; 
                
	wire CKint_dft;
	wire CKint_func;
	wire CSNint;
        wire MEMEN;
        wire MEMEN_dft;
        wire TSE;

	wire WENint;
	wire WENsys;
        wire SLEEPint;
        wire STDBYint;
        wire SEint;
        wire SEsys;
        wire SCTRLIint;
        wire SDLIint;
        wire SDRIint;
        
        wire SMLIint;
        wire SMRIint;
        
        wire INITNint;
        wire TBYPASSint;
        wire TBYPASSsys;
        wire LSint; 
        wire HSint; 
        wire ATPint;
        wire DEint;
        
        wire [Addr-1 : 0] TAint;
        wire TBISTint;
        wire TBISTsys;
        wire TCSNint;
        wire TEDint;
        wire TODint;
        wire TEMint;
        wire TOMint;
        wire [Bits-1 : 0] TMint;
        wire [Bits-1 : 0] TDint;
        wire TWENint;
        wire IGint;
        wire IGbuf;
        wire CSNbuf;
        wire WENbuf;
        wire [read_margin_size-1:0] RMint;
        wire [write_margin_size-1:0] WMint;

        //Wires for scan chains
        //  ====================     
        wire [scanlen_ctrl -1:0]scanreg_ctrl_wire;
        wire [scanlen_l -1:0]  scanreg_dl_wire; 
        wire [scanlen_r -1:0]  scanreg_dr_wire; 
   
        wire [scanlen_l -1:0]  scanreg_ml_wire; 
        wire [scanlen_r -1:0]  scanreg_mr_wire; 


        wire [repair_address_width -1 : 0] RRAint;
        wire RRAEint;
        wire TRRAEint;    
        wire red_en;
        wire [repair_address_width -1 : 0] repair_add, next_repair_add;


//  REG DECLARATION
//  ====================     
        reg MEMEN_reg;
        reg MEMEN_prev;
        reg reg_mem_block;
        reg flag_mem_block;
        reg SCTRLIint_temp;
        reg SDLIint_temp;
        reg SDRIint_temp;
        reg SMLIint_temp;
        reg SMRIint_temp;

        //  REG DECLARATION
        //  ====================
        reg SCTRLOint;
        
        reg SDLOint,SDROint;
        
        reg SMLOint,SMROint;   
        
        reg next_cycle_corrupt_func;
        reg next_cycle_corrupt_dft;
        reg [Bits-1 : 0] delOutReg_data;//delayed Output Register
        reg [Bits-1 : 0] OutReg_data;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_tbypass;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_scan;   // Data Output registe
        reg [Bits-1 : 0] OutReg_rado_retained;   // register for retaining rado data when SLEEP --> 1
        reg delSCTRLO_data,SCTRLO_data;      // delayed Output Register
        reg delSDLO_data,SDLO_data;      // delayed Output Register
        reg delSDRO_data,SDRO_data;      // delayed Output Register
        
        reg delSMLO_data,SMLO_data;      // delayed Output Register
        reg delSMRO_data,SMRO_data; 
        
        // SCAN CHAINS register
        reg scanreg_ctrl; 
        reg scanreg_dl; 
        reg scanreg_dr; 
         
        reg scanreg_ml; 
        reg scanreg_mr; 
        
        
        reg CK_sc;
        reg Latch_open=0;
        reg lastCK_dft,CKreg_dft;
        reg lastCK_func,CKreg_func;
        reg lastSLEEP;
        reg lastPSWLARGEMP,lastPSWLARGEMA,lastPSWSMALLMP,lastPSWSMALLMA;
        reg CSNreg;
        reg init_pulse_done; //if == 1 then it implies that initb low pulse has been applied
        reg power_up_done; //if == 1 then it implies that power up has been done
        `ifdef slm
        `else
	      
             reg [Bits-1 : 0] Mem [Words-1 : 0];
             reg [Bits-1 : 0] RedMem [RedWords-1 : 0];
 
        `endif
        
	reg [Bits-1 :0] Mem_temp;
        reg [Bits-1 :0] Mem_slm; 
	reg ValidAddress;
	reg ValidDebugCode;
        reg decoding_start;
        reg file_loaded;
        reg [Bits-1 :0] Dreg;
        reg [Bits-1 :0] Mreg;
        reg WENreg;
        reg [Addr-1 :0] Areg;
        reg SE_reg;
        reg TBYPASS_reg;
        reg INITNreg;
        reg IGreg;
        reg DEreg;
        reg SLEEPreg;
        reg STDBYreg;
        reg ATPreg;
        reg MEMEN_dft_reg;
        reg MEMEN_dft_prev;
        reg RRMATCHreg;
        reg RRMATCHreg_last;//changes_made
        reg RRMATCHreg_glitch;
        reg [repair_address_width -1 : 0] repair_add_last;
        reg RRAEint_last;
        reg [Addr-mux_bits-1:0] row_add_temp;
        reg [Addr-mux_bits-bank_bits-1:0] row_add_cmp_temp;

       
        //parameter registers
        reg [2047:0] reg_Fault_file_name;
        reg reg_ConfigFault;
        reg reg_MEM_INITIALIZE;
        reg reg_BinaryInit;
        reg [2047:0] reg_InitFileName;
        reg [Bits -1 :0] reg_Initn_reset_value;
        time reg_File_load_time;

        //Power Supply Registers        
        reg vddmireg;
        reg vddmreg;
        reg vddsmreg;
        reg gndmreg;
        reg gndsmreg;   
        reg vddmpreg;
        reg vddmpireg;
        reg vddmareg;
        reg vddsmpreg;
        reg vddsmareg;
        reg vddmoreg;
        time vddmp_rise_time;
        time vddmp_fall_time;
        time vddsmp_rise_time;
        time vddsmp_fall_time;
        time vddma_rise_time;
        time vddma_fall_time;
        time vddsma_rise_time;
        time vddsma_fall_time;
        reg reg_check_rise;
        reg reg_check_fall;
        reg reg_check_rise_vddma;
        reg reg_check_fall_vddsma;
        reg  reg_check_rise_vddm, reg_check_fall_vddsm ;
        time vddm_fall_time,  vddm_rise_time,  vddsm_fall_time, vddsm_rise_time ;
  /* This register is used to force all warning messages 
  ** OFF during run time.
  ** It is a 2 bit register.
  ** USAGE :
  ** debug_level_off = 2'b00 -> ALL MESSAGES(INFO/WARNINGS/ERRORS) will be DISPLAYED 
  ** debug_level = 2'b01     -> ONLY WARNINGS/ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b10     -> ONLY ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b11     -> NO MESSAGES will be DISPLAYED.
  */ 
        reg [1:0] debug_level;
        reg [8*10: 0] operating_mode;
        reg [8*44: 0] message_status;

        integer i, k, j, l,m,q,w,r,s,num1,redcnt,n,num2,FirstHalf,Bfaileff,memcnt,ptr;
        integer decoder[Bits-1:0];
        `ifdef slm
           integer MemAddr;
        `endif


        //************************************************************
        //****** CONFIG FAULT IMPLEMENTATION VARIABLES*************** 
        //************************************************************ 

        integer file_ptr, ret_val;
        integer fault_word;
        integer fault_bit;
        integer fcnt, Fault_in_memory,faultnum,stop_loop,count;
        integer t;  
        integer FailureLocn [max_faults -1 :0];
        integer Failurebit [max_faults -1 :0];
        reg [100 : 0] stuck_at;
        reg [100 : 0] fault_array;
        reg [200 : 0] tempStr;
        reg [7:0] fault_char;
        reg [7:0] fault_char1; // 8 Bit File Pointer
        reg [Addr -1 : 0] std_fault_word;
        reg [Addr -1 : mux_bits] fault_row_add [max_faults -1 :0];
        reg [max_faults -1 :0] fault_repair_flag;
        reg [max_faults -1 :0] dont_insert_fault;
        reg [max_faults -1 :0] repair_flag;
        reg [100 : 0] array_stuck_at[max_faults -1 : 0] ;
        reg [100 : 0] mem_red_array_stuck_at[max_faults -1 : 0] ; 
        reg msgcnt;
        
       
        reg [Bits - 1: 0] stuck_at_0fault [max_faults -1 : 0];
        reg [Bits - 1: 0] stuck_at_1fault [max_faults -1 : 0];
        reg [Bits -1 : 0] stuck0;
        reg [Bits -1 : 0] stuck1;

        reg [Bits+Red_extrabit :0] Mem_last;
        

        `ifdef slm
        reg [Bits -1 : 0] slm_temp_data;
        `endif
        
        real time_CK_func_rise , time_RADCK_rise;
        real time_fall_sleep,time_fall_PSWLARGEMP,time_fall_PSWLARGEMP_0,time_fall_PSWLARGEMA,time_fall_PSWLARGEMA_0,time_fall_PSWSMALLMP,time_fall_PSWSMALLMA;
        integer flag_error;
        
//BUFFER INSTANTIATION
//=========================
       `ifdef functional
       
         buf (SCTRLO,delSCTRLO_data); 
         buf bufq [Bits-1:0] (Q,delOutReg_data);
      `else
       
         buf (SCTRLO,SCTRLO_data);
         buf bufq [Bits-1:0] (Q,OutReg_data);
      `endif
      
  
        buf (SEsys,SE);
	buf (SCTRLIint, SCTRLI);
   

	buf (CKint_func, CK);
	buf (CKint_dft, CK);
        buf bufaddr [Addr-1:0] (Asys,A);
        buf (INITNint,INITN);
        
        buf (LSint,1'b0); 
        buf (IGbuf,IG);
        buf (ATPint,ATP);

        buf bufTaddr [Addr-1 : 0] (TAint,TA);
        buf (TBISTsys,TBIST);
        buf (TCSNint,TCSN);

        buf (CSNsys,CSN);
        buf (STDBYint,STDBY );   
        
        buf (SLEEPint,SLEEP ); 

        buf bufrm [read_margin_size-1:0] (RMint, RM); 

        
        

        assign RRAEint = 1'b0;
        assign TRRAEint = 1'b0;
        assign repair_add = 0;
        assign next_repair_add = 0;
        assign red_en = 1'b0; 
        
        
        
        
        
        
        
        buf (PSWLARGEMPint,1'b0);
        buf (PSWSMALLMPint,1'b0); 
        buf (PSWLARGEMAint,1'b0);
        buf (PSWSMALLMAint,1'b0);   

      `ifdef functional
       
       
         buf (SDLO,delSDLO_data);
         buf (SDRO,delSDRO_data);
         
         buf (SMLO,delSMLO_data);
         buf (SMRO,delSMRO_data);  
      `else
       
         buf (SDLO,SDLO_data);
         buf (SDRO,SDRO_data);
         
         buf (SMLO,SMLO_data);
         buf (SMRO,SMRO_data);  
      `endif
       
         
       
        buf bufdata [Bits-1:0] (Dsys,D);
        
        buf bufmask [64-1:0] (Msys,M);
        
	

        
        buf (TBYPASSsys, TBYPASS);
        


        buf (WENsys,WEN);
	 
	buf (SDLIint, SDLI);
	buf (SDRIint, SDRI);
	
        buf (SMLIint, SMLI);
	buf (SMRIint, SMRI);
	 
        
        buf (HSint,1'b0); 

        
        buf (TEDint,TED);
        buf (TODint,TOD);
         
        buf (TEMint,TEM);
        buf (TOMint,TOM); 
        buf (TWENint,TWEN);
        
        
        buf bufwm [write_margin_size-1:0] (WMint, WM); 
        



//      assign scanreg_ctrl_wire={scanreg_ctrl[scanlen_ctrl - 2:0],SCTRLIint};
//      assign scanreg_dl_wire={scanreg_dl[scanlen_l - 2:0],SDLIint};
//      assign scanreg_dr_wire={scanreg_dr[scanlen_r - 2:0],SDRIint};
      
//      assign scanreg_ml_wire={scanreg_ml[scanlen_l - 2:0],SMLIint};
//      assign scanreg_mr_wire={scanreg_mr[scanlen_r - 2:0],SMRIint}; 
        
      assign Aint   = (TBISTint === 1'b0 ) ? Asys : (TBISTint === 1'bx ) ? {Addr{1'bx}} : TAint;  

        
//        assign A_int = Aint;
	
        
                
        assign Dint[0] = (TBISTint === 1'b0) ? Dsys[0] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[1] = (TBISTint === 1'b0) ? Dsys[1] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[2] = (TBISTint === 1'b0) ? Dsys[2] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[3] = (TBISTint === 1'b0) ? Dsys[3] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[4] = (TBISTint === 1'b0) ? Dsys[4] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[5] = (TBISTint === 1'b0) ? Dsys[5] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[6] = (TBISTint === 1'b0) ? Dsys[6] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[7] = (TBISTint === 1'b0) ? Dsys[7] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[8] = (TBISTint === 1'b0) ? Dsys[8] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[9] = (TBISTint === 1'b0) ? Dsys[9] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[10] = (TBISTint === 1'b0) ? Dsys[10] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[11] = (TBISTint === 1'b0) ? Dsys[11] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[12] = (TBISTint === 1'b0) ? Dsys[12] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[13] = (TBISTint === 1'b0) ? Dsys[13] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[14] = (TBISTint === 1'b0) ? Dsys[14] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[15] = (TBISTint === 1'b0) ? Dsys[15] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[16] = (TBISTint === 1'b0) ? Dsys[16] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[17] = (TBISTint === 1'b0) ? Dsys[17] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[18] = (TBISTint === 1'b0) ? Dsys[18] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[19] = (TBISTint === 1'b0) ? Dsys[19] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[20] = (TBISTint === 1'b0) ? Dsys[20] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[21] = (TBISTint === 1'b0) ? Dsys[21] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[22] = (TBISTint === 1'b0) ? Dsys[22] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[23] = (TBISTint === 1'b0) ? Dsys[23] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[24] = (TBISTint === 1'b0) ? Dsys[24] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[25] = (TBISTint === 1'b0) ? Dsys[25] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[26] = (TBISTint === 1'b0) ? Dsys[26] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[27] = (TBISTint === 1'b0) ? Dsys[27] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[28] = (TBISTint === 1'b0) ? Dsys[28] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[29] = (TBISTint === 1'b0) ? Dsys[29] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[30] = (TBISTint === 1'b0) ? Dsys[30] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[31] = (TBISTint === 1'b0) ? Dsys[31] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[32] = (TBISTint === 1'b0) ? Dsys[32] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[33] = (TBISTint === 1'b0) ? Dsys[33] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[34] = (TBISTint === 1'b0) ? Dsys[34] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[35] = (TBISTint === 1'b0) ? Dsys[35] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[36] = (TBISTint === 1'b0) ? Dsys[36] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[37] = (TBISTint === 1'b0) ? Dsys[37] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[38] = (TBISTint === 1'b0) ? Dsys[38] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[39] = (TBISTint === 1'b0) ? Dsys[39] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[40] = (TBISTint === 1'b0) ? Dsys[40] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[41] = (TBISTint === 1'b0) ? Dsys[41] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[42] = (TBISTint === 1'b0) ? Dsys[42] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[43] = (TBISTint === 1'b0) ? Dsys[43] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[44] = (TBISTint === 1'b0) ? Dsys[44] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[45] = (TBISTint === 1'b0) ? Dsys[45] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[46] = (TBISTint === 1'b0) ? Dsys[46] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[47] = (TBISTint === 1'b0) ? Dsys[47] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[48] = (TBISTint === 1'b0) ? Dsys[48] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[49] = (TBISTint === 1'b0) ? Dsys[49] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[50] = (TBISTint === 1'b0) ? Dsys[50] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[51] = (TBISTint === 1'b0) ? Dsys[51] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[52] = (TBISTint === 1'b0) ? Dsys[52] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[53] = (TBISTint === 1'b0) ? Dsys[53] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[54] = (TBISTint === 1'b0) ? Dsys[54] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[55] = (TBISTint === 1'b0) ? Dsys[55] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[56] = (TBISTint === 1'b0) ? Dsys[56] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[57] = (TBISTint === 1'b0) ? Dsys[57] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[58] = (TBISTint === 1'b0) ? Dsys[58] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[59] = (TBISTint === 1'b0) ? Dsys[59] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[60] = (TBISTint === 1'b0) ? Dsys[60] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[61] = (TBISTint === 1'b0) ? Dsys[61] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[62] = (TBISTint === 1'b0) ? Dsys[62] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[63] = (TBISTint === 1'b0) ? Dsys[63] : (TBISTint === 1'b1) ? TODint : 1'bx;          
	
        
        assign Mint[0] = (TBISTint === 1'b0) ? Msys[0] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[1] = (TBISTint === 1'b0) ? Msys[1] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[2] = (TBISTint === 1'b0) ? Msys[2] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[3] = (TBISTint === 1'b0) ? Msys[3] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[4] = (TBISTint === 1'b0) ? Msys[4] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[5] = (TBISTint === 1'b0) ? Msys[5] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[6] = (TBISTint === 1'b0) ? Msys[6] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[7] = (TBISTint === 1'b0) ? Msys[7] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[8] = (TBISTint === 1'b0) ? Msys[8] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[9] = (TBISTint === 1'b0) ? Msys[9] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[10] = (TBISTint === 1'b0) ? Msys[10] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[11] = (TBISTint === 1'b0) ? Msys[11] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[12] = (TBISTint === 1'b0) ? Msys[12] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[13] = (TBISTint === 1'b0) ? Msys[13] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[14] = (TBISTint === 1'b0) ? Msys[14] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[15] = (TBISTint === 1'b0) ? Msys[15] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[16] = (TBISTint === 1'b0) ? Msys[16] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[17] = (TBISTint === 1'b0) ? Msys[17] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[18] = (TBISTint === 1'b0) ? Msys[18] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[19] = (TBISTint === 1'b0) ? Msys[19] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[20] = (TBISTint === 1'b0) ? Msys[20] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[21] = (TBISTint === 1'b0) ? Msys[21] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[22] = (TBISTint === 1'b0) ? Msys[22] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[23] = (TBISTint === 1'b0) ? Msys[23] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[24] = (TBISTint === 1'b0) ? Msys[24] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[25] = (TBISTint === 1'b0) ? Msys[25] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[26] = (TBISTint === 1'b0) ? Msys[26] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[27] = (TBISTint === 1'b0) ? Msys[27] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[28] = (TBISTint === 1'b0) ? Msys[28] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[29] = (TBISTint === 1'b0) ? Msys[29] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[30] = (TBISTint === 1'b0) ? Msys[30] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[31] = (TBISTint === 1'b0) ? Msys[31] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[32] = (TBISTint === 1'b0) ? Msys[32] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[33] = (TBISTint === 1'b0) ? Msys[33] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[34] = (TBISTint === 1'b0) ? Msys[34] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[35] = (TBISTint === 1'b0) ? Msys[35] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[36] = (TBISTint === 1'b0) ? Msys[36] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[37] = (TBISTint === 1'b0) ? Msys[37] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[38] = (TBISTint === 1'b0) ? Msys[38] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[39] = (TBISTint === 1'b0) ? Msys[39] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[40] = (TBISTint === 1'b0) ? Msys[40] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[41] = (TBISTint === 1'b0) ? Msys[41] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[42] = (TBISTint === 1'b0) ? Msys[42] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[43] = (TBISTint === 1'b0) ? Msys[43] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[44] = (TBISTint === 1'b0) ? Msys[44] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[45] = (TBISTint === 1'b0) ? Msys[45] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[46] = (TBISTint === 1'b0) ? Msys[46] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[47] = (TBISTint === 1'b0) ? Msys[47] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[48] = (TBISTint === 1'b0) ? Msys[48] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[49] = (TBISTint === 1'b0) ? Msys[49] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[50] = (TBISTint === 1'b0) ? Msys[50] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[51] = (TBISTint === 1'b0) ? Msys[51] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[52] = (TBISTint === 1'b0) ? Msys[52] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[53] = (TBISTint === 1'b0) ? Msys[53] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[54] = (TBISTint === 1'b0) ? Msys[54] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[55] = (TBISTint === 1'b0) ? Msys[55] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[56] = (TBISTint === 1'b0) ? Msys[56] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[57] = (TBISTint === 1'b0) ? Msys[57] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[58] = (TBISTint === 1'b0) ? Msys[58] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[59] = (TBISTint === 1'b0) ? Msys[59] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[60] = (TBISTint === 1'b0) ? Msys[60] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[61] = (TBISTint === 1'b0) ? Msys[61] : (TBISTint === 1'b1) ? TOMint : 1'bx; 

        assign Mint[62] = (TBISTint === 1'b0) ? Msys[62] : (TBISTint === 1'b1) ? TEMint : 1'bx; 

        assign Mint[63] = (TBISTint === 1'b0) ? Msys[63] : (TBISTint === 1'b1) ? TOMint : 1'bx;  
        

         

        assign WENbuf = (TBISTint === 1'b0 ) ? WENsys : (TBISTint === 1'bx ) ? 1'bx : TWENint;  
        assign WENint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? WENbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[13] : (ATPint === 1'b0 ) ? WENsys : 1'bx ; 
        
        assign CSNbuf = (TBISTint === 1'b0 ) ? CSNsys : (TBISTint === 1'bx ) ? 1'bx : TCSNint;  
        assign CSNint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? CSNbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[11] : (ATPint === 1'b0 ) ? CSNsys : 1'bx ; 
        assign IGint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? IGbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[14] : (ATPint === 1'b0 ) ? IGbuf : 1'bx;

        
        assign DEint = (LSint === 1'bx || (LSint === 1'b0 && HSint === 1'bx) || ^RMint !== 1'b0 || ^WMint !== 1'b0 ) ? 1'bx : 1'b0;
        
     
     and (TBISTint, ATPint, TBISTsys);
     and (SEint, ATPint, SEsys);
     and (TBYPASSint, ATPint, TBYPASSsys);
     and (TSE,TBYPASSint,!SEsys);
     and (MEMEN,INITNint,!CSNint,!SLEEPint,!TBYPASSint,!SEint,!IGint,!DEint,!STDBYint );
     and (MEMEN_dft,INITNint, !SLEEPint, ATPint,!STDBYint);

 `ifdef functional
/*****************assertions added to optimize dynamic power consumption**********/

//psl a_M: assert always ({( RW_assertions_en);(MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1))  } |-> (stable(Msys))) @(posedge CK); 

//psl a_WEN: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(WENsys))) @(posedge CK); 

//psl a_A: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(Asys))) @(posedge CK); 

//psl a_D: assert always ({( RW_assertions_en);((MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1)) && TBYPASSint === 1'b0)  } |-> (stable(Dsys))) @(posedge CK); 

/**********************************************************************************************/
`endif       

     

         
reg vddmp,vddmo, vddma, vddsmp, vddsma, gndsm, gndm,  vddmpi ; 
 
initial 
begin

        vddmp = 1'b1 ; 
        vddmo = 1'b1 ;
        vddma = 1'b1 ;
        
        vddsmp = 1'b1 ;
        
        
         gndm = 1'b0 ;
          
end

        
         assign gndmint = (reg_mem_block === 0) ? gndm : 1'b1;
         
         
         
         
         assign vddmpint = vddmp;
         assign vddmoint = vddmo;
         assign vddmaint = vddma;
         
          
        
         

        //CPF Changes

        
                
        initial
        begin : cpfvddmp 
           vddmpreg = vddmpint;
        end

        always @(vddmpint) begin
           vddmpreg = vddmpint;
        end
        
        initial
        begin : cpfvddmo 
           vddmoreg = vddmoint;
        end

        always @(vddmoint) begin
           vddmoreg = vddmoint;
        end
        
        initial
        begin : cpfvddma 
           vddmareg = vddmaint;
        end

        always @(vddmaint) begin
           vddmareg = vddmaint;
        end

        
        
 
        initial
        begin : cpfgndm 
           gndmreg = gndmint;
        end

        always @(gndmint) begin
           gndmreg = gndmint;
        end

        
        



 `ifdef functional
  `else
  initial begin
    if (debug_level < 1) begin
     $display ("%m  INFORMATION");
     $display ("***************************************");
     $display ("The Model is Operating in TIMING MODE");
     $display ("Please make sure that SDF is properly annotated otherwise dummy values will be used");
     $display ("%s", message_status);
     $display ("***************************************");
    end
  end

//////////////////////////
 //REG DECLARATIONS
   //======================

   reg [Bits-1 : 0] TimingViol_data;
   reg  [Bits-1 : 0] TimingViol_mask;
   reg [Bits-1 : 0] TimingViol_data_last, TimingViol_mask_last;
	reg TimingViol_data_0;
	reg TimingViol_data_1;
	reg TimingViol_data_2;
	reg TimingViol_data_3;
	reg TimingViol_data_4;
	reg TimingViol_data_5;
	reg TimingViol_data_6;
	reg TimingViol_data_7;
	reg TimingViol_data_8;
	reg TimingViol_data_9;
	reg TimingViol_data_10;
	reg TimingViol_data_11;
	reg TimingViol_data_12;
	reg TimingViol_data_13;
	reg TimingViol_data_14;
	reg TimingViol_data_15;
	reg TimingViol_data_16;
	reg TimingViol_data_17;
	reg TimingViol_data_18;
	reg TimingViol_data_19;
	reg TimingViol_data_20;
	reg TimingViol_data_21;
	reg TimingViol_data_22;
	reg TimingViol_data_23;
	reg TimingViol_data_24;
	reg TimingViol_data_25;
	reg TimingViol_data_26;
	reg TimingViol_data_27;
	reg TimingViol_data_28;
	reg TimingViol_data_29;
	reg TimingViol_data_30;
	reg TimingViol_data_31;
	reg TimingViol_data_32;
	reg TimingViol_data_33;
	reg TimingViol_data_34;
	reg TimingViol_data_35;
	reg TimingViol_data_36;
	reg TimingViol_data_37;
	reg TimingViol_data_38;
	reg TimingViol_data_39;
	reg TimingViol_data_40;
	reg TimingViol_data_41;
	reg TimingViol_data_42;
	reg TimingViol_data_43;
	reg TimingViol_data_44;
	reg TimingViol_data_45;
	reg TimingViol_data_46;
	reg TimingViol_data_47;
	reg TimingViol_data_48;
	reg TimingViol_data_49;
	reg TimingViol_data_50;
	reg TimingViol_data_51;
	reg TimingViol_data_52;
	reg TimingViol_data_53;
	reg TimingViol_data_54;
	reg TimingViol_data_55;
	reg TimingViol_data_56;
	reg TimingViol_data_57;
	reg TimingViol_data_58;
	reg TimingViol_data_59;
	reg TimingViol_data_60;
	reg TimingViol_data_61;
	reg TimingViol_data_62;
	reg TimingViol_data_63;
 reg TimingViol_mask_0;
 reg TimingViol_mask_1;
 reg TimingViol_mask_2;
 reg TimingViol_mask_3;
 reg TimingViol_mask_4;
 reg TimingViol_mask_5;
 reg TimingViol_mask_6;
 reg TimingViol_mask_7;
 reg TimingViol_mask_8;
 reg TimingViol_mask_9;
 reg TimingViol_mask_10;
 reg TimingViol_mask_11;
 reg TimingViol_mask_12;
 reg TimingViol_mask_13;
 reg TimingViol_mask_14;
 reg TimingViol_mask_15;
 reg TimingViol_mask_16;
 reg TimingViol_mask_17;
 reg TimingViol_mask_18;
 reg TimingViol_mask_19;
 reg TimingViol_mask_20;
 reg TimingViol_mask_21;
 reg TimingViol_mask_22;
 reg TimingViol_mask_23;
 reg TimingViol_mask_24;
 reg TimingViol_mask_25;
 reg TimingViol_mask_26;
 reg TimingViol_mask_27;
 reg TimingViol_mask_28;
 reg TimingViol_mask_29;
 reg TimingViol_mask_30;
 reg TimingViol_mask_31;
 reg TimingViol_mask_32;
 reg TimingViol_mask_33;
 reg TimingViol_mask_34;
 reg TimingViol_mask_35;
 reg TimingViol_mask_36;
 reg TimingViol_mask_37;
 reg TimingViol_mask_38;
 reg TimingViol_mask_39;
 reg TimingViol_mask_40;
 reg TimingViol_mask_41;
 reg TimingViol_mask_42;
 reg TimingViol_mask_43;
 reg TimingViol_mask_44;
 reg TimingViol_mask_45;
 reg TimingViol_mask_46;
 reg TimingViol_mask_47;
 reg TimingViol_mask_48;
 reg TimingViol_mask_49;
 reg TimingViol_mask_50;
 reg TimingViol_mask_51;
 reg TimingViol_mask_52;
 reg TimingViol_mask_53;
 reg TimingViol_mask_54;
 reg TimingViol_mask_55;
 reg TimingViol_mask_56;
 reg TimingViol_mask_57;
 reg TimingViol_mask_58;
 reg TimingViol_mask_59;
 reg TimingViol_mask_60;
 reg TimingViol_mask_61;
 reg TimingViol_mask_62;
 reg TimingViol_mask_63;

   reg TimingViol_addr;
   reg TimingViol_CSN, TimingViol_WEN, TimingViol_tbypass;
   reg TimingViol_tckh, TimingViol_tckl, TimingViol_tcycle;
   reg TimingViol_tckh_se, TimingViol_tckl_se, TimingViol_tcycle_se;
   reg TimingViol_sctrli,TimingViol_sdli,TimingViol_sdri,TimingViol_se;
   reg TimingViol_smli,TimingViol_smri;
   reg TimingViol_sctrli_flag,TimingViol_sdli_flag,TimingViol_sdri_flag;
   reg TimingViol_smli_flag,TimingViol_smri_flag;
   reg TimingViol_initnl;
   reg TimingViol_initn;
   reg TimingViol_ls;
   reg TimingViol_hs;
   reg TimingViol_sleep;
   reg TimingViol_stdby;
   reg TimingViol_rm;
   reg TimingViol_wm;
   reg TimingViol_tbist,TimingViol_ig,TimingViol_atp,TimingViol_TED,TimingViol_TOD,TimingViol_TEM,TimingViol_TOM;
   reg TimingViolRRAE,TimingViolRRA;

   wire CSTBYPASSN,cond_sdf_tas,cond_sdf_tds,cond_sdf_tms,cond_sdf_tws,cond_sdf_tbas,cond_sdf_tbps,cond_sdf_tbws,cond_sdf_tbdes,cond_sdf_tbdos,cond_sdf_tbmes,cond_sdf_tbmos;
   wire SETB_EN,CSIG_EN,MEM_ACT,EN_ADM,CS_EN,CS_ADM,cond_sdf_tps,IG_EN,IG_ADM,cond_sdf_tigs,cond_sdf_taa,cond_sdf_taa_ls1,cond_sdf_taa_hs1,cond_tseq_tm;
   wire cond_sdf_tcycle,cond_sdf_tcycle_ls1,cond_sdf_tcycle_hs1,cond_sdf_tcycle_se,cond_sdf_tckl_se,cond_sdf_tsctrlis,cond_sdf_tsdlis,cond_sdf_tsdris,cond_sdf_tsmlis,cond_sdf_tsmris;
   wire cond_sdf_tckh_se,cond_sdf_taa_sctrlo_se,cond_sdf_taa_sdlo_se,cond_sdf_taa_sdro_se,cond_sdf_taa_smlo_se,cond_sdf_taa_smro_se,cond_sdf_tckl,cond_sdf_tckh;
   wire cond_sdf_ttms,cond_sdf_tbists,INITNandnotSLEEPandATPandnotSE,cond_sdf_taa_sctrlo,cond_sdf_taa_sdlo,cond_sdf_taa_sdro,cond_sdf_taa_smlo,cond_sdf_taa_smro;
   wire cond_sdf_taa_tm,cond_sdf_taa_tm_ls1, cond_sdf_taa_tm_hs1,cond_sdf_taa_tckq_tm,cond_sdf_taa_tseq_tm;

   wire CSWETBYPASSN;
   wire cond_sdf_tstdbys,cond_sdf_tsls,sleep_en,atp_csn_en;
   wire cond_sdf_tlss,cond_sdf_thss,cond_sdf_trms,cond_sdf_twms; 
   wire cond_sdf_tses,cond_sdf_tinitns;
   wire tby_se_en;
   wire rra_en;
   wire tbist_atp_en;
   wire rrae_en;
   wire tbist_rrae_en;
   wire cond_sdf_trraes;
   wire cond_sdf_ttrraes;
   wire cond_sdf_taa_trramatch;
   wire cond_sdf_ttrraematch;
   wire cond_sdf_tamatch;
   wire cond_sdf_ttamatch;
   wire cond_sdf_tatpmatch;
   wire cond_sdf_ttbistmatch;



 and (CSWEMTBYPASS[0], !Mreg[0], CSWETBYPASSN);
 and (CSWEMTBYPASS[1], !Mreg[1], CSWETBYPASSN);
 and (CSWEMTBYPASS[2], !Mreg[2], CSWETBYPASSN);
 and (CSWEMTBYPASS[3], !Mreg[3], CSWETBYPASSN);
 and (CSWEMTBYPASS[4], !Mreg[4], CSWETBYPASSN);
 and (CSWEMTBYPASS[5], !Mreg[5], CSWETBYPASSN);
 and (CSWEMTBYPASS[6], !Mreg[6], CSWETBYPASSN);
 and (CSWEMTBYPASS[7], !Mreg[7], CSWETBYPASSN);
 and (CSWEMTBYPASS[8], !Mreg[8], CSWETBYPASSN);
 and (CSWEMTBYPASS[9], !Mreg[9], CSWETBYPASSN);
 and (CSWEMTBYPASS[10], !Mreg[10], CSWETBYPASSN);
 and (CSWEMTBYPASS[11], !Mreg[11], CSWETBYPASSN);
 and (CSWEMTBYPASS[12], !Mreg[12], CSWETBYPASSN);
 and (CSWEMTBYPASS[13], !Mreg[13], CSWETBYPASSN);
 and (CSWEMTBYPASS[14], !Mreg[14], CSWETBYPASSN);
 and (CSWEMTBYPASS[15], !Mreg[15], CSWETBYPASSN);
 and (CSWEMTBYPASS[16], !Mreg[16], CSWETBYPASSN);
 and (CSWEMTBYPASS[17], !Mreg[17], CSWETBYPASSN);
 and (CSWEMTBYPASS[18], !Mreg[18], CSWETBYPASSN);
 and (CSWEMTBYPASS[19], !Mreg[19], CSWETBYPASSN);
 and (CSWEMTBYPASS[20], !Mreg[20], CSWETBYPASSN);
 and (CSWEMTBYPASS[21], !Mreg[21], CSWETBYPASSN);
 and (CSWEMTBYPASS[22], !Mreg[22], CSWETBYPASSN);
 and (CSWEMTBYPASS[23], !Mreg[23], CSWETBYPASSN);
 and (CSWEMTBYPASS[24], !Mreg[24], CSWETBYPASSN);
 and (CSWEMTBYPASS[25], !Mreg[25], CSWETBYPASSN);
 and (CSWEMTBYPASS[26], !Mreg[26], CSWETBYPASSN);
 and (CSWEMTBYPASS[27], !Mreg[27], CSWETBYPASSN);
 and (CSWEMTBYPASS[28], !Mreg[28], CSWETBYPASSN);
 and (CSWEMTBYPASS[29], !Mreg[29], CSWETBYPASSN);
 and (CSWEMTBYPASS[30], !Mreg[30], CSWETBYPASSN);
 and (CSWEMTBYPASS[31], !Mreg[31], CSWETBYPASSN);
 and (CSWEMTBYPASS[32], !Mreg[32], CSWETBYPASSN);
 and (CSWEMTBYPASS[33], !Mreg[33], CSWETBYPASSN);
 and (CSWEMTBYPASS[34], !Mreg[34], CSWETBYPASSN);
 and (CSWEMTBYPASS[35], !Mreg[35], CSWETBYPASSN);
 and (CSWEMTBYPASS[36], !Mreg[36], CSWETBYPASSN);
 and (CSWEMTBYPASS[37], !Mreg[37], CSWETBYPASSN);
 and (CSWEMTBYPASS[38], !Mreg[38], CSWETBYPASSN);
 and (CSWEMTBYPASS[39], !Mreg[39], CSWETBYPASSN);
 and (CSWEMTBYPASS[40], !Mreg[40], CSWETBYPASSN);
 and (CSWEMTBYPASS[41], !Mreg[41], CSWETBYPASSN);
 and (CSWEMTBYPASS[42], !Mreg[42], CSWETBYPASSN);
 and (CSWEMTBYPASS[43], !Mreg[43], CSWETBYPASSN);
 and (CSWEMTBYPASS[44], !Mreg[44], CSWETBYPASSN);
 and (CSWEMTBYPASS[45], !Mreg[45], CSWETBYPASSN);
 and (CSWEMTBYPASS[46], !Mreg[46], CSWETBYPASSN);
 and (CSWEMTBYPASS[47], !Mreg[47], CSWETBYPASSN);
 and (CSWEMTBYPASS[48], !Mreg[48], CSWETBYPASSN);
 and (CSWEMTBYPASS[49], !Mreg[49], CSWETBYPASSN);
 and (CSWEMTBYPASS[50], !Mreg[50], CSWETBYPASSN);
 and (CSWEMTBYPASS[51], !Mreg[51], CSWETBYPASSN);
 and (CSWEMTBYPASS[52], !Mreg[52], CSWETBYPASSN);
 and (CSWEMTBYPASS[53], !Mreg[53], CSWETBYPASSN);
 and (CSWEMTBYPASS[54], !Mreg[54], CSWETBYPASSN);
 and (CSWEMTBYPASS[55], !Mreg[55], CSWETBYPASSN);
 and (CSWEMTBYPASS[56], !Mreg[56], CSWETBYPASSN);
 and (CSWEMTBYPASS[57], !Mreg[57], CSWETBYPASSN);
 and (CSWEMTBYPASS[58], !Mreg[58], CSWETBYPASSN);
 and (CSWEMTBYPASS[59], !Mreg[59], CSWETBYPASSN);
 and (CSWEMTBYPASS[60], !Mreg[60], CSWETBYPASSN);
 and (CSWEMTBYPASS[61], !Mreg[61], CSWETBYPASSN);
 and (CSWEMTBYPASS[62], !Mreg[62], CSWETBYPASSN);
 and (CSWEMTBYPASS[63], !Mreg[63], CSWETBYPASSN);

and (atp_csn_en,!ATPint,!CSNint,!IGint);
or (sleep_en,atp_csn_en,ATPint);
or (SETB_EN,SEint,TBISTint);
and (ATP_SETB_EN,ATPint,SETB_EN); 
or (CSIG_EN,IGint,CSNint);
and (MEM_ACT,!ATPint,CSIG_EN);
or (EN_ADM,MEM_ACT,ATP_SETB_EN);
and (CS_EN,!ATPint,IGint);
or (CS_ADM,CS_EN,ATP_SETB_EN);
and (atp_ig_csn_en,!ATPint,!CSNint,!IGint);
and (atp_se_en,!SEsys,ATPint);
or (cycle_en,atp_ig_csn_en,atp_se_en);
and (atp_ig_csn_en_reg,!ATPreg,!CSNreg,!IGreg);
and (atp_se_en_reg,!SE_reg,ATPreg);
or (cycle_en_reg,atp_ig_csn_en,atp_se_en);
and (INITNandnotSLEEPandATPandnotSE,cond_gac,!SEsys,ATPint);
and (csn_ig_en,!IGint,!CSNint);
and (atp_tby_ls_en,atp_se_en,cond_ls_tby_en);
and (IG_EN,!ATPint,!CSNint);
or (IG_ADM,IG_EN,atp_se_en);
and (CSWETBYPASSN, !WENreg, 1'b1);



assign cond_sdf_tsls=((sleep_en && INITNint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tstdbys=((sleep_en && INITNint && !SLEEPint) !==0) ? 1:0;
assign cond_sdf_atps=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_gac=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tas=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tds=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tms=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tws=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tps=((cond_gac && !CS_ADM) !==0) ? 1:0;
assign cond_sdf_tcycle=((cond_gac && cycle_en && !LSint && !HSint) !==0) ? 1:0;  
assign cond_sdf_tcycle_ls1=((cond_gac && cycle_en && LSint) !==0) ? 1:0;
assign cond_sdf_tcycle_hs1=((cond_gac && cycle_en && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_tckh=((cond_gac && cycle_en_reg) !==0) ? 1:0;
assign cond_sdf_tckl=((cond_gac && cycle_en) !==0) ? 1:0;
assign cond_sdf_tcycle_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckl_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsctrlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckh_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_ttms=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_tbists=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_tckq_tm=((cond_gac && SE_reg && ATPreg && TBYPASSsys) !==0) ? 1:0;
assign cond_ls_en=((atp_ig_csn_en || atp_tby_ls_en) !==0) ? 1:0;
assign cond_sdf_tlss=((cond_ls_en && cond_gac) !==0) ? 1:0;
assign cond_sdf_thss=((cond_ls_en && cond_gac && !LSint) !==0) ? 1:0;
assign cond_sdf_trms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_twms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_tses=((cond_gac && ATPint) !==0) ? 1:0;
assign cond_sdf_tbas=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbps=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbws=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tigs=((cond_gac && IG_ADM) !==0) ? 1:0;
assign cond_sdf_taa=((MEMEN_reg && WENreg && !LSint && !HSint) !==0) ? 1:0; 
// assign cond_sdf_taa_tbypass_q = ((MEMEN_reg && ATPint && TBYPASSint) !== 1'b0) ? 1'b1 : 1'b0;
assign cond_sdf_taa_ls1=((MEMEN_reg && WENreg && LSint) !==0) ? 1:0; 
assign cond_sdf_taa_hs1=((MEMEN_reg && WENreg && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && !HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_ls1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && LSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_hs1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tseq_tm=((cond_gac && TBYPASSint) !==0) ? 1:0;
assign cond_sdf_tinitns =(( sleep_en && !STDBYint && !SLEEPint) !==0) ? 1:0;
assign cond_ls_tby_en=((TBYPASSsys || csn_ig_en) !==0) ? 1:0;



//specify block begins

specify
    specparam
    
         PATHPULSE$CK$Q = 0,
         PATHPULSE$CK$SCTRLO = 0,

         PATHPULSE$CK$SDLO = 0,
         PATHPULSE$CK$SDRO = 0,
        
         PATHPULSE$CK$SMLO = 0,
         PATHPULSE$CK$SMRO = 0,
         PATHPULSE$SE$Q = 0,
         
//         PATHPULSE$TBYPASS$Q = 0,


        
         
        
         tsls = `setup_time,
         tslh = `hold_time ,
         tstdbys = `setup_time,
         tstdbyh = `hold_time , 
	 

        
         tms = `setup_time,
         tmh = `hold_time , 
         tsmlis=`setup_time,
         tsmlih=`hold_time ,
         tsmris=`setup_time,
         tsmrih=`hold_time , 
         tcycle = `cycle_time,
         
         
         tckh = `pulse_width_time,
         tckl = `pulse_width_time,
         tcycle_se = `cycle_time,
         tckh_se = `pulse_width_time,
         tckl_se = `pulse_width_time,
         
         ttms = `setup_time,
         ttmh = `hold_time ,
         tps = `setup_time,
         tph = `hold_time ,
         tws = `setup_time,
         twh = `hold_time ,
         tds = `setup_time,
         tdh = `hold_time , 
         tas = `setup_time,
         tah = `hold_time ,
         tses= `setup_time,
         tseh= `hold_time ,
         tsctrlis=`setup_time,
         tsctrlih=`hold_time ,
         tsdlis=`setup_time,
         tsdlih=`hold_time ,
         tsdris=`setup_time,
         tsdrih=`hold_time , 
         tbists=`setup_time,
         tbisth=`hold_time ,
         tbps=`setup_time,
         tbph=`hold_time ,
         tbws=`setup_time,
         tbwh=`hold_time ,
         tbdes=`setup_time,
         tbdeh=`hold_time ,
         tbdos=`setup_time,
         tbdoh=`hold_time ,
        
         tbmes=`setup_time,
         tbmeh=`hold_time ,
         tbmos=`setup_time,
         tbmoh=`hold_time ,  
         tbas=`setup_time,
         tbah=`hold_time ,
         tinitnl=`initin_low_pulse,
         tinitns=`setup_time,
         tinitnh=`hold_time ,
         tatps=`setup_time,
         tatph=`hold_time ,
         tigs=`setup_time,
         tigh=`hold_time ,
         
         
         trms=`setup_time,
         trmh=`hold_time ,
         twms=`setup_time,
         twmh=`hold_time , 

/*************************************************************************************************/
           // taa_tbypass_q = `access_time,
           // th_tbypass_q  = `retain_time,
            taa =`access_time,
            th = `retain_time,

 


            taa_tm =`access_time,
            th_tm = `retain_time,

            
            taa_tseq_tm =`access_time,
            th_tseq_tm = `retain_time,
            taa_tckq_tm   = `access_time,
            th_tckq_tm    = `retain_time,
            taa_sctrlo=`access_time,
            th_sctrlo= `retain_time,
            taa_sdlo=`access_time,
            th_sdlo= `retain_time,
            taa_sdro=`access_time,
            th_sdro= `retain_time,
            
        
            taa_smlo=`access_time,
            th_smlo= `retain_time,
            taa_smro=`access_time,
            th_smro= `retain_time, 
            taa_sctrlo_se=`access_time,
            th_sctrlo_se= `retain_time
,
            taa_sdlo_se=`access_time,
            th_sdlo_se= `retain_time,
            taa_sdro_se=`access_time,
            th_sdro_se= `retain_time
        ,
            taa_smlo_se=`access_time,
            th_smlo_se= `retain_time,
            taa_smro_se=`access_time,
            th_smro_se= `retain_time;   


        /*---------------------- Timing Checks ---------------------*/

	$setup(posedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[5], tah, TimingViol_addr);

	$setup(posedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(posedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(posedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(posedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(posedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(posedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(posedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(posedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(posedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(posedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(posedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(posedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(posedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(posedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(posedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(posedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(posedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(posedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(posedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(posedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(posedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(posedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$setup(posedge D[22], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_22);
	$setup(posedge D[23], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_23);
	$setup(posedge D[24], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_24);
	$setup(posedge D[25], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_25);
	$setup(posedge D[26], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_26);
	$setup(posedge D[27], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_27);
	$setup(posedge D[28], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_28);
	$setup(posedge D[29], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_29);
	$setup(posedge D[30], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_30);
	$setup(posedge D[31], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_31);
	$setup(posedge D[32], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_32);
	$setup(posedge D[33], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_33);
	$setup(posedge D[34], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_34);
	$setup(posedge D[35], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_35);
	$setup(posedge D[36], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_36);
	$setup(posedge D[37], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_37);
	$setup(posedge D[38], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_38);
	$setup(posedge D[39], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_39);
	$setup(posedge D[40], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_40);
	$setup(posedge D[41], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_41);
	$setup(posedge D[42], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_42);
	$setup(posedge D[43], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_43);
	$setup(posedge D[44], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_44);
	$setup(posedge D[45], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_45);
	$setup(posedge D[46], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_46);
	$setup(posedge D[47], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_47);
	$setup(posedge D[48], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_48);
	$setup(posedge D[49], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_49);
	$setup(posedge D[50], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_50);
	$setup(posedge D[51], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_51);
	$setup(posedge D[52], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_52);
	$setup(posedge D[53], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_53);
	$setup(posedge D[54], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_54);
	$setup(posedge D[55], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_55);
	$setup(posedge D[56], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_56);
	$setup(posedge D[57], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_57);
	$setup(posedge D[58], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_58);
	$setup(posedge D[59], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_59);
	$setup(posedge D[60], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_60);
	$setup(posedge D[61], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_61);
	$setup(posedge D[62], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_62);
	$setup(posedge D[63], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_63);
	$setup(negedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(negedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(negedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(negedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(negedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(negedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(negedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(negedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(negedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(negedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(negedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(negedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(negedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(negedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(negedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(negedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(negedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(negedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(negedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(negedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(negedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(negedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$setup(negedge D[22], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_22);
	$setup(negedge D[23], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_23);
	$setup(negedge D[24], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_24);
	$setup(negedge D[25], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_25);
	$setup(negedge D[26], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_26);
	$setup(negedge D[27], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_27);
	$setup(negedge D[28], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_28);
	$setup(negedge D[29], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_29);
	$setup(negedge D[30], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_30);
	$setup(negedge D[31], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_31);
	$setup(negedge D[32], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_32);
	$setup(negedge D[33], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_33);
	$setup(negedge D[34], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_34);
	$setup(negedge D[35], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_35);
	$setup(negedge D[36], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_36);
	$setup(negedge D[37], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_37);
	$setup(negedge D[38], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_38);
	$setup(negedge D[39], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_39);
	$setup(negedge D[40], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_40);
	$setup(negedge D[41], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_41);
	$setup(negedge D[42], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_42);
	$setup(negedge D[43], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_43);
	$setup(negedge D[44], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_44);
	$setup(negedge D[45], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_45);
	$setup(negedge D[46], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_46);
	$setup(negedge D[47], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_47);
	$setup(negedge D[48], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_48);
	$setup(negedge D[49], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_49);
	$setup(negedge D[50], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_50);
	$setup(negedge D[51], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_51);
	$setup(negedge D[52], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_52);
	$setup(negedge D[53], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_53);
	$setup(negedge D[54], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_54);
	$setup(negedge D[55], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_55);
	$setup(negedge D[56], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_56);
	$setup(negedge D[57], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_57);
	$setup(negedge D[58], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_58);
	$setup(negedge D[59], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_59);
	$setup(negedge D[60], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_60);
	$setup(negedge D[61], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_61);
	$setup(negedge D[62], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_62);
	$setup(negedge D[63], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_63);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[21], tdh, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[22], tdh, TimingViol_data_22);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[23], tdh, TimingViol_data_23);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[24], tdh, TimingViol_data_24);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[25], tdh, TimingViol_data_25);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[26], tdh, TimingViol_data_26);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[27], tdh, TimingViol_data_27);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[28], tdh, TimingViol_data_28);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[29], tdh, TimingViol_data_29);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[30], tdh, TimingViol_data_30);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[31], tdh, TimingViol_data_31);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[32], tdh, TimingViol_data_32);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[33], tdh, TimingViol_data_33);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[34], tdh, TimingViol_data_34);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[35], tdh, TimingViol_data_35);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[36], tdh, TimingViol_data_36);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[37], tdh, TimingViol_data_37);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[38], tdh, TimingViol_data_38);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[39], tdh, TimingViol_data_39);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[40], tdh, TimingViol_data_40);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[41], tdh, TimingViol_data_41);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[42], tdh, TimingViol_data_42);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[43], tdh, TimingViol_data_43);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[44], tdh, TimingViol_data_44);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[45], tdh, TimingViol_data_45);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[46], tdh, TimingViol_data_46);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[47], tdh, TimingViol_data_47);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[48], tdh, TimingViol_data_48);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[49], tdh, TimingViol_data_49);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[50], tdh, TimingViol_data_50);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[51], tdh, TimingViol_data_51);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[52], tdh, TimingViol_data_52);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[53], tdh, TimingViol_data_53);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[54], tdh, TimingViol_data_54);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[55], tdh, TimingViol_data_55);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[56], tdh, TimingViol_data_56);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[57], tdh, TimingViol_data_57);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[58], tdh, TimingViol_data_58);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[59], tdh, TimingViol_data_59);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[60], tdh, TimingViol_data_60);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[61], tdh, TimingViol_data_61);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[62], tdh, TimingViol_data_62);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[63], tdh, TimingViol_data_63);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[21], tdh, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[22], tdh, TimingViol_data_22);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[23], tdh, TimingViol_data_23);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[24], tdh, TimingViol_data_24);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[25], tdh, TimingViol_data_25);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[26], tdh, TimingViol_data_26);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[27], tdh, TimingViol_data_27);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[28], tdh, TimingViol_data_28);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[29], tdh, TimingViol_data_29);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[30], tdh, TimingViol_data_30);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[31], tdh, TimingViol_data_31);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[32], tdh, TimingViol_data_32);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[33], tdh, TimingViol_data_33);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[34], tdh, TimingViol_data_34);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[35], tdh, TimingViol_data_35);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[36], tdh, TimingViol_data_36);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[37], tdh, TimingViol_data_37);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[38], tdh, TimingViol_data_38);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[39], tdh, TimingViol_data_39);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[40], tdh, TimingViol_data_40);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[41], tdh, TimingViol_data_41);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[42], tdh, TimingViol_data_42);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[43], tdh, TimingViol_data_43);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[44], tdh, TimingViol_data_44);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[45], tdh, TimingViol_data_45);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[46], tdh, TimingViol_data_46);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[47], tdh, TimingViol_data_47);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[48], tdh, TimingViol_data_48);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[49], tdh, TimingViol_data_49);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[50], tdh, TimingViol_data_50);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[51], tdh, TimingViol_data_51);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[52], tdh, TimingViol_data_52);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[53], tdh, TimingViol_data_53);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[54], tdh, TimingViol_data_54);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[55], tdh, TimingViol_data_55);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[56], tdh, TimingViol_data_56);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[57], tdh, TimingViol_data_57);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[58], tdh, TimingViol_data_58);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[59], tdh, TimingViol_data_59);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[60], tdh, TimingViol_data_60);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[61], tdh, TimingViol_data_61);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[62], tdh, TimingViol_data_62);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[63], tdh, TimingViol_data_63);

     $setup(posedge M[0], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_0);
	$setup(negedge M[0], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_0);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[0], tmh, TimingViol_mask_0);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[0], tmh, TimingViol_mask_0);
     $setup(posedge M[1], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_1);
	$setup(negedge M[1], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_1);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[1], tmh, TimingViol_mask_1);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[1], tmh, TimingViol_mask_1);
     $setup(posedge M[2], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_2);
	$setup(negedge M[2], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_2);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[2], tmh, TimingViol_mask_2);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[2], tmh, TimingViol_mask_2);
     $setup(posedge M[3], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_3);
	$setup(negedge M[3], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_3);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[3], tmh, TimingViol_mask_3);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[3], tmh, TimingViol_mask_3);
     $setup(posedge M[4], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_4);
	$setup(negedge M[4], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_4);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[4], tmh, TimingViol_mask_4);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[4], tmh, TimingViol_mask_4);
     $setup(posedge M[5], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_5);
	$setup(negedge M[5], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_5);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[5], tmh, TimingViol_mask_5);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[5], tmh, TimingViol_mask_5);
     $setup(posedge M[6], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_6);
	$setup(negedge M[6], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_6);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[6], tmh, TimingViol_mask_6);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[6], tmh, TimingViol_mask_6);
     $setup(posedge M[7], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_7);
	$setup(negedge M[7], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_7);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[7], tmh, TimingViol_mask_7);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[7], tmh, TimingViol_mask_7);
     $setup(posedge M[8], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_8);
	$setup(negedge M[8], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_8);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[8], tmh, TimingViol_mask_8);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[8], tmh, TimingViol_mask_8);
     $setup(posedge M[9], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_9);
	$setup(negedge M[9], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_9);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[9], tmh, TimingViol_mask_9);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[9], tmh, TimingViol_mask_9);
     $setup(posedge M[10], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_10);
	$setup(negedge M[10], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_10);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[10], tmh, TimingViol_mask_10);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[10], tmh, TimingViol_mask_10);
     $setup(posedge M[11], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_11);
	$setup(negedge M[11], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_11);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[11], tmh, TimingViol_mask_11);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[11], tmh, TimingViol_mask_11);
     $setup(posedge M[12], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_12);
	$setup(negedge M[12], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_12);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[12], tmh, TimingViol_mask_12);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[12], tmh, TimingViol_mask_12);
     $setup(posedge M[13], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_13);
	$setup(negedge M[13], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_13);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[13], tmh, TimingViol_mask_13);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[13], tmh, TimingViol_mask_13);
     $setup(posedge M[14], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_14);
	$setup(negedge M[14], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_14);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[14], tmh, TimingViol_mask_14);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[14], tmh, TimingViol_mask_14);
     $setup(posedge M[15], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_15);
	$setup(negedge M[15], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_15);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[15], tmh, TimingViol_mask_15);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[15], tmh, TimingViol_mask_15);
     $setup(posedge M[16], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_16);
	$setup(negedge M[16], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_16);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[16], tmh, TimingViol_mask_16);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[16], tmh, TimingViol_mask_16);
     $setup(posedge M[17], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_17);
	$setup(negedge M[17], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_17);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[17], tmh, TimingViol_mask_17);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[17], tmh, TimingViol_mask_17);
     $setup(posedge M[18], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_18);
	$setup(negedge M[18], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_18);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[18], tmh, TimingViol_mask_18);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[18], tmh, TimingViol_mask_18);
     $setup(posedge M[19], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_19);
	$setup(negedge M[19], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_19);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[19], tmh, TimingViol_mask_19);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[19], tmh, TimingViol_mask_19);
     $setup(posedge M[20], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_20);
	$setup(negedge M[20], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_20);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[20], tmh, TimingViol_mask_20);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[20], tmh, TimingViol_mask_20);
     $setup(posedge M[21], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_21);
	$setup(negedge M[21], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_21);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[21], tmh, TimingViol_mask_21);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[21], tmh, TimingViol_mask_21);
     $setup(posedge M[22], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_22);
	$setup(negedge M[22], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_22);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[22], tmh, TimingViol_mask_22);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[22], tmh, TimingViol_mask_22);
     $setup(posedge M[23], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_23);
	$setup(negedge M[23], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_23);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[23], tmh, TimingViol_mask_23);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[23], tmh, TimingViol_mask_23);
     $setup(posedge M[24], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_24);
	$setup(negedge M[24], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_24);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[24], tmh, TimingViol_mask_24);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[24], tmh, TimingViol_mask_24);
     $setup(posedge M[25], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_25);
	$setup(negedge M[25], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_25);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[25], tmh, TimingViol_mask_25);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[25], tmh, TimingViol_mask_25);
     $setup(posedge M[26], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_26);
	$setup(negedge M[26], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_26);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[26], tmh, TimingViol_mask_26);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[26], tmh, TimingViol_mask_26);
     $setup(posedge M[27], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_27);
	$setup(negedge M[27], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_27);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[27], tmh, TimingViol_mask_27);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[27], tmh, TimingViol_mask_27);
     $setup(posedge M[28], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_28);
	$setup(negedge M[28], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_28);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[28], tmh, TimingViol_mask_28);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[28], tmh, TimingViol_mask_28);
     $setup(posedge M[29], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_29);
	$setup(negedge M[29], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_29);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[29], tmh, TimingViol_mask_29);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[29], tmh, TimingViol_mask_29);
     $setup(posedge M[30], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_30);
	$setup(negedge M[30], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_30);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[30], tmh, TimingViol_mask_30);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[30], tmh, TimingViol_mask_30);
     $setup(posedge M[31], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_31);
	$setup(negedge M[31], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_31);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[31], tmh, TimingViol_mask_31);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[31], tmh, TimingViol_mask_31);
     $setup(posedge M[32], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_32);
	$setup(negedge M[32], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_32);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[32], tmh, TimingViol_mask_32);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[32], tmh, TimingViol_mask_32);
     $setup(posedge M[33], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_33);
	$setup(negedge M[33], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_33);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[33], tmh, TimingViol_mask_33);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[33], tmh, TimingViol_mask_33);
     $setup(posedge M[34], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_34);
	$setup(negedge M[34], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_34);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[34], tmh, TimingViol_mask_34);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[34], tmh, TimingViol_mask_34);
     $setup(posedge M[35], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_35);
	$setup(negedge M[35], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_35);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[35], tmh, TimingViol_mask_35);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[35], tmh, TimingViol_mask_35);
     $setup(posedge M[36], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_36);
	$setup(negedge M[36], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_36);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[36], tmh, TimingViol_mask_36);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[36], tmh, TimingViol_mask_36);
     $setup(posedge M[37], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_37);
	$setup(negedge M[37], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_37);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[37], tmh, TimingViol_mask_37);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[37], tmh, TimingViol_mask_37);
     $setup(posedge M[38], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_38);
	$setup(negedge M[38], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_38);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[38], tmh, TimingViol_mask_38);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[38], tmh, TimingViol_mask_38);
     $setup(posedge M[39], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_39);
	$setup(negedge M[39], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_39);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[39], tmh, TimingViol_mask_39);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[39], tmh, TimingViol_mask_39);
     $setup(posedge M[40], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_40);
	$setup(negedge M[40], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_40);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[40], tmh, TimingViol_mask_40);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[40], tmh, TimingViol_mask_40);
     $setup(posedge M[41], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_41);
	$setup(negedge M[41], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_41);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[41], tmh, TimingViol_mask_41);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[41], tmh, TimingViol_mask_41);
     $setup(posedge M[42], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_42);
	$setup(negedge M[42], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_42);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[42], tmh, TimingViol_mask_42);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[42], tmh, TimingViol_mask_42);
     $setup(posedge M[43], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_43);
	$setup(negedge M[43], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_43);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[43], tmh, TimingViol_mask_43);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[43], tmh, TimingViol_mask_43);
     $setup(posedge M[44], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_44);
	$setup(negedge M[44], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_44);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[44], tmh, TimingViol_mask_44);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[44], tmh, TimingViol_mask_44);
     $setup(posedge M[45], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_45);
	$setup(negedge M[45], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_45);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[45], tmh, TimingViol_mask_45);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[45], tmh, TimingViol_mask_45);
     $setup(posedge M[46], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_46);
	$setup(negedge M[46], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_46);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[46], tmh, TimingViol_mask_46);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[46], tmh, TimingViol_mask_46);
     $setup(posedge M[47], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_47);
	$setup(negedge M[47], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_47);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[47], tmh, TimingViol_mask_47);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[47], tmh, TimingViol_mask_47);
     $setup(posedge M[48], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_48);
	$setup(negedge M[48], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_48);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[48], tmh, TimingViol_mask_48);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[48], tmh, TimingViol_mask_48);
     $setup(posedge M[49], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_49);
	$setup(negedge M[49], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_49);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[49], tmh, TimingViol_mask_49);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[49], tmh, TimingViol_mask_49);
     $setup(posedge M[50], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_50);
	$setup(negedge M[50], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_50);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[50], tmh, TimingViol_mask_50);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[50], tmh, TimingViol_mask_50);
     $setup(posedge M[51], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_51);
	$setup(negedge M[51], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_51);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[51], tmh, TimingViol_mask_51);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[51], tmh, TimingViol_mask_51);
     $setup(posedge M[52], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_52);
	$setup(negedge M[52], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_52);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[52], tmh, TimingViol_mask_52);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[52], tmh, TimingViol_mask_52);
     $setup(posedge M[53], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_53);
	$setup(negedge M[53], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_53);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[53], tmh, TimingViol_mask_53);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[53], tmh, TimingViol_mask_53);
     $setup(posedge M[54], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_54);
	$setup(negedge M[54], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_54);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[54], tmh, TimingViol_mask_54);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[54], tmh, TimingViol_mask_54);
     $setup(posedge M[55], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_55);
	$setup(negedge M[55], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_55);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[55], tmh, TimingViol_mask_55);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[55], tmh, TimingViol_mask_55);
     $setup(posedge M[56], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_56);
	$setup(negedge M[56], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_56);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[56], tmh, TimingViol_mask_56);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[56], tmh, TimingViol_mask_56);
     $setup(posedge M[57], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_57);
	$setup(negedge M[57], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_57);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[57], tmh, TimingViol_mask_57);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[57], tmh, TimingViol_mask_57);
     $setup(posedge M[58], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_58);
	$setup(negedge M[58], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_58);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[58], tmh, TimingViol_mask_58);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[58], tmh, TimingViol_mask_58);
     $setup(posedge M[59], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_59);
	$setup(negedge M[59], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_59);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[59], tmh, TimingViol_mask_59);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[59], tmh, TimingViol_mask_59);
     $setup(posedge M[60], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_60);
	$setup(negedge M[60], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_60);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[60], tmh, TimingViol_mask_60);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[60], tmh, TimingViol_mask_60);
     $setup(posedge M[61], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_61);
	$setup(negedge M[61], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_61);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[61], tmh, TimingViol_mask_61);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[61], tmh, TimingViol_mask_61);
     $setup(posedge M[62], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_62);
	$setup(negedge M[62], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_62);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[62], tmh, TimingViol_mask_62);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[62], tmh, TimingViol_mask_62);
     $setup(posedge M[63], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_63);
	$setup(negedge M[63], posedge CK &&& cond_sdf_tms, tms, TimingViol_mask_63);
	$hold(posedge CK &&& cond_sdf_tms, posedge M[63], tmh, TimingViol_mask_63);
	$hold(posedge CK &&& cond_sdf_tms, negedge M[63], tmh, TimingViol_mask_63);


        $setup(posedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $setup(negedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, posedge WEN, twh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, negedge WEN, twh, TimingViol_WEN); 
        $setup(posedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$setup(negedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, posedge CSN, tph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, negedge CSN, tph, TimingViol_CSN);
        $period(posedge CK &&& cond_sdf_tcycle, tcycle, TimingViol_tcycle);  

        
        $width(posedge CK  &&& cond_sdf_tckh, tckh, 0, TimingViol_tckh);
        $width(negedge CK  &&& cond_sdf_tckl, tckl, 0, TimingViol_tckl);
        $period(posedge CK &&& cond_sdf_tcycle_se, tcycle_se, TimingViol_tcycle_se);
        $width(posedge CK  &&& cond_sdf_tckh_se, tckh_se, 0, TimingViol_tckh_se);
        $width(negedge CK  &&& cond_sdf_tckl_se, tckl_se, 0, TimingViol_tckl_se);

        
        $setup(posedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $setup(negedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $hold(posedge CK &&& cond_sdf_ttms, posedge TBYPASS, ttmh, TimingViol_tbypass); 
        $hold(posedge CK &&& cond_sdf_ttms, negedge TBYPASS, ttmh, TimingViol_tbypass); 
 



        
        $setup(posedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $setup(negedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $hold(posedge CK &&& cond_sdf_tsls, posedge SLEEP, tslh, TimingViol_sleep);        
        $hold(posedge CK &&& cond_sdf_tsls, negedge SLEEP, tslh, TimingViol_sleep);

        $setup(posedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $setup(negedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $hold(posedge CK &&& cond_sdf_tstdbys, posedge STDBY, tstdbyh, TimingViol_stdby);        
        $hold(posedge CK &&& cond_sdf_tstdbys, negedge STDBY, tstdbyh, TimingViol_stdby); 
        
        
        $setup (posedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
	$setup (negedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
        
        $hold (posedge CK &&& cond_sdf_tses, posedge SE ,tseh,TimingViol_se);
	$hold (posedge CK &&& cond_sdf_tses, negedge SE ,tseh,TimingViol_se);
        
        $setup(posedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis , tsctrlis, TimingViol_sctrli);
        $setup(negedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis, tsctrlis, TimingViol_sctrli);
        $hold(posedge CK &&& cond_sdf_tsctrlis , posedge SCTRLI, tsctrlih, TimingViol_sctrli);        
        $hold(posedge CK &&& cond_sdf_tsctrlis , negedge SCTRLI, tsctrlih, TimingViol_sctrli);

        $setup(posedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $setup(negedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $hold(posedge CK &&& cond_sdf_tsdlis, posedge SDLI, tsdlih, TimingViol_sdli);        
        $hold(posedge CK &&& cond_sdf_tsdlis, negedge SDLI, tsdlih, TimingViol_sdli);

        $setup(posedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $setup(negedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $hold(posedge CK &&& cond_sdf_tsdris, posedge SDRI, tsdrih, TimingViol_sdri);        
        $hold(posedge CK &&& cond_sdf_tsdris, negedge SDRI, tsdrih, TimingViol_sdri);
        
 
        $setup(posedge SMLI, posedge CK &&& cond_sdf_tsmlis, tsmlis, TimingViol_smli);
        $setup(negedge SMLI, posedge CK &&& cond_sdf_tsmlis, tsmlis, TimingViol_smli);
        $hold(posedge CK &&& cond_sdf_tsmlis, posedge SMLI, tsmlih, TimingViol_smli);        
        $hold(posedge CK &&& cond_sdf_tsmlis, negedge SMLI, tsmlih, TimingViol_smli);

        $setup(posedge SMRI, posedge CK &&& cond_sdf_tsmris, tsmris, TimingViol_smri);
        $setup(negedge SMRI, posedge CK &&& cond_sdf_tsmris, tsmris, TimingViol_smri);
        $hold(posedge CK &&& cond_sdf_tsmris, posedge SMRI, tsmrih, TimingViol_smri);        
        $hold(posedge CK &&& cond_sdf_tsmris, negedge SMRI, tsmrih, TimingViol_smri);
	
         
        $width(negedge INITN , tinitnl, 0, TimingViol_initnl);
        
        $setup(posedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        $setup(negedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        
        $hold (posedge CK &&& cond_sdf_tinitns,posedge INITN, tinitnh, TimingViol_initn);
        $hold (posedge CK &&& cond_sdf_tinitns,negedge INITN, tinitnh, TimingViol_initn);

        $setup(posedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $setup(negedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $hold(posedge CK &&& cond_sdf_atps, posedge ATP, tatph, TimingViol_atp);        
        $hold(posedge CK &&& cond_sdf_atps, negedge ATP, tatph, TimingViol_atp);
        
        $setup(posedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $setup(negedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $hold(posedge CK &&& cond_sdf_tigs, posedge IG, tigh, TimingViol_ig);        
        $hold(posedge CK &&& cond_sdf_tigs, negedge IG, tigh, TimingViol_ig);



         
$setup(posedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[2], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[2], trmh, TimingViol_rm); 

        
$setup(posedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(posedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[1], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[1], twmh, TimingViol_wm);
 
        
        $setup(posedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $setup(negedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $hold(posedge CK &&& cond_sdf_tbists, posedge TBIST, tbisth, TimingViol_tbist);        
        $hold(posedge CK &&& cond_sdf_tbists, negedge TBIST, tbisth, TimingViol_tbist);
        
        	$setup(posedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$setup(negedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[5], tbah, TimingViol_addr);
       	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[5], tbah, TimingViol_addr);

        $setup(posedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$setup(negedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, posedge TCSN, tbph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, negedge TCSN, tbph, TimingViol_CSN); 
       
        $setup(posedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $setup(negedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, posedge TWEN, tbwh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, negedge TWEN, tbwh, TimingViol_WEN);
       
       
        $setup(posedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $setup(negedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, posedge TED, tbdeh, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, negedge TED, tbdeh, TimingViol_TED);

        $setup(posedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $setup(negedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, posedge TOD, tbdoh, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, negedge TOD, tbdoh, TimingViol_TOD);

        $setup(posedge TEM, posedge CK &&& cond_sdf_tbmes, tbmes, TimingViol_TEM);
        $setup(negedge TEM, posedge CK &&& cond_sdf_tbmes, tbmes, TimingViol_TEM);
        $hold(posedge CK &&& cond_sdf_tbmes, posedge TEM, tbmeh, TimingViol_TEM);
        $hold(posedge CK &&& cond_sdf_tbmes, negedge TEM, tbmeh, TimingViol_TEM);

        $setup(posedge TOM, posedge CK &&& cond_sdf_tbmos, tbmos, TimingViol_TOM);
        $setup(negedge TOM, posedge CK &&& cond_sdf_tbmos, tbmos, TimingViol_TOM);
        $hold(posedge CK &&& cond_sdf_tbmos, posedge TOM, tbmoh, TimingViol_TOM);
        $hold(posedge CK &&& cond_sdf_tbmos, negedge TOM, tbmoh, TimingViol_TOM);
       
          


          

          /*-------------------- Propagation Delays ------------------*/
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[22] +: OutReg_data[22])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[23] +: OutReg_data[23])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[24] +: OutReg_data[24])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[25] +: OutReg_data[25])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[26] +: OutReg_data[26])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[27] +: OutReg_data[27])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[28] +: OutReg_data[28])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[29] +: OutReg_data[29])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[30] +: OutReg_data[30])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[31] +: OutReg_data[31])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[32] +: OutReg_data[32])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[33] +: OutReg_data[33])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[34] +: OutReg_data[34])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[35] +: OutReg_data[35])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[36] +: OutReg_data[36])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[37] +: OutReg_data[37])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[38] +: OutReg_data[38])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[39] +: OutReg_data[39])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[40] +: OutReg_data[40])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[41] +: OutReg_data[41])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[42] +: OutReg_data[42])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[43] +: OutReg_data[43])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[44] +: OutReg_data[44])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[45] +: OutReg_data[45])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[46] +: OutReg_data[46])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[47] +: OutReg_data[47])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[48] +: OutReg_data[48])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[49] +: OutReg_data[49])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[50] +: OutReg_data[50])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[51] +: OutReg_data[51])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[52] +: OutReg_data[52])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[53] +: OutReg_data[53])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[54] +: OutReg_data[54])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[55] +: OutReg_data[55])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[56] +: OutReg_data[56])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[57] +: OutReg_data[57])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[58] +: OutReg_data[58])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[59] +: OutReg_data[59])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[60] +: OutReg_data[60])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[61] +: OutReg_data[61])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[62] +: OutReg_data[62])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[63] +: OutReg_data[63])) = (taa, taa, th, taa, th, taa);
                 

/* // //	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[0] +: OutReg_data[0])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[1] +: OutReg_data[1])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[2] +: OutReg_data[2])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[3] +: OutReg_data[3])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[4] +: OutReg_data[4])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[5] +: OutReg_data[5])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[6] +: OutReg_data[6])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[7] +: OutReg_data[7])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[8] +: OutReg_data[8])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[9] +: OutReg_data[9])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[10] +: OutReg_data[10])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[11] +: OutReg_data[11])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[12] +: OutReg_data[12])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[13] +: OutReg_data[13])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[14] +: OutReg_data[14])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[15] +: OutReg_data[15])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[16] +: OutReg_data[16])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[17] +: OutReg_data[17])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[18] +: OutReg_data[18])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[19] +: OutReg_data[19])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[20] +: OutReg_data[20])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[21] +: OutReg_data[21])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[22] +: OutReg_data[22])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[23] +: OutReg_data[23])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[24] +: OutReg_data[24])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[25] +: OutReg_data[25])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[26] +: OutReg_data[26])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[27] +: OutReg_data[27])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[28] +: OutReg_data[28])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[29] +: OutReg_data[29])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[30] +: OutReg_data[30])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[31] +: OutReg_data[31])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[32] +: OutReg_data[32])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[33] +: OutReg_data[33])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[34] +: OutReg_data[34])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[35] +: OutReg_data[35])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[36] +: OutReg_data[36])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[37] +: OutReg_data[37])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[38] +: OutReg_data[38])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[39] +: OutReg_data[39])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[40] +: OutReg_data[40])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[41] +: OutReg_data[41])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[42] +: OutReg_data[42])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[43] +: OutReg_data[43])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[44] +: OutReg_data[44])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[45] +: OutReg_data[45])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[46] +: OutReg_data[46])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[47] +: OutReg_data[47])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[48] +: OutReg_data[48])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[49] +: OutReg_data[49])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[50] +: OutReg_data[50])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[51] +: OutReg_data[51])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[52] +: OutReg_data[52])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[53] +: OutReg_data[53])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[54] +: OutReg_data[54])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[55] +: OutReg_data[55])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[56] +: OutReg_data[56])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[57] +: OutReg_data[57])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[58] +: OutReg_data[58])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[59] +: OutReg_data[59])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[60] +: OutReg_data[60])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[61] +: OutReg_data[61])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[62] +: OutReg_data[62])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[63] +: OutReg_data[63])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q); */ 








	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[22] +: OutReg_data[22])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[23] +: OutReg_data[23])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[24] +: OutReg_data[24])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[25] +: OutReg_data[25])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[26] +: OutReg_data[26])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[27] +: OutReg_data[27])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[28] +: OutReg_data[28])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[29] +: OutReg_data[29])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[30] +: OutReg_data[30])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[31] +: OutReg_data[31])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[32] +: OutReg_data[32])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[33] +: OutReg_data[33])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[34] +: OutReg_data[34])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[35] +: OutReg_data[35])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[36] +: OutReg_data[36])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[37] +: OutReg_data[37])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[38] +: OutReg_data[38])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[39] +: OutReg_data[39])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[40] +: OutReg_data[40])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[41] +: OutReg_data[41])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[42] +: OutReg_data[42])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[43] +: OutReg_data[43])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[44] +: OutReg_data[44])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[45] +: OutReg_data[45])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[46] +: OutReg_data[46])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[47] +: OutReg_data[47])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[48] +: OutReg_data[48])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[49] +: OutReg_data[49])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[50] +: OutReg_data[50])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[51] +: OutReg_data[51])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[52] +: OutReg_data[52])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[53] +: OutReg_data[53])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[54] +: OutReg_data[54])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[55] +: OutReg_data[55])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[56] +: OutReg_data[56])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[57] +: OutReg_data[57])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[58] +: OutReg_data[58])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[59] +: OutReg_data[59])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[60] +: OutReg_data[60])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[61] +: OutReg_data[61])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[62] +: OutReg_data[62])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[63] +: OutReg_data[63])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                





	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[22] +: OutReg_data[22])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[22] +: OutReg_data[22])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[23] +: OutReg_data[23])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[23] +: OutReg_data[23])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[24] +: OutReg_data[24])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[24] +: OutReg_data[24])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[25] +: OutReg_data[25])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[25] +: OutReg_data[25])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[26] +: OutReg_data[26])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[26] +: OutReg_data[26])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[27] +: OutReg_data[27])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[27] +: OutReg_data[27])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[28] +: OutReg_data[28])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[28] +: OutReg_data[28])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[29] +: OutReg_data[29])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[29] +: OutReg_data[29])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[30] +: OutReg_data[30])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[30] +: OutReg_data[30])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[31] +: OutReg_data[31])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[31] +: OutReg_data[31])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[32] +: OutReg_data[32])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[32] +: OutReg_data[32])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[33] +: OutReg_data[33])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[33] +: OutReg_data[33])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[34] +: OutReg_data[34])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[34] +: OutReg_data[34])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[35] +: OutReg_data[35])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[35] +: OutReg_data[35])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[36] +: OutReg_data[36])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[36] +: OutReg_data[36])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[37] +: OutReg_data[37])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[37] +: OutReg_data[37])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[38] +: OutReg_data[38])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[38] +: OutReg_data[38])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[39] +: OutReg_data[39])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[39] +: OutReg_data[39])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[40] +: OutReg_data[40])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[40] +: OutReg_data[40])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[41] +: OutReg_data[41])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[41] +: OutReg_data[41])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[42] +: OutReg_data[42])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[42] +: OutReg_data[42])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[43] +: OutReg_data[43])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[43] +: OutReg_data[43])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[44] +: OutReg_data[44])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[44] +: OutReg_data[44])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[45] +: OutReg_data[45])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[45] +: OutReg_data[45])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[46] +: OutReg_data[46])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[46] +: OutReg_data[46])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[47] +: OutReg_data[47])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[47] +: OutReg_data[47])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[48] +: OutReg_data[48])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[48] +: OutReg_data[48])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[49] +: OutReg_data[49])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[49] +: OutReg_data[49])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[50] +: OutReg_data[50])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[50] +: OutReg_data[50])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[51] +: OutReg_data[51])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[51] +: OutReg_data[51])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[52] +: OutReg_data[52])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[52] +: OutReg_data[52])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[53] +: OutReg_data[53])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[53] +: OutReg_data[53])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[54] +: OutReg_data[54])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[54] +: OutReg_data[54])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[55] +: OutReg_data[55])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[55] +: OutReg_data[55])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[56] +: OutReg_data[56])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[56] +: OutReg_data[56])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[57] +: OutReg_data[57])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[57] +: OutReg_data[57])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[58] +: OutReg_data[58])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[58] +: OutReg_data[58])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[59] +: OutReg_data[59])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[59] +: OutReg_data[59])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[60] +: OutReg_data[60])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[60] +: OutReg_data[60])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[61] +: OutReg_data[61])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[61] +: OutReg_data[61])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[62] +: OutReg_data[62])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[62] +: OutReg_data[62])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[63] +: OutReg_data[63])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[63] +: OutReg_data[63])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                 

	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[0] +: OutReg_data[0])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[1] +: OutReg_data[1])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[2] +: OutReg_data[2])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[3] +: OutReg_data[3])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[4] +: OutReg_data[4])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[5] +: OutReg_data[5])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[6] +: OutReg_data[6])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[7] +: OutReg_data[7])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[8] +: OutReg_data[8])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[9] +: OutReg_data[9])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[10] +: OutReg_data[10])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[11] +: OutReg_data[11])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[12] +: OutReg_data[12])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[13] +: OutReg_data[13])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[14] +: OutReg_data[14])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[15] +: OutReg_data[15])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[16] +: OutReg_data[16])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[17] +: OutReg_data[17])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[18] +: OutReg_data[18])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[19] +: OutReg_data[19])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[20] +: OutReg_data[20])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[21] +: OutReg_data[21])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[22] +: OutReg_data[22])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[23] +: OutReg_data[23])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[24] +: OutReg_data[24])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[25] +: OutReg_data[25])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[26] +: OutReg_data[26])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[27] +: OutReg_data[27])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[28] +: OutReg_data[28])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[29] +: OutReg_data[29])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[30] +: OutReg_data[30])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[31] +: OutReg_data[31])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[32] +: OutReg_data[32])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[33] +: OutReg_data[33])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[34] +: OutReg_data[34])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[35] +: OutReg_data[35])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[36] +: OutReg_data[36])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[37] +: OutReg_data[37])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[38] +: OutReg_data[38])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[39] +: OutReg_data[39])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[40] +: OutReg_data[40])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[41] +: OutReg_data[41])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[42] +: OutReg_data[42])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[43] +: OutReg_data[43])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[44] +: OutReg_data[44])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[45] +: OutReg_data[45])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[46] +: OutReg_data[46])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[47] +: OutReg_data[47])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[48] +: OutReg_data[48])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[49] +: OutReg_data[49])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[50] +: OutReg_data[50])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[51] +: OutReg_data[51])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[52] +: OutReg_data[52])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[53] +: OutReg_data[53])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[54] +: OutReg_data[54])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[55] +: OutReg_data[55])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[56] +: OutReg_data[56])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[57] +: OutReg_data[57])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[58] +: OutReg_data[58])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[59] +: OutReg_data[59])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[60] +: OutReg_data[60])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[61] +: OutReg_data[61])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[62] +: OutReg_data[62])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[63] +: OutReg_data[63])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                



if (cond_sdf_taa_sctrlo) 
        (posedge CK *> (SCTRLO :  SCTRLI)) = (taa_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo); 

if (cond_sdf_taa_sctrlo_se) 
        (negedge CK *> (SCTRLO : SCTRLI)) = (taa_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se); 
 

if (cond_sdf_taa_sdlo) 
        (posedge CK *> (SDLO :  SDLI)) = (taa_sdlo,taa_sdlo,th_sdlo,taa_sdlo,th_sdlo,taa_sdlo); 

if (cond_sdf_taa_sdlo_se) 
        (negedge CK *> (SDLO : SDLI)) = (taa_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se);

if (cond_sdf_taa_sdro) 
        (posedge CK *> (SDRO :  SDRI)) = (taa_sdro,taa_sdro,th_sdro,taa_sdro,th_sdro,taa_sdro); 

if (cond_sdf_taa_sdro_se) 
        (negedge CK *> (SDRO : SDRI)) = (taa_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se); 


if (cond_sdf_taa_smlo) 
        (posedge CK *> (SMLO :  SMLI)) = (taa_smlo,taa_smlo,th_smlo,taa_smlo,th_smlo,taa_smlo); 

if (cond_sdf_taa_smlo_se) 
        (negedge CK *> (SMLO : SMLI)) = (taa_smlo_se,taa_smlo_se,th_smlo_se,taa_smlo_se,th_smlo_se,taa_smlo_se);

if (cond_sdf_taa_smro) 
        (posedge CK *> (SMRO :  SMRI)) = (taa_smro,taa_smro,th_smro,taa_smro,th_smro,taa_smro);

if (cond_sdf_taa_smro_se) 
        (negedge CK *> (SMRO : SMRI)) = (taa_smro_se,taa_smro_se,th_smro_se,taa_smro_se,th_smro_se,taa_smro_se);

  
     




endspecify //specify block ends


// conversion from registers to array elements for mask setup violation notifiers 
   
always @(TimingViol_mask_0   or TimingViol_TEM   )
begin
          TimingViol_mask[0]=~TimingViol_mask[0]; 
end

   
always @(TimingViol_mask_1   or TimingViol_TOM   )
begin
          TimingViol_mask[1]=~TimingViol_mask[1]; 
end

   
always @(TimingViol_mask_2   or TimingViol_TEM   )
begin
          TimingViol_mask[2]=~TimingViol_mask[2]; 
end

   
always @(TimingViol_mask_3   or TimingViol_TOM   )
begin
          TimingViol_mask[3]=~TimingViol_mask[3]; 
end

   
always @(TimingViol_mask_4   or TimingViol_TEM   )
begin
          TimingViol_mask[4]=~TimingViol_mask[4]; 
end

   
always @(TimingViol_mask_5   or TimingViol_TOM   )
begin
          TimingViol_mask[5]=~TimingViol_mask[5]; 
end

   
always @(TimingViol_mask_6   or TimingViol_TEM   )
begin
          TimingViol_mask[6]=~TimingViol_mask[6]; 
end

   
always @(TimingViol_mask_7   or TimingViol_TOM   )
begin
          TimingViol_mask[7]=~TimingViol_mask[7]; 
end

   
always @(TimingViol_mask_8   or TimingViol_TEM   )
begin
          TimingViol_mask[8]=~TimingViol_mask[8]; 
end

   
always @(TimingViol_mask_9   or TimingViol_TOM   )
begin
          TimingViol_mask[9]=~TimingViol_mask[9]; 
end

   
always @(TimingViol_mask_10   or TimingViol_TEM   )
begin
          TimingViol_mask[10]=~TimingViol_mask[10]; 
end

   
always @(TimingViol_mask_11   or TimingViol_TOM   )
begin
          TimingViol_mask[11]=~TimingViol_mask[11]; 
end

   
always @(TimingViol_mask_12   or TimingViol_TEM   )
begin
          TimingViol_mask[12]=~TimingViol_mask[12]; 
end

   
always @(TimingViol_mask_13   or TimingViol_TOM   )
begin
          TimingViol_mask[13]=~TimingViol_mask[13]; 
end

   
always @(TimingViol_mask_14   or TimingViol_TEM   )
begin
          TimingViol_mask[14]=~TimingViol_mask[14]; 
end

   
always @(TimingViol_mask_15   or TimingViol_TOM   )
begin
          TimingViol_mask[15]=~TimingViol_mask[15]; 
end

   
always @(TimingViol_mask_16   or TimingViol_TEM   )
begin
          TimingViol_mask[16]=~TimingViol_mask[16]; 
end

   
always @(TimingViol_mask_17   or TimingViol_TOM   )
begin
          TimingViol_mask[17]=~TimingViol_mask[17]; 
end

   
always @(TimingViol_mask_18   or TimingViol_TEM   )
begin
          TimingViol_mask[18]=~TimingViol_mask[18]; 
end

   
always @(TimingViol_mask_19   or TimingViol_TOM   )
begin
          TimingViol_mask[19]=~TimingViol_mask[19]; 
end

   
always @(TimingViol_mask_20   or TimingViol_TEM   )
begin
          TimingViol_mask[20]=~TimingViol_mask[20]; 
end

   
always @(TimingViol_mask_21   or TimingViol_TOM   )
begin
          TimingViol_mask[21]=~TimingViol_mask[21]; 
end

   
always @(TimingViol_mask_22   or TimingViol_TEM   )
begin
          TimingViol_mask[22]=~TimingViol_mask[22]; 
end

   
always @(TimingViol_mask_23   or TimingViol_TOM   )
begin
          TimingViol_mask[23]=~TimingViol_mask[23]; 
end

   
always @(TimingViol_mask_24   or TimingViol_TEM   )
begin
          TimingViol_mask[24]=~TimingViol_mask[24]; 
end

   
always @(TimingViol_mask_25   or TimingViol_TOM   )
begin
          TimingViol_mask[25]=~TimingViol_mask[25]; 
end

   
always @(TimingViol_mask_26   or TimingViol_TEM   )
begin
          TimingViol_mask[26]=~TimingViol_mask[26]; 
end

   
always @(TimingViol_mask_27   or TimingViol_TOM   )
begin
          TimingViol_mask[27]=~TimingViol_mask[27]; 
end

   
always @(TimingViol_mask_28   or TimingViol_TEM   )
begin
          TimingViol_mask[28]=~TimingViol_mask[28]; 
end

   
always @(TimingViol_mask_29   or TimingViol_TOM   )
begin
          TimingViol_mask[29]=~TimingViol_mask[29]; 
end

   
always @(TimingViol_mask_30   or TimingViol_TEM   )
begin
          TimingViol_mask[30]=~TimingViol_mask[30]; 
end

   
always @(TimingViol_mask_31   or TimingViol_TOM   )
begin
          TimingViol_mask[31]=~TimingViol_mask[31]; 
end

   
always @(TimingViol_mask_32   or TimingViol_TEM   )
begin
          TimingViol_mask[32]=~TimingViol_mask[32]; 
end

   
always @(TimingViol_mask_33   or TimingViol_TOM   )
begin
          TimingViol_mask[33]=~TimingViol_mask[33]; 
end

   
always @(TimingViol_mask_34   or TimingViol_TEM   )
begin
          TimingViol_mask[34]=~TimingViol_mask[34]; 
end

   
always @(TimingViol_mask_35   or TimingViol_TOM   )
begin
          TimingViol_mask[35]=~TimingViol_mask[35]; 
end

   
always @(TimingViol_mask_36   or TimingViol_TEM   )
begin
          TimingViol_mask[36]=~TimingViol_mask[36]; 
end

   
always @(TimingViol_mask_37   or TimingViol_TOM   )
begin
          TimingViol_mask[37]=~TimingViol_mask[37]; 
end

   
always @(TimingViol_mask_38   or TimingViol_TEM   )
begin
          TimingViol_mask[38]=~TimingViol_mask[38]; 
end

   
always @(TimingViol_mask_39   or TimingViol_TOM   )
begin
          TimingViol_mask[39]=~TimingViol_mask[39]; 
end

   
always @(TimingViol_mask_40   or TimingViol_TEM   )
begin
          TimingViol_mask[40]=~TimingViol_mask[40]; 
end

   
always @(TimingViol_mask_41   or TimingViol_TOM   )
begin
          TimingViol_mask[41]=~TimingViol_mask[41]; 
end

   
always @(TimingViol_mask_42   or TimingViol_TEM   )
begin
          TimingViol_mask[42]=~TimingViol_mask[42]; 
end

   
always @(TimingViol_mask_43   or TimingViol_TOM   )
begin
          TimingViol_mask[43]=~TimingViol_mask[43]; 
end

   
always @(TimingViol_mask_44   or TimingViol_TEM   )
begin
          TimingViol_mask[44]=~TimingViol_mask[44]; 
end

   
always @(TimingViol_mask_45   or TimingViol_TOM   )
begin
          TimingViol_mask[45]=~TimingViol_mask[45]; 
end

   
always @(TimingViol_mask_46   or TimingViol_TEM   )
begin
          TimingViol_mask[46]=~TimingViol_mask[46]; 
end

   
always @(TimingViol_mask_47   or TimingViol_TOM   )
begin
          TimingViol_mask[47]=~TimingViol_mask[47]; 
end

   
always @(TimingViol_mask_48   or TimingViol_TEM   )
begin
          TimingViol_mask[48]=~TimingViol_mask[48]; 
end

   
always @(TimingViol_mask_49   or TimingViol_TOM   )
begin
          TimingViol_mask[49]=~TimingViol_mask[49]; 
end

   
always @(TimingViol_mask_50   or TimingViol_TEM   )
begin
          TimingViol_mask[50]=~TimingViol_mask[50]; 
end

   
always @(TimingViol_mask_51   or TimingViol_TOM   )
begin
          TimingViol_mask[51]=~TimingViol_mask[51]; 
end

   
always @(TimingViol_mask_52   or TimingViol_TEM   )
begin
          TimingViol_mask[52]=~TimingViol_mask[52]; 
end

   
always @(TimingViol_mask_53   or TimingViol_TOM   )
begin
          TimingViol_mask[53]=~TimingViol_mask[53]; 
end

   
always @(TimingViol_mask_54   or TimingViol_TEM   )
begin
          TimingViol_mask[54]=~TimingViol_mask[54]; 
end

   
always @(TimingViol_mask_55   or TimingViol_TOM   )
begin
          TimingViol_mask[55]=~TimingViol_mask[55]; 
end

   
always @(TimingViol_mask_56   or TimingViol_TEM   )
begin
          TimingViol_mask[56]=~TimingViol_mask[56]; 
end

   
always @(TimingViol_mask_57   or TimingViol_TOM   )
begin
          TimingViol_mask[57]=~TimingViol_mask[57]; 
end

   
always @(TimingViol_mask_58   or TimingViol_TEM   )
begin
          TimingViol_mask[58]=~TimingViol_mask[58]; 
end

   
always @(TimingViol_mask_59   or TimingViol_TOM   )
begin
          TimingViol_mask[59]=~TimingViol_mask[59]; 
end

   
always @(TimingViol_mask_60   or TimingViol_TEM   )
begin
          TimingViol_mask[60]=~TimingViol_mask[60]; 
end

   
always @(TimingViol_mask_61   or TimingViol_TOM   )
begin
          TimingViol_mask[61]=~TimingViol_mask[61]; 
end

   
always @(TimingViol_mask_62   or TimingViol_TEM   )
begin
          TimingViol_mask[62]=~TimingViol_mask[62]; 
end

   
always @(TimingViol_mask_63   or TimingViol_TOM   )
begin
          TimingViol_mask[63]=~TimingViol_mask[63]; 
end






// conversion from registers to array elements for data setup violation notifiers

always @(TimingViol_data_0   or TimingViol_TED  )
begin
        TimingViol_data[0]=~TimingViol_data[0];   
end


always @(TimingViol_data_1   or TimingViol_TOD  )
begin
        TimingViol_data[1]=~TimingViol_data[1];   
end


always @(TimingViol_data_2   or TimingViol_TED  )
begin
        TimingViol_data[2]=~TimingViol_data[2];   
end


always @(TimingViol_data_3   or TimingViol_TOD  )
begin
        TimingViol_data[3]=~TimingViol_data[3];   
end


always @(TimingViol_data_4   or TimingViol_TED  )
begin
        TimingViol_data[4]=~TimingViol_data[4];   
end


always @(TimingViol_data_5   or TimingViol_TOD  )
begin
        TimingViol_data[5]=~TimingViol_data[5];   
end


always @(TimingViol_data_6   or TimingViol_TED  )
begin
        TimingViol_data[6]=~TimingViol_data[6];   
end


always @(TimingViol_data_7   or TimingViol_TOD  )
begin
        TimingViol_data[7]=~TimingViol_data[7];   
end


always @(TimingViol_data_8   or TimingViol_TED  )
begin
        TimingViol_data[8]=~TimingViol_data[8];   
end


always @(TimingViol_data_9   or TimingViol_TOD  )
begin
        TimingViol_data[9]=~TimingViol_data[9];   
end


always @(TimingViol_data_10   or TimingViol_TED  )
begin
        TimingViol_data[10]=~TimingViol_data[10];   
end


always @(TimingViol_data_11   or TimingViol_TOD  )
begin
        TimingViol_data[11]=~TimingViol_data[11];   
end


always @(TimingViol_data_12   or TimingViol_TED  )
begin
        TimingViol_data[12]=~TimingViol_data[12];   
end


always @(TimingViol_data_13   or TimingViol_TOD  )
begin
        TimingViol_data[13]=~TimingViol_data[13];   
end


always @(TimingViol_data_14   or TimingViol_TED  )
begin
        TimingViol_data[14]=~TimingViol_data[14];   
end


always @(TimingViol_data_15   or TimingViol_TOD  )
begin
        TimingViol_data[15]=~TimingViol_data[15];   
end


always @(TimingViol_data_16   or TimingViol_TED  )
begin
        TimingViol_data[16]=~TimingViol_data[16];   
end


always @(TimingViol_data_17   or TimingViol_TOD  )
begin
        TimingViol_data[17]=~TimingViol_data[17];   
end


always @(TimingViol_data_18   or TimingViol_TED  )
begin
        TimingViol_data[18]=~TimingViol_data[18];   
end


always @(TimingViol_data_19   or TimingViol_TOD  )
begin
        TimingViol_data[19]=~TimingViol_data[19];   
end


always @(TimingViol_data_20   or TimingViol_TED  )
begin
        TimingViol_data[20]=~TimingViol_data[20];   
end


always @(TimingViol_data_21   or TimingViol_TOD  )
begin
        TimingViol_data[21]=~TimingViol_data[21];   
end


always @(TimingViol_data_22   or TimingViol_TED  )
begin
        TimingViol_data[22]=~TimingViol_data[22];   
end


always @(TimingViol_data_23   or TimingViol_TOD  )
begin
        TimingViol_data[23]=~TimingViol_data[23];   
end


always @(TimingViol_data_24   or TimingViol_TED  )
begin
        TimingViol_data[24]=~TimingViol_data[24];   
end


always @(TimingViol_data_25   or TimingViol_TOD  )
begin
        TimingViol_data[25]=~TimingViol_data[25];   
end


always @(TimingViol_data_26   or TimingViol_TED  )
begin
        TimingViol_data[26]=~TimingViol_data[26];   
end


always @(TimingViol_data_27   or TimingViol_TOD  )
begin
        TimingViol_data[27]=~TimingViol_data[27];   
end


always @(TimingViol_data_28   or TimingViol_TED  )
begin
        TimingViol_data[28]=~TimingViol_data[28];   
end


always @(TimingViol_data_29   or TimingViol_TOD  )
begin
        TimingViol_data[29]=~TimingViol_data[29];   
end


always @(TimingViol_data_30   or TimingViol_TED  )
begin
        TimingViol_data[30]=~TimingViol_data[30];   
end


always @(TimingViol_data_31   or TimingViol_TOD  )
begin
        TimingViol_data[31]=~TimingViol_data[31];   
end


always @(TimingViol_data_32   or TimingViol_TED  )
begin
        TimingViol_data[32]=~TimingViol_data[32];   
end


always @(TimingViol_data_33   or TimingViol_TOD  )
begin
        TimingViol_data[33]=~TimingViol_data[33];   
end


always @(TimingViol_data_34   or TimingViol_TED  )
begin
        TimingViol_data[34]=~TimingViol_data[34];   
end


always @(TimingViol_data_35   or TimingViol_TOD  )
begin
        TimingViol_data[35]=~TimingViol_data[35];   
end


always @(TimingViol_data_36   or TimingViol_TED  )
begin
        TimingViol_data[36]=~TimingViol_data[36];   
end


always @(TimingViol_data_37   or TimingViol_TOD  )
begin
        TimingViol_data[37]=~TimingViol_data[37];   
end


always @(TimingViol_data_38   or TimingViol_TED  )
begin
        TimingViol_data[38]=~TimingViol_data[38];   
end


always @(TimingViol_data_39   or TimingViol_TOD  )
begin
        TimingViol_data[39]=~TimingViol_data[39];   
end


always @(TimingViol_data_40   or TimingViol_TED  )
begin
        TimingViol_data[40]=~TimingViol_data[40];   
end


always @(TimingViol_data_41   or TimingViol_TOD  )
begin
        TimingViol_data[41]=~TimingViol_data[41];   
end


always @(TimingViol_data_42   or TimingViol_TED  )
begin
        TimingViol_data[42]=~TimingViol_data[42];   
end


always @(TimingViol_data_43   or TimingViol_TOD  )
begin
        TimingViol_data[43]=~TimingViol_data[43];   
end


always @(TimingViol_data_44   or TimingViol_TED  )
begin
        TimingViol_data[44]=~TimingViol_data[44];   
end


always @(TimingViol_data_45   or TimingViol_TOD  )
begin
        TimingViol_data[45]=~TimingViol_data[45];   
end


always @(TimingViol_data_46   or TimingViol_TED  )
begin
        TimingViol_data[46]=~TimingViol_data[46];   
end


always @(TimingViol_data_47   or TimingViol_TOD  )
begin
        TimingViol_data[47]=~TimingViol_data[47];   
end


always @(TimingViol_data_48   or TimingViol_TED  )
begin
        TimingViol_data[48]=~TimingViol_data[48];   
end


always @(TimingViol_data_49   or TimingViol_TOD  )
begin
        TimingViol_data[49]=~TimingViol_data[49];   
end


always @(TimingViol_data_50   or TimingViol_TED  )
begin
        TimingViol_data[50]=~TimingViol_data[50];   
end


always @(TimingViol_data_51   or TimingViol_TOD  )
begin
        TimingViol_data[51]=~TimingViol_data[51];   
end


always @(TimingViol_data_52   or TimingViol_TED  )
begin
        TimingViol_data[52]=~TimingViol_data[52];   
end


always @(TimingViol_data_53   or TimingViol_TOD  )
begin
        TimingViol_data[53]=~TimingViol_data[53];   
end


always @(TimingViol_data_54   or TimingViol_TED  )
begin
        TimingViol_data[54]=~TimingViol_data[54];   
end


always @(TimingViol_data_55   or TimingViol_TOD  )
begin
        TimingViol_data[55]=~TimingViol_data[55];   
end


always @(TimingViol_data_56   or TimingViol_TED  )
begin
        TimingViol_data[56]=~TimingViol_data[56];   
end


always @(TimingViol_data_57   or TimingViol_TOD  )
begin
        TimingViol_data[57]=~TimingViol_data[57];   
end


always @(TimingViol_data_58   or TimingViol_TED  )
begin
        TimingViol_data[58]=~TimingViol_data[58];   
end


always @(TimingViol_data_59   or TimingViol_TOD  )
begin
        TimingViol_data[59]=~TimingViol_data[59];   
end


always @(TimingViol_data_60   or TimingViol_TED  )
begin
        TimingViol_data[60]=~TimingViol_data[60];   
end


always @(TimingViol_data_61   or TimingViol_TOD  )
begin
        TimingViol_data[61]=~TimingViol_data[61];   
end


always @(TimingViol_data_62   or TimingViol_TED  )
begin
        TimingViol_data[62]=~TimingViol_data[62];   
end


always @(TimingViol_data_63   or TimingViol_TOD  )
begin
        TimingViol_data[63]=~TimingViol_data[63];   
end


`endif


// TASK DEFINITION DESCRIPTION
// ================================



task task_insert_faults_in_memory;
begin
   if (reg_ConfigFault)
   begin   
     for(i = 0;i< fcnt;i = i+ 1) begin
        if(mem_red_array_stuck_at[i] === "mem_array") begin
          if (array_stuck_at[i] === "sa0") begin
           `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data & stuck_at_0fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
          `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] & stuck_at_0fault[i];
          `endif
         end //if(array_stuck_at)
                                        
         if(array_stuck_at[i] === "sa1") begin
         `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data | stuck_at_1fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
         `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] | stuck_at_1fault[i]; 
         `endif
         end //if(array_stuck_at)
       end //if mem_red_array_stuck_at
    
    
     end    // end of for
   end  
end
endtask



task task_read_fault_file;
begin
/*  -----------Implemetation for config fault starts------*/
   msgcnt = X;
   t = 0;
   fault_repair_flag = {max_faults{1'b1}};
   repair_flag = {max_faults{1'b1}};
   if(reg_ConfigFault) 
   begin
      file_ptr = $fopen(reg_Fault_file_name , "r");
      if(file_ptr == 0)
      begin     
          if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: File cannot be opened ",$realtime);
      end        
      else                
      begin : read_fault_file
        t = 0;
        for (i = 0; i< max_faults; i= i + 1)
        begin
         
           stuck0 = {Bits{1'b1}};
           stuck1 = {Bits{1'b0}};
           fault_char1 = $fgetc (file_ptr);
           if (fault_char1 == 8'b11111111)
              disable read_fault_file;
           ret_val = $ungetc (fault_char1, file_ptr);
           ret_val = $fgets(tempStr, file_ptr);
           ret_val = $sscanf(tempStr, "%s %d %d %s",fault_array,fault_word, fault_bit, stuck_at) ;
           flag_error = 0; 
           if(ret_val !== 0)
           begin         
              if(ret_val == 3 || ret_val == 4)
              begin
                if(ret_val == 3)
                   stuck_at = "sa0";

                if(stuck_at !== "sa0" && stuck_at !== "sa1" && stuck_at !== "none")
                begin
                    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: Wrong value for stuck at in fault file ",$realtime);
                   flag_error = 1;
                end    
                      
                if(fault_word >= Words)
                begin
                   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Address out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                if(fault_bit >= Bits)
                begin  
                    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Faulty bit out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                
                        
                if(fault_array !== "mem_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array is not mem_array ",$realtime);
                  flag_error = 1;
                end

                if(fault_array === "red_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array can't be on redundancy array in non redundancy cut.",$realtime);
                  flag_error = 1;
                end

                
                

                if(flag_error == 0)
                //Correct Inputs
                begin
                   if(stuck_at === "none")
                   begin
                       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
                   end
                   else
                   //Adding the faults
                   begin
                      FailureLocn[t] = fault_word;
                      Failurebit[t]  = fault_bit ;
                      std_fault_word = fault_word;
                      fault_row_add[t] = std_fault_word[Addr-1:mux_bits];
                      mem_red_array_stuck_at[t] = fault_array;
                      fault_repair_flag[t] = 1'b0;
                      if (stuck_at === "sa0" )
                      begin
                         stuck0[fault_bit] = 1'b0;         
                         stuck_at_0fault[t] = stuck0;
                      end     
                      if (stuck_at === "sa1" )
                      begin
                         stuck1[fault_bit] = 1'b1;
                         stuck_at_1fault[t] = stuck1; 
                      end

                      array_stuck_at[t] = stuck_at;
                      t = t + 1;
                   end //if(stuck_at === "none")  
                end //if(flag_error == 0)
              end //if(ret_val == 2 || ret_val == 3 
              else
              //wrong number of arguments
              begin
                if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: WRONG VALUES ENTERED FOR FAULTY WORD OR FAULTY BIT OR STUCK_AT IN Fault_file_name ",$realtime); 
                flag_error = 1;
              end
           end //if(ret_val !== 0)
           else
           begin 
               if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
           end    
        end //for (i = 0; i< m
      end //begin: read_fault_file  
      $fclose (file_ptr);

      fcnt = t;
      
      //fault injection at time 0.
      task_insert_faults_in_memory;
  end // config_fault 
end
endtask


task WriteMemX;
begin

`ifdef slm
   $slm_ResetMemory(MemAddr, WordX);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = WordX;
   
`endif        
 task_insert_faults_in_memory;
end
endtask

task WriteMem0;
begin
`ifdef slm
   $slm_ResetMemory(MemAddr, Word0);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = Word0;
  
`endif 
   task_insert_faults_in_memory;
end
endtask


task WriteOutX;                
begin
   OutReg_data <= #0 WordX;
end
endtask


task Invalid_next_cycle_func;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_func = 1;
     `else 
       #0 next_cycle_corrupt_func = 0; 
     `endif  
   end 
end
endtask

task Invalid_next_cycle_dft;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_dft = 1;
     `else 
       #0 next_cycle_corrupt_dft = 0; 
     `endif  
  end
end
endtask

task Invalid_next_cycle_func_tim;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
   #0 next_cycle_corrupt_func <= 1;
  end 
end
endtask

task Invalid_next_cycle_dft_tim;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
  #0 next_cycle_corrupt_dft <= 1;
  end
end
endtask


task ScanOutX;                
begin
   
   dff_SCTRLO_SE.Q <= 1'bx;   
   dff_SDLO_SE.Q <= 1'bx; 
   dff_SDRO_SE.Q <= 1'bx; 
   
   dff_SMLO_SE.Q <= 1'bx; 
   dff_SMRO_SE.Q <= 1'bx; 
   
   SCTRLOint=X;
   SDLOint=X;
   SDROint=X;
   
   SMLOint=X;
   SMROint=X;
    
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   SDLO_data<=1'bx;
   SDRO_data<=1'bx;
   
   SMLO_data<=1'bx;
   SMRO_data<=1'bx; 
   `endif
end
endtask

task delScanOutX;                
begin
   delSCTRLO_data<=X;
   delSDLO_data<=X;
   delSDRO_data<=X;
   
   delSMLO_data<=X;
   delSMRO_data<=X;
    
end
endtask

task ScanChainX;                
begin
 scanreg_ctrl=1'bx; 
 scanreg_dl=1'bx; 
 scanreg_dr =1'bx; 
 
 scanreg_ml =1'bx; 
 scanreg_mr=1'bx; 
  
end
endtask

task mem_blocked;
begin
 
   WriteMemX;
   WriteOutX;
   ScanChainX;
   ScanOutX;//immediately;
   delScanOutX;//immediately
   `ifdef POWER_SEQUENCING_OFF
   `else
   reg_mem_block=1;
   `endif
   debug_level = 2'b11;
end
endtask

task corrupt_all;
begin
 
  WriteMemX;
  WriteOutX;
  ScanChainX;
  ScanOutX;
  delScanOutX;//immediately;
  OutReg_data = WordX; 
  delOutReg_data=WordX;
  
end
endtask

task WriteCycle;                  
input [Addr-1 : 0] Address;
reg [Bits-1:0] tempReg1;
reg [Bits-1:0] tempReg_slm;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;


reg repair_flag;

integer po,i,num,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;
begin

   tempReg1 = WordX;
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];

   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};
   
   if (ValidAddress === X )   begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
        WriteMemX;
        if (INITNint !== 0) begin
        `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
           #0 next_cycle_corrupt_func = 1;
       `else 
           #0 next_cycle_corrupt_func = 0; 
       `endif  
   end 

   end


   if (ValidAddress !== X && next_cycle_corrupt_func === 0  )
   begin
         if (red_en === 1 && ((Row_Add_cmp === repair_add) || (Row_Add_cmp === next_repair_add)) ) begin
             repair_flag = 1'b1;
             
             Bank_sel_integer = 0;
                     
             if (Row_Add_cmp === repair_add) begin
               Col_Add_integer  = Col_Add; 
             end
             else if (Row_Add_cmp === next_repair_add) begin
               Col_Add_integer  = Col_Add + mux; 
             end  
             RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
        end  

        if(repair_flag === 0 && ValidAddress === 1) begin
           `ifdef slm
              $slm_ReadMemoryS(MemAddr, Address, tempReg_slm);
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = Mem[Address];
            `endif
          end  
        else if(repair_flag === 1) begin
           `ifdef slm
//              $slm_ReadMemoryS(RedMemAddr, RedMem_address, tempReg_slm);
          
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = RedMem[RedMem_address];
            `endif
        end
        
        for (num=0;num<Bits;num=num+1) begin
             po=num;        
             if ( Dint [num] !== tempReg1 [po]) begin
                if (Mint[num] === 1'b0)
                   tempReg1[po] = Dint[num];
                else if (Mint[num] === 1'bX)
                   tempReg1[po] = 1'bx;
             end                
        end //for (num=0
            
         if(repair_flag === 0 ) begin    
            if(ValidAddress === 1) begin  
              `ifdef slm
                  tempReg_slm=tempReg1; 
                  $slm_WriteMemory(MemAddr, Address, tempReg_slm);
              `else
                   Mem[Address] = tempReg1;
              `endif
            end
            else begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address Out Of Range. ",$realtime);
            end        
         end
         else if (repair_flag === 1 ) begin
            `ifdef slm
                tempReg_slm=tempReg1; 
//                $slm_WriteMemory(RedMemAddr, RedMem_address, tempReg_slm);
            `else
                RedMem[RedMem_address] = tempReg1;
            `endif
         end
   end //if (ValidAddress !== X
   task_insert_faults_in_memory;
end
endtask 

task ReadCycle;
input [Addr-1 : 0] Address;

reg [Bits-1:0] MemData_tmp;
reg [Bits-1:0] MemData;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;

reg repair_flag;

integer a,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;

begin
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];
   
   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};

   

   if (ValidAddress !== X && next_cycle_corrupt_func === 0 ) begin   
       if(red_en === 1 && ( Row_Add_cmp === repair_add ||  Row_Add_cmp === next_repair_add )) begin
              repair_flag = 1;
              
              Bank_sel_integer = 0;
               
              if(Row_Add_cmp === repair_add) begin
                Col_Add_integer = Col_Add;
              end
              else if (Row_Add_cmp === next_repair_add) begin
                Col_Add_integer = Col_Add + mux; 
              end
              RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
       end

      if(repair_flag === 0) begin
          if(ValidAddress === 1) begin 
           `ifdef slm
              $slm_ReadMemory(MemAddr, Address, MemData);
           `else
              MemData = Mem[Address];
           `endif
          end
          else begin
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Address Out Of Range. Output Corrupted ",$realtime);
             MemData = WordX;
          end
     end
      else if(repair_flag === 1) begin
        `ifdef slm
//           $slm_ReadMemory(RedMemAddr, RedMem_address, MemData);
        `else
           MemData = RedMem[RedMem_address];
        `endif
      end
   end //if (ValidAddress)  
   
   if(ValidAddress === X)
   begin
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Illegal Value on Address Bus. Memory and Output Corrupted ",$realtime); 
         Invalid_next_cycle_func;
   end 
   
  if(ValidAddress !== X && next_cycle_corrupt_func === 0 )
   begin
   for (a = 0; a < Bits; a = a + 1)
   begin
      if (MemData[a] !== OutReg_data[a])
         OutReg_data[a] = WordX[a];
   end//for (a = 0; a <  
         OutReg_data <= MemData;
   end     
end
endtask



// SCAN CHAINS
supply0 gnd;
buf (A_int[0], Aint[0]);
buf (A_int[1], Aint[1]);
buf (A_int[2], Aint[2]);
buf (A_int[3], Aint[3]);
buf (A_int[4], Aint[4]);
buf (A_int[5], Aint[5]);                  //used for capturing
buf (A_int[6], gnd);
buf (A_int[7], gnd);
buf (A_int[8], gnd);
buf (A_int[9], gnd);
buf (A_int[10], gnd);
buf (A_int[11], gnd);
buf (A_int[12], gnd);
buf (A_int[13], gnd);
buf (A_int[14], gnd);   //used for capturing

buf (WEN_int, WENint);
buf (CSN_int, CSNint);
buf (IG_int, IGint);


// Scan flops



// CONTROL SCAN CHAIN
     ST_SPREG_LOLEAK_64x64m4_bTl_SCFF cntrl_scff_0 (.D(1'b0), .TI(SCTRLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[0]), .OUTX(scanreg_ctrl));

      
 ST_SPREG_LOLEAK_64x64m4_bTl_SCFF cntrl_scff_1 (.D(A_int[3]), .TI(scanreg_ctrl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[1]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m4_bTl_SCFF cntrl_scff_2 (.D(A_int[5]), .TI(scanreg_ctrl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[2]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m4_bTl_SCFF cntrl_scff_3 (.D(A_int[8]), .TI(scanreg_ctrl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[3]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m4_bTl_SCFF cntrl_scff_4 (.D(A_int[2]), .TI(scanreg_ctrl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[4]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m4_bTl_SCFF cntrl_scff_5 (.D(A_int[10]), .TI(scanreg_ctrl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[5]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m4_bTl_SCFF cntrl_scff_6 (.D(A_int[9]), .TI(scanreg_ctrl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[6]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m4_bTl_SCFF cntrl_scff_7 (.D(A_int[1]), .TI(scanreg_ctrl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[7]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m4_bTl_SCFF cntrl_scff_8 (.D(A_int[0]), .TI(scanreg_ctrl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[8]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m4_bTl_SCFF cntrl_scff_9 (.D(A_int[4]), .TI(scanreg_ctrl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[9]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m4_bTl_SCFF cntrl_scff_10 (.D(A_int[6]), .TI(scanreg_ctrl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[10]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m4_bTl_SCFF cntrl_scff_11 (.D(CSN_int), .TI(scanreg_ctrl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[11]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m4_bTl_SCFF cntrl_scff_12 (.D(A_int[7]), .TI(scanreg_ctrl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[12]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m4_bTl_SCFF cntrl_scff_13 (.D(WEN_int), .TI(scanreg_ctrl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[13]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_64x64m4_bTl_SCFF cntrl_scff_14 (.D(scanreg_ctrl_wire[14]), .TI(scanreg_ctrl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[14]), .OUTX(scanreg_ctrl));  

reg LP_CK_gate;

// Lock Up Latch
wire SCTRLO_temp;
 ST_SPREG_LOLEAK_64x64m4_bTl_lock_up_latch  dff_SCTRLO_SE (Latch_open, scanreg_ctrl_wire[14], SCTRLO_temp);

always @(SCTRLO_temp) begin
     SCTRLOint= SCTRLO_temp;
 `ifdef functional
 `else
 if (SCTRLOint !== SCTRLO_data) begin 
  if (SCTRLOint !==X)
   SCTRLO_data=1'bx;
   SCTRLO_data <= SCTRLOint;
 end 
 `endif
end  


// LEFT DATA SCAN CHAIN
     ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_0 (.D(Dint[31]), .TI(SDLI), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[0]), .OUTX(scanreg_dl));
      
   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_1 (.D(Dint[30]), .TI(scanreg_dl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[1]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_2 (.D(Dint[29]), .TI(scanreg_dl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[2]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_3 (.D(Dint[28]), .TI(scanreg_dl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[3]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_4 (.D(Dint[27]), .TI(scanreg_dl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[4]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_5 (.D(Dint[26]), .TI(scanreg_dl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[5]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_6 (.D(Dint[25]), .TI(scanreg_dl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[6]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_7 (.D(Dint[24]), .TI(scanreg_dl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[7]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_8 (.D(Dint[23]), .TI(scanreg_dl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[8]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_9 (.D(Dint[22]), .TI(scanreg_dl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[9]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_10 (.D(Dint[21]), .TI(scanreg_dl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[10]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_11 (.D(Dint[20]), .TI(scanreg_dl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[11]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_12 (.D(Dint[19]), .TI(scanreg_dl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[12]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_13 (.D(Dint[18]), .TI(scanreg_dl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[13]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_14 (.D(Dint[17]), .TI(scanreg_dl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[14]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_15 (.D(Dint[16]), .TI(scanreg_dl_wire[14]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[15]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_16 (.D(Dint[15]), .TI(scanreg_dl_wire[15]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[16]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_17 (.D(Dint[14]), .TI(scanreg_dl_wire[16]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[17]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_18 (.D(Dint[13]), .TI(scanreg_dl_wire[17]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[18]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_19 (.D(Dint[12]), .TI(scanreg_dl_wire[18]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[19]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_20 (.D(Dint[11]), .TI(scanreg_dl_wire[19]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[20]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_21 (.D(Dint[10]), .TI(scanreg_dl_wire[20]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[21]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_22 (.D(Dint[9]), .TI(scanreg_dl_wire[21]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[22]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_23 (.D(Dint[8]), .TI(scanreg_dl_wire[22]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[23]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_24 (.D(Dint[7]), .TI(scanreg_dl_wire[23]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[24]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_25 (.D(Dint[6]), .TI(scanreg_dl_wire[24]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[25]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_26 (.D(Dint[5]), .TI(scanreg_dl_wire[25]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[26]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_27 (.D(Dint[4]), .TI(scanreg_dl_wire[26]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[27]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_28 (.D(Dint[3]), .TI(scanreg_dl_wire[27]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[28]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_29 (.D(Dint[2]), .TI(scanreg_dl_wire[28]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[29]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_30 (.D(Dint[1]), .TI(scanreg_dl_wire[29]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[30]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF ldata_scff_31 (.D(Dint[0]), .TI(scanreg_dl_wire[30]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[31]), .OUTX(scanreg_dl));



// Lock Up Latch
wire SDLO_temp;
 ST_SPREG_LOLEAK_64x64m4_bTl_lock_up_latch  dff_SDLO_SE (Latch_open, scanreg_dl_wire[31], SDLO_temp);

always @(SDLO_temp) begin
     SDLOint= SDLO_temp;
 `ifdef functional
 `else
 if (SDLOint !== SDLO_data) begin 
  if (SDLOint !==X)
   SDLO_data=1'bx;
   SDLO_data <= SDLOint;
 end 
 `endif
end  






// RIGHT DATA SCAN CHAIN

     ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_0 (.D(Dint[63]), .TI(SDRI), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[0]), .OUTX(scanreg_dr));
     
 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_1 (.D(Dint[62]), .TI(scanreg_dr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[1]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_2 (.D(Dint[61]), .TI(scanreg_dr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[2]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_3 (.D(Dint[60]), .TI(scanreg_dr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[3]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_4 (.D(Dint[59]), .TI(scanreg_dr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[4]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_5 (.D(Dint[58]), .TI(scanreg_dr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[5]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_6 (.D(Dint[57]), .TI(scanreg_dr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[6]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_7 (.D(Dint[56]), .TI(scanreg_dr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[7]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_8 (.D(Dint[55]), .TI(scanreg_dr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[8]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_9 (.D(Dint[54]), .TI(scanreg_dr_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[9]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_10 (.D(Dint[53]), .TI(scanreg_dr_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[10]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_11 (.D(Dint[52]), .TI(scanreg_dr_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[11]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_12 (.D(Dint[51]), .TI(scanreg_dr_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[12]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_13 (.D(Dint[50]), .TI(scanreg_dr_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[13]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_14 (.D(Dint[49]), .TI(scanreg_dr_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[14]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_15 (.D(Dint[48]), .TI(scanreg_dr_wire[14]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[15]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_16 (.D(Dint[47]), .TI(scanreg_dr_wire[15]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[16]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_17 (.D(Dint[46]), .TI(scanreg_dr_wire[16]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[17]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_18 (.D(Dint[45]), .TI(scanreg_dr_wire[17]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[18]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_19 (.D(Dint[44]), .TI(scanreg_dr_wire[18]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[19]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_20 (.D(Dint[43]), .TI(scanreg_dr_wire[19]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[20]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_21 (.D(Dint[42]), .TI(scanreg_dr_wire[20]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[21]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_22 (.D(Dint[41]), .TI(scanreg_dr_wire[21]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[22]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_23 (.D(Dint[40]), .TI(scanreg_dr_wire[22]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[23]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_24 (.D(Dint[39]), .TI(scanreg_dr_wire[23]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[24]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_25 (.D(Dint[38]), .TI(scanreg_dr_wire[24]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[25]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_26 (.D(Dint[37]), .TI(scanreg_dr_wire[25]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[26]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_27 (.D(Dint[36]), .TI(scanreg_dr_wire[26]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[27]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_28 (.D(Dint[35]), .TI(scanreg_dr_wire[27]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[28]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_29 (.D(Dint[34]), .TI(scanreg_dr_wire[28]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[29]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_30 (.D(Dint[33]), .TI(scanreg_dr_wire[29]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[30]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rdata_scff_31 (.D(Dint[32]), .TI(scanreg_dr_wire[30]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[31]), .OUTX(scanreg_dr)); 


// Lock Up Latch
wire SDRO_temp;
 ST_SPREG_LOLEAK_64x64m4_bTl_lock_up_latch  dff_SDRO_SE (Latch_open, scanreg_dr_wire[31], SDRO_temp);


always @(SDRO_temp) begin
     SDROint= SDRO_temp;
 `ifdef functional
 `else
 if (SDROint !== SDRO_data) begin 
  if (SDROint !==X)
   SDRO_data=1'bx;
   SDRO_data <= SDROint;
 end 
 `endif
end




// LEFT MASK SCAN CHAIN
     ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_0 (.D(Mint[31]), .TI(SMLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[0]), .OUTX(scanreg_ml));
     


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_1 (.D(Mint[30]), .TI(scanreg_ml_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[1]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_2 (.D(Mint[29]), .TI(scanreg_ml_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[2]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_3 (.D(Mint[28]), .TI(scanreg_ml_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[3]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_4 (.D(Mint[27]), .TI(scanreg_ml_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[4]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_5 (.D(Mint[26]), .TI(scanreg_ml_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[5]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_6 (.D(Mint[25]), .TI(scanreg_ml_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[6]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_7 (.D(Mint[24]), .TI(scanreg_ml_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[7]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_8 (.D(Mint[23]), .TI(scanreg_ml_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[8]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_9 (.D(Mint[22]), .TI(scanreg_ml_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[9]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_10 (.D(Mint[21]), .TI(scanreg_ml_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[10]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_11 (.D(Mint[20]), .TI(scanreg_ml_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[11]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_12 (.D(Mint[19]), .TI(scanreg_ml_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[12]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_13 (.D(Mint[18]), .TI(scanreg_ml_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[13]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_14 (.D(Mint[17]), .TI(scanreg_ml_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[14]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_15 (.D(Mint[16]), .TI(scanreg_ml_wire[14]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[15]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_16 (.D(Mint[15]), .TI(scanreg_ml_wire[15]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[16]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_17 (.D(Mint[14]), .TI(scanreg_ml_wire[16]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[17]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_18 (.D(Mint[13]), .TI(scanreg_ml_wire[17]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[18]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_19 (.D(Mint[12]), .TI(scanreg_ml_wire[18]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[19]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_20 (.D(Mint[11]), .TI(scanreg_ml_wire[19]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[20]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_21 (.D(Mint[10]), .TI(scanreg_ml_wire[20]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[21]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_22 (.D(Mint[9]), .TI(scanreg_ml_wire[21]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[22]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_23 (.D(Mint[8]), .TI(scanreg_ml_wire[22]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[23]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_24 (.D(Mint[7]), .TI(scanreg_ml_wire[23]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[24]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_25 (.D(Mint[6]), .TI(scanreg_ml_wire[24]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[25]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_26 (.D(Mint[5]), .TI(scanreg_ml_wire[25]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[26]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_27 (.D(Mint[4]), .TI(scanreg_ml_wire[26]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[27]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_28 (.D(Mint[3]), .TI(scanreg_ml_wire[27]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[28]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_29 (.D(Mint[2]), .TI(scanreg_ml_wire[28]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[29]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_30 (.D(Mint[1]), .TI(scanreg_ml_wire[29]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[30]), .OUTX(scanreg_ml));  


        ST_SPREG_LOLEAK_64x64m4_bTl_SCFF lmask_scff_31 (.D(Mint[0]), .TI(scanreg_ml_wire[30]), .TE(SE), .CP(CK_sc), .Q(scanreg_ml_wire[31]), .OUTX(scanreg_ml));  
        

// Lock Up Latch
wire SMLO_temp;
 ST_SPREG_LOLEAK_64x64m4_bTl_lock_up_latch  dff_SMLO_SE (Latch_open, scanreg_ml_wire[31], SMLO_temp);

always @(SMLO_temp) begin
     SMLOint= SMLO_temp;
 `ifdef functional
 `else
 if (SMLOint !== SMLO_data) begin 
  if (SMLOint !==X)
   SMLO_data=1'bx;
   SMLO_data <= SMLOint;
 end 
 `endif
end  






// RIGHT MASK SCAN CHAIN

     ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_0 (.D(Mint[63]), .TI(SMRI), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[0]), .OUTX(scanreg_mr));
     
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_1 (.D(Mint[62]), .TI(scanreg_mr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[1]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_2 (.D(Mint[61]), .TI(scanreg_mr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[2]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_3 (.D(Mint[60]), .TI(scanreg_mr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[3]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_4 (.D(Mint[59]), .TI(scanreg_mr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[4]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_5 (.D(Mint[58]), .TI(scanreg_mr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[5]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_6 (.D(Mint[57]), .TI(scanreg_mr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[6]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_7 (.D(Mint[56]), .TI(scanreg_mr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[7]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_8 (.D(Mint[55]), .TI(scanreg_mr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[8]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_9 (.D(Mint[54]), .TI(scanreg_mr_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[9]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_10 (.D(Mint[53]), .TI(scanreg_mr_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[10]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_11 (.D(Mint[52]), .TI(scanreg_mr_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[11]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_12 (.D(Mint[51]), .TI(scanreg_mr_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[12]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_13 (.D(Mint[50]), .TI(scanreg_mr_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[13]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_14 (.D(Mint[49]), .TI(scanreg_mr_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[14]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_15 (.D(Mint[48]), .TI(scanreg_mr_wire[14]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[15]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_16 (.D(Mint[47]), .TI(scanreg_mr_wire[15]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[16]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_17 (.D(Mint[46]), .TI(scanreg_mr_wire[16]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[17]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_18 (.D(Mint[45]), .TI(scanreg_mr_wire[17]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[18]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_19 (.D(Mint[44]), .TI(scanreg_mr_wire[18]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[19]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_20 (.D(Mint[43]), .TI(scanreg_mr_wire[19]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[20]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_21 (.D(Mint[42]), .TI(scanreg_mr_wire[20]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[21]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_22 (.D(Mint[41]), .TI(scanreg_mr_wire[21]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[22]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_23 (.D(Mint[40]), .TI(scanreg_mr_wire[22]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[23]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_24 (.D(Mint[39]), .TI(scanreg_mr_wire[23]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[24]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_25 (.D(Mint[38]), .TI(scanreg_mr_wire[24]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[25]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_26 (.D(Mint[37]), .TI(scanreg_mr_wire[25]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[26]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_27 (.D(Mint[36]), .TI(scanreg_mr_wire[26]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[27]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_28 (.D(Mint[35]), .TI(scanreg_mr_wire[27]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[28]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_29 (.D(Mint[34]), .TI(scanreg_mr_wire[28]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[29]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_30 (.D(Mint[33]), .TI(scanreg_mr_wire[29]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[30]), .OUTX(scanreg_mr));    
  
    ST_SPREG_LOLEAK_64x64m4_bTl_SCFF rmask_scff_31 (.D(Mint[32]), .TI(scanreg_mr_wire[30]), .TE(SE), .CP(CK_sc), .Q(scanreg_mr_wire[31]), .OUTX(scanreg_mr));    

// Lock Up Latch
wire SMRO_temp;
 ST_SPREG_LOLEAK_64x64m4_bTl_lock_up_latch  dff_SMRO_SE (Latch_open, scanreg_mr_wire[31], SMRO_temp);


always @(SMRO_temp) begin
     SMROint= SMRO_temp;
 `ifdef functional
 `else
 if (SMROint !== SMRO_data) begin 
  if (SMROint !==X)
   SMRO_data=1'bx;
   SMRO_data <= SMROint;
 end 
 `endif
end





//


 //////// CAPTURE TASK //////
task scan_acquire;
begin
   if (supply_ok === 1) begin 
      if ( SEsys === 0 && ((LP_CK_gate === 0 && TBYPASSsys !== 1'bx)|| TBYPASSsys===0)) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;

         scanreg_mr=1'b0;
         scanreg_ml=1'b0;
                    
         Latch_open=1;
         

      end //if ( SEint === 0
   end//if(supply_ok 
end
endtask

task scan_shift;
begin
 if (supply_ok === 1) begin
   if (STDBYint === 0 && SLEEPint === 0) begin
      if (CKint_dft === X && INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0) begin
         ScanChainX;
         ScanOutX;
      end
      else if (CKint_dft === 1 && lastCK_dft === 0 ) begin
          //// SHIFT
        if (SEsys === 1) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
           
          scanreg_mr=1'b0;
         scanreg_ml=1'b0;
           
        //// SHIFT Ends
        end //if (SEsys === 1
        else if (SEsys === X) begin
            ScanChainX;
            ScanOutX;
            delScanOutX;
        end//if (SEint ==X
      
      end///if (CKint === 
    
      else if (CKint_dft === 0 && lastCK_dft === 1 ) begin
        Latch_open=1;
      end
    end  //if (STDByint === 0 && SLEEPint === 0
 end//if(supply_ok
end
endtask






// BEHAVIOURAL MODULE DESCRIPTION
// ================================

initial
begin
  // Define format for timing value
  $timeformat (-9, 3, " ns", 0);
  `ifdef slm
  $slm_RegisterMemory(MemAddr, Words, Bits);
  `endif   
   reg_mem_block=0;
   flag_mem_block=0;
  `ifdef functional
  `else
   TimingViol_data=0;
   TimingViol_mask=0;
   `endif
   decoding_start=0;
  
   //Parameter Assignment
   
   reg_Fault_file_name = Fault_file_name; 
   reg_ConfigFault     = ConfigFault;
   reg_MEM_INITIALIZE  = MEM_INITIALIZE;
   reg_BinaryInit      = BinaryInit;
   reg_InitFileName    = InitFileName;
   reg_Initn_reset_value = Initn_reset_value;
   reg_File_load_time    = File_load_time;

   time_fall_sleep=0;
   time_fall_PSWLARGEMP=0;
   time_fall_PSWLARGEMP_0=0;
   time_fall_PSWLARGEMA=0;
   time_fall_PSWLARGEMA_0=0;
   time_fall_PSWSMALLMP=0;
   time_fall_PSWSMALLMA=0;

   vddmp_rise_time=0;
   vddmp_fall_time=0;
   vddsmp_rise_time=0;
   vddsmp_fall_time=0;
   vddma_rise_time=0;
   vddma_fall_time=0;
   vddsma_rise_time=0;
   vddsma_fall_time=0;
   vddm_fall_time=0;  
   vddm_rise_time=0;  
   vddsm_fall_time=0; 
   vddsm_rise_time=0;

   next_cycle_corrupt_func=0;
   next_cycle_corrupt_dft=0;
   init_pulse_done = 0;
   power_up_done = 0;
   file_loaded=1;
   debug_level= 2'b01;
   message_status = "ONLY WARNINGS/ERRORS are Switched ON.For INFO also use debug_level=2'b00";
  `ifdef  NO_WARNING_MODE
     debug_level = 2'b11;
     message_status = "All Warning/Errors/Info Messages are Switched OFF";
  `endif  
  `ifdef  ONLY_ERROR_MODE
     debug_level = 2'b10;
     message_status = "All Warning/Info Messages are Switched OFF.Errors are switched on";
  `endif 
  `ifdef  ALL_MSG_MODE
     debug_level = 2'b00;
     message_status = "All Messages are Switched ON";
  `endif 
  
  `ifdef slm
     operating_mode = "SLM";
   `else
      `ifdef functional
         operating_mode = "FUNCTIONAL";
       `else
         operating_mode = "TIMING";
      `endif
   `endif   
  
  if (debug_level < 1) begin
  $display ("%m INFORMATION ");
  $display ("***************************************");
  $display ("The Model is Operating in %s MODE", operating_mode);
  $display ("%s", message_status);
  if(reg_ConfigFault)
  $display ("Configurable Fault Functionality is ON");   
  else
  $display ("Configurable Fault Functionality is OFF");   
  $display("Fault File used by the model Fault_File_Name=%s" ,reg_Fault_file_name);
  $display("Values of Config_fault used in model=%d" ,reg_ConfigFault);
  $display("Values of Mem_INITALIZE used in model=%d" ,reg_MEM_INITIALIZE);
  $display("Values of BinaryInit used in model=%d" ,reg_BinaryInit);
  $display("Values of InitFileName used in model=%s" ,reg_InitFileName);
  $display("Values of Initn_reset_value used in model=%d" ,reg_Initn_reset_value);
  $display("Values of File_load_time used in model=%t" ,reg_File_load_time);

  $display ("***************************************");
  end
     
  task_read_fault_file; 
   if(!INITNint) begin
    if(supply_ok ) begin 
      init_pulse_done = 1;
      power_up_done = 1;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif 
    end 
   end 
        
   lastCK_func = CKint_func;
   lastCK_dft = CKint_dft;

 `ifdef MEM_CONTENTS_SLEEP
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","w");
   $fclose(ptr);
 `endif 

   
end  // initial block ends



//+++++++++++++++++++++++++++++++ CONFIG FAULT IMPLEMETATION ENDS+++++++++++++++++++++++++++++++//
        




//INITN block starts
//================================
always @(INITNint  or supply_ok )
begin
 if (INITNint === 1'b0) begin
   if(supply_ok) begin
     init_pulse_done = 1;
     power_up_done = 1;
     lastCK_func=CKint_func;
     lastCK_dft=CKint_dft;
     next_cycle_corrupt_func = 0;
     next_cycle_corrupt_dft = 0;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif     
   end 
 end        

 if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && INITNint !== 1)
   begin
     ScanOutX;
     ScanChainX;
     delScanOutX;
   end  
         
 if (init_pulse_done === 0 && INITNint !== 0) begin
     if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) INFO: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
 end
 
end//always @(INITNint)


// Clock Generation 
//wire gated_clock;
//wire clock_gate_en;
//ST_SPREG_LOLEAK_64x64m4_bTl_lock_up_latch CK_SE_latch (!CK , SE, SE_latch_CK);
//and (clock_gate_en, ATP, TBYPASS, !SE_latch_CK);

//ST_SPREG_LOLEAK_64x64m4_bTl_lock_up_latch LP_latch (!CK , scanreg_ctrl_wire[14], LP_latch_CK);
//and (gated_clock,CK,!LP_latch_CK);
//assign CK_new= clock_gate_en ===0 ? CK : (clock_gate_en ===1 ? gated_clock: (CK===0) ? 0 :1'bx);


// Clock Generation Ends


// Functional CK block starts
//======================================
always @(CKint_func)
begin
   lastCK_func=CKreg_func;  
   CKreg_func=CKint_func;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
        if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
      if (CKreg_func === 1'bX || (CKreg_func === 1'b1 && lastCK_func === 1'bx)) begin
        if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
         
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
         Invalid_next_cycle_func;
        end
      end
      else if (CKreg_func === 1'b1 && lastCK_func === 1'b0 ) begin
        time_CK_func_rise=$realtime;
        MEMEN_prev = MEMEN_reg;
        MEMEN_reg = MEMEN;
        CSNreg = CSNint;
        IGreg = IGint;
        DEreg = DEint;
        SE_reg = SEsys;
        TBYPASS_reg = TBYPASSsys;
        ATPreg = ATPint;
        INITNreg = INITNint;
        SLEEPreg = SLEEPint;
        STDBYreg = STDBYint;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 

    `ifdef functional
    `else
        Mem_last=Mem[Aint];
    `endif 
        if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.INITN pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SLEEP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.STANDBY pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg === X && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.chip select  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg === X && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.IG pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg === X && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.Debug pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg === X && (SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.ATP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg === X && TBYPASS_reg !== 1) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SE pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg !== 1 && TBYPASS_reg === X) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.TBYPASS pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end

        else if ((INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0))) && WENint === X) begin
            // Uncertain write cycle
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: write enable going to X  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end 
        else if (next_cycle_corrupt_func === 1) begin
          next_cycle_corrupt_func = X;
        end
        else if (next_cycle_corrupt_func === 1'bx) begin
          next_cycle_corrupt_func = 0;
        end 
        
//        if (next_cycle_corrupt_func === 0 ) begin 
         
          /*---------------------- File initialization -----------------*/
          
          if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0)) && flag_mem_block === 1'b0) begin
                 Areg=Aint;
                 Dreg=Dint;
                 Mreg=Mint;
                 WENreg=WENint;     
             if (reg_MEM_INITIALIZE === 1'b1 && $realtime >= reg_File_load_time && file_loaded ) begin   
                `ifdef slm
                  if (reg_BinaryInit)
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_BIN");
                  else
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_HEX");
   
                `else
                  if (reg_BinaryInit)
                     $readmemb(reg_InitFileName, Mem, 0, Words-1);
                  else
                     $readmemh(reg_InitFileName, Mem, 0, Words-1);
                `endif
                 file_loaded = 0;
             end
   
             if (^Aint === X)
               ValidAddress = X;
             else if (Aint < Words)
               ValidAddress = 1;
             else    
               ValidAddress = 0;
   
             if(red_en === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Redundancy Enable is Invalid. Either RRAE is X or TRRAE is X",$realtime);
                ValidAddress = X; 
           end
           else if(red_en === 1'b1 && ^repair_add === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Repair Address is invalid.RRA is X",$realtime);
                ValidAddress = X;
           end
             
             if (ValidAddress)
               `ifdef slm
                   $slm_ReadMemoryS(MemAddr, Aint, Mem_temp);
               `else
                    Mem_temp = Mem[Aint];
               `endif
             else
                Mem_temp = WordX;  
          
     /*---------------------- Normal Read and Write -----------------*/
     
             if (WENint === 1) begin
               ReadCycle(Aint);
             end
       
             else if (WENint === 0) begin
               WriteCycle(Aint);
             end 
                
          
          end //  if (MEMEN === 1'b1 
       
//        end  // if (next_cycle_corrupt_func === 0
      
      end // if (CKint = 1   
   end // if (init_pulse_done === 1           
 end 
end // always @(CKint_func)
        
always @(MEMEN)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) && CKint_func === 1'bx) begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.clock pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
    Invalid_next_cycle_func;
  end
 end 
end

// DFT CK block starts
//======================================
always @(CKint_dft) 
begin
   lastCK_dft=CKreg_dft;
   CKreg_dft=CKint_dft;
   
   Latch_open=0;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
     if (CKreg_dft === 1'bX || (CKreg_dft === 1'b1 && lastCK_dft === 1'bx)) begin
       if (INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0 ) begin
        
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: DFT clock  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime); 
         Invalid_next_cycle_dft;
         if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
           WriteOutX;
         end
       end
     end 

     if(CKint_dft === 0 && lastCK_dft === 1) begin
      if(ATPreg === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
       if(SE_reg === 1'b1 && SEsys === 1'b0) begin
        if(TBYPASSint === 1'b1) begin   
    
       
       
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],
scanreg_dr_wire[10],
scanreg_dr_wire[11],
scanreg_dr_wire[12],
scanreg_dr_wire[13],
scanreg_dr_wire[14],
scanreg_dr_wire[15],
scanreg_dr_wire[16],
scanreg_dr_wire[17],
scanreg_dr_wire[18],
scanreg_dr_wire[19],
scanreg_dr_wire[20],
scanreg_dr_wire[21],
scanreg_dr_wire[22],
scanreg_dr_wire[23],
scanreg_dr_wire[24],
scanreg_dr_wire[25],
scanreg_dr_wire[26],
scanreg_dr_wire[27],
scanreg_dr_wire[28],
scanreg_dr_wire[29],
scanreg_dr_wire[30],
scanreg_dr_wire[31],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9],
scanreg_dl_wire[10],
scanreg_dl_wire[11],
scanreg_dl_wire[12],
scanreg_dl_wire[13],
scanreg_dl_wire[14],
scanreg_dl_wire[15],
scanreg_dl_wire[16],
scanreg_dl_wire[17],
scanreg_dl_wire[18],
scanreg_dl_wire[19],
scanreg_dl_wire[20],
scanreg_dl_wire[21],
scanreg_dl_wire[22],
scanreg_dl_wire[23],
scanreg_dl_wire[24],
scanreg_dl_wire[25],
scanreg_dl_wire[26],
scanreg_dl_wire[27],
scanreg_dl_wire[28],
scanreg_dl_wire[29],
scanreg_dl_wire[30], scanreg_dl_wire[scanlen_l-1]}; 
       


         for (i = 0; i < Bits; i = i + 1)
         begin
          if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
         end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
        end 
       end
      end
     end 
     
     else if (CKreg_dft === 1'b1 && lastCK_dft === 1'b0 ) begin
       SE_reg = SEsys;
       TBYPASS_reg = TBYPASSsys;
       ATPreg = ATPint;
       INITNreg = INITNint;
       SLEEPreg = SLEEPint;
       STDBYreg = STDBYint;
       MEMEN_dft_prev = MEMEN_dft_reg;
       MEMEN_dft_reg = MEMEN_dft;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 
       if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ) begin 
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
 //     else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys === X && TBYPASSsys !== 1) begin
///           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
//           Invalid_next_cycle_dft;
//        end       
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys === X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
        end 
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys !== 0 && LP_CK_gate===X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: LP FLOP Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           ScanChainX;
           ScanOutX;   
          if( TBYPASSint !== 0 && SEint !== 1) begin
            WriteOutX;
          end
          next_cycle_corrupt_dft=0;
        end        
       else if (next_cycle_corrupt_dft === 1'b1) begin 
         next_cycle_corrupt_dft = X;
       end 
       else if (next_cycle_corrupt_dft === 1'bx) begin
         next_cycle_corrupt_dft = 0;
       end
       
       if (next_cycle_corrupt_dft === 0 ) begin
         
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1 && flag_mem_block === 1'b0) begin
           
           if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0  && LP_CK_gate===0) begin
              OutReg_data_tbypass = Dint;
              for (i = 0; i < Bits; i = i + 1)
              begin
               if (OutReg_data_tbypass[i] !== OutReg_data[i])
                 OutReg_data[i] = WordX[i];
              end//for (i = 0; i < */ 
              OutReg_data <= OutReg_data_tbypass;
           end
           
             scan_acquire;
         end //MEMEN_dft == 1        
       end // if ( next_cycle_corrupt_dft
       
     end // if (CKint_dft === 1'b1
      //  if (next_cycle_corrupt_dft === 0 ) begin 
       if (SE_reg !== 0) begin
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1  && flag_mem_block === 1'b0) begin
           next_cycle_corrupt_dft = 0;
           if ( next_cycle_corrupt_func === 1) begin
	    next_cycle_corrupt_func = 0 ;
	   end	
           scan_shift;
         end
       end
     //end // if ( next_cycle_corrupt_dft    
     if ((!(TBYPASSsys!==0 && SEsys!==1 && LP_CK_gate!==0 ) && next_cycle_corrupt_dft === 0) || CKint_dft !==1) begin          
       CK_sc=INITNreg & !STDBYreg & !SLEEPreg & ATPreg & CKreg_dft ;
     end     
   end // if (init_pulse_done 
 end // if (supply_ok 
end // always @(CKint_dft)

always @(MEMEN_dft)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) && CKint_dft === 1'bx)  begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.MEMEN_dft and clock should not be X at this time instant. ScanChains and ScanOuts Corrupted ",$realtime); 
    Invalid_next_cycle_dft;
    
    if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
      WriteOutX;
    end
  end
  if ( MEMEN_dft !== 0 && TBYPASSsys !== 0 && SEsys !== 1) begin
     WriteOutX;
     OutReg_data = WordX; 
     delOutReg_data=WordX;
 end 
end
end //always @(MEMEN_dft

always @(TBYPASSsys or ATPint)
begin
   if(supply_ok === 1'b1) begin 
    if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0 && INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1) begin
      if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
    end  
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint === X && SEsys !== 1) ) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end 
end //always @(TBYPASSint





always @(SEsys)
begin
 if(supply_ok === 1'b1) begin 
  if(CKint_dft === 0 && ATPint === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
    if(SE_reg === 1'b1 && SEsys === 1'b0) begin
      if(TBYPASSsys === 1'b1) begin
  
     
         
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],
scanreg_dr_wire[10],
scanreg_dr_wire[11],
scanreg_dr_wire[12],
scanreg_dr_wire[13],
scanreg_dr_wire[14],
scanreg_dr_wire[15],
scanreg_dr_wire[16],
scanreg_dr_wire[17],
scanreg_dr_wire[18],
scanreg_dr_wire[19],
scanreg_dr_wire[20],
scanreg_dr_wire[21],
scanreg_dr_wire[22],
scanreg_dr_wire[23],
scanreg_dr_wire[24],
scanreg_dr_wire[25],
scanreg_dr_wire[26],
scanreg_dr_wire[27],
scanreg_dr_wire[28],
scanreg_dr_wire[29],
scanreg_dr_wire[30],
scanreg_dr_wire[31],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9],
scanreg_dl_wire[10],
scanreg_dl_wire[11],
scanreg_dl_wire[12],
scanreg_dl_wire[13],
scanreg_dl_wire[14],
scanreg_dl_wire[15],
scanreg_dl_wire[16],
scanreg_dl_wire[17],
scanreg_dl_wire[18],
scanreg_dl_wire[19],
scanreg_dl_wire[20],
scanreg_dl_wire[21],
scanreg_dl_wire[22],
scanreg_dl_wire[23],
scanreg_dl_wire[24],
scanreg_dl_wire[25],
scanreg_dl_wire[26],
scanreg_dl_wire[27],
scanreg_dl_wire[28],
scanreg_dl_wire[29],
scanreg_dl_wire[30], scanreg_dl_wire[scanlen_l-1]};
           
      


        for (i = 0; i < Bits; i = i + 1)
        begin
         if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
        end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
      end
    end
  end
  if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0) begin
      if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
  end 
  else if ((TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint === X && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end   
end

//assign output data
`ifdef functional        

   
always @(SDLOint)
#0.001 delSDLO_data<=SDLOint;

always @(SDROint)
#0.001 delSDRO_data<=SDROint;


always @(SMLOint)
#0.001 delSMLO_data<=SMLOint;

always @(SMROint)
#0.001 delSMRO_data<=SMROint;
 
always @(SCTRLOint)
#0.001 delSCTRLO_data<=SCTRLOint;


always @(OutReg_data)
   #0.001 delOutReg_data = OutReg_data;
`else
`endif

/***************************** Embeded switch functionality starts here ***********************************/





always @(STDBYint)
begin
  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0 && STDBYint !== 1'b0)
    begin
      ScanOutX;
      ScanChainX;
     delScanOutX;     
    end
  end
end



always @(SLEEPint)
begin


  if (SLEEPint !== 1'b1) begin
    time_fall_sleep = $realtime;
  end

  if (power_up_done === 0)
    begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
    end
  else begin
    if (SLEEPint === 1'b1 && lastSLEEP === 1'b0 ) begin 
      
    end
    else if (SLEEPint !== 1'b1 && lastSLEEP === 1'b1 && full_shutdown !== 1) begin 
      
      if (supply_ok !== 1 && ($realtime > 0)) begin
         if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID LOW_POWER) ERROR: ISOLATION signal removed from the memory but array and periphery supply is not completely switched on.Very High Current would be drawn by the memory. All further operations on memory are blocked",$realtime);
          WriteMemX;
          WriteOutX;
          ScanChainX;
          OutReg_data = WordX; 
          delOutReg_data=WordX;
          ScanOutX;//immediately;
          delScanOutX;//immediately;
          init_pulse_done = 0;
          power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            debug_level = 2'b11;
          `endif
          
      end        
      
       
    end   
    else if (SLEEPint === X && lastSLEEP === 1'b0 && full_shutdown !== 1'b1) begin 
     
    end 
  end  


  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && SLEEPint !== 0)
    begin
      ScanOutX;
      ScanChainX;
        delScanOutX;      
    end
  end

// if (init_pulse_done === 0)
//   begin
//     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
//   end
//
// else if ( SLEEPint !== 1 && (supply_ok !==1) ) begin
//    
//    WriteOutX;
//    OutReg_data = WordX; 
//    delOutReg_data=WordX;
//    ScanOutX;//immediately;
//    delScanOutX;//immediately;
//    ScanChainX;
//    WriteMemX;
//    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies with sleep/Power down signal being low.This scenario can lead to high dc currents and some reliability issues Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
// end

 print_sleep;    
 lastSLEEP=SLEEPint;
end

/********************************** Embeded switch functionality ends here *******************************/

task print_sleep;
begin
  if (SLEEPint === 1'b0) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been deasserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end  
  else if (SLEEPint === 1'b1) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been asserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_ACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif

  end        
  else begin
      if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) ERROR: SLEEP pin is at an invalid state.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INVALID in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end        
end
endtask





 

//// C28SOI non flip compiler power functionality 
always @(gndmreg )
begin
 if (power_up_done === 1 && $realtime > 0) begin    
    if(gndmreg !== 1'b0 ) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or gndsm is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
        corrupt_all;
        init_pulse_done = 0;
        power_up_done = 0;
     `ifdef NO_BLOCK_MEM
     `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of ground pins.Ground must be maintained at 0 Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime);
        debug_level = 2'b11;
     `endif   

    end   
 end

end




always @(vddmareg )
begin

if (vddmareg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddma(Array Supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 
    end
   end   
   else if (SLEEPint === 1) begin
    WriteMemX;
   end

end

if ((vddmareg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1 ) && $realtime > 0) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddm or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         corrupt_all;
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif

end


end

always @(vddmpreg )
begin
 if (vddmpreg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or vddsmp is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmp(Periphery Supply)/vddsmp(Substrate power supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 

    end
   end   
   else if (SLEEPint === 1) begin
    WriteOutX;
    ScanChainX;
    ScanOutX;
    delScanOutX;//immediately;
    OutReg_data = WordX; 
    delOutReg_data=WordX;
   end
 end

if( (vddmpreg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1'b1 )  && $realtime > 0) begin
         corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif
end
 
 
end


always @(vddmoreg)
begin
  if (power_up_done === 1 && $realtime > 0) begin   
      if (vddmoreg !== 1'b1)  begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin
           corrupt_all;
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
         end //if (vddmareg === 1'b1 

      else if (vddmareg === 1'b0 && vddmpreg === 1'b0   && SLEEPint === 1'b1 &&  $realtime > 0)
        begin 
            if((debug_level < 2) && ($realtime > 0)) $display("%m - %t WARNING: Illegal Value on power pin(s). Memory and Output Corrupted ", $realtime);
 
           corrupt_all;
        end //else if (vddmareg === 1'b 
     end   // if (vddmoreg !== 1'b1)
     else if (vddmoreg === 1'b1 && $realtime > 0 ) begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin     
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           corrupt_all;
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
        end        
     end // else if (vddmoreg === 1'b1
  end 
end // always @(vddmoreg)












always @(gndmreg) begin
 if (gndmreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 0. ",$realtime);
 end
 else if (gndmreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 1. ",$realtime);
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to invalid state. ",$realtime);
 end
end




 
always @(vddmareg) begin
 if (vddmareg === 0) begin 
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 0. ",$realtime);
  vddma_fall_time = $realtime;
 end
 else if (vddmareg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 1. ",$realtime);
  vddma_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to invalid state. ",$realtime);
  vddma_fall_time = $realtime;
 end 

 

end

always @(vddmpreg) begin
 if (vddmpreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 0. ",$realtime);
  vddmp_fall_time = $realtime;
 end
 else if (vddmpreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 1. ",$realtime);
  vddmp_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to invalid state. ",$realtime);
  vddmp_fall_time = $realtime;
 end

 
 
end



// end of C28SOI power functionality 
 


assign supply_ok          =  (vddmareg === 1'b1 && vddmpreg  === 1'b1  && gndmreg === 1'b0 && vddmoreg === 1'b1 ) ? 1'b1 : 1'b0;
assign core_supply_ok     =  (vddmoreg === 1'b1 && vddmareg === 1'b1 && gndmreg === 1'b0 ) ? 1'b1 : 1'b0;
assign peri_supply_ok     =  (vddmoreg === 1'b1 && vddmpreg === 1'b1 && gndmreg === 1'b0  ) ? 1'b1 : 1'b0;

assign full_shutdown = (vddmpreg === 1'b0 && vddmareg === 1'b0   ) ? 1'b1 : 1'b0 ;




`ifdef functional
`else


task WriteLocMskX_bwise;
   input [Addr-1 : 0] Address;
   input [Bits-1 : 0] Mask;

reg [Bits+Red_extrabit:0] tempReg1;
integer num1; 
begin
   tempReg1 = WordX;
   if (^Address !== X )
   begin
      tempReg1 = Mem[Address];
             
      for (j = 0;j< Bits; j=j+1) begin
         num1=j;
        if (Mask[j] === 1'bx)
            tempReg1[num1] = 1'bx;
      end
      Mem[Address] = tempReg1;
      task_insert_faults_in_memory;
   end//if (^Address !== X
   else begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      WriteMemX;
   end   
end
endtask


/****************Actions taken on timing violations*****************/

 always @(TimingViol_data)
// tds or tdh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  for (l = 0; l < Bits; l = l + 1) begin   
    if (CSWEMTBYPASS[l] !== 0) begin
     if((TimingViol_data[l] !== TimingViol_data_last[l])) begin


         Mreg[l] = 1'bx;
     end    
     WriteLocMskX_bwise(Areg,Mreg);
    end   
   end 
  end
    if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin
     scanreg_dl =1'bx; 
     scanreg_dr =1'bx; 
     SDLOint=X;
     SDROint=X;
     `ifdef functional
     `else
     SDLO_data<=1'bx;
     SDRO_data<=1'bx;
     `endif
    end
     TimingViol_data_last = TimingViol_data; 
end



always @(TimingViol_mask)
// tms or tmh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  if(CSWETBYPASSN !== 0) begin
   for (i = 0; i < Bits; i = i+1) begin   
      if ( (TimingViol_mask_last[i] !== TimingViol_mask[i])) begin
         Mem[Areg][i]=Mem_last[i];
         if (Dint[i] !== Mem[Areg][i]) begin
          Mreg[i] = 1'bx;
         end
      end   
   end      
   WriteLocMskX_bwise(Areg, Mreg);
   end      
  end
  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
  scanreg_ml =1'bx; 
  scanreg_mr =1'bx; 
  SMLOint=X;
  SMROint=X; 
  `ifdef functional
  `else
  SMLO_data<=1'bx;
  SMRO_data<=1'bx;
  `endif
  end

  TimingViol_mask_last = TimingViol_mask; 
 end 


always @(TimingViol_addr)
// tas or tah
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
      scanreg_ctrl=1'bx; 
      SCTRLOint=X;
      `ifdef functional
      `else
      SCTRLO_data<=1'bx;
      `endif
  end
end


always @(TimingViol_WEN)
//tws or twh
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WEN pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end 

always @(TimingViol_CSN )
// tps or tph 
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;

   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CSN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end

always @(TimingViol_tcycle )
//tcycle
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
   if (MEMEN !== 0 && MEMEN_prev !== 0) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckl )
// tckl 
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckh) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end


always @(TimingViol_tcycle_se )
//tcycle_se
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckl_se  )
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckh_se) begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tbist) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
   end
   if (TBYPASSint !== 1'b0) begin 
    WriteOutX;
   end 
   if (INITNreg !==0 && STDBYreg !== 1 && TBYPASS_reg !== 1 && SLEEPreg !== 1 && SE_reg !== 1 && IGreg !== 1 && DEreg !== 1) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBIST pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end






always @(TimingViol_tbypass)
//ttmck
begin
#0  
  WriteOutX;
  if (INITNreg !== 0 && SLEEPreg !== 1 && SE_reg !== 1 && STDBYreg !== 1 &&  DEreg !== 1) begin
   Invalid_next_cycle_dft_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
end



always @(TimingViol_sleep)
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_stdby)
begin
#0
  if (CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin 
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (ATPreg !== 0) begin 
   Invalid_next_cycle_dft_tim;
  end
end






always @(TimingViol_se) begin
#0
   if (TBYPASS_reg !== 0) begin 
    WriteOutX;
   end 
  if (TBYPASS_reg === 0) begin
     WriteOutX;
     WriteMemX;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE timing violation  Memory State Machine is corrupted. Output Corrupted ",$realtime); 
  end 
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
  end
end

always @(TimingViol_sctrli) begin
  scanreg_ctrl=1'bx; 
end


always @(TimingViol_sdli) begin
 scanreg_dl=1'bx; 
end

always @(TimingViol_sdri) begin
   scanreg_dr=1'bx;
end


always @(TimingViol_smli) begin
    scanreg_ml=1'bx;
    end

always @(TimingViol_smri) begin
    scanreg_mr=1'bx;
end
 

always @(TimingViol_initnl) begin
init_pulse_done=0;
WriteOutX;
OutReg_data = WordX; 
delOutReg_data=WordX;
ScanOutX;
delScanOutX;
ScanChainX;
WriteMemX;
end

always @(TimingViol_initn) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end

always @(TimingViol_ig) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && INITNreg !== 0 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: IG pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   ScanChainX;
   ScanOutX;
   delScanOutX;       
  end
end

always @(TimingViol_atp) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin  
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_rm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^WMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: RM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
   end
end
 
always @(TimingViol_wm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^RMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);        
   end
end 


`endif


endmodule




module ST_SPREG_LOLEAK_64x64m4_bTl_lock_up_latch (EN,D,Q);
input EN,D;
output reg Q;

  always @ (EN or D) begin
    if (EN === 1) begin
       Q = D;
    end
    else if ((EN === 1'bz || EN === 1'bx  )&& D !== Q) begin
        Q=1'bx;
    end    
  end
endmodule

module ST_SPREG_LOLEAK_64x64m4_bTl_SCFF (D,TI,TE,CP,Q,OUTX);
input D,TI,TE,CP;
input OUTX;
output reg Q;
wire Dint;
assign Dint= (TE===1)?TI:(TE===0)?D:1'bx;

always @(posedge CP)
        begin
          if(Dint === 1'bZ || CP ===1'bx || OUTX === 1'bx)
          begin
                  Q = 1'bx;
          end
          else
          begin
                  Q = Dint;
          end        
        end
always @(posedge OUTX)
Q = 1'bx;
endmodule



`undef setup_time
`undef hold_time
`undef access_time
`undef retain_time
`undef cycle_time
`undef pulse_width_time
`undef initin_low_pulse


`delay_mode_path
`endcelldefine
`nosuppress_faults






/****************************************************************
--  Description         : Verilog Model 
--  ModelVersion        : 1.2
--  Date                : Apr, 2013
--  Changes Made by	: PS
--  Revision History    : 
 
****************************************************************/


/******************** START OF HEADER****************************
   This Header Gives Information about the parameters & options present in the Model
   
   words = 512
   bits  = 20
   mux   = 8 
   
   
   
   write_mask = no 
   
   margin_control = yes 
   
   
   Dft = Yes  

    ------------------------------------------------------------------------------------
     Signal Name             | Description       |             Port Mode        | Active When
                             |                   |          r    |  w   | rw    |
   ------------------------------------------------------------------------------------

    D 	        Data in                     na     x      na       -  
    IG    Input Gate Enable           x      x      na       High     
    ATP            ATPG Enable                 x      x      na       High     
    INITN                 INITN pin                   x      x      na       Low
    
    
     
    Q 	        Data out	            x      na     na       -
    A              Address                     x      x      na       high and low
    
    CK                Clock	                    x      x      na       posedge
    CSN          Chip Enable                 x      x      na       low
    
    RM         Read Margins                 x      x      na       High 
    SCTRLI         Scan Input (Control)
    SCTRLO        Scan Output (Control)
    SDLI         Scan Input (Data-Left)
    SDLO        Scan Output (Data-Left)
    SDRI         Scan Input (Data-Right)
    SDRO        Scan Output (Data-Right)
    SE          Scan Enable pin 
    STDBY              Standby pin                 x      x      na       High
    
    SLEEP                        Sleep pin                   x      x      na        High 
    
     
     
    TBIST          Bist Enable Pin 
    
    TBYPASS                      Memory Bypass                na     na     na        High
    
    TED        Bist Even Data pin
    TOD         Bist Odd Data Pin
     
    TA         Bist Read Address
    TCSN     Bist Read Chip Select
    
    TWEN    Bist Write Enable 
    WEN         Write Enable                na     x      na       Low 
    
    WM        Write Margins Code          x      x      na       -
     

******************** END OF HEADER ****************************/


//********************************************//
// ST_SPREG_LOLEAK_512x20m8_Tl Verilog Model                 //  
//********************************************//




`ifdef slm
        `define functional
`endif

`celldefine
`suppress_faults
  `ifdef functional
   `delay_mode_unit
  `else
   `delay_mode_path
  `endif

`define setup_time 0.0
`define hold_time 0.0
`define access_time 1.0
`define retain_time 0.9
`define cycle_time 0.0
`define pulse_width_time 0.0
`define initin_low_pulse 0.0



 






`timescale 1ns / 1ps


module ST_SPREG_LOLEAK_512x20m8_Tl (A,ATP,CK,CSN,D ,IG,INITN , Q ,RM    ,SCTRLI,SCTRLO,SDLI,SDLO,SDRI,SDRO,SE,SLEEP   , STDBY  ,TA,TBIST   ,TBYPASS ,TCSN,TED ,TOD   ,TWEN ,WEN,WM  );

 parameter
  Words = 512,
  Bits = 20,
  Addr = 9,
  mux = 8,
  repair_address_width = 6,
  write_margin_size = 2, 
  read_margin_size = 3; 

 //  INPUT OUTPUT PORTS DECLARATION DONE SEPARATELY FOR SPREG and ROM
 // ========================


        output [Bits-1 : 0] Q;
         
        output SCTRLO;
        input SE,SCTRLI;
        
        input [Addr-1 : 0] A;
        
        input [read_margin_size-1 : 0] RM;
        
         
        input CK,CSN,INITN,IG,ATP; 
        
        
        input [Addr-1 :0 ] TA;
input TBIST,TCSN ;
        
        input STDBY;
        
        input SLEEP; 
        
         
        
        
         
        output SDLO;
        output SDRO;
        
        
        
        
        input [Bits-1 : 0] D ;
	
          
         
        
        input [write_margin_size-1 : 0] WM;
        
        
        input TBYPASS;
        
        input WEN;
        
        
         
        input SDLI,SDRI  ; 
        
        
        
        //Bist inputs
        // ===========
        input TWEN,TED,TOD; 
        
        
        
        

        






    parameter
        Fault_file_name = "ST_SPREG_LOLEAK_512x20m8_Tl_faults.txt",
        `ifdef ConfigFault
        ConfigFault = 1,
        `else
        ConfigFault = 0,
        `endif
        max_faults = 514,
        
        MEM_INITIALIZE  = 1'b0,
        BinaryInit = 1'b0, 
        InitFileName = "ST_SPREG_LOLEAK_512x20m8_Tl.cde",
        Debug_mode = "all_warning_mode",
        File_load_time=0,
        Initn_reset_value={20{1'b0}},
        InstancePath = "ST_SPREG_LOLEAK_512x20m8_Tl";
    
    parameter
        
        bank = 1, 
        mux_bits=3,
        Red_extrabit=0,
        bank_bits = 0,
        RedWords = mux * 2 * bank,
        max_address_bits = 15 ,
        Rows = Words/mux;

  
    parameter 

     

        
           scanchains=3,    
          
        
        scanlen_ctrl=15,
        
        

      

        
        scanlen_r=(Bits)/2,
        
        scanlen_l=(Bits+1)/2 ; 
      
      

    parameter
        
        `ifdef functional  
            RW_assertions_en = 0,
        `endif
        WordX = {Bits{1'bx}},
        AddrX = {Addr{1'bx}},
        Word0 = {Bits{1'b0}},
        X = 1'bx;
   



//  WIRE DECLARATION RELATED TO POWER PINS
//  ======================================
	
        wire supply_ok, full_shutdown;
        
        wire core_supply_ok;
        wire peri_supply_ok;

        wire gndmint, gndsmint;
         
        
        wire vddmpint;
        wire vddmoint;
        wire vddmaint;
        wire vddsmpint;  
        wire vddsmaint;  
        
        

//  WIRE DECLARATION 
//  ==================
        wire [Bits-1 : 0] CSWEMTBYPASS;
        wire [Bits-1 : 0] Dint, Dsys;
        wire [Bits-1 : 0] Mint; 
        wire [20-1:0] Msys;
	wire [Addr-1 : 0] Aint;
        wire [Addr-1 : 0] Asys;

       


        wire [max_address_bits-1 : 0] A_int; 
                
	wire CKint_dft;
	wire CKint_func;
	wire CSNint;
        wire MEMEN;
        wire MEMEN_dft;
        wire TSE;

	wire WENint;
	wire WENsys;
        wire SLEEPint;
        wire STDBYint;
        wire SEint;
        wire SEsys;
        wire SCTRLIint;
        wire SDLIint;
        wire SDRIint;
        
        wire INITNint;
        wire TBYPASSint;
        wire TBYPASSsys;
        wire LSint; 
        wire HSint; 
        wire ATPint;
        wire DEint;
        
        wire [Addr-1 : 0] TAint;
        wire TBISTint;
        wire TBISTsys;
        wire TCSNint;
        wire TEDint;
        wire TODint;
        wire TEMint;
        wire TOMint;
        wire [Bits-1 : 0] TMint;
        wire [Bits-1 : 0] TDint;
        wire TWENint;
        wire IGint;
        wire IGbuf;
        wire CSNbuf;
        wire WENbuf;
        wire [read_margin_size-1:0] RMint;
        wire [write_margin_size-1:0] WMint;

        //Wires for scan chains
        //  ====================     
        wire [scanlen_ctrl -1:0]scanreg_ctrl_wire;
        wire [scanlen_l -1:0]  scanreg_dl_wire; 
        wire [scanlen_r -1:0]  scanreg_dr_wire; 
   
        wire [scanlen_l -1:0]  scanreg_ml_wire; 
        wire [scanlen_r -1:0]  scanreg_mr_wire; 


        wire [repair_address_width -1 : 0] RRAint;
        wire RRAEint;
        wire TRRAEint;    
        wire red_en;
        wire [repair_address_width -1 : 0] repair_add, next_repair_add;


//  REG DECLARATION
//  ====================     
        reg MEMEN_reg;
        reg MEMEN_prev;
        reg reg_mem_block;
        reg flag_mem_block;
        reg SCTRLIint_temp;
        reg SDLIint_temp;
        reg SDRIint_temp;
        reg SMLIint_temp;
        reg SMRIint_temp;

        //  REG DECLARATION
        //  ====================
        reg SCTRLOint;
        
        reg SDLOint,SDROint;
         
        
        reg next_cycle_corrupt_func;
        reg next_cycle_corrupt_dft;
        reg [Bits-1 : 0] delOutReg_data;//delayed Output Register
        reg [Bits-1 : 0] OutReg_data;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_tbypass;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_scan;   // Data Output registe
        reg [Bits-1 : 0] OutReg_rado_retained;   // register for retaining rado data when SLEEP --> 1
        reg delSCTRLO_data,SCTRLO_data;      // delayed Output Register
        reg delSDLO_data,SDLO_data;      // delayed Output Register
        reg delSDRO_data,SDRO_data;      // delayed Output Register
        
        
        // SCAN CHAINS register
        reg scanreg_ctrl; 
        reg scanreg_dl; 
        reg scanreg_dr; 
        
        
        reg CK_sc;
        reg Latch_open=0;
        reg lastCK_dft,CKreg_dft;
        reg lastCK_func,CKreg_func;
        reg lastSLEEP;
        reg lastPSWLARGEMP,lastPSWLARGEMA,lastPSWSMALLMP,lastPSWSMALLMA;
        reg CSNreg;
        reg init_pulse_done; //if == 1 then it implies that initb low pulse has been applied
        reg power_up_done; //if == 1 then it implies that power up has been done
        `ifdef slm
        `else
	      
             reg [Bits-1 : 0] Mem [Words-1 : 0];
             reg [Bits-1 : 0] RedMem [RedWords-1 : 0];
 
        `endif
        
	reg [Bits-1 :0] Mem_temp;
        reg [Bits-1 :0] Mem_slm; 
	reg ValidAddress;
	reg ValidDebugCode;
        reg decoding_start;
        reg file_loaded;
        reg [Bits-1 :0] Dreg;
        reg [Bits-1 :0] Mreg;
        reg WENreg;
        reg [Addr-1 :0] Areg;
        reg SE_reg;
        reg TBYPASS_reg;
        reg INITNreg;
        reg IGreg;
        reg DEreg;
        reg SLEEPreg;
        reg STDBYreg;
        reg ATPreg;
        reg MEMEN_dft_reg;
        reg MEMEN_dft_prev;
        reg RRMATCHreg;
        reg RRMATCHreg_last;//changes_made
        reg RRMATCHreg_glitch;
        reg [repair_address_width -1 : 0] repair_add_last;
        reg RRAEint_last;
        reg [Addr-mux_bits-1:0] row_add_temp;
        reg [Addr-mux_bits-bank_bits-1:0] row_add_cmp_temp;

       
        //parameter registers
        reg [2047:0] reg_Fault_file_name;
        reg reg_ConfigFault;
        reg reg_MEM_INITIALIZE;
        reg reg_BinaryInit;
        reg [2047:0] reg_InitFileName;
        reg [Bits -1 :0] reg_Initn_reset_value;
        time reg_File_load_time;

        //Power Supply Registers        
        reg vddmireg;
        reg vddmreg;
        reg vddsmreg;
        reg gndmreg;
        reg gndsmreg;   
        reg vddmpreg;
        reg vddmpireg;
        reg vddmareg;
        reg vddsmpreg;
        reg vddsmareg;
        reg vddmoreg;
        time vddmp_rise_time;
        time vddmp_fall_time;
        time vddsmp_rise_time;
        time vddsmp_fall_time;
        time vddma_rise_time;
        time vddma_fall_time;
        time vddsma_rise_time;
        time vddsma_fall_time;
        reg reg_check_rise;
        reg reg_check_fall;
        reg reg_check_rise_vddma;
        reg reg_check_fall_vddsma;
        reg  reg_check_rise_vddm, reg_check_fall_vddsm ;
        time vddm_fall_time,  vddm_rise_time,  vddsm_fall_time, vddsm_rise_time ;
  /* This register is used to force all warning messages 
  ** OFF during run time.
  ** It is a 2 bit register.
  ** USAGE :
  ** debug_level_off = 2'b00 -> ALL MESSAGES(INFO/WARNINGS/ERRORS) will be DISPLAYED 
  ** debug_level = 2'b01     -> ONLY WARNINGS/ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b10     -> ONLY ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b11     -> NO MESSAGES will be DISPLAYED.
  */ 
        reg [1:0] debug_level;
        reg [8*10: 0] operating_mode;
        reg [8*44: 0] message_status;

        integer i, k, j, l,m,q,w,r,s,num1,redcnt,n,num2,FirstHalf,Bfaileff,memcnt,ptr;
        integer decoder[Bits-1:0];
        `ifdef slm
           integer MemAddr;
        `endif


        //************************************************************
        //****** CONFIG FAULT IMPLEMENTATION VARIABLES*************** 
        //************************************************************ 

        integer file_ptr, ret_val;
        integer fault_word;
        integer fault_bit;
        integer fcnt, Fault_in_memory,faultnum,stop_loop,count;
        integer t;  
        integer FailureLocn [max_faults -1 :0];
        integer Failurebit [max_faults -1 :0];
        reg [100 : 0] stuck_at;
        reg [100 : 0] fault_array;
        reg [200 : 0] tempStr;
        reg [7:0] fault_char;
        reg [7:0] fault_char1; // 8 Bit File Pointer
        reg [Addr -1 : 0] std_fault_word;
        reg [Addr -1 : mux_bits] fault_row_add [max_faults -1 :0];
        reg [max_faults -1 :0] fault_repair_flag;
        reg [max_faults -1 :0] dont_insert_fault;
        reg [max_faults -1 :0] repair_flag;
        reg [100 : 0] array_stuck_at[max_faults -1 : 0] ;
        reg [100 : 0] mem_red_array_stuck_at[max_faults -1 : 0] ; 
        reg msgcnt;
        
       
        reg [Bits - 1: 0] stuck_at_0fault [max_faults -1 : 0];
        reg [Bits - 1: 0] stuck_at_1fault [max_faults -1 : 0];
        reg [Bits -1 : 0] stuck0;
        reg [Bits -1 : 0] stuck1;

        reg [Bits+Red_extrabit :0] Mem_last;
        

        `ifdef slm
        reg [Bits -1 : 0] slm_temp_data;
        `endif
        
        real time_CK_func_rise , time_RADCK_rise;
        real time_fall_sleep,time_fall_PSWLARGEMP,time_fall_PSWLARGEMP_0,time_fall_PSWLARGEMA,time_fall_PSWLARGEMA_0,time_fall_PSWSMALLMP,time_fall_PSWSMALLMA;
        integer flag_error;
        
//BUFFER INSTANTIATION
//=========================
       `ifdef functional
       
         buf (SCTRLO,delSCTRLO_data); 
         buf bufq [Bits-1:0] (Q,delOutReg_data);
      `else
       
         buf (SCTRLO,SCTRLO_data);
         buf bufq [Bits-1:0] (Q,OutReg_data);
      `endif
      
  
        buf (SEsys,SE);
	buf (SCTRLIint, SCTRLI);
   

	buf (CKint_func, CK);
	buf (CKint_dft, CK);
        buf bufaddr [Addr-1:0] (Asys,A);
        buf (INITNint,INITN);
        
        buf (LSint,1'b0); 
        buf (IGbuf,IG);
        buf (ATPint,ATP);

        buf bufTaddr [Addr-1 : 0] (TAint,TA);
        buf (TBISTsys,TBIST);
        buf (TCSNint,TCSN);

        buf (CSNsys,CSN);
        buf (STDBYint,STDBY );   
        
        buf (SLEEPint,SLEEP ); 

        buf bufrm [read_margin_size-1:0] (RMint, RM); 

        
        

        assign RRAEint = 1'b0;
        assign TRRAEint = 1'b0;
        assign repair_add = 0;
        assign next_repair_add = 0;
        assign red_en = 1'b0; 
        
        
        
        
        
        
        
        buf (PSWLARGEMPint,1'b0);
        buf (PSWSMALLMPint,1'b0); 
        buf (PSWLARGEMAint,1'b0);
        buf (PSWSMALLMAint,1'b0);   

      `ifdef functional
       
       
         buf (SDLO,delSDLO_data);
         buf (SDRO,delSDRO_data);
        
      `else
       
         buf (SDLO,SDLO_data);
         buf (SDRO,SDRO_data);
         
      `endif
       
         
       
        buf bufdata [Bits-1:0] (Dsys,D);
        
        
        assign Msys=20'b0; 
	

        
        buf (TBYPASSsys, TBYPASS);
        


        buf (WENsys,WEN);
	 
	buf (SDLIint, SDLI);
	buf (SDRIint, SDRI);
	 
        
        buf (HSint,1'b0); 

        
        buf (TEDint,TED);
        buf (TODint,TOD);
         
        buf (TWENint,TWEN);
        
        
        buf bufwm [write_margin_size-1:0] (WMint, WM); 
        



//      assign scanreg_ctrl_wire={scanreg_ctrl[scanlen_ctrl - 2:0],SCTRLIint};
//      assign scanreg_dl_wire={scanreg_dl[scanlen_l - 2:0],SDLIint};
//      assign scanreg_dr_wire={scanreg_dr[scanlen_r - 2:0],SDRIint};
      
        
      assign Aint   = (TBISTint === 1'b0 ) ? Asys : (TBISTint === 1'bx ) ? {Addr{1'bx}} : TAint;  

        
//        assign A_int = Aint;
	
        
                
        assign Dint[0] = (TBISTint === 1'b0) ? Dsys[0] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[1] = (TBISTint === 1'b0) ? Dsys[1] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[2] = (TBISTint === 1'b0) ? Dsys[2] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[3] = (TBISTint === 1'b0) ? Dsys[3] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[4] = (TBISTint === 1'b0) ? Dsys[4] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[5] = (TBISTint === 1'b0) ? Dsys[5] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[6] = (TBISTint === 1'b0) ? Dsys[6] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[7] = (TBISTint === 1'b0) ? Dsys[7] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[8] = (TBISTint === 1'b0) ? Dsys[8] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[9] = (TBISTint === 1'b0) ? Dsys[9] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[10] = (TBISTint === 1'b0) ? Dsys[10] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[11] = (TBISTint === 1'b0) ? Dsys[11] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[12] = (TBISTint === 1'b0) ? Dsys[12] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[13] = (TBISTint === 1'b0) ? Dsys[13] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[14] = (TBISTint === 1'b0) ? Dsys[14] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[15] = (TBISTint === 1'b0) ? Dsys[15] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[16] = (TBISTint === 1'b0) ? Dsys[16] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[17] = (TBISTint === 1'b0) ? Dsys[17] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[18] = (TBISTint === 1'b0) ? Dsys[18] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[19] = (TBISTint === 1'b0) ? Dsys[19] : (TBISTint === 1'b1) ? TODint : 1'bx;          
	 
        assign Mint = 20'b0;
         

        assign WENbuf = (TBISTint === 1'b0 ) ? WENsys : (TBISTint === 1'bx ) ? 1'bx : TWENint;  
        assign WENint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? WENbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[13] : (ATPint === 1'b0 ) ? WENsys : 1'bx ; 
        
        assign CSNbuf = (TBISTint === 1'b0 ) ? CSNsys : (TBISTint === 1'bx ) ? 1'bx : TCSNint;  
        assign CSNint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? CSNbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[11] : (ATPint === 1'b0 ) ? CSNsys : 1'bx ; 
        assign IGint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? IGbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[14] : (ATPint === 1'b0 ) ? IGbuf : 1'bx;

        
        assign DEint = (LSint === 1'bx || (LSint === 1'b0 && HSint === 1'bx) || ^RMint !== 1'b0 || ^WMint !== 1'b0 ) ? 1'bx : 1'b0;
        
     
     and (TBISTint, ATPint, TBISTsys);
     and (SEint, ATPint, SEsys);
     and (TBYPASSint, ATPint, TBYPASSsys);
     and (TSE,TBYPASSint,!SEsys);
     and (MEMEN,INITNint,!CSNint,!SLEEPint,!TBYPASSint,!SEint,!IGint,!DEint,!STDBYint );
     and (MEMEN_dft,INITNint, !SLEEPint, ATPint,!STDBYint);

 `ifdef functional
/*****************assertions added to optimize dynamic power consumption**********/

//psl a_M: assert always ({( RW_assertions_en);(MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1))  } |-> (stable(Msys))) @(posedge CK); 

//psl a_WEN: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(WENsys))) @(posedge CK); 

//psl a_A: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(Asys))) @(posedge CK); 

//psl a_D: assert always ({( RW_assertions_en);((MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1)) && TBYPASSint === 1'b0)  } |-> (stable(Dsys))) @(posedge CK); 

/**********************************************************************************************/
`endif       

     

         
reg vddmp,vddmo, vddma, vddsmp, vddsma, gndsm, gndm,  vddmpi ; 
 
initial 
begin

        vddmp = 1'b1 ; 
        vddmo = 1'b1 ;
        vddma = 1'b1 ;
        
        vddsmp = 1'b1 ;
        
        
         gndm = 1'b0 ;
          
end

        
         assign gndmint = (reg_mem_block === 0) ? gndm : 1'b1;
         
         
         
         
         assign vddmpint = vddmp;
         assign vddmoint = vddmo;
         assign vddmaint = vddma;
         
          
        
         

        //CPF Changes

        
                
        initial
        begin : cpfvddmp 
           vddmpreg = vddmpint;
        end

        always @(vddmpint) begin
           vddmpreg = vddmpint;
        end
        
        initial
        begin : cpfvddmo 
           vddmoreg = vddmoint;
        end

        always @(vddmoint) begin
           vddmoreg = vddmoint;
        end
        
        initial
        begin : cpfvddma 
           vddmareg = vddmaint;
        end

        always @(vddmaint) begin
           vddmareg = vddmaint;
        end

        
        
 
        initial
        begin : cpfgndm 
           gndmreg = gndmint;
        end

        always @(gndmint) begin
           gndmreg = gndmint;
        end

        
        



 `ifdef functional
  `else
  initial begin
    if (debug_level < 1) begin
     $display ("%m  INFORMATION");
     $display ("***************************************");
     $display ("The Model is Operating in TIMING MODE");
     $display ("Please make sure that SDF is properly annotated otherwise dummy values will be used");
     $display ("%s", message_status);
     $display ("***************************************");
    end
  end

//////////////////////////
 //REG DECLARATIONS
   //======================

   reg [Bits-1 : 0] TimingViol_data;
   reg  [Bits-1 : 0] TimingViol_mask;
   reg [Bits-1 : 0] TimingViol_data_last, TimingViol_mask_last;
	reg TimingViol_data_0;
	reg TimingViol_data_1;
	reg TimingViol_data_2;
	reg TimingViol_data_3;
	reg TimingViol_data_4;
	reg TimingViol_data_5;
	reg TimingViol_data_6;
	reg TimingViol_data_7;
	reg TimingViol_data_8;
	reg TimingViol_data_9;
	reg TimingViol_data_10;
	reg TimingViol_data_11;
	reg TimingViol_data_12;
	reg TimingViol_data_13;
	reg TimingViol_data_14;
	reg TimingViol_data_15;
	reg TimingViol_data_16;
	reg TimingViol_data_17;
	reg TimingViol_data_18;
	reg TimingViol_data_19;
 reg TimingViol_mask_0;
 reg TimingViol_mask_1;
 reg TimingViol_mask_2;
 reg TimingViol_mask_3;
 reg TimingViol_mask_4;
 reg TimingViol_mask_5;
 reg TimingViol_mask_6;
 reg TimingViol_mask_7;
 reg TimingViol_mask_8;
 reg TimingViol_mask_9;
 reg TimingViol_mask_10;
 reg TimingViol_mask_11;
 reg TimingViol_mask_12;
 reg TimingViol_mask_13;
 reg TimingViol_mask_14;
 reg TimingViol_mask_15;
 reg TimingViol_mask_16;
 reg TimingViol_mask_17;
 reg TimingViol_mask_18;
 reg TimingViol_mask_19;

   reg TimingViol_addr;
   reg TimingViol_CSN, TimingViol_WEN, TimingViol_tbypass;
   reg TimingViol_tckh, TimingViol_tckl, TimingViol_tcycle;
   reg TimingViol_tckh_se, TimingViol_tckl_se, TimingViol_tcycle_se;
   reg TimingViol_sctrli,TimingViol_sdli,TimingViol_sdri,TimingViol_se;
   reg TimingViol_smli,TimingViol_smri;
   reg TimingViol_sctrli_flag,TimingViol_sdli_flag,TimingViol_sdri_flag;
   reg TimingViol_smli_flag,TimingViol_smri_flag;
   reg TimingViol_initnl;
   reg TimingViol_initn;
   reg TimingViol_ls;
   reg TimingViol_hs;
   reg TimingViol_sleep;
   reg TimingViol_stdby;
   reg TimingViol_rm;
   reg TimingViol_wm;
   reg TimingViol_tbist,TimingViol_ig,TimingViol_atp,TimingViol_TED,TimingViol_TOD,TimingViol_TEM,TimingViol_TOM;
   reg TimingViolRRAE,TimingViolRRA;

   wire CSTBYPASSN,cond_sdf_tas,cond_sdf_tds,cond_sdf_tms,cond_sdf_tws,cond_sdf_tbas,cond_sdf_tbps,cond_sdf_tbws,cond_sdf_tbdes,cond_sdf_tbdos,cond_sdf_tbmes,cond_sdf_tbmos;
   wire SETB_EN,CSIG_EN,MEM_ACT,EN_ADM,CS_EN,CS_ADM,cond_sdf_tps,IG_EN,IG_ADM,cond_sdf_tigs,cond_sdf_taa,cond_sdf_taa_ls1,cond_sdf_taa_hs1,cond_tseq_tm;
   wire cond_sdf_tcycle,cond_sdf_tcycle_ls1,cond_sdf_tcycle_hs1,cond_sdf_tcycle_se,cond_sdf_tckl_se,cond_sdf_tsctrlis,cond_sdf_tsdlis,cond_sdf_tsdris,cond_sdf_tsmlis,cond_sdf_tsmris;
   wire cond_sdf_tckh_se,cond_sdf_taa_sctrlo_se,cond_sdf_taa_sdlo_se,cond_sdf_taa_sdro_se,cond_sdf_taa_smlo_se,cond_sdf_taa_smro_se,cond_sdf_tckl,cond_sdf_tckh;
   wire cond_sdf_ttms,cond_sdf_tbists,INITNandnotSLEEPandATPandnotSE,cond_sdf_taa_sctrlo,cond_sdf_taa_sdlo,cond_sdf_taa_sdro,cond_sdf_taa_smlo,cond_sdf_taa_smro;
   wire cond_sdf_taa_tm,cond_sdf_taa_tm_ls1, cond_sdf_taa_tm_hs1,cond_sdf_taa_tckq_tm,cond_sdf_taa_tseq_tm;

   wire CSWETBYPASSN;
   wire cond_sdf_tstdbys,cond_sdf_tsls,sleep_en,atp_csn_en;
   wire cond_sdf_tlss,cond_sdf_thss,cond_sdf_trms,cond_sdf_twms; 
   wire cond_sdf_tses,cond_sdf_tinitns;
   wire tby_se_en;
   wire rra_en;
   wire tbist_atp_en;
   wire rrae_en;
   wire tbist_rrae_en;
   wire cond_sdf_trraes;
   wire cond_sdf_ttrraes;
   wire cond_sdf_taa_trramatch;
   wire cond_sdf_ttrraematch;
   wire cond_sdf_tamatch;
   wire cond_sdf_ttamatch;
   wire cond_sdf_tatpmatch;
   wire cond_sdf_ttbistmatch;



 and (CSWEMTBYPASS[0], !Mreg[0], CSWETBYPASSN);
 and (CSWEMTBYPASS[1], !Mreg[1], CSWETBYPASSN);
 and (CSWEMTBYPASS[2], !Mreg[2], CSWETBYPASSN);
 and (CSWEMTBYPASS[3], !Mreg[3], CSWETBYPASSN);
 and (CSWEMTBYPASS[4], !Mreg[4], CSWETBYPASSN);
 and (CSWEMTBYPASS[5], !Mreg[5], CSWETBYPASSN);
 and (CSWEMTBYPASS[6], !Mreg[6], CSWETBYPASSN);
 and (CSWEMTBYPASS[7], !Mreg[7], CSWETBYPASSN);
 and (CSWEMTBYPASS[8], !Mreg[8], CSWETBYPASSN);
 and (CSWEMTBYPASS[9], !Mreg[9], CSWETBYPASSN);
 and (CSWEMTBYPASS[10], !Mreg[10], CSWETBYPASSN);
 and (CSWEMTBYPASS[11], !Mreg[11], CSWETBYPASSN);
 and (CSWEMTBYPASS[12], !Mreg[12], CSWETBYPASSN);
 and (CSWEMTBYPASS[13], !Mreg[13], CSWETBYPASSN);
 and (CSWEMTBYPASS[14], !Mreg[14], CSWETBYPASSN);
 and (CSWEMTBYPASS[15], !Mreg[15], CSWETBYPASSN);
 and (CSWEMTBYPASS[16], !Mreg[16], CSWETBYPASSN);
 and (CSWEMTBYPASS[17], !Mreg[17], CSWETBYPASSN);
 and (CSWEMTBYPASS[18], !Mreg[18], CSWETBYPASSN);
 and (CSWEMTBYPASS[19], !Mreg[19], CSWETBYPASSN);

and (atp_csn_en,!ATPint,!CSNint,!IGint);
or (sleep_en,atp_csn_en,ATPint);
or (SETB_EN,SEint,TBISTint);
and (ATP_SETB_EN,ATPint,SETB_EN); 
or (CSIG_EN,IGint,CSNint);
and (MEM_ACT,!ATPint,CSIG_EN);
or (EN_ADM,MEM_ACT,ATP_SETB_EN);
and (CS_EN,!ATPint,IGint);
or (CS_ADM,CS_EN,ATP_SETB_EN);
and (atp_ig_csn_en,!ATPint,!CSNint,!IGint);
and (atp_se_en,!SEsys,ATPint);
or (cycle_en,atp_ig_csn_en,atp_se_en);
and (atp_ig_csn_en_reg,!ATPreg,!CSNreg,!IGreg);
and (atp_se_en_reg,!SE_reg,ATPreg);
or (cycle_en_reg,atp_ig_csn_en,atp_se_en);
and (INITNandnotSLEEPandATPandnotSE,cond_gac,!SEsys,ATPint);
and (csn_ig_en,!IGint,!CSNint);
and (atp_tby_ls_en,atp_se_en,cond_ls_tby_en);
and (IG_EN,!ATPint,!CSNint);
or (IG_ADM,IG_EN,atp_se_en);
and (CSWETBYPASSN, !WENreg, 1'b1);



assign cond_sdf_tsls=((sleep_en && INITNint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tstdbys=((sleep_en && INITNint && !SLEEPint) !==0) ? 1:0;
assign cond_sdf_atps=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_gac=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tas=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tds=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tms=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tws=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tps=((cond_gac && !CS_ADM) !==0) ? 1:0;
assign cond_sdf_tcycle=((cond_gac && cycle_en && !LSint && !HSint) !==0) ? 1:0;  
assign cond_sdf_tcycle_ls1=((cond_gac && cycle_en && LSint) !==0) ? 1:0;
assign cond_sdf_tcycle_hs1=((cond_gac && cycle_en && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_tckh=((cond_gac && cycle_en_reg) !==0) ? 1:0;
assign cond_sdf_tckl=((cond_gac && cycle_en) !==0) ? 1:0;
assign cond_sdf_tcycle_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckl_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsctrlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckh_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_ttms=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_tbists=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_tckq_tm=((cond_gac && SE_reg && ATPreg && TBYPASSsys) !==0) ? 1:0;
assign cond_ls_en=((atp_ig_csn_en || atp_tby_ls_en) !==0) ? 1:0;
assign cond_sdf_tlss=((cond_ls_en && cond_gac) !==0) ? 1:0;
assign cond_sdf_thss=((cond_ls_en && cond_gac && !LSint) !==0) ? 1:0;
assign cond_sdf_trms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_twms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_tses=((cond_gac && ATPint) !==0) ? 1:0;
assign cond_sdf_tbas=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbps=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbws=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tigs=((cond_gac && IG_ADM) !==0) ? 1:0;
assign cond_sdf_taa=((MEMEN_reg && WENreg && !LSint && !HSint) !==0) ? 1:0; 
// assign cond_sdf_taa_tbypass_q = ((MEMEN_reg && ATPint && TBYPASSint) !== 1'b0) ? 1'b1 : 1'b0;
assign cond_sdf_taa_ls1=((MEMEN_reg && WENreg && LSint) !==0) ? 1:0; 
assign cond_sdf_taa_hs1=((MEMEN_reg && WENreg && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && !HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_ls1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && LSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_hs1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tseq_tm=((cond_gac && TBYPASSint) !==0) ? 1:0;
assign cond_sdf_tinitns =(( sleep_en && !STDBYint && !SLEEPint) !==0) ? 1:0;
assign cond_ls_tby_en=((TBYPASSsys || csn_ig_en) !==0) ? 1:0;



//specify block begins

specify
    specparam
    
         PATHPULSE$CK$Q = 0,
         PATHPULSE$CK$SCTRLO = 0,

         PATHPULSE$CK$SDLO = 0,
         PATHPULSE$CK$SDRO = 0,
        
         PATHPULSE$SE$Q = 0,
         
//         PATHPULSE$TBYPASS$Q = 0,


        
         
        
         tsls = `setup_time,
         tslh = `hold_time ,
         tstdbys = `setup_time,
         tstdbyh = `hold_time , 
	 

         
         tcycle = `cycle_time,
         
         
         tckh = `pulse_width_time,
         tckl = `pulse_width_time,
         tcycle_se = `cycle_time,
         tckh_se = `pulse_width_time,
         tckl_se = `pulse_width_time,
         
         ttms = `setup_time,
         ttmh = `hold_time ,
         tps = `setup_time,
         tph = `hold_time ,
         tws = `setup_time,
         twh = `hold_time ,
         tds = `setup_time,
         tdh = `hold_time , 
         tas = `setup_time,
         tah = `hold_time ,
         tses= `setup_time,
         tseh= `hold_time ,
         tsctrlis=`setup_time,
         tsctrlih=`hold_time ,
         tsdlis=`setup_time,
         tsdlih=`hold_time ,
         tsdris=`setup_time,
         tsdrih=`hold_time , 
         tbists=`setup_time,
         tbisth=`hold_time ,
         tbps=`setup_time,
         tbph=`hold_time ,
         tbws=`setup_time,
         tbwh=`hold_time ,
         tbdes=`setup_time,
         tbdeh=`hold_time ,
         tbdos=`setup_time,
         tbdoh=`hold_time ,
         
         tbas=`setup_time,
         tbah=`hold_time ,
         tinitnl=`initin_low_pulse,
         tinitns=`setup_time,
         tinitnh=`hold_time ,
         tatps=`setup_time,
         tatph=`hold_time ,
         tigs=`setup_time,
         tigh=`hold_time ,
         
         
         trms=`setup_time,
         trmh=`hold_time ,
         twms=`setup_time,
         twmh=`hold_time , 

/*************************************************************************************************/
           // taa_tbypass_q = `access_time,
           // th_tbypass_q  = `retain_time,
            taa =`access_time,
            th = `retain_time,

 


            taa_tm =`access_time,
            th_tm = `retain_time,

            
            taa_tseq_tm =`access_time,
            th_tseq_tm = `retain_time,
            taa_tckq_tm   = `access_time,
            th_tckq_tm    = `retain_time,
            taa_sctrlo=`access_time,
            th_sctrlo= `retain_time,
            taa_sdlo=`access_time,
            th_sdlo= `retain_time,
            taa_sdro=`access_time,
            th_sdro= `retain_time,
            
         
            taa_sctrlo_se=`access_time,
            th_sctrlo_se= `retain_time
,
            taa_sdlo_se=`access_time,
            th_sdlo_se= `retain_time,
            taa_sdro_se=`access_time,
            th_sdro_se= `retain_time
         ;  


        /*---------------------- Timing Checks ---------------------*/

	$setup(posedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[7], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[8], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[7], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[8], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[7], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[8], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[7], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[8], tah, TimingViol_addr);

	$setup(posedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(posedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(posedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(posedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(posedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(posedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(posedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(posedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(posedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(posedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(posedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(posedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(posedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(posedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(posedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(posedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(posedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(posedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(posedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(posedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(negedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(negedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(negedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(negedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(negedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(negedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(negedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(negedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(negedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(negedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(negedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(negedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(negedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(negedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(negedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(negedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(negedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(negedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(negedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(negedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[19], tdh, TimingViol_data_19);

        



        $setup(posedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $setup(negedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, posedge WEN, twh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, negedge WEN, twh, TimingViol_WEN); 
        $setup(posedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$setup(negedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, posedge CSN, tph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, negedge CSN, tph, TimingViol_CSN);
        $period(posedge CK &&& cond_sdf_tcycle, tcycle, TimingViol_tcycle);  

        
        $width(posedge CK  &&& cond_sdf_tckh, tckh, 0, TimingViol_tckh);
        $width(negedge CK  &&& cond_sdf_tckl, tckl, 0, TimingViol_tckl);
        $period(posedge CK &&& cond_sdf_tcycle_se, tcycle_se, TimingViol_tcycle_se);
        $width(posedge CK  &&& cond_sdf_tckh_se, tckh_se, 0, TimingViol_tckh_se);
        $width(negedge CK  &&& cond_sdf_tckl_se, tckl_se, 0, TimingViol_tckl_se);

        
        $setup(posedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $setup(negedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $hold(posedge CK &&& cond_sdf_ttms, posedge TBYPASS, ttmh, TimingViol_tbypass); 
        $hold(posedge CK &&& cond_sdf_ttms, negedge TBYPASS, ttmh, TimingViol_tbypass); 
 



        
        $setup(posedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $setup(negedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $hold(posedge CK &&& cond_sdf_tsls, posedge SLEEP, tslh, TimingViol_sleep);        
        $hold(posedge CK &&& cond_sdf_tsls, negedge SLEEP, tslh, TimingViol_sleep);

        $setup(posedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $setup(negedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $hold(posedge CK &&& cond_sdf_tstdbys, posedge STDBY, tstdbyh, TimingViol_stdby);        
        $hold(posedge CK &&& cond_sdf_tstdbys, negedge STDBY, tstdbyh, TimingViol_stdby); 
        
        
        $setup (posedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
	$setup (negedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
        
        $hold (posedge CK &&& cond_sdf_tses, posedge SE ,tseh,TimingViol_se);
	$hold (posedge CK &&& cond_sdf_tses, negedge SE ,tseh,TimingViol_se);
        
        $setup(posedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis , tsctrlis, TimingViol_sctrli);
        $setup(negedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis, tsctrlis, TimingViol_sctrli);
        $hold(posedge CK &&& cond_sdf_tsctrlis , posedge SCTRLI, tsctrlih, TimingViol_sctrli);        
        $hold(posedge CK &&& cond_sdf_tsctrlis , negedge SCTRLI, tsctrlih, TimingViol_sctrli);

        $setup(posedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $setup(negedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $hold(posedge CK &&& cond_sdf_tsdlis, posedge SDLI, tsdlih, TimingViol_sdli);        
        $hold(posedge CK &&& cond_sdf_tsdlis, negedge SDLI, tsdlih, TimingViol_sdli);

        $setup(posedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $setup(negedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $hold(posedge CK &&& cond_sdf_tsdris, posedge SDRI, tsdrih, TimingViol_sdri);        
        $hold(posedge CK &&& cond_sdf_tsdris, negedge SDRI, tsdrih, TimingViol_sdri);
        
 
	
         
        $width(negedge INITN , tinitnl, 0, TimingViol_initnl);
        
        $setup(posedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        $setup(negedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        
        $hold (posedge CK &&& cond_sdf_tinitns,posedge INITN, tinitnh, TimingViol_initn);
        $hold (posedge CK &&& cond_sdf_tinitns,negedge INITN, tinitnh, TimingViol_initn);

        $setup(posedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $setup(negedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $hold(posedge CK &&& cond_sdf_atps, posedge ATP, tatph, TimingViol_atp);        
        $hold(posedge CK &&& cond_sdf_atps, negedge ATP, tatph, TimingViol_atp);
        
        $setup(posedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $setup(negedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $hold(posedge CK &&& cond_sdf_tigs, posedge IG, tigh, TimingViol_ig);        
        $hold(posedge CK &&& cond_sdf_tigs, negedge IG, tigh, TimingViol_ig);



         
$setup(posedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[2], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[2], trmh, TimingViol_rm); 

        
$setup(posedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(posedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[1], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[1], twmh, TimingViol_wm);
 
        
        $setup(posedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $setup(negedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $hold(posedge CK &&& cond_sdf_tbists, posedge TBIST, tbisth, TimingViol_tbist);        
        $hold(posedge CK &&& cond_sdf_tbists, negedge TBIST, tbisth, TimingViol_tbist);
        
        	$setup(posedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[7], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[8], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$setup(negedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[7], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[8], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[6], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[7], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[8], tbah, TimingViol_addr);
       	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[6], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[7], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[8], tbah, TimingViol_addr);

        $setup(posedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$setup(negedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, posedge TCSN, tbph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, negedge TCSN, tbph, TimingViol_CSN); 
       
        $setup(posedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $setup(negedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, posedge TWEN, tbwh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, negedge TWEN, tbwh, TimingViol_WEN);
       
       
        $setup(posedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $setup(negedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, posedge TED, tbdeh, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, negedge TED, tbdeh, TimingViol_TED);

        $setup(posedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $setup(negedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, posedge TOD, tbdoh, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, negedge TOD, tbdoh, TimingViol_TOD);

          


          

          /*-------------------- Propagation Delays ------------------*/
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa, taa, th, taa, th, taa);
                 

/* // //	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[0] +: OutReg_data[0])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[1] +: OutReg_data[1])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[2] +: OutReg_data[2])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[3] +: OutReg_data[3])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[4] +: OutReg_data[4])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[5] +: OutReg_data[5])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[6] +: OutReg_data[6])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[7] +: OutReg_data[7])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[8] +: OutReg_data[8])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[9] +: OutReg_data[9])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[10] +: OutReg_data[10])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[11] +: OutReg_data[11])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[12] +: OutReg_data[12])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[13] +: OutReg_data[13])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[14] +: OutReg_data[14])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[15] +: OutReg_data[15])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[16] +: OutReg_data[16])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[17] +: OutReg_data[17])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[18] +: OutReg_data[18])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[19] +: OutReg_data[19])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q); */ 








	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                





	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                 

	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[0] +: OutReg_data[0])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[1] +: OutReg_data[1])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[2] +: OutReg_data[2])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[3] +: OutReg_data[3])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[4] +: OutReg_data[4])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[5] +: OutReg_data[5])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[6] +: OutReg_data[6])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[7] +: OutReg_data[7])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[8] +: OutReg_data[8])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[9] +: OutReg_data[9])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[10] +: OutReg_data[10])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[11] +: OutReg_data[11])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[12] +: OutReg_data[12])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[13] +: OutReg_data[13])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[14] +: OutReg_data[14])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[15] +: OutReg_data[15])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[16] +: OutReg_data[16])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[17] +: OutReg_data[17])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[18] +: OutReg_data[18])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[19] +: OutReg_data[19])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                



if (cond_sdf_taa_sctrlo) 
        (posedge CK *> (SCTRLO :  SCTRLI)) = (taa_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo); 

if (cond_sdf_taa_sctrlo_se) 
        (negedge CK *> (SCTRLO : SCTRLI)) = (taa_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se); 
 

if (cond_sdf_taa_sdlo) 
        (posedge CK *> (SDLO :  SDLI)) = (taa_sdlo,taa_sdlo,th_sdlo,taa_sdlo,th_sdlo,taa_sdlo); 

if (cond_sdf_taa_sdlo_se) 
        (negedge CK *> (SDLO : SDLI)) = (taa_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se);

if (cond_sdf_taa_sdro) 
        (posedge CK *> (SDRO :  SDRI)) = (taa_sdro,taa_sdro,th_sdro,taa_sdro,th_sdro,taa_sdro); 

if (cond_sdf_taa_sdro_se) 
        (negedge CK *> (SDRO : SDRI)) = (taa_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se); 

  
     




endspecify //specify block ends






// conversion from registers to array elements for data setup violation notifiers

always @(TimingViol_data_0   or TimingViol_TED  )
begin
        TimingViol_data[0]=~TimingViol_data[0];   
end


always @(TimingViol_data_1   or TimingViol_TOD  )
begin
        TimingViol_data[1]=~TimingViol_data[1];   
end


always @(TimingViol_data_2   or TimingViol_TED  )
begin
        TimingViol_data[2]=~TimingViol_data[2];   
end


always @(TimingViol_data_3   or TimingViol_TOD  )
begin
        TimingViol_data[3]=~TimingViol_data[3];   
end


always @(TimingViol_data_4   or TimingViol_TED  )
begin
        TimingViol_data[4]=~TimingViol_data[4];   
end


always @(TimingViol_data_5   or TimingViol_TOD  )
begin
        TimingViol_data[5]=~TimingViol_data[5];   
end


always @(TimingViol_data_6   or TimingViol_TED  )
begin
        TimingViol_data[6]=~TimingViol_data[6];   
end


always @(TimingViol_data_7   or TimingViol_TOD  )
begin
        TimingViol_data[7]=~TimingViol_data[7];   
end


always @(TimingViol_data_8   or TimingViol_TED  )
begin
        TimingViol_data[8]=~TimingViol_data[8];   
end


always @(TimingViol_data_9   or TimingViol_TOD  )
begin
        TimingViol_data[9]=~TimingViol_data[9];   
end


always @(TimingViol_data_10   or TimingViol_TED  )
begin
        TimingViol_data[10]=~TimingViol_data[10];   
end


always @(TimingViol_data_11   or TimingViol_TOD  )
begin
        TimingViol_data[11]=~TimingViol_data[11];   
end


always @(TimingViol_data_12   or TimingViol_TED  )
begin
        TimingViol_data[12]=~TimingViol_data[12];   
end


always @(TimingViol_data_13   or TimingViol_TOD  )
begin
        TimingViol_data[13]=~TimingViol_data[13];   
end


always @(TimingViol_data_14   or TimingViol_TED  )
begin
        TimingViol_data[14]=~TimingViol_data[14];   
end


always @(TimingViol_data_15   or TimingViol_TOD  )
begin
        TimingViol_data[15]=~TimingViol_data[15];   
end


always @(TimingViol_data_16   or TimingViol_TED  )
begin
        TimingViol_data[16]=~TimingViol_data[16];   
end


always @(TimingViol_data_17   or TimingViol_TOD  )
begin
        TimingViol_data[17]=~TimingViol_data[17];   
end


always @(TimingViol_data_18   or TimingViol_TED  )
begin
        TimingViol_data[18]=~TimingViol_data[18];   
end


always @(TimingViol_data_19   or TimingViol_TOD  )
begin
        TimingViol_data[19]=~TimingViol_data[19];   
end


`endif


// TASK DEFINITION DESCRIPTION
// ================================



task task_insert_faults_in_memory;
begin
   if (reg_ConfigFault)
   begin   
     for(i = 0;i< fcnt;i = i+ 1) begin
        if(mem_red_array_stuck_at[i] === "mem_array") begin
          if (array_stuck_at[i] === "sa0") begin
           `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data & stuck_at_0fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
          `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] & stuck_at_0fault[i];
          `endif
         end //if(array_stuck_at)
                                        
         if(array_stuck_at[i] === "sa1") begin
         `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data | stuck_at_1fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
         `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] | stuck_at_1fault[i]; 
         `endif
         end //if(array_stuck_at)
       end //if mem_red_array_stuck_at
    
    
     end    // end of for
   end  
end
endtask



task task_read_fault_file;
begin
/*  -----------Implemetation for config fault starts------*/
   msgcnt = X;
   t = 0;
   fault_repair_flag = {max_faults{1'b1}};
   repair_flag = {max_faults{1'b1}};
   if(reg_ConfigFault) 
   begin
      file_ptr = $fopen(reg_Fault_file_name , "r");
      if(file_ptr == 0)
      begin     
          if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: File cannot be opened ",$realtime);
      end        
      else                
      begin : read_fault_file
        t = 0;
        for (i = 0; i< max_faults; i= i + 1)
        begin
         
           stuck0 = {Bits{1'b1}};
           stuck1 = {Bits{1'b0}};
           fault_char1 = $fgetc (file_ptr);
           if (fault_char1 == 8'b11111111)
              disable read_fault_file;
           ret_val = $ungetc (fault_char1, file_ptr);
           ret_val = $fgets(tempStr, file_ptr);
           ret_val = $sscanf(tempStr, "%s %d %d %s",fault_array,fault_word, fault_bit, stuck_at) ;
           flag_error = 0; 
           if(ret_val !== 0)
           begin         
              if(ret_val == 3 || ret_val == 4)
              begin
                if(ret_val == 3)
                   stuck_at = "sa0";

                if(stuck_at !== "sa0" && stuck_at !== "sa1" && stuck_at !== "none")
                begin
                    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: Wrong value for stuck at in fault file ",$realtime);
                   flag_error = 1;
                end    
                      
                if(fault_word >= Words)
                begin
                   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Address out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                if(fault_bit >= Bits)
                begin  
                    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Faulty bit out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                
                        
                if(fault_array !== "mem_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array is not mem_array ",$realtime);
                  flag_error = 1;
                end

                if(fault_array === "red_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array can't be on redundancy array in non redundancy cut.",$realtime);
                  flag_error = 1;
                end

                
                

                if(flag_error == 0)
                //Correct Inputs
                begin
                   if(stuck_at === "none")
                   begin
                       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
                   end
                   else
                   //Adding the faults
                   begin
                      FailureLocn[t] = fault_word;
                      Failurebit[t]  = fault_bit ;
                      std_fault_word = fault_word;
                      fault_row_add[t] = std_fault_word[Addr-1:mux_bits];
                      mem_red_array_stuck_at[t] = fault_array;
                      fault_repair_flag[t] = 1'b0;
                      if (stuck_at === "sa0" )
                      begin
                         stuck0[fault_bit] = 1'b0;         
                         stuck_at_0fault[t] = stuck0;
                      end     
                      if (stuck_at === "sa1" )
                      begin
                         stuck1[fault_bit] = 1'b1;
                         stuck_at_1fault[t] = stuck1; 
                      end

                      array_stuck_at[t] = stuck_at;
                      t = t + 1;
                   end //if(stuck_at === "none")  
                end //if(flag_error == 0)
              end //if(ret_val == 2 || ret_val == 3 
              else
              //wrong number of arguments
              begin
                if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: WRONG VALUES ENTERED FOR FAULTY WORD OR FAULTY BIT OR STUCK_AT IN Fault_file_name ",$realtime); 
                flag_error = 1;
              end
           end //if(ret_val !== 0)
           else
           begin 
               if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
           end    
        end //for (i = 0; i< m
      end //begin: read_fault_file  
      $fclose (file_ptr);

      fcnt = t;
      
      //fault injection at time 0.
      task_insert_faults_in_memory;
  end // config_fault 
end
endtask


task WriteMemX;
begin

`ifdef slm
   $slm_ResetMemory(MemAddr, WordX);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = WordX;
   
`endif        
 task_insert_faults_in_memory;
end
endtask

task WriteMem0;
begin
`ifdef slm
   $slm_ResetMemory(MemAddr, Word0);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = Word0;
  
`endif 
   task_insert_faults_in_memory;
end
endtask


task WriteOutX;                
begin
   OutReg_data <= #0 WordX;
end
endtask


task Invalid_next_cycle_func;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_func = 1;
     `else 
       #0 next_cycle_corrupt_func = 0; 
     `endif  
   end 
end
endtask

task Invalid_next_cycle_dft;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_dft = 1;
     `else 
       #0 next_cycle_corrupt_dft = 0; 
     `endif  
  end
end
endtask

task Invalid_next_cycle_func_tim;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
   #0 next_cycle_corrupt_func <= 1;
  end 
end
endtask

task Invalid_next_cycle_dft_tim;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
  #0 next_cycle_corrupt_dft <= 1;
  end
end
endtask


task ScanOutX;                
begin
   
   dff_SCTRLO_SE.Q <= 1'bx;   
   dff_SDLO_SE.Q <= 1'bx; 
   dff_SDRO_SE.Q <= 1'bx; 
    
   
   SCTRLOint=X;
   SDLOint=X;
   SDROint=X;
    
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   SDLO_data<=1'bx;
   SDRO_data<=1'bx;
    
   `endif
end
endtask

task delScanOutX;                
begin
   delSCTRLO_data<=X;
   delSDLO_data<=X;
   delSDRO_data<=X;
    
end
endtask

task ScanChainX;                
begin
 scanreg_ctrl=1'bx; 
 scanreg_dl=1'bx; 
 scanreg_dr =1'bx; 
  
end
endtask

task mem_blocked;
begin
 
   WriteMemX;
   WriteOutX;
   ScanChainX;
   ScanOutX;//immediately;
   delScanOutX;//immediately
   `ifdef POWER_SEQUENCING_OFF
   `else
   reg_mem_block=1;
   `endif
   debug_level = 2'b11;
end
endtask

task corrupt_all;
begin
 
  WriteMemX;
  WriteOutX;
  ScanChainX;
  ScanOutX;
  delScanOutX;//immediately;
  OutReg_data = WordX; 
  delOutReg_data=WordX;
  
end
endtask

task WriteCycle;                  
input [Addr-1 : 0] Address;
reg [Bits-1:0] tempReg1;
reg [Bits-1:0] tempReg_slm;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;


reg repair_flag;

integer po,i,num,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;
begin

   tempReg1 = WordX;
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];

   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};
   
   if (ValidAddress === X )   begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
        WriteMemX;
        if (INITNint !== 0) begin
        `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
           #0 next_cycle_corrupt_func = 1;
       `else 
           #0 next_cycle_corrupt_func = 0; 
       `endif  
   end 

   end


   if (ValidAddress !== X && next_cycle_corrupt_func === 0  )
   begin
         if (red_en === 1 && ((Row_Add_cmp === repair_add) || (Row_Add_cmp === next_repair_add)) ) begin
             repair_flag = 1'b1;
             
             Bank_sel_integer = 0;
                     
             if (Row_Add_cmp === repair_add) begin
               Col_Add_integer  = Col_Add; 
             end
             else if (Row_Add_cmp === next_repair_add) begin
               Col_Add_integer  = Col_Add + mux; 
             end  
             RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
        end  

        if(repair_flag === 0 && ValidAddress === 1) begin
           `ifdef slm
              $slm_ReadMemoryS(MemAddr, Address, tempReg_slm);
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = Mem[Address];
            `endif
          end  
        else if(repair_flag === 1) begin
           `ifdef slm
//              $slm_ReadMemoryS(RedMemAddr, RedMem_address, tempReg_slm);
          
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = RedMem[RedMem_address];
            `endif
        end
        
        for (num=0;num<Bits;num=num+1) begin
             po=num;        
             if ( Dint [num] !== tempReg1 [po]) begin
                if (Mint[num] === 1'b0)
                   tempReg1[po] = Dint[num];
                else if (Mint[num] === 1'bX)
                   tempReg1[po] = 1'bx;
             end                
        end //for (num=0
            
         if(repair_flag === 0 ) begin    
            if(ValidAddress === 1) begin  
              `ifdef slm
                  tempReg_slm=tempReg1; 
                  $slm_WriteMemory(MemAddr, Address, tempReg_slm);
              `else
                   Mem[Address] = tempReg1;
              `endif
            end
            else begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address Out Of Range. ",$realtime);
            end        
         end
         else if (repair_flag === 1 ) begin
            `ifdef slm
                tempReg_slm=tempReg1; 
//                $slm_WriteMemory(RedMemAddr, RedMem_address, tempReg_slm);
            `else
                RedMem[RedMem_address] = tempReg1;
            `endif
         end
   end //if (ValidAddress !== X
   task_insert_faults_in_memory;
end
endtask 

task ReadCycle;
input [Addr-1 : 0] Address;

reg [Bits-1:0] MemData_tmp;
reg [Bits-1:0] MemData;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;

reg repair_flag;

integer a,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;

begin
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];
   
   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};

   

   if (ValidAddress !== X && next_cycle_corrupt_func === 0 ) begin   
       if(red_en === 1 && ( Row_Add_cmp === repair_add ||  Row_Add_cmp === next_repair_add )) begin
              repair_flag = 1;
              
              Bank_sel_integer = 0;
               
              if(Row_Add_cmp === repair_add) begin
                Col_Add_integer = Col_Add;
              end
              else if (Row_Add_cmp === next_repair_add) begin
                Col_Add_integer = Col_Add + mux; 
              end
              RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
       end

      if(repair_flag === 0) begin
          if(ValidAddress === 1) begin 
           `ifdef slm
              $slm_ReadMemory(MemAddr, Address, MemData);
           `else
              MemData = Mem[Address];
           `endif
          end
          else begin
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Address Out Of Range. Output Corrupted ",$realtime);
             MemData = WordX;
          end
     end
      else if(repair_flag === 1) begin
        `ifdef slm
//           $slm_ReadMemory(RedMemAddr, RedMem_address, MemData);
        `else
           MemData = RedMem[RedMem_address];
        `endif
      end
   end //if (ValidAddress)  
   
   if(ValidAddress === X)
   begin
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Illegal Value on Address Bus. Memory and Output Corrupted ",$realtime); 
         Invalid_next_cycle_func;
   end 
   
  if(ValidAddress !== X && next_cycle_corrupt_func === 0 )
   begin
   for (a = 0; a < Bits; a = a + 1)
   begin
      if (MemData[a] !== OutReg_data[a])
         OutReg_data[a] = WordX[a];
   end//for (a = 0; a <  
         OutReg_data <= MemData;
   end     
end
endtask



// SCAN CHAINS
supply0 gnd;
buf (A_int[0], Aint[0]);
buf (A_int[1], Aint[1]);
buf (A_int[2], Aint[2]);
buf (A_int[3], Aint[3]);
buf (A_int[4], Aint[4]);
buf (A_int[5], Aint[5]);
buf (A_int[6], Aint[6]);
buf (A_int[7], Aint[7]);
buf (A_int[8], Aint[8]);                  //used for capturing
buf (A_int[9], gnd);
buf (A_int[10], gnd);
buf (A_int[11], gnd);
buf (A_int[12], gnd);
buf (A_int[13], gnd);
buf (A_int[14], gnd);   //used for capturing

buf (WEN_int, WENint);
buf (CSN_int, CSNint);
buf (IG_int, IGint);


// Scan flops



// CONTROL SCAN CHAIN
     ST_SPREG_LOLEAK_512x20m8_Tl_SCFF cntrl_scff_0 (.D(A_int[2]), .TI(SCTRLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[0]), .OUTX(scanreg_ctrl));

      
 ST_SPREG_LOLEAK_512x20m8_Tl_SCFF cntrl_scff_1 (.D(A_int[4]), .TI(scanreg_ctrl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[1]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m8_Tl_SCFF cntrl_scff_2 (.D(A_int[6]), .TI(scanreg_ctrl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[2]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m8_Tl_SCFF cntrl_scff_3 (.D(A_int[9]), .TI(scanreg_ctrl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[3]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m8_Tl_SCFF cntrl_scff_4 (.D(A_int[3]), .TI(scanreg_ctrl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[4]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m8_Tl_SCFF cntrl_scff_5 (.D(A_int[11]), .TI(scanreg_ctrl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[5]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m8_Tl_SCFF cntrl_scff_6 (.D(A_int[10]), .TI(scanreg_ctrl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[6]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m8_Tl_SCFF cntrl_scff_7 (.D(A_int[1]), .TI(scanreg_ctrl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[7]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m8_Tl_SCFF cntrl_scff_8 (.D(A_int[0]), .TI(scanreg_ctrl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[8]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m8_Tl_SCFF cntrl_scff_9 (.D(A_int[5]), .TI(scanreg_ctrl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[9]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m8_Tl_SCFF cntrl_scff_10 (.D(A_int[7]), .TI(scanreg_ctrl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[10]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m8_Tl_SCFF cntrl_scff_11 (.D(CSN_int), .TI(scanreg_ctrl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[11]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m8_Tl_SCFF cntrl_scff_12 (.D(A_int[8]), .TI(scanreg_ctrl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[12]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m8_Tl_SCFF cntrl_scff_13 (.D(WEN_int), .TI(scanreg_ctrl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[13]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_512x20m8_Tl_SCFF cntrl_scff_14 (.D(scanreg_ctrl_wire[14]), .TI(scanreg_ctrl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[14]), .OUTX(scanreg_ctrl));  

reg LP_CK_gate;

// Lock Up Latch
wire SCTRLO_temp;
 ST_SPREG_LOLEAK_512x20m8_Tl_lock_up_latch  dff_SCTRLO_SE (Latch_open, scanreg_ctrl_wire[14], SCTRLO_temp);

always @(SCTRLO_temp) begin
     SCTRLOint= SCTRLO_temp;
 `ifdef functional
 `else
 if (SCTRLOint !== SCTRLO_data) begin 
  if (SCTRLOint !==X)
   SCTRLO_data=1'bx;
   SCTRLO_data <= SCTRLOint;
 end 
 `endif
end  


// LEFT DATA SCAN CHAIN
     ST_SPREG_LOLEAK_512x20m8_Tl_SCFF ldata_scff_0 (.D(Dint[9]), .TI(SDLI), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[0]), .OUTX(scanreg_dl));
      
   
 
        ST_SPREG_LOLEAK_512x20m8_Tl_SCFF ldata_scff_1 (.D(Dint[8]), .TI(scanreg_dl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[1]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m8_Tl_SCFF ldata_scff_2 (.D(Dint[7]), .TI(scanreg_dl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[2]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m8_Tl_SCFF ldata_scff_3 (.D(Dint[6]), .TI(scanreg_dl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[3]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m8_Tl_SCFF ldata_scff_4 (.D(Dint[5]), .TI(scanreg_dl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[4]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m8_Tl_SCFF ldata_scff_5 (.D(Dint[4]), .TI(scanreg_dl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[5]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m8_Tl_SCFF ldata_scff_6 (.D(Dint[3]), .TI(scanreg_dl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[6]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m8_Tl_SCFF ldata_scff_7 (.D(Dint[2]), .TI(scanreg_dl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[7]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m8_Tl_SCFF ldata_scff_8 (.D(Dint[1]), .TI(scanreg_dl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[8]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_512x20m8_Tl_SCFF ldata_scff_9 (.D(Dint[0]), .TI(scanreg_dl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[9]), .OUTX(scanreg_dl));



// Lock Up Latch
wire SDLO_temp;
 ST_SPREG_LOLEAK_512x20m8_Tl_lock_up_latch  dff_SDLO_SE (Latch_open, scanreg_dl_wire[9], SDLO_temp);

always @(SDLO_temp) begin
     SDLOint= SDLO_temp;
 `ifdef functional
 `else
 if (SDLOint !== SDLO_data) begin 
  if (SDLOint !==X)
   SDLO_data=1'bx;
   SDLO_data <= SDLOint;
 end 
 `endif
end  






// RIGHT DATA SCAN CHAIN

     ST_SPREG_LOLEAK_512x20m8_Tl_SCFF rdata_scff_0 (.D(Dint[19]), .TI(SDRI), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[0]), .OUTX(scanreg_dr));
     
 
 
        ST_SPREG_LOLEAK_512x20m8_Tl_SCFF rdata_scff_1 (.D(Dint[18]), .TI(scanreg_dr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[1]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m8_Tl_SCFF rdata_scff_2 (.D(Dint[17]), .TI(scanreg_dr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[2]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m8_Tl_SCFF rdata_scff_3 (.D(Dint[16]), .TI(scanreg_dr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[3]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m8_Tl_SCFF rdata_scff_4 (.D(Dint[15]), .TI(scanreg_dr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[4]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m8_Tl_SCFF rdata_scff_5 (.D(Dint[14]), .TI(scanreg_dr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[5]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m8_Tl_SCFF rdata_scff_6 (.D(Dint[13]), .TI(scanreg_dr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[6]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m8_Tl_SCFF rdata_scff_7 (.D(Dint[12]), .TI(scanreg_dr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[7]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m8_Tl_SCFF rdata_scff_8 (.D(Dint[11]), .TI(scanreg_dr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[8]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_512x20m8_Tl_SCFF rdata_scff_9 (.D(Dint[10]), .TI(scanreg_dr_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[9]), .OUTX(scanreg_dr)); 


// Lock Up Latch
wire SDRO_temp;
 ST_SPREG_LOLEAK_512x20m8_Tl_lock_up_latch  dff_SDRO_SE (Latch_open, scanreg_dr_wire[9], SDRO_temp);


always @(SDRO_temp) begin
     SDROint= SDRO_temp;
 `ifdef functional
 `else
 if (SDROint !== SDRO_data) begin 
  if (SDROint !==X)
   SDRO_data=1'bx;
   SDRO_data <= SDROint;
 end 
 `endif
end






//


 //////// CAPTURE TASK //////
task scan_acquire;
begin
   if (supply_ok === 1) begin 
      if ( SEsys === 0 && ((LP_CK_gate === 0 && TBYPASSsys !== 1'bx)|| TBYPASSsys===0)) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
         
         Latch_open=1;
         

      end //if ( SEint === 0
   end//if(supply_ok 
end
endtask

task scan_shift;
begin
 if (supply_ok === 1) begin
   if (STDBYint === 0 && SLEEPint === 0) begin
      if (CKint_dft === X && INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0) begin
         ScanChainX;
         ScanOutX;
      end
      else if (CKint_dft === 1 && lastCK_dft === 0 ) begin
          //// SHIFT
        if (SEsys === 1) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
           
        //// SHIFT Ends
        end //if (SEsys === 1
        else if (SEsys === X) begin
            ScanChainX;
            ScanOutX;
            delScanOutX;
        end//if (SEint ==X
      
      end///if (CKint === 
    
      else if (CKint_dft === 0 && lastCK_dft === 1 ) begin
        Latch_open=1;
      end
    end  //if (STDByint === 0 && SLEEPint === 0
 end//if(supply_ok
end
endtask






// BEHAVIOURAL MODULE DESCRIPTION
// ================================

initial
begin
  // Define format for timing value
  $timeformat (-9, 3, " ns", 0);
  `ifdef slm
  $slm_RegisterMemory(MemAddr, Words, Bits);
  `endif   
   reg_mem_block=0;
   flag_mem_block=0;
  `ifdef functional
  `else
   TimingViol_data=0;
   TimingViol_mask=0;
   `endif
   decoding_start=0;
  
   //Parameter Assignment
   
   reg_Fault_file_name = Fault_file_name; 
   reg_ConfigFault     = ConfigFault;
   reg_MEM_INITIALIZE  = MEM_INITIALIZE;
   reg_BinaryInit      = BinaryInit;
   reg_InitFileName    = InitFileName;
   reg_Initn_reset_value = Initn_reset_value;
   reg_File_load_time    = File_load_time;

   time_fall_sleep=0;
   time_fall_PSWLARGEMP=0;
   time_fall_PSWLARGEMP_0=0;
   time_fall_PSWLARGEMA=0;
   time_fall_PSWLARGEMA_0=0;
   time_fall_PSWSMALLMP=0;
   time_fall_PSWSMALLMA=0;

   vddmp_rise_time=0;
   vddmp_fall_time=0;
   vddsmp_rise_time=0;
   vddsmp_fall_time=0;
   vddma_rise_time=0;
   vddma_fall_time=0;
   vddsma_rise_time=0;
   vddsma_fall_time=0;
   vddm_fall_time=0;  
   vddm_rise_time=0;  
   vddsm_fall_time=0; 
   vddsm_rise_time=0;

   next_cycle_corrupt_func=0;
   next_cycle_corrupt_dft=0;
   init_pulse_done = 0;
   power_up_done = 0;
   file_loaded=1;
   debug_level= 2'b01;
   message_status = "ONLY WARNINGS/ERRORS are Switched ON.For INFO also use debug_level=2'b00";
  `ifdef  NO_WARNING_MODE
     debug_level = 2'b11;
     message_status = "All Warning/Errors/Info Messages are Switched OFF";
  `endif  
  `ifdef  ONLY_ERROR_MODE
     debug_level = 2'b10;
     message_status = "All Warning/Info Messages are Switched OFF.Errors are switched on";
  `endif 
  `ifdef  ALL_MSG_MODE
     debug_level = 2'b00;
     message_status = "All Messages are Switched ON";
  `endif 
  
  `ifdef slm
     operating_mode = "SLM";
   `else
      `ifdef functional
         operating_mode = "FUNCTIONAL";
       `else
         operating_mode = "TIMING";
      `endif
   `endif   
  
  if (debug_level < 1) begin
  $display ("%m INFORMATION ");
  $display ("***************************************");
  $display ("The Model is Operating in %s MODE", operating_mode);
  $display ("%s", message_status);
  if(reg_ConfigFault)
  $display ("Configurable Fault Functionality is ON");   
  else
  $display ("Configurable Fault Functionality is OFF");   
  $display("Fault File used by the model Fault_File_Name=%s" ,reg_Fault_file_name);
  $display("Values of Config_fault used in model=%d" ,reg_ConfigFault);
  $display("Values of Mem_INITALIZE used in model=%d" ,reg_MEM_INITIALIZE);
  $display("Values of BinaryInit used in model=%d" ,reg_BinaryInit);
  $display("Values of InitFileName used in model=%s" ,reg_InitFileName);
  $display("Values of Initn_reset_value used in model=%d" ,reg_Initn_reset_value);
  $display("Values of File_load_time used in model=%t" ,reg_File_load_time);

  $display ("***************************************");
  end
     
  task_read_fault_file; 
   if(!INITNint) begin
    if(supply_ok ) begin 
      init_pulse_done = 1;
      power_up_done = 1;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif 
    end 
   end 
        
   lastCK_func = CKint_func;
   lastCK_dft = CKint_dft;

 `ifdef MEM_CONTENTS_SLEEP
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","w");
   $fclose(ptr);
 `endif 

   
end  // initial block ends



//+++++++++++++++++++++++++++++++ CONFIG FAULT IMPLEMETATION ENDS+++++++++++++++++++++++++++++++//
        




//INITN block starts
//================================
always @(INITNint  or supply_ok )
begin
 if (INITNint === 1'b0) begin
   if(supply_ok) begin
     init_pulse_done = 1;
     power_up_done = 1;
     lastCK_func=CKint_func;
     lastCK_dft=CKint_dft;
     next_cycle_corrupt_func = 0;
     next_cycle_corrupt_dft = 0;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif     
   end 
 end        

 if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && INITNint !== 1)
   begin
     ScanOutX;
     ScanChainX;
     delScanOutX;
   end  
         
 if (init_pulse_done === 0 && INITNint !== 0) begin
     if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) INFO: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
 end
 
end//always @(INITNint)


// Clock Generation 
//wire gated_clock;
//wire clock_gate_en;
//ST_SPREG_LOLEAK_512x20m8_Tl_lock_up_latch CK_SE_latch (!CK , SE, SE_latch_CK);
//and (clock_gate_en, ATP, TBYPASS, !SE_latch_CK);

//ST_SPREG_LOLEAK_512x20m8_Tl_lock_up_latch LP_latch (!CK , scanreg_ctrl_wire[14], LP_latch_CK);
//and (gated_clock,CK,!LP_latch_CK);
//assign CK_new= clock_gate_en ===0 ? CK : (clock_gate_en ===1 ? gated_clock: (CK===0) ? 0 :1'bx);


// Clock Generation Ends


// Functional CK block starts
//======================================
always @(CKint_func)
begin
   lastCK_func=CKreg_func;  
   CKreg_func=CKint_func;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
        if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
      if (CKreg_func === 1'bX || (CKreg_func === 1'b1 && lastCK_func === 1'bx)) begin
        if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
         
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
         Invalid_next_cycle_func;
        end
      end
      else if (CKreg_func === 1'b1 && lastCK_func === 1'b0 ) begin
        time_CK_func_rise=$realtime;
        MEMEN_prev = MEMEN_reg;
        MEMEN_reg = MEMEN;
        CSNreg = CSNint;
        IGreg = IGint;
        DEreg = DEint;
        SE_reg = SEsys;
        TBYPASS_reg = TBYPASSsys;
        ATPreg = ATPint;
        INITNreg = INITNint;
        SLEEPreg = SLEEPint;
        STDBYreg = STDBYint;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 

    `ifdef functional
    `else
        Mem_last=Mem[Aint];
    `endif 
        if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.INITN pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SLEEP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.STANDBY pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg === X && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.chip select  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg === X && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.IG pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg === X && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.Debug pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg === X && (SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.ATP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg === X && TBYPASS_reg !== 1) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SE pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg !== 1 && TBYPASS_reg === X) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.TBYPASS pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end

        else if ((INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0))) && WENint === X) begin
            // Uncertain write cycle
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: write enable going to X  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end 
        else if (next_cycle_corrupt_func === 1) begin
          next_cycle_corrupt_func = X;
        end
        else if (next_cycle_corrupt_func === 1'bx) begin
          next_cycle_corrupt_func = 0;
        end 
        
//        if (next_cycle_corrupt_func === 0 ) begin 
         
          /*---------------------- File initialization -----------------*/
          
          if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0)) && flag_mem_block === 1'b0) begin
                 Areg=Aint;
                 Dreg=Dint;
                 Mreg=Mint;
                 WENreg=WENint;     
             if (reg_MEM_INITIALIZE === 1'b1 && $realtime >= reg_File_load_time && file_loaded ) begin   
                `ifdef slm
                  if (reg_BinaryInit)
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_BIN");
                  else
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_HEX");
   
                `else
                  if (reg_BinaryInit)
                     $readmemb(reg_InitFileName, Mem, 0, Words-1);
                  else
                     $readmemh(reg_InitFileName, Mem, 0, Words-1);
                `endif
                 file_loaded = 0;
             end
   
             if (^Aint === X)
               ValidAddress = X;
             else if (Aint < Words)
               ValidAddress = 1;
             else    
               ValidAddress = 0;
   
             if(red_en === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Redundancy Enable is Invalid. Either RRAE is X or TRRAE is X",$realtime);
                ValidAddress = X; 
           end
           else if(red_en === 1'b1 && ^repair_add === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Repair Address is invalid.RRA is X",$realtime);
                ValidAddress = X;
           end
             
             if (ValidAddress)
               `ifdef slm
                   $slm_ReadMemoryS(MemAddr, Aint, Mem_temp);
               `else
                    Mem_temp = Mem[Aint];
               `endif
             else
                Mem_temp = WordX;  
          
     /*---------------------- Normal Read and Write -----------------*/
     
             if (WENint === 1) begin
               ReadCycle(Aint);
             end
       
             else if (WENint === 0) begin
               WriteCycle(Aint);
             end 
                
          
          end //  if (MEMEN === 1'b1 
       
//        end  // if (next_cycle_corrupt_func === 0
      
      end // if (CKint = 1   
   end // if (init_pulse_done === 1           
 end 
end // always @(CKint_func)
        
always @(MEMEN)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) && CKint_func === 1'bx) begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.clock pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
    Invalid_next_cycle_func;
  end
 end 
end

// DFT CK block starts
//======================================
always @(CKint_dft) 
begin
   lastCK_dft=CKreg_dft;
   CKreg_dft=CKint_dft;
   
   Latch_open=0;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
     if (CKreg_dft === 1'bX || (CKreg_dft === 1'b1 && lastCK_dft === 1'bx)) begin
       if (INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0 ) begin
        
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: DFT clock  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime); 
         Invalid_next_cycle_dft;
         if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
           WriteOutX;
         end
       end
     end 

     if(CKint_dft === 0 && lastCK_dft === 1) begin
      if(ATPreg === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
       if(SE_reg === 1'b1 && SEsys === 1'b0) begin
        if(TBYPASSint === 1'b1) begin   
    
       
       
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8], scanreg_dl_wire[scanlen_l-1]}; 
       


         for (i = 0; i < Bits; i = i + 1)
         begin
          if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
         end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
        end 
       end
      end
     end 
     
     else if (CKreg_dft === 1'b1 && lastCK_dft === 1'b0 ) begin
       SE_reg = SEsys;
       TBYPASS_reg = TBYPASSsys;
       ATPreg = ATPint;
       INITNreg = INITNint;
       SLEEPreg = SLEEPint;
       STDBYreg = STDBYint;
       MEMEN_dft_prev = MEMEN_dft_reg;
       MEMEN_dft_reg = MEMEN_dft;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 
       if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ) begin 
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
 //     else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys === X && TBYPASSsys !== 1) begin
///           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
//           Invalid_next_cycle_dft;
//        end       
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys === X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
        end 
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys !== 0 && LP_CK_gate===X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: LP FLOP Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           ScanChainX;
           ScanOutX;   
          if( TBYPASSint !== 0 && SEint !== 1) begin
            WriteOutX;
          end
          next_cycle_corrupt_dft=0;
        end        
       else if (next_cycle_corrupt_dft === 1'b1) begin 
         next_cycle_corrupt_dft = X;
       end 
       else if (next_cycle_corrupt_dft === 1'bx) begin
         next_cycle_corrupt_dft = 0;
       end
       
       if (next_cycle_corrupt_dft === 0 ) begin
         
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1 && flag_mem_block === 1'b0) begin
           
           if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0  && LP_CK_gate===0) begin
              OutReg_data_tbypass = Dint;
              for (i = 0; i < Bits; i = i + 1)
              begin
               if (OutReg_data_tbypass[i] !== OutReg_data[i])
                 OutReg_data[i] = WordX[i];
              end//for (i = 0; i < */ 
              OutReg_data <= OutReg_data_tbypass;
           end
           
             scan_acquire;
         end //MEMEN_dft == 1        
       end // if ( next_cycle_corrupt_dft
       
     end // if (CKint_dft === 1'b1
      //  if (next_cycle_corrupt_dft === 0 ) begin 
       if (SE_reg !== 0) begin
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1  && flag_mem_block === 1'b0) begin
           next_cycle_corrupt_dft = 0;
           if ( next_cycle_corrupt_func === 1) begin
	    next_cycle_corrupt_func = 0 ;
	   end	
           scan_shift;
         end
       end
     //end // if ( next_cycle_corrupt_dft    
     if ((!(TBYPASSsys!==0 && SEsys!==1 && LP_CK_gate!==0 ) && next_cycle_corrupt_dft === 0) || CKint_dft !==1) begin          
       CK_sc=INITNreg & !STDBYreg & !SLEEPreg & ATPreg & CKreg_dft ;
     end     
   end // if (init_pulse_done 
 end // if (supply_ok 
end // always @(CKint_dft)

always @(MEMEN_dft)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) && CKint_dft === 1'bx)  begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.MEMEN_dft and clock should not be X at this time instant. ScanChains and ScanOuts Corrupted ",$realtime); 
    Invalid_next_cycle_dft;
    
    if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
      WriteOutX;
    end
  end
  if ( MEMEN_dft !== 0 && TBYPASSsys !== 0 && SEsys !== 1) begin
     WriteOutX;
     OutReg_data = WordX; 
     delOutReg_data=WordX;
 end 
end
end //always @(MEMEN_dft

always @(TBYPASSsys or ATPint)
begin
   if(supply_ok === 1'b1) begin 
    if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0 && INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1) begin
      if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
    end  
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint === X && SEsys !== 1) ) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end 
end //always @(TBYPASSint





always @(SEsys)
begin
 if(supply_ok === 1'b1) begin 
  if(CKint_dft === 0 && ATPint === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
    if(SE_reg === 1'b1 && SEsys === 1'b0) begin
      if(TBYPASSsys === 1'b1) begin
  
     
         
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8], scanreg_dl_wire[scanlen_l-1]};
           
      


        for (i = 0; i < Bits; i = i + 1)
        begin
         if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
        end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
      end
    end
  end
  if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0) begin
      if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
  end 
  else if ((TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint === X && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end   
end

//assign output data
`ifdef functional        

   
always @(SDLOint)
#0.001 delSDLO_data<=SDLOint;

always @(SDROint)
#0.001 delSDRO_data<=SDROint;

 
always @(SCTRLOint)
#0.001 delSCTRLO_data<=SCTRLOint;


always @(OutReg_data)
   #0.001 delOutReg_data = OutReg_data;
`else
`endif

/***************************** Embeded switch functionality starts here ***********************************/





always @(STDBYint)
begin
  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0 && STDBYint !== 1'b0)
    begin
      ScanOutX;
      ScanChainX;
     delScanOutX;     
    end
  end
end



always @(SLEEPint)
begin


  if (SLEEPint !== 1'b1) begin
    time_fall_sleep = $realtime;
  end

  if (power_up_done === 0)
    begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
    end
  else begin
    if (SLEEPint === 1'b1 && lastSLEEP === 1'b0 ) begin 
      
    end
    else if (SLEEPint !== 1'b1 && lastSLEEP === 1'b1 && full_shutdown !== 1) begin 
      
      if (supply_ok !== 1 && ($realtime > 0)) begin
         if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID LOW_POWER) ERROR: ISOLATION signal removed from the memory but array and periphery supply is not completely switched on.Very High Current would be drawn by the memory. All further operations on memory are blocked",$realtime);
          WriteMemX;
          WriteOutX;
          ScanChainX;
          OutReg_data = WordX; 
          delOutReg_data=WordX;
          ScanOutX;//immediately;
          delScanOutX;//immediately;
          init_pulse_done = 0;
          power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            debug_level = 2'b11;
          `endif
          
      end        
      
       
    end   
    else if (SLEEPint === X && lastSLEEP === 1'b0 && full_shutdown !== 1'b1) begin 
     
    end 
  end  


  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && SLEEPint !== 0)
    begin
      ScanOutX;
      ScanChainX;
        delScanOutX;      
    end
  end

// if (init_pulse_done === 0)
//   begin
//     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
//   end
//
// else if ( SLEEPint !== 1 && (supply_ok !==1) ) begin
//    
//    WriteOutX;
//    OutReg_data = WordX; 
//    delOutReg_data=WordX;
//    ScanOutX;//immediately;
//    delScanOutX;//immediately;
//    ScanChainX;
//    WriteMemX;
//    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies with sleep/Power down signal being low.This scenario can lead to high dc currents and some reliability issues Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
// end

 print_sleep;    
 lastSLEEP=SLEEPint;
end

/********************************** Embeded switch functionality ends here *******************************/

task print_sleep;
begin
  if (SLEEPint === 1'b0) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been deasserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end  
  else if (SLEEPint === 1'b1) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been asserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_ACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif

  end        
  else begin
      if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) ERROR: SLEEP pin is at an invalid state.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INVALID in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end        
end
endtask





 

//// C28SOI non flip compiler power functionality 
always @(gndmreg )
begin
 if (power_up_done === 1 && $realtime > 0) begin    
    if(gndmreg !== 1'b0 ) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or gndsm is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
        corrupt_all;
        init_pulse_done = 0;
        power_up_done = 0;
     `ifdef NO_BLOCK_MEM
     `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of ground pins.Ground must be maintained at 0 Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime);
        debug_level = 2'b11;
     `endif   

    end   
 end

end




always @(vddmareg )
begin

if (vddmareg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddma(Array Supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 
    end
   end   
   else if (SLEEPint === 1) begin
    WriteMemX;
   end

end

if ((vddmareg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1 ) && $realtime > 0) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddm or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         corrupt_all;
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif

end


end

always @(vddmpreg )
begin
 if (vddmpreg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or vddsmp is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmp(Periphery Supply)/vddsmp(Substrate power supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 

    end
   end   
   else if (SLEEPint === 1) begin
    WriteOutX;
    ScanChainX;
    ScanOutX;
    delScanOutX;//immediately;
    OutReg_data = WordX; 
    delOutReg_data=WordX;
   end
 end

if( (vddmpreg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1'b1 )  && $realtime > 0) begin
         corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif
end
 
 
end


always @(vddmoreg)
begin
  if (power_up_done === 1 && $realtime > 0) begin   
      if (vddmoreg !== 1'b1)  begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin
           corrupt_all;
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
         end //if (vddmareg === 1'b1 

      else if (vddmareg === 1'b0 && vddmpreg === 1'b0   && SLEEPint === 1'b1 &&  $realtime > 0)
        begin 
            if((debug_level < 2) && ($realtime > 0)) $display("%m - %t WARNING: Illegal Value on power pin(s). Memory and Output Corrupted ", $realtime);
 
           corrupt_all;
        end //else if (vddmareg === 1'b 
     end   // if (vddmoreg !== 1'b1)
     else if (vddmoreg === 1'b1 && $realtime > 0 ) begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin     
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           corrupt_all;
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
        end        
     end // else if (vddmoreg === 1'b1
  end 
end // always @(vddmoreg)












always @(gndmreg) begin
 if (gndmreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 0. ",$realtime);
 end
 else if (gndmreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 1. ",$realtime);
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to invalid state. ",$realtime);
 end
end




 
always @(vddmareg) begin
 if (vddmareg === 0) begin 
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 0. ",$realtime);
  vddma_fall_time = $realtime;
 end
 else if (vddmareg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 1. ",$realtime);
  vddma_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to invalid state. ",$realtime);
  vddma_fall_time = $realtime;
 end 

 

end

always @(vddmpreg) begin
 if (vddmpreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 0. ",$realtime);
  vddmp_fall_time = $realtime;
 end
 else if (vddmpreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 1. ",$realtime);
  vddmp_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to invalid state. ",$realtime);
  vddmp_fall_time = $realtime;
 end

 
 
end



// end of C28SOI power functionality 
 


assign supply_ok          =  (vddmareg === 1'b1 && vddmpreg  === 1'b1  && gndmreg === 1'b0 && vddmoreg === 1'b1 ) ? 1'b1 : 1'b0;
assign core_supply_ok     =  (vddmoreg === 1'b1 && vddmareg === 1'b1 && gndmreg === 1'b0 ) ? 1'b1 : 1'b0;
assign peri_supply_ok     =  (vddmoreg === 1'b1 && vddmpreg === 1'b1 && gndmreg === 1'b0  ) ? 1'b1 : 1'b0;

assign full_shutdown = (vddmpreg === 1'b0 && vddmareg === 1'b0   ) ? 1'b1 : 1'b0 ;




`ifdef functional
`else


task WriteLocMskX_bwise;
   input [Addr-1 : 0] Address;
   input [Bits-1 : 0] Mask;

reg [Bits+Red_extrabit:0] tempReg1;
integer num1; 
begin
   tempReg1 = WordX;
   if (^Address !== X )
   begin
      tempReg1 = Mem[Address];
             
      for (j = 0;j< Bits; j=j+1) begin
         num1=j;
        if (Mask[j] === 1'bx)
            tempReg1[num1] = 1'bx;
      end
      Mem[Address] = tempReg1;
      task_insert_faults_in_memory;
   end//if (^Address !== X
   else begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      WriteMemX;
   end   
end
endtask


/****************Actions taken on timing violations*****************/

 always @(TimingViol_data)
// tds or tdh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  for (l = 0; l < Bits; l = l + 1) begin   
    if (CSWEMTBYPASS[l] !== 0) begin
     if((TimingViol_data[l] !== TimingViol_data_last[l])) begin


         Mreg[l] = 1'bx;
     end    
     WriteLocMskX_bwise(Areg,Mreg);
    end   
   end 
  end
    if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin
     scanreg_dl =1'bx; 
     scanreg_dr =1'bx; 
     SDLOint=X;
     SDROint=X;
     `ifdef functional
     `else
     SDLO_data<=1'bx;
     SDRO_data<=1'bx;
     `endif
    end
     TimingViol_data_last = TimingViol_data; 
end





always @(TimingViol_addr)
// tas or tah
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
      scanreg_ctrl=1'bx; 
      SCTRLOint=X;
      `ifdef functional
      `else
      SCTRLO_data<=1'bx;
      `endif
  end
end


always @(TimingViol_WEN)
//tws or twh
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WEN pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end 

always @(TimingViol_CSN )
// tps or tph 
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;

   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CSN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end

always @(TimingViol_tcycle )
//tcycle
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
   if (MEMEN !== 0 && MEMEN_prev !== 0) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckl )
// tckl 
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckh) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end


always @(TimingViol_tcycle_se )
//tcycle_se
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckl_se  )
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckh_se) begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tbist) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
   end
   if (TBYPASSint !== 1'b0) begin 
    WriteOutX;
   end 
   if (INITNreg !==0 && STDBYreg !== 1 && TBYPASS_reg !== 1 && SLEEPreg !== 1 && SE_reg !== 1 && IGreg !== 1 && DEreg !== 1) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBIST pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end






always @(TimingViol_tbypass)
//ttmck
begin
#0  
  WriteOutX;
  if (INITNreg !== 0 && SLEEPreg !== 1 && SE_reg !== 1 && STDBYreg !== 1 &&  DEreg !== 1) begin
   Invalid_next_cycle_dft_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
end



always @(TimingViol_sleep)
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_stdby)
begin
#0
  if (CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin 
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (ATPreg !== 0) begin 
   Invalid_next_cycle_dft_tim;
  end
end






always @(TimingViol_se) begin
#0
   if (TBYPASS_reg !== 0) begin 
    WriteOutX;
   end 
  if (TBYPASS_reg === 0) begin
     WriteOutX;
     WriteMemX;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE timing violation  Memory State Machine is corrupted. Output Corrupted ",$realtime); 
  end 
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
  end
end

always @(TimingViol_sctrli) begin
  scanreg_ctrl=1'bx; 
end


always @(TimingViol_sdli) begin
 scanreg_dl=1'bx; 
end

always @(TimingViol_sdri) begin
   scanreg_dr=1'bx;
end

 

always @(TimingViol_initnl) begin
init_pulse_done=0;
WriteOutX;
OutReg_data = WordX; 
delOutReg_data=WordX;
ScanOutX;
delScanOutX;
ScanChainX;
WriteMemX;
end

always @(TimingViol_initn) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end

always @(TimingViol_ig) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && INITNreg !== 0 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: IG pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   ScanChainX;
   ScanOutX;
   delScanOutX;       
  end
end

always @(TimingViol_atp) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin  
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_rm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^WMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: RM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
   end
end
 
always @(TimingViol_wm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^RMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);        
   end
end 


`endif


endmodule




module ST_SPREG_LOLEAK_512x20m8_Tl_lock_up_latch (EN,D,Q);
input EN,D;
output reg Q;

  always @ (EN or D) begin
    if (EN === 1) begin
       Q = D;
    end
    else if ((EN === 1'bz || EN === 1'bx  )&& D !== Q) begin
        Q=1'bx;
    end    
  end
endmodule

module ST_SPREG_LOLEAK_512x20m8_Tl_SCFF (D,TI,TE,CP,Q,OUTX);
input D,TI,TE,CP;
input OUTX;
output reg Q;
wire Dint;
assign Dint= (TE===1)?TI:(TE===0)?D:1'bx;

always @(posedge CP)
        begin
          if(Dint === 1'bZ || CP ===1'bx || OUTX === 1'bx)
          begin
                  Q = 1'bx;
          end
          else
          begin
                  Q = Dint;
          end        
        end
always @(posedge OUTX)
Q = 1'bx;
endmodule



`undef setup_time
`undef hold_time
`undef access_time
`undef retain_time
`undef cycle_time
`undef pulse_width_time
`undef initin_low_pulse


`delay_mode_path
`endcelldefine
`nosuppress_faults






/****************************************************************
--  Description         : Verilog Model 
--  ModelVersion        : 1.2
--  Date                : Apr, 2013
--  Changes Made by	: PS
--  Revision History    : 
 
****************************************************************/


/******************** START OF HEADER****************************
   This Header Gives Information about the parameters & options present in the Model
   
   words = 1024
   bits  = 19
   mux   = 2 
   
   
   
   write_mask = no 
   
   margin_control = yes 
   
   
   Dft = Yes  

    ------------------------------------------------------------------------------------
     Signal Name             | Description       |             Port Mode        | Active When
                             |                   |          r    |  w   | rw    |
   ------------------------------------------------------------------------------------

    D 	        Data in                     na     x      na       -  
    IG    Input Gate Enable           x      x      na       High     
    ATP            ATPG Enable                 x      x      na       High     
    INITN                 INITN pin                   x      x      na       Low
    
    
     
    Q 	        Data out	            x      na     na       -
    A              Address                     x      x      na       high and low
    
    CK                Clock	                    x      x      na       posedge
    CSN          Chip Enable                 x      x      na       low
    
    RM         Read Margins                 x      x      na       High 
    SCTRLI         Scan Input (Control)
    SCTRLO        Scan Output (Control)
    SDLI         Scan Input (Data-Left)
    SDLO        Scan Output (Data-Left)
    SDRI         Scan Input (Data-Right)
    SDRO        Scan Output (Data-Right)
    SE          Scan Enable pin 
    STDBY              Standby pin                 x      x      na       High
    
    SLEEP                        Sleep pin                   x      x      na        High 
    
     
     
    TBIST          Bist Enable Pin 
    
    TBYPASS                      Memory Bypass                na     na     na        High
    
    TED        Bist Even Data pin
    TOD         Bist Odd Data Pin
     
    TA         Bist Read Address
    TCSN     Bist Read Chip Select
    
    TWEN    Bist Write Enable 
    WEN         Write Enable                na     x      na       Low 
    
    WM        Write Margins Code          x      x      na       -
     

******************** END OF HEADER ****************************/


//********************************************//
// ST_SPREG_LOLEAK_1024x19m2_Tl Verilog Model                 //  
//********************************************//




`ifdef slm
        `define functional
`endif

`celldefine
`suppress_faults
  `ifdef functional
   `delay_mode_unit
  `else
   `delay_mode_path
  `endif

`define setup_time 0.0
`define hold_time 0.0
`define access_time 1.0
`define retain_time 0.9
`define cycle_time 0.0
`define pulse_width_time 0.0
`define initin_low_pulse 0.0



 






`timescale 1ns / 1ps


module ST_SPREG_LOLEAK_1024x19m2_Tl (A,ATP,CK,CSN,D ,IG,INITN , Q ,RM    ,SCTRLI,SCTRLO,SDLI,SDLO,SDRI,SDRO,SE,SLEEP   , STDBY  ,TA,TBIST   ,TBYPASS ,TCSN,TED ,TOD   ,TWEN ,WEN,WM  );

 parameter
  Words = 1024,
  Bits = 19,
  Addr = 10,
  mux = 2,
  repair_address_width = 9,
  write_margin_size = 2, 
  read_margin_size = 3; 

 //  INPUT OUTPUT PORTS DECLARATION DONE SEPARATELY FOR SPREG and ROM
 // ========================


        output [Bits-1 : 0] Q;
         
        output SCTRLO;
        input SE,SCTRLI;
        
        input [Addr-1 : 0] A;
        
        input [read_margin_size-1 : 0] RM;
        
         
        input CK,CSN,INITN,IG,ATP; 
        
        
        input [Addr-1 :0 ] TA;
input TBIST,TCSN ;
        
        input STDBY;
        
        input SLEEP; 
        
         
        
        
         
        output SDLO;
        output SDRO;
        
        
        
        
        input [Bits-1 : 0] D ;
	
          
         
        
        input [write_margin_size-1 : 0] WM;
        
        
        input TBYPASS;
        
        input WEN;
        
        
         
        input SDLI,SDRI  ; 
        
        
        
        //Bist inputs
        // ===========
        input TWEN,TED,TOD; 
        
        
        
        

        






    parameter
        Fault_file_name = "ST_SPREG_LOLEAK_1024x19m2_Tl_faults.txt",
        `ifdef ConfigFault
        ConfigFault = 1,
        `else
        ConfigFault = 0,
        `endif
        max_faults = 1026,
        
        MEM_INITIALIZE  = 1'b0,
        BinaryInit = 1'b0, 
        InitFileName = "ST_SPREG_LOLEAK_1024x19m2_Tl.cde",
        Debug_mode = "all_warning_mode",
        File_load_time=0,
        Initn_reset_value={19{1'b0}},
        InstancePath = "ST_SPREG_LOLEAK_1024x19m2_Tl";
    
    parameter
        
        bank = 1, 
        mux_bits=1,
        Red_extrabit=0,
        bank_bits = 0,
        RedWords = mux * 2 * bank,
        max_address_bits = 15 ,
        Rows = Words/mux;

  
    parameter 

     

        
           scanchains=3,    
          
        
        scanlen_ctrl=15,
        
        

      

        
        
        scanlen_r=(2*((Bits+1)/4)),
        
        scanlen_l=((Bits+1)-(2*((Bits+1)/4)))   ; 
      
      

    parameter
        
        `ifdef functional  
            RW_assertions_en = 0,
        `endif
        WordX = {Bits{1'bx}},
        AddrX = {Addr{1'bx}},
        Word0 = {Bits{1'b0}},
        X = 1'bx;
   



//  WIRE DECLARATION RELATED TO POWER PINS
//  ======================================
	
        wire supply_ok, full_shutdown;
        
        wire core_supply_ok;
        wire peri_supply_ok;

        wire gndmint, gndsmint;
         
        
        wire vddmpint;
        wire vddmoint;
        wire vddmaint;
        wire vddsmpint;  
        wire vddsmaint;  
        
        

//  WIRE DECLARATION 
//  ==================
        wire [Bits-1 : 0] CSWEMTBYPASS;
        wire [Bits-1 : 0] Dint, Dsys;
        wire [Bits-1 : 0] Mint; 
        wire [19-1:0] Msys;
	wire [Addr-1 : 0] Aint;
        wire [Addr-1 : 0] Asys;

       


        wire [max_address_bits-1 : 0] A_int; 
                
	wire CKint_dft;
	wire CKint_func;
	wire CSNint;
        wire MEMEN;
        wire MEMEN_dft;
        wire TSE;

	wire WENint;
	wire WENsys;
        wire SLEEPint;
        wire STDBYint;
        wire SEint;
        wire SEsys;
        wire SCTRLIint;
        wire SDLIint;
        wire SDRIint;
        
        wire INITNint;
        wire TBYPASSint;
        wire TBYPASSsys;
        wire LSint; 
        wire HSint; 
        wire ATPint;
        wire DEint;
        
        wire [Addr-1 : 0] TAint;
        wire TBISTint;
        wire TBISTsys;
        wire TCSNint;
        wire TEDint;
        wire TODint;
        wire TEMint;
        wire TOMint;
        wire [Bits-1 : 0] TMint;
        wire [Bits-1 : 0] TDint;
        wire TWENint;
        wire IGint;
        wire IGbuf;
        wire CSNbuf;
        wire WENbuf;
        wire [read_margin_size-1:0] RMint;
        wire [write_margin_size-1:0] WMint;

        //Wires for scan chains
        //  ====================     
        wire [scanlen_ctrl -1:0]scanreg_ctrl_wire;
        wire [scanlen_l -1:0]  scanreg_dl_wire; 
        wire [scanlen_r -1:0]  scanreg_dr_wire; 
   
        wire [scanlen_l -1:0]  scanreg_ml_wire; 
        wire [scanlen_r -1:0]  scanreg_mr_wire; 


        wire [repair_address_width -1 : 0] RRAint;
        wire RRAEint;
        wire TRRAEint;    
        wire red_en;
        wire [repair_address_width -1 : 0] repair_add, next_repair_add;


//  REG DECLARATION
//  ====================     
        reg MEMEN_reg;
        reg MEMEN_prev;
        reg reg_mem_block;
        reg flag_mem_block;
        reg SCTRLIint_temp;
        reg SDLIint_temp;
        reg SDRIint_temp;
        reg SMLIint_temp;
        reg SMRIint_temp;

        //  REG DECLARATION
        //  ====================
        reg SCTRLOint;
        
        reg SDLOint,SDROint;
         
        
        reg next_cycle_corrupt_func;
        reg next_cycle_corrupt_dft;
        reg [Bits-1 : 0] delOutReg_data;//delayed Output Register
        reg [Bits-1 : 0] OutReg_data;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_tbypass;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_scan;   // Data Output registe
        reg [Bits-1 : 0] OutReg_rado_retained;   // register for retaining rado data when SLEEP --> 1
        reg delSCTRLO_data,SCTRLO_data;      // delayed Output Register
        reg delSDLO_data,SDLO_data;      // delayed Output Register
        reg delSDRO_data,SDRO_data;      // delayed Output Register
        
        
        // SCAN CHAINS register
        reg scanreg_ctrl; 
        reg scanreg_dl; 
        reg scanreg_dr; 
        
        
        reg CK_sc;
        reg Latch_open=0;
        reg lastCK_dft,CKreg_dft;
        reg lastCK_func,CKreg_func;
        reg lastSLEEP;
        reg lastPSWLARGEMP,lastPSWLARGEMA,lastPSWSMALLMP,lastPSWSMALLMA;
        reg CSNreg;
        reg init_pulse_done; //if == 1 then it implies that initb low pulse has been applied
        reg power_up_done; //if == 1 then it implies that power up has been done
        `ifdef slm
        `else
	      
             reg [Bits-1 : 0] Mem [Words-1 : 0];
             reg [Bits-1 : 0] RedMem [RedWords-1 : 0];
 
        `endif
        
	reg [Bits-1 :0] Mem_temp;
        reg [Bits-1 :0] Mem_slm; 
	reg ValidAddress;
	reg ValidDebugCode;
        reg decoding_start;
        reg file_loaded;
        reg [Bits-1 :0] Dreg;
        reg [Bits-1 :0] Mreg;
        reg WENreg;
        reg [Addr-1 :0] Areg;
        reg SE_reg;
        reg TBYPASS_reg;
        reg INITNreg;
        reg IGreg;
        reg DEreg;
        reg SLEEPreg;
        reg STDBYreg;
        reg ATPreg;
        reg MEMEN_dft_reg;
        reg MEMEN_dft_prev;
        reg RRMATCHreg;
        reg RRMATCHreg_last;//changes_made
        reg RRMATCHreg_glitch;
        reg [repair_address_width -1 : 0] repair_add_last;
        reg RRAEint_last;
        reg [Addr-mux_bits-1:0] row_add_temp;
        reg [Addr-mux_bits-bank_bits-1:0] row_add_cmp_temp;

       
        //parameter registers
        reg [2047:0] reg_Fault_file_name;
        reg reg_ConfigFault;
        reg reg_MEM_INITIALIZE;
        reg reg_BinaryInit;
        reg [2047:0] reg_InitFileName;
        reg [Bits -1 :0] reg_Initn_reset_value;
        time reg_File_load_time;

        //Power Supply Registers        
        reg vddmireg;
        reg vddmreg;
        reg vddsmreg;
        reg gndmreg;
        reg gndsmreg;   
        reg vddmpreg;
        reg vddmpireg;
        reg vddmareg;
        reg vddsmpreg;
        reg vddsmareg;
        reg vddmoreg;
        time vddmp_rise_time;
        time vddmp_fall_time;
        time vddsmp_rise_time;
        time vddsmp_fall_time;
        time vddma_rise_time;
        time vddma_fall_time;
        time vddsma_rise_time;
        time vddsma_fall_time;
        reg reg_check_rise;
        reg reg_check_fall;
        reg reg_check_rise_vddma;
        reg reg_check_fall_vddsma;
        reg  reg_check_rise_vddm, reg_check_fall_vddsm ;
        time vddm_fall_time,  vddm_rise_time,  vddsm_fall_time, vddsm_rise_time ;
  /* This register is used to force all warning messages 
  ** OFF during run time.
  ** It is a 2 bit register.
  ** USAGE :
  ** debug_level_off = 2'b00 -> ALL MESSAGES(INFO/WARNINGS/ERRORS) will be DISPLAYED 
  ** debug_level = 2'b01     -> ONLY WARNINGS/ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b10     -> ONLY ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b11     -> NO MESSAGES will be DISPLAYED.
  */ 
        reg [1:0] debug_level;
        reg [8*10: 0] operating_mode;
        reg [8*44: 0] message_status;

        integer i, k, j, l,m,q,w,r,s,num1,redcnt,n,num2,FirstHalf,Bfaileff,memcnt,ptr;
        integer decoder[Bits-1:0];
        `ifdef slm
           integer MemAddr;
        `endif


        //************************************************************
        //****** CONFIG FAULT IMPLEMENTATION VARIABLES*************** 
        //************************************************************ 

        integer file_ptr, ret_val;
        integer fault_word;
        integer fault_bit;
        integer fcnt, Fault_in_memory,faultnum,stop_loop,count;
        integer t;  
        integer FailureLocn [max_faults -1 :0];
        integer Failurebit [max_faults -1 :0];
        reg [100 : 0] stuck_at;
        reg [100 : 0] fault_array;
        reg [200 : 0] tempStr;
        reg [7:0] fault_char;
        reg [7:0] fault_char1; // 8 Bit File Pointer
        reg [Addr -1 : 0] std_fault_word;
        reg [Addr -1 : mux_bits] fault_row_add [max_faults -1 :0];
        reg [max_faults -1 :0] fault_repair_flag;
        reg [max_faults -1 :0] dont_insert_fault;
        reg [max_faults -1 :0] repair_flag;
        reg [100 : 0] array_stuck_at[max_faults -1 : 0] ;
        reg [100 : 0] mem_red_array_stuck_at[max_faults -1 : 0] ; 
        reg msgcnt;
        
       
        reg [Bits - 1: 0] stuck_at_0fault [max_faults -1 : 0];
        reg [Bits - 1: 0] stuck_at_1fault [max_faults -1 : 0];
        reg [Bits -1 : 0] stuck0;
        reg [Bits -1 : 0] stuck1;

        reg [Bits+Red_extrabit :0] Mem_last;
        

        `ifdef slm
        reg [Bits -1 : 0] slm_temp_data;
        `endif
        
        real time_CK_func_rise , time_RADCK_rise;
        real time_fall_sleep,time_fall_PSWLARGEMP,time_fall_PSWLARGEMP_0,time_fall_PSWLARGEMA,time_fall_PSWLARGEMA_0,time_fall_PSWSMALLMP,time_fall_PSWSMALLMA;
        integer flag_error;
        
//BUFFER INSTANTIATION
//=========================
       `ifdef functional
       
         buf (SCTRLO,delSCTRLO_data); 
         buf bufq [Bits-1:0] (Q,delOutReg_data);
      `else
       
         buf (SCTRLO,SCTRLO_data);
         buf bufq [Bits-1:0] (Q,OutReg_data);
      `endif
      
  
        buf (SEsys,SE);
	buf (SCTRLIint, SCTRLI);
   

	buf (CKint_func, CK);
	buf (CKint_dft, CK);
        buf bufaddr [Addr-1:0] (Asys,A);
        buf (INITNint,INITN);
        
        buf (LSint,1'b0); 
        buf (IGbuf,IG);
        buf (ATPint,ATP);

        buf bufTaddr [Addr-1 : 0] (TAint,TA);
        buf (TBISTsys,TBIST);
        buf (TCSNint,TCSN);

        buf (CSNsys,CSN);
        buf (STDBYint,STDBY );   
        
        buf (SLEEPint,SLEEP ); 

        buf bufrm [read_margin_size-1:0] (RMint, RM); 

        
        

        assign RRAEint = 1'b0;
        assign TRRAEint = 1'b0;
        assign repair_add = 0;
        assign next_repair_add = 0;
        assign red_en = 1'b0; 
        
        
        
        
        
        
        
        buf (PSWLARGEMPint,1'b0);
        buf (PSWSMALLMPint,1'b0); 
        buf (PSWLARGEMAint,1'b0);
        buf (PSWSMALLMAint,1'b0);   

      `ifdef functional
       
       
         buf (SDLO,delSDLO_data);
         buf (SDRO,delSDRO_data);
        
      `else
       
         buf (SDLO,SDLO_data);
         buf (SDRO,SDRO_data);
         
      `endif
       
         
       
        buf bufdata [Bits-1:0] (Dsys,D);
        
        
        assign Msys=19'b0; 
	

        
        buf (TBYPASSsys, TBYPASS);
        


        buf (WENsys,WEN);
	 
	buf (SDLIint, SDLI);
	buf (SDRIint, SDRI);
	 
        
        buf (HSint,1'b0); 

        
        buf (TEDint,TED);
        buf (TODint,TOD);
         
        buf (TWENint,TWEN);
        
        
        buf bufwm [write_margin_size-1:0] (WMint, WM); 
        



//      assign scanreg_ctrl_wire={scanreg_ctrl[scanlen_ctrl - 2:0],SCTRLIint};
//      assign scanreg_dl_wire={scanreg_dl[scanlen_l - 2:0],SDLIint};
//      assign scanreg_dr_wire={scanreg_dr[scanlen_r - 2:0],SDRIint};
      
        
      assign Aint   = (TBISTint === 1'b0 ) ? Asys : (TBISTint === 1'bx ) ? {Addr{1'bx}} : TAint;  

        
//        assign A_int = Aint;
	
        
                
        assign Dint[0] = (TBISTint === 1'b0) ? Dsys[0] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[1] = (TBISTint === 1'b0) ? Dsys[1] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[2] = (TBISTint === 1'b0) ? Dsys[2] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[3] = (TBISTint === 1'b0) ? Dsys[3] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[4] = (TBISTint === 1'b0) ? Dsys[4] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[5] = (TBISTint === 1'b0) ? Dsys[5] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[6] = (TBISTint === 1'b0) ? Dsys[6] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[7] = (TBISTint === 1'b0) ? Dsys[7] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[8] = (TBISTint === 1'b0) ? Dsys[8] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[9] = (TBISTint === 1'b0) ? Dsys[9] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[10] = (TBISTint === 1'b0) ? Dsys[10] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[11] = (TBISTint === 1'b0) ? Dsys[11] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[12] = (TBISTint === 1'b0) ? Dsys[12] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[13] = (TBISTint === 1'b0) ? Dsys[13] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[14] = (TBISTint === 1'b0) ? Dsys[14] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[15] = (TBISTint === 1'b0) ? Dsys[15] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[16] = (TBISTint === 1'b0) ? Dsys[16] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[17] = (TBISTint === 1'b0) ? Dsys[17] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[18] = (TBISTint === 1'b0) ? Dsys[18] : (TBISTint === 1'b1) ? TEDint : 1'bx;          
	 
        assign Mint = 19'b0;
         

        assign WENbuf = (TBISTint === 1'b0 ) ? WENsys : (TBISTint === 1'bx ) ? 1'bx : TWENint;  
        assign WENint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? WENbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[13] : (ATPint === 1'b0 ) ? WENsys : 1'bx ; 
        
        assign CSNbuf = (TBISTint === 1'b0 ) ? CSNsys : (TBISTint === 1'bx ) ? 1'bx : TCSNint;  
        assign CSNint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? CSNbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[11] : (ATPint === 1'b0 ) ? CSNsys : 1'bx ; 
        assign IGint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? IGbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[14] : (ATPint === 1'b0 ) ? IGbuf : 1'bx;

        
        assign DEint = (LSint === 1'bx || (LSint === 1'b0 && HSint === 1'bx) || ^RMint !== 1'b0 || ^WMint !== 1'b0 ) ? 1'bx : 1'b0;
        
     
     and (TBISTint, ATPint, TBISTsys);
     and (SEint, ATPint, SEsys);
     and (TBYPASSint, ATPint, TBYPASSsys);
     and (TSE,TBYPASSint,!SEsys);
     and (MEMEN,INITNint,!CSNint,!SLEEPint,!TBYPASSint,!SEint,!IGint,!DEint,!STDBYint );
     and (MEMEN_dft,INITNint, !SLEEPint, ATPint,!STDBYint);

 `ifdef functional
/*****************assertions added to optimize dynamic power consumption**********/

//psl a_M: assert always ({( RW_assertions_en);(MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1))  } |-> (stable(Msys))) @(posedge CK); 

//psl a_WEN: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(WENsys))) @(posedge CK); 

//psl a_A: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(Asys))) @(posedge CK); 

//psl a_D: assert always ({( RW_assertions_en);((MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1)) && TBYPASSint === 1'b0)  } |-> (stable(Dsys))) @(posedge CK); 

/**********************************************************************************************/
`endif       

     

         
reg vddmp,vddmo, vddma, vddsmp, vddsma, gndsm, gndm,  vddmpi ; 
 
initial 
begin

        vddmp = 1'b1 ; 
        vddmo = 1'b1 ;
        vddma = 1'b1 ;
        
        vddsmp = 1'b1 ;
        
        
         gndm = 1'b0 ;
          
end

        
         assign gndmint = (reg_mem_block === 0) ? gndm : 1'b1;
         
         
         
         
         assign vddmpint = vddmp;
         assign vddmoint = vddmo;
         assign vddmaint = vddma;
         
          
        
         

        //CPF Changes

        
                
        initial
        begin : cpfvddmp 
           vddmpreg = vddmpint;
        end

        always @(vddmpint) begin
           vddmpreg = vddmpint;
        end
        
        initial
        begin : cpfvddmo 
           vddmoreg = vddmoint;
        end

        always @(vddmoint) begin
           vddmoreg = vddmoint;
        end
        
        initial
        begin : cpfvddma 
           vddmareg = vddmaint;
        end

        always @(vddmaint) begin
           vddmareg = vddmaint;
        end

        
        
 
        initial
        begin : cpfgndm 
           gndmreg = gndmint;
        end

        always @(gndmint) begin
           gndmreg = gndmint;
        end

        
        



 `ifdef functional
  `else
  initial begin
    if (debug_level < 1) begin
     $display ("%m  INFORMATION");
     $display ("***************************************");
     $display ("The Model is Operating in TIMING MODE");
     $display ("Please make sure that SDF is properly annotated otherwise dummy values will be used");
     $display ("%s", message_status);
     $display ("***************************************");
    end
  end

//////////////////////////
 //REG DECLARATIONS
   //======================

   reg [Bits-1 : 0] TimingViol_data;
   reg  [Bits-1 : 0] TimingViol_mask;
   reg [Bits-1 : 0] TimingViol_data_last, TimingViol_mask_last;
	reg TimingViol_data_0;
	reg TimingViol_data_1;
	reg TimingViol_data_2;
	reg TimingViol_data_3;
	reg TimingViol_data_4;
	reg TimingViol_data_5;
	reg TimingViol_data_6;
	reg TimingViol_data_7;
	reg TimingViol_data_8;
	reg TimingViol_data_9;
	reg TimingViol_data_10;
	reg TimingViol_data_11;
	reg TimingViol_data_12;
	reg TimingViol_data_13;
	reg TimingViol_data_14;
	reg TimingViol_data_15;
	reg TimingViol_data_16;
	reg TimingViol_data_17;
	reg TimingViol_data_18;
 reg TimingViol_mask_0;
 reg TimingViol_mask_1;
 reg TimingViol_mask_2;
 reg TimingViol_mask_3;
 reg TimingViol_mask_4;
 reg TimingViol_mask_5;
 reg TimingViol_mask_6;
 reg TimingViol_mask_7;
 reg TimingViol_mask_8;
 reg TimingViol_mask_9;
 reg TimingViol_mask_10;
 reg TimingViol_mask_11;
 reg TimingViol_mask_12;
 reg TimingViol_mask_13;
 reg TimingViol_mask_14;
 reg TimingViol_mask_15;
 reg TimingViol_mask_16;
 reg TimingViol_mask_17;
 reg TimingViol_mask_18;

   reg TimingViol_addr;
   reg TimingViol_CSN, TimingViol_WEN, TimingViol_tbypass;
   reg TimingViol_tckh, TimingViol_tckl, TimingViol_tcycle;
   reg TimingViol_tckh_se, TimingViol_tckl_se, TimingViol_tcycle_se;
   reg TimingViol_sctrli,TimingViol_sdli,TimingViol_sdri,TimingViol_se;
   reg TimingViol_smli,TimingViol_smri;
   reg TimingViol_sctrli_flag,TimingViol_sdli_flag,TimingViol_sdri_flag;
   reg TimingViol_smli_flag,TimingViol_smri_flag;
   reg TimingViol_initnl;
   reg TimingViol_initn;
   reg TimingViol_ls;
   reg TimingViol_hs;
   reg TimingViol_sleep;
   reg TimingViol_stdby;
   reg TimingViol_rm;
   reg TimingViol_wm;
   reg TimingViol_tbist,TimingViol_ig,TimingViol_atp,TimingViol_TED,TimingViol_TOD,TimingViol_TEM,TimingViol_TOM;
   reg TimingViolRRAE,TimingViolRRA;

   wire CSTBYPASSN,cond_sdf_tas,cond_sdf_tds,cond_sdf_tms,cond_sdf_tws,cond_sdf_tbas,cond_sdf_tbps,cond_sdf_tbws,cond_sdf_tbdes,cond_sdf_tbdos,cond_sdf_tbmes,cond_sdf_tbmos;
   wire SETB_EN,CSIG_EN,MEM_ACT,EN_ADM,CS_EN,CS_ADM,cond_sdf_tps,IG_EN,IG_ADM,cond_sdf_tigs,cond_sdf_taa,cond_sdf_taa_ls1,cond_sdf_taa_hs1,cond_tseq_tm;
   wire cond_sdf_tcycle,cond_sdf_tcycle_ls1,cond_sdf_tcycle_hs1,cond_sdf_tcycle_se,cond_sdf_tckl_se,cond_sdf_tsctrlis,cond_sdf_tsdlis,cond_sdf_tsdris,cond_sdf_tsmlis,cond_sdf_tsmris;
   wire cond_sdf_tckh_se,cond_sdf_taa_sctrlo_se,cond_sdf_taa_sdlo_se,cond_sdf_taa_sdro_se,cond_sdf_taa_smlo_se,cond_sdf_taa_smro_se,cond_sdf_tckl,cond_sdf_tckh;
   wire cond_sdf_ttms,cond_sdf_tbists,INITNandnotSLEEPandATPandnotSE,cond_sdf_taa_sctrlo,cond_sdf_taa_sdlo,cond_sdf_taa_sdro,cond_sdf_taa_smlo,cond_sdf_taa_smro;
   wire cond_sdf_taa_tm,cond_sdf_taa_tm_ls1, cond_sdf_taa_tm_hs1,cond_sdf_taa_tckq_tm,cond_sdf_taa_tseq_tm;

   wire CSWETBYPASSN;
   wire cond_sdf_tstdbys,cond_sdf_tsls,sleep_en,atp_csn_en;
   wire cond_sdf_tlss,cond_sdf_thss,cond_sdf_trms,cond_sdf_twms; 
   wire cond_sdf_tses,cond_sdf_tinitns;
   wire tby_se_en;
   wire rra_en;
   wire tbist_atp_en;
   wire rrae_en;
   wire tbist_rrae_en;
   wire cond_sdf_trraes;
   wire cond_sdf_ttrraes;
   wire cond_sdf_taa_trramatch;
   wire cond_sdf_ttrraematch;
   wire cond_sdf_tamatch;
   wire cond_sdf_ttamatch;
   wire cond_sdf_tatpmatch;
   wire cond_sdf_ttbistmatch;



 and (CSWEMTBYPASS[0], !Mreg[0], CSWETBYPASSN);
 and (CSWEMTBYPASS[1], !Mreg[1], CSWETBYPASSN);
 and (CSWEMTBYPASS[2], !Mreg[2], CSWETBYPASSN);
 and (CSWEMTBYPASS[3], !Mreg[3], CSWETBYPASSN);
 and (CSWEMTBYPASS[4], !Mreg[4], CSWETBYPASSN);
 and (CSWEMTBYPASS[5], !Mreg[5], CSWETBYPASSN);
 and (CSWEMTBYPASS[6], !Mreg[6], CSWETBYPASSN);
 and (CSWEMTBYPASS[7], !Mreg[7], CSWETBYPASSN);
 and (CSWEMTBYPASS[8], !Mreg[8], CSWETBYPASSN);
 and (CSWEMTBYPASS[9], !Mreg[9], CSWETBYPASSN);
 and (CSWEMTBYPASS[10], !Mreg[10], CSWETBYPASSN);
 and (CSWEMTBYPASS[11], !Mreg[11], CSWETBYPASSN);
 and (CSWEMTBYPASS[12], !Mreg[12], CSWETBYPASSN);
 and (CSWEMTBYPASS[13], !Mreg[13], CSWETBYPASSN);
 and (CSWEMTBYPASS[14], !Mreg[14], CSWETBYPASSN);
 and (CSWEMTBYPASS[15], !Mreg[15], CSWETBYPASSN);
 and (CSWEMTBYPASS[16], !Mreg[16], CSWETBYPASSN);
 and (CSWEMTBYPASS[17], !Mreg[17], CSWETBYPASSN);
 and (CSWEMTBYPASS[18], !Mreg[18], CSWETBYPASSN);

and (atp_csn_en,!ATPint,!CSNint,!IGint);
or (sleep_en,atp_csn_en,ATPint);
or (SETB_EN,SEint,TBISTint);
and (ATP_SETB_EN,ATPint,SETB_EN); 
or (CSIG_EN,IGint,CSNint);
and (MEM_ACT,!ATPint,CSIG_EN);
or (EN_ADM,MEM_ACT,ATP_SETB_EN);
and (CS_EN,!ATPint,IGint);
or (CS_ADM,CS_EN,ATP_SETB_EN);
and (atp_ig_csn_en,!ATPint,!CSNint,!IGint);
and (atp_se_en,!SEsys,ATPint);
or (cycle_en,atp_ig_csn_en,atp_se_en);
and (atp_ig_csn_en_reg,!ATPreg,!CSNreg,!IGreg);
and (atp_se_en_reg,!SE_reg,ATPreg);
or (cycle_en_reg,atp_ig_csn_en,atp_se_en);
and (INITNandnotSLEEPandATPandnotSE,cond_gac,!SEsys,ATPint);
and (csn_ig_en,!IGint,!CSNint);
and (atp_tby_ls_en,atp_se_en,cond_ls_tby_en);
and (IG_EN,!ATPint,!CSNint);
or (IG_ADM,IG_EN,atp_se_en);
and (CSWETBYPASSN, !WENreg, 1'b1);



assign cond_sdf_tsls=((sleep_en && INITNint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tstdbys=((sleep_en && INITNint && !SLEEPint) !==0) ? 1:0;
assign cond_sdf_atps=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_gac=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tas=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tds=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tms=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tws=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tps=((cond_gac && !CS_ADM) !==0) ? 1:0;
assign cond_sdf_tcycle=((cond_gac && cycle_en && !LSint && !HSint) !==0) ? 1:0;  
assign cond_sdf_tcycle_ls1=((cond_gac && cycle_en && LSint) !==0) ? 1:0;
assign cond_sdf_tcycle_hs1=((cond_gac && cycle_en && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_tckh=((cond_gac && cycle_en_reg) !==0) ? 1:0;
assign cond_sdf_tckl=((cond_gac && cycle_en) !==0) ? 1:0;
assign cond_sdf_tcycle_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckl_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsctrlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckh_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_ttms=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_tbists=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_tckq_tm=((cond_gac && SE_reg && ATPreg && TBYPASSsys) !==0) ? 1:0;
assign cond_ls_en=((atp_ig_csn_en || atp_tby_ls_en) !==0) ? 1:0;
assign cond_sdf_tlss=((cond_ls_en && cond_gac) !==0) ? 1:0;
assign cond_sdf_thss=((cond_ls_en && cond_gac && !LSint) !==0) ? 1:0;
assign cond_sdf_trms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_twms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_tses=((cond_gac && ATPint) !==0) ? 1:0;
assign cond_sdf_tbas=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbps=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbws=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tigs=((cond_gac && IG_ADM) !==0) ? 1:0;
assign cond_sdf_taa=((MEMEN_reg && WENreg && !LSint && !HSint) !==0) ? 1:0; 
// assign cond_sdf_taa_tbypass_q = ((MEMEN_reg && ATPint && TBYPASSint) !== 1'b0) ? 1'b1 : 1'b0;
assign cond_sdf_taa_ls1=((MEMEN_reg && WENreg && LSint) !==0) ? 1:0; 
assign cond_sdf_taa_hs1=((MEMEN_reg && WENreg && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && !HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_ls1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && LSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_hs1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tseq_tm=((cond_gac && TBYPASSint) !==0) ? 1:0;
assign cond_sdf_tinitns =(( sleep_en && !STDBYint && !SLEEPint) !==0) ? 1:0;
assign cond_ls_tby_en=((TBYPASSsys || csn_ig_en) !==0) ? 1:0;



//specify block begins

specify
    specparam
    
         PATHPULSE$CK$Q = 0,
         PATHPULSE$CK$SCTRLO = 0,

         PATHPULSE$CK$SDLO = 0,
         PATHPULSE$CK$SDRO = 0,
        
         PATHPULSE$SE$Q = 0,
         
//         PATHPULSE$TBYPASS$Q = 0,


        
         
        
         tsls = `setup_time,
         tslh = `hold_time ,
         tstdbys = `setup_time,
         tstdbyh = `hold_time , 
	 

         
         tcycle = `cycle_time,
         
         
         tckh = `pulse_width_time,
         tckl = `pulse_width_time,
         tcycle_se = `cycle_time,
         tckh_se = `pulse_width_time,
         tckl_se = `pulse_width_time,
         
         ttms = `setup_time,
         ttmh = `hold_time ,
         tps = `setup_time,
         tph = `hold_time ,
         tws = `setup_time,
         twh = `hold_time ,
         tds = `setup_time,
         tdh = `hold_time , 
         tas = `setup_time,
         tah = `hold_time ,
         tses= `setup_time,
         tseh= `hold_time ,
         tsctrlis=`setup_time,
         tsctrlih=`hold_time ,
         tsdlis=`setup_time,
         tsdlih=`hold_time ,
         tsdris=`setup_time,
         tsdrih=`hold_time , 
         tbists=`setup_time,
         tbisth=`hold_time ,
         tbps=`setup_time,
         tbph=`hold_time ,
         tbws=`setup_time,
         tbwh=`hold_time ,
         tbdes=`setup_time,
         tbdeh=`hold_time ,
         tbdos=`setup_time,
         tbdoh=`hold_time ,
         
         tbas=`setup_time,
         tbah=`hold_time ,
         tinitnl=`initin_low_pulse,
         tinitns=`setup_time,
         tinitnh=`hold_time ,
         tatps=`setup_time,
         tatph=`hold_time ,
         tigs=`setup_time,
         tigh=`hold_time ,
         
         
         trms=`setup_time,
         trmh=`hold_time ,
         twms=`setup_time,
         twmh=`hold_time , 

/*************************************************************************************************/
           // taa_tbypass_q = `access_time,
           // th_tbypass_q  = `retain_time,
            taa =`access_time,
            th = `retain_time,

 


            taa_tm =`access_time,
            th_tm = `retain_time,

            
            taa_tseq_tm =`access_time,
            th_tseq_tm = `retain_time,
            taa_tckq_tm   = `access_time,
            th_tckq_tm    = `retain_time,
            taa_sctrlo=`access_time,
            th_sctrlo= `retain_time,
            taa_sdlo=`access_time,
            th_sdlo= `retain_time,
            taa_sdro=`access_time,
            th_sdro= `retain_time,
            
         
            taa_sctrlo_se=`access_time,
            th_sctrlo_se= `retain_time
,
            taa_sdlo_se=`access_time,
            th_sdlo_se= `retain_time,
            taa_sdro_se=`access_time,
            th_sdro_se= `retain_time
         ;  


        /*---------------------- Timing Checks ---------------------*/

	$setup(posedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[7], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[8], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[9], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[7], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[8], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[9], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[7], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[8], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[9], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[7], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[8], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[9], tah, TimingViol_addr);

	$setup(posedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(posedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(posedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(posedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(posedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(posedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(posedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(posedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(posedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(posedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(posedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(posedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(posedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(posedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(posedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(posedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(posedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(posedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(posedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(negedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(negedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(negedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(negedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(negedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(negedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(negedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(negedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(negedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(negedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(negedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(negedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(negedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(negedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(negedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(negedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(negedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(negedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(negedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[18], tdh, TimingViol_data_18);

        



        $setup(posedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $setup(negedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, posedge WEN, twh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, negedge WEN, twh, TimingViol_WEN); 
        $setup(posedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$setup(negedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, posedge CSN, tph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, negedge CSN, tph, TimingViol_CSN);
        $period(posedge CK &&& cond_sdf_tcycle, tcycle, TimingViol_tcycle);  

        
        $width(posedge CK  &&& cond_sdf_tckh, tckh, 0, TimingViol_tckh);
        $width(negedge CK  &&& cond_sdf_tckl, tckl, 0, TimingViol_tckl);
        $period(posedge CK &&& cond_sdf_tcycle_se, tcycle_se, TimingViol_tcycle_se);
        $width(posedge CK  &&& cond_sdf_tckh_se, tckh_se, 0, TimingViol_tckh_se);
        $width(negedge CK  &&& cond_sdf_tckl_se, tckl_se, 0, TimingViol_tckl_se);

        
        $setup(posedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $setup(negedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $hold(posedge CK &&& cond_sdf_ttms, posedge TBYPASS, ttmh, TimingViol_tbypass); 
        $hold(posedge CK &&& cond_sdf_ttms, negedge TBYPASS, ttmh, TimingViol_tbypass); 
 



        
        $setup(posedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $setup(negedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $hold(posedge CK &&& cond_sdf_tsls, posedge SLEEP, tslh, TimingViol_sleep);        
        $hold(posedge CK &&& cond_sdf_tsls, negedge SLEEP, tslh, TimingViol_sleep);

        $setup(posedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $setup(negedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $hold(posedge CK &&& cond_sdf_tstdbys, posedge STDBY, tstdbyh, TimingViol_stdby);        
        $hold(posedge CK &&& cond_sdf_tstdbys, negedge STDBY, tstdbyh, TimingViol_stdby); 
        
        
        $setup (posedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
	$setup (negedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
        
        $hold (posedge CK &&& cond_sdf_tses, posedge SE ,tseh,TimingViol_se);
	$hold (posedge CK &&& cond_sdf_tses, negedge SE ,tseh,TimingViol_se);
        
        $setup(posedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis , tsctrlis, TimingViol_sctrli);
        $setup(negedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis, tsctrlis, TimingViol_sctrli);
        $hold(posedge CK &&& cond_sdf_tsctrlis , posedge SCTRLI, tsctrlih, TimingViol_sctrli);        
        $hold(posedge CK &&& cond_sdf_tsctrlis , negedge SCTRLI, tsctrlih, TimingViol_sctrli);

        $setup(posedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $setup(negedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $hold(posedge CK &&& cond_sdf_tsdlis, posedge SDLI, tsdlih, TimingViol_sdli);        
        $hold(posedge CK &&& cond_sdf_tsdlis, negedge SDLI, tsdlih, TimingViol_sdli);

        $setup(posedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $setup(negedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $hold(posedge CK &&& cond_sdf_tsdris, posedge SDRI, tsdrih, TimingViol_sdri);        
        $hold(posedge CK &&& cond_sdf_tsdris, negedge SDRI, tsdrih, TimingViol_sdri);
        
 
	
         
        $width(negedge INITN , tinitnl, 0, TimingViol_initnl);
        
        $setup(posedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        $setup(negedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        
        $hold (posedge CK &&& cond_sdf_tinitns,posedge INITN, tinitnh, TimingViol_initn);
        $hold (posedge CK &&& cond_sdf_tinitns,negedge INITN, tinitnh, TimingViol_initn);

        $setup(posedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $setup(negedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $hold(posedge CK &&& cond_sdf_atps, posedge ATP, tatph, TimingViol_atp);        
        $hold(posedge CK &&& cond_sdf_atps, negedge ATP, tatph, TimingViol_atp);
        
        $setup(posedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $setup(negedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $hold(posedge CK &&& cond_sdf_tigs, posedge IG, tigh, TimingViol_ig);        
        $hold(posedge CK &&& cond_sdf_tigs, negedge IG, tigh, TimingViol_ig);



         
$setup(posedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[2], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[2], trmh, TimingViol_rm); 

        
$setup(posedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(posedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[1], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[1], twmh, TimingViol_wm);
 
        
        $setup(posedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $setup(negedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $hold(posedge CK &&& cond_sdf_tbists, posedge TBIST, tbisth, TimingViol_tbist);        
        $hold(posedge CK &&& cond_sdf_tbists, negedge TBIST, tbisth, TimingViol_tbist);
        
        	$setup(posedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[7], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[8], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[9], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$setup(negedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[7], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[8], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[9], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[6], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[7], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[8], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[9], tbah, TimingViol_addr);
       	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[6], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[7], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[8], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[9], tbah, TimingViol_addr);

        $setup(posedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$setup(negedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, posedge TCSN, tbph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, negedge TCSN, tbph, TimingViol_CSN); 
       
        $setup(posedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $setup(negedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, posedge TWEN, tbwh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, negedge TWEN, tbwh, TimingViol_WEN);
       
       
        $setup(posedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $setup(negedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, posedge TED, tbdeh, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, negedge TED, tbdeh, TimingViol_TED);

        $setup(posedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $setup(negedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, posedge TOD, tbdoh, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, negedge TOD, tbdoh, TimingViol_TOD);

          


          

          /*-------------------- Propagation Delays ------------------*/
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa, taa, th, taa, th, taa);
                 

/* // //	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[0] +: OutReg_data[0])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[1] +: OutReg_data[1])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[2] +: OutReg_data[2])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[3] +: OutReg_data[3])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[4] +: OutReg_data[4])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[5] +: OutReg_data[5])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[6] +: OutReg_data[6])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[7] +: OutReg_data[7])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[8] +: OutReg_data[8])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[9] +: OutReg_data[9])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[10] +: OutReg_data[10])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[11] +: OutReg_data[11])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[12] +: OutReg_data[12])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[13] +: OutReg_data[13])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[14] +: OutReg_data[14])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[15] +: OutReg_data[15])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[16] +: OutReg_data[16])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[17] +: OutReg_data[17])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[18] +: OutReg_data[18])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q); */ 








	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                





	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                 

	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[0] +: OutReg_data[0])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[1] +: OutReg_data[1])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[2] +: OutReg_data[2])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[3] +: OutReg_data[3])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[4] +: OutReg_data[4])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[5] +: OutReg_data[5])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[6] +: OutReg_data[6])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[7] +: OutReg_data[7])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[8] +: OutReg_data[8])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[9] +: OutReg_data[9])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[10] +: OutReg_data[10])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[11] +: OutReg_data[11])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[12] +: OutReg_data[12])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[13] +: OutReg_data[13])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[14] +: OutReg_data[14])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[15] +: OutReg_data[15])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[16] +: OutReg_data[16])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[17] +: OutReg_data[17])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[18] +: OutReg_data[18])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                



if (cond_sdf_taa_sctrlo) 
        (posedge CK *> (SCTRLO :  SCTRLI)) = (taa_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo); 

if (cond_sdf_taa_sctrlo_se) 
        (negedge CK *> (SCTRLO : SCTRLI)) = (taa_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se); 
 

if (cond_sdf_taa_sdlo) 
        (posedge CK *> (SDLO :  SDLI)) = (taa_sdlo,taa_sdlo,th_sdlo,taa_sdlo,th_sdlo,taa_sdlo); 

if (cond_sdf_taa_sdlo_se) 
        (negedge CK *> (SDLO : SDLI)) = (taa_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se);

if (cond_sdf_taa_sdro) 
        (posedge CK *> (SDRO :  SDRI)) = (taa_sdro,taa_sdro,th_sdro,taa_sdro,th_sdro,taa_sdro); 

if (cond_sdf_taa_sdro_se) 
        (negedge CK *> (SDRO : SDRI)) = (taa_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se); 

  
     




endspecify //specify block ends






// conversion from registers to array elements for data setup violation notifiers

always @(TimingViol_data_0   or TimingViol_TED  )
begin
        TimingViol_data[0]=~TimingViol_data[0];   
end


always @(TimingViol_data_1   or TimingViol_TOD  )
begin
        TimingViol_data[1]=~TimingViol_data[1];   
end


always @(TimingViol_data_2   or TimingViol_TED  )
begin
        TimingViol_data[2]=~TimingViol_data[2];   
end


always @(TimingViol_data_3   or TimingViol_TOD  )
begin
        TimingViol_data[3]=~TimingViol_data[3];   
end


always @(TimingViol_data_4   or TimingViol_TED  )
begin
        TimingViol_data[4]=~TimingViol_data[4];   
end


always @(TimingViol_data_5   or TimingViol_TOD  )
begin
        TimingViol_data[5]=~TimingViol_data[5];   
end


always @(TimingViol_data_6   or TimingViol_TED  )
begin
        TimingViol_data[6]=~TimingViol_data[6];   
end


always @(TimingViol_data_7   or TimingViol_TOD  )
begin
        TimingViol_data[7]=~TimingViol_data[7];   
end


always @(TimingViol_data_8   or TimingViol_TED  )
begin
        TimingViol_data[8]=~TimingViol_data[8];   
end


always @(TimingViol_data_9   or TimingViol_TOD  )
begin
        TimingViol_data[9]=~TimingViol_data[9];   
end


always @(TimingViol_data_10   or TimingViol_TED  )
begin
        TimingViol_data[10]=~TimingViol_data[10];   
end


always @(TimingViol_data_11   or TimingViol_TOD  )
begin
        TimingViol_data[11]=~TimingViol_data[11];   
end


always @(TimingViol_data_12   or TimingViol_TED  )
begin
        TimingViol_data[12]=~TimingViol_data[12];   
end


always @(TimingViol_data_13   or TimingViol_TOD  )
begin
        TimingViol_data[13]=~TimingViol_data[13];   
end


always @(TimingViol_data_14   or TimingViol_TED  )
begin
        TimingViol_data[14]=~TimingViol_data[14];   
end


always @(TimingViol_data_15   or TimingViol_TOD  )
begin
        TimingViol_data[15]=~TimingViol_data[15];   
end


always @(TimingViol_data_16   or TimingViol_TED  )
begin
        TimingViol_data[16]=~TimingViol_data[16];   
end


always @(TimingViol_data_17   or TimingViol_TOD  )
begin
        TimingViol_data[17]=~TimingViol_data[17];   
end


always @(TimingViol_data_18   or TimingViol_TED  )
begin
        TimingViol_data[18]=~TimingViol_data[18];   
end


`endif


// TASK DEFINITION DESCRIPTION
// ================================



task task_insert_faults_in_memory;
begin
   if (reg_ConfigFault)
   begin   
     for(i = 0;i< fcnt;i = i+ 1) begin
        if(mem_red_array_stuck_at[i] === "mem_array") begin
          if (array_stuck_at[i] === "sa0") begin
           `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data & stuck_at_0fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
          `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] & stuck_at_0fault[i];
          `endif
         end //if(array_stuck_at)
                                        
         if(array_stuck_at[i] === "sa1") begin
         `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data | stuck_at_1fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
         `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] | stuck_at_1fault[i]; 
         `endif
         end //if(array_stuck_at)
       end //if mem_red_array_stuck_at
    
    
     end    // end of for
   end  
end
endtask



task task_read_fault_file;
begin
/*  -----------Implemetation for config fault starts------*/
   msgcnt = X;
   t = 0;
   fault_repair_flag = {max_faults{1'b1}};
   repair_flag = {max_faults{1'b1}};
   if(reg_ConfigFault) 
   begin
      file_ptr = $fopen(reg_Fault_file_name , "r");
      if(file_ptr == 0)
      begin     
          if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: File cannot be opened ",$realtime);
      end        
      else                
      begin : read_fault_file
        t = 0;
        for (i = 0; i< max_faults; i= i + 1)
        begin
         
           stuck0 = {Bits{1'b1}};
           stuck1 = {Bits{1'b0}};
           fault_char1 = $fgetc (file_ptr);
           if (fault_char1 == 8'b11111111)
              disable read_fault_file;
           ret_val = $ungetc (fault_char1, file_ptr);
           ret_val = $fgets(tempStr, file_ptr);
           ret_val = $sscanf(tempStr, "%s %d %d %s",fault_array,fault_word, fault_bit, stuck_at) ;
           flag_error = 0; 
           if(ret_val !== 0)
           begin         
              if(ret_val == 3 || ret_val == 4)
              begin
                if(ret_val == 3)
                   stuck_at = "sa0";

                if(stuck_at !== "sa0" && stuck_at !== "sa1" && stuck_at !== "none")
                begin
                    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: Wrong value for stuck at in fault file ",$realtime);
                   flag_error = 1;
                end    
                      
                if(fault_word >= Words)
                begin
                   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Address out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                if(fault_bit >= Bits)
                begin  
                    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Faulty bit out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                
                        
                if(fault_array !== "mem_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array is not mem_array ",$realtime);
                  flag_error = 1;
                end

                if(fault_array === "red_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array can't be on redundancy array in non redundancy cut.",$realtime);
                  flag_error = 1;
                end

                
                

                if(flag_error == 0)
                //Correct Inputs
                begin
                   if(stuck_at === "none")
                   begin
                       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
                   end
                   else
                   //Adding the faults
                   begin
                      FailureLocn[t] = fault_word;
                      Failurebit[t]  = fault_bit ;
                      std_fault_word = fault_word;
                      fault_row_add[t] = std_fault_word[Addr-1:mux_bits];
                      mem_red_array_stuck_at[t] = fault_array;
                      fault_repair_flag[t] = 1'b0;
                      if (stuck_at === "sa0" )
                      begin
                         stuck0[fault_bit] = 1'b0;         
                         stuck_at_0fault[t] = stuck0;
                      end     
                      if (stuck_at === "sa1" )
                      begin
                         stuck1[fault_bit] = 1'b1;
                         stuck_at_1fault[t] = stuck1; 
                      end

                      array_stuck_at[t] = stuck_at;
                      t = t + 1;
                   end //if(stuck_at === "none")  
                end //if(flag_error == 0)
              end //if(ret_val == 2 || ret_val == 3 
              else
              //wrong number of arguments
              begin
                if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: WRONG VALUES ENTERED FOR FAULTY WORD OR FAULTY BIT OR STUCK_AT IN Fault_file_name ",$realtime); 
                flag_error = 1;
              end
           end //if(ret_val !== 0)
           else
           begin 
               if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
           end    
        end //for (i = 0; i< m
      end //begin: read_fault_file  
      $fclose (file_ptr);

      fcnt = t;
      
      //fault injection at time 0.
      task_insert_faults_in_memory;
  end // config_fault 
end
endtask


task WriteMemX;
begin

`ifdef slm
   $slm_ResetMemory(MemAddr, WordX);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = WordX;
   
`endif        
 task_insert_faults_in_memory;
end
endtask

task WriteMem0;
begin
`ifdef slm
   $slm_ResetMemory(MemAddr, Word0);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = Word0;
  
`endif 
   task_insert_faults_in_memory;
end
endtask


task WriteOutX;                
begin
   OutReg_data <= #0 WordX;
end
endtask


task Invalid_next_cycle_func;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_func = 1;
     `else 
       #0 next_cycle_corrupt_func = 0; 
     `endif  
   end 
end
endtask

task Invalid_next_cycle_dft;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_dft = 1;
     `else 
       #0 next_cycle_corrupt_dft = 0; 
     `endif  
  end
end
endtask

task Invalid_next_cycle_func_tim;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
   #0 next_cycle_corrupt_func <= 1;
  end 
end
endtask

task Invalid_next_cycle_dft_tim;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
  #0 next_cycle_corrupt_dft <= 1;
  end
end
endtask


task ScanOutX;                
begin
   
   dff_SCTRLO_SE.Q <= 1'bx;   
   dff_SDLO_SE.Q <= 1'bx; 
   dff_SDRO_SE.Q <= 1'bx; 
    
   
   SCTRLOint=X;
   SDLOint=X;
   SDROint=X;
    
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   SDLO_data<=1'bx;
   SDRO_data<=1'bx;
    
   `endif
end
endtask

task delScanOutX;                
begin
   delSCTRLO_data<=X;
   delSDLO_data<=X;
   delSDRO_data<=X;
    
end
endtask

task ScanChainX;                
begin
 scanreg_ctrl=1'bx; 
 scanreg_dl=1'bx; 
 scanreg_dr =1'bx; 
  
end
endtask

task mem_blocked;
begin
 
   WriteMemX;
   WriteOutX;
   ScanChainX;
   ScanOutX;//immediately;
   delScanOutX;//immediately
   `ifdef POWER_SEQUENCING_OFF
   `else
   reg_mem_block=1;
   `endif
   debug_level = 2'b11;
end
endtask

task corrupt_all;
begin
 
  WriteMemX;
  WriteOutX;
  ScanChainX;
  ScanOutX;
  delScanOutX;//immediately;
  OutReg_data = WordX; 
  delOutReg_data=WordX;
  
end
endtask

task WriteCycle;                  
input [Addr-1 : 0] Address;
reg [Bits-1:0] tempReg1;
reg [Bits-1:0] tempReg_slm;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;


reg repair_flag;

integer po,i,num,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;
begin

   tempReg1 = WordX;
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];

   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};
   
   if (ValidAddress === X )   begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
        WriteMemX;
        if (INITNint !== 0) begin
        `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
           #0 next_cycle_corrupt_func = 1;
       `else 
           #0 next_cycle_corrupt_func = 0; 
       `endif  
   end 

   end


   if (ValidAddress !== X && next_cycle_corrupt_func === 0  )
   begin
         if (red_en === 1 && ((Row_Add_cmp === repair_add) || (Row_Add_cmp === next_repair_add)) ) begin
             repair_flag = 1'b1;
             
             Bank_sel_integer = 0;
                     
             if (Row_Add_cmp === repair_add) begin
               Col_Add_integer  = Col_Add; 
             end
             else if (Row_Add_cmp === next_repair_add) begin
               Col_Add_integer  = Col_Add + mux; 
             end  
             RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
        end  

        if(repair_flag === 0 && ValidAddress === 1) begin
           `ifdef slm
              $slm_ReadMemoryS(MemAddr, Address, tempReg_slm);
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = Mem[Address];
            `endif
          end  
        else if(repair_flag === 1) begin
           `ifdef slm
//              $slm_ReadMemoryS(RedMemAddr, RedMem_address, tempReg_slm);
          
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = RedMem[RedMem_address];
            `endif
        end
        
        for (num=0;num<Bits;num=num+1) begin
             po=num;        
             if ( Dint [num] !== tempReg1 [po]) begin
                if (Mint[num] === 1'b0)
                   tempReg1[po] = Dint[num];
                else if (Mint[num] === 1'bX)
                   tempReg1[po] = 1'bx;
             end                
        end //for (num=0
            
         if(repair_flag === 0 ) begin    
            if(ValidAddress === 1) begin  
              `ifdef slm
                  tempReg_slm=tempReg1; 
                  $slm_WriteMemory(MemAddr, Address, tempReg_slm);
              `else
                   Mem[Address] = tempReg1;
              `endif
            end
            else begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address Out Of Range. ",$realtime);
            end        
         end
         else if (repair_flag === 1 ) begin
            `ifdef slm
                tempReg_slm=tempReg1; 
//                $slm_WriteMemory(RedMemAddr, RedMem_address, tempReg_slm);
            `else
                RedMem[RedMem_address] = tempReg1;
            `endif
         end
   end //if (ValidAddress !== X
   task_insert_faults_in_memory;
end
endtask 

task ReadCycle;
input [Addr-1 : 0] Address;

reg [Bits-1:0] MemData_tmp;
reg [Bits-1:0] MemData;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;

reg repair_flag;

integer a,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;

begin
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];
   
   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};

   

   if (ValidAddress !== X && next_cycle_corrupt_func === 0 ) begin   
       if(red_en === 1 && ( Row_Add_cmp === repair_add ||  Row_Add_cmp === next_repair_add )) begin
              repair_flag = 1;
              
              Bank_sel_integer = 0;
               
              if(Row_Add_cmp === repair_add) begin
                Col_Add_integer = Col_Add;
              end
              else if (Row_Add_cmp === next_repair_add) begin
                Col_Add_integer = Col_Add + mux; 
              end
              RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
       end

      if(repair_flag === 0) begin
          if(ValidAddress === 1) begin 
           `ifdef slm
              $slm_ReadMemory(MemAddr, Address, MemData);
           `else
              MemData = Mem[Address];
           `endif
          end
          else begin
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Address Out Of Range. Output Corrupted ",$realtime);
             MemData = WordX;
          end
     end
      else if(repair_flag === 1) begin
        `ifdef slm
//           $slm_ReadMemory(RedMemAddr, RedMem_address, MemData);
        `else
           MemData = RedMem[RedMem_address];
        `endif
      end
   end //if (ValidAddress)  
   
   if(ValidAddress === X)
   begin
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Illegal Value on Address Bus. Memory and Output Corrupted ",$realtime); 
         Invalid_next_cycle_func;
   end 
   
  if(ValidAddress !== X && next_cycle_corrupt_func === 0 )
   begin
   for (a = 0; a < Bits; a = a + 1)
   begin
      if (MemData[a] !== OutReg_data[a])
         OutReg_data[a] = WordX[a];
   end//for (a = 0; a <  
         OutReg_data <= MemData;
   end     
end
endtask



// SCAN CHAINS
supply0 gnd;
buf (A_int[0], Aint[0]);
buf (A_int[1], Aint[1]);
buf (A_int[2], Aint[2]);
buf (A_int[3], Aint[3]);
buf (A_int[4], Aint[4]);
buf (A_int[5], Aint[5]);
buf (A_int[6], Aint[6]);
buf (A_int[7], Aint[7]);
buf (A_int[8], Aint[8]);
buf (A_int[9], Aint[9]);                  //used for capturing
buf (A_int[10], gnd);
buf (A_int[11], gnd);
buf (A_int[12], gnd);
buf (A_int[13], gnd);
buf (A_int[14], gnd);   //used for capturing

buf (WEN_int, WENint);
buf (CSN_int, CSNint);
buf (IG_int, IGint);


// Scan flops



// CONTROL SCAN CHAIN
     ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF cntrl_scff_0 (.D(1'b0), .TI(SCTRLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[0]), .OUTX(scanreg_ctrl));

      
 ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF cntrl_scff_1 (.D(A_int[2]), .TI(scanreg_ctrl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[1]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF cntrl_scff_2 (.D(A_int[4]), .TI(scanreg_ctrl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[2]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF cntrl_scff_3 (.D(A_int[7]), .TI(scanreg_ctrl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[3]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF cntrl_scff_4 (.D(A_int[1]), .TI(scanreg_ctrl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[4]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF cntrl_scff_5 (.D(A_int[9]), .TI(scanreg_ctrl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[5]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF cntrl_scff_6 (.D(A_int[8]), .TI(scanreg_ctrl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[6]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF cntrl_scff_7 (.D(1'b0), .TI(scanreg_ctrl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[7]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF cntrl_scff_8 (.D(A_int[0]), .TI(scanreg_ctrl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[8]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF cntrl_scff_9 (.D(A_int[3]), .TI(scanreg_ctrl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[9]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF cntrl_scff_10 (.D(A_int[5]), .TI(scanreg_ctrl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[10]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF cntrl_scff_11 (.D(CSN_int), .TI(scanreg_ctrl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[11]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF cntrl_scff_12 (.D(A_int[6]), .TI(scanreg_ctrl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[12]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF cntrl_scff_13 (.D(WEN_int), .TI(scanreg_ctrl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[13]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF cntrl_scff_14 (.D(scanreg_ctrl_wire[14]), .TI(scanreg_ctrl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[14]), .OUTX(scanreg_ctrl));  

reg LP_CK_gate;

// Lock Up Latch
wire SCTRLO_temp;
 ST_SPREG_LOLEAK_1024x19m2_Tl_lock_up_latch  dff_SCTRLO_SE (Latch_open, scanreg_ctrl_wire[14], SCTRLO_temp);

always @(SCTRLO_temp) begin
     SCTRLOint= SCTRLO_temp;
 `ifdef functional
 `else
 if (SCTRLOint !== SCTRLO_data) begin 
  if (SCTRLOint !==X)
   SCTRLO_data=1'bx;
   SCTRLO_data <= SCTRLOint;
 end 
 `endif
end  


// LEFT DATA SCAN CHAIN
     ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF ldata_scff_0 (.D(Dint[9]), .TI(SDLI), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[0]), .OUTX(scanreg_dl));
      
   
 
        ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF ldata_scff_1 (.D(Dint[8]), .TI(scanreg_dl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[1]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF ldata_scff_2 (.D(Dint[7]), .TI(scanreg_dl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[2]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF ldata_scff_3 (.D(Dint[6]), .TI(scanreg_dl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[3]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF ldata_scff_4 (.D(Dint[5]), .TI(scanreg_dl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[4]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF ldata_scff_5 (.D(Dint[4]), .TI(scanreg_dl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[5]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF ldata_scff_6 (.D(Dint[3]), .TI(scanreg_dl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[6]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF ldata_scff_7 (.D(Dint[2]), .TI(scanreg_dl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[7]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF ldata_scff_8 (.D(Dint[1]), .TI(scanreg_dl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[8]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF ldata_scff_9 (.D(Dint[0]), .TI(scanreg_dl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[9]), .OUTX(scanreg_dl));



// Lock Up Latch
wire SDLO_temp;
 ST_SPREG_LOLEAK_1024x19m2_Tl_lock_up_latch  dff_SDLO_SE (Latch_open, scanreg_dl_wire[9], SDLO_temp);

always @(SDLO_temp) begin
     SDLOint= SDLO_temp;
 `ifdef functional
 `else
 if (SDLOint !== SDLO_data) begin 
  if (SDLOint !==X)
   SDLO_data=1'bx;
   SDLO_data <= SDLOint;
 end 
 `endif
end  






// RIGHT DATA SCAN CHAIN

     ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF rdata_scff_0 (.D(1'b0), .TI(SDRI), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[0]), .OUTX(scanreg_dr));
     
 
 
        ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF rdata_scff_1 (.D(Dint[18]), .TI(scanreg_dr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[1]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF rdata_scff_2 (.D(Dint[17]), .TI(scanreg_dr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[2]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF rdata_scff_3 (.D(Dint[16]), .TI(scanreg_dr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[3]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF rdata_scff_4 (.D(Dint[15]), .TI(scanreg_dr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[4]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF rdata_scff_5 (.D(Dint[14]), .TI(scanreg_dr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[5]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF rdata_scff_6 (.D(Dint[13]), .TI(scanreg_dr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[6]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF rdata_scff_7 (.D(Dint[12]), .TI(scanreg_dr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[7]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF rdata_scff_8 (.D(Dint[11]), .TI(scanreg_dr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[8]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF rdata_scff_9 (.D(Dint[10]), .TI(scanreg_dr_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[9]), .OUTX(scanreg_dr)); 


// Lock Up Latch
wire SDRO_temp;
 ST_SPREG_LOLEAK_1024x19m2_Tl_lock_up_latch  dff_SDRO_SE (Latch_open, scanreg_dr_wire[9], SDRO_temp);


always @(SDRO_temp) begin
     SDROint= SDRO_temp;
 `ifdef functional
 `else
 if (SDROint !== SDRO_data) begin 
  if (SDROint !==X)
   SDRO_data=1'bx;
   SDRO_data <= SDROint;
 end 
 `endif
end






//


 //////// CAPTURE TASK //////
task scan_acquire;
begin
   if (supply_ok === 1) begin 
      if ( SEsys === 0 && ((LP_CK_gate === 0 && TBYPASSsys !== 1'bx)|| TBYPASSsys===0)) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
         
         Latch_open=1;
         

      end //if ( SEint === 0
   end//if(supply_ok 
end
endtask

task scan_shift;
begin
 if (supply_ok === 1) begin
   if (STDBYint === 0 && SLEEPint === 0) begin
      if (CKint_dft === X && INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0) begin
         ScanChainX;
         ScanOutX;
      end
      else if (CKint_dft === 1 && lastCK_dft === 0 ) begin
          //// SHIFT
        if (SEsys === 1) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
           
        //// SHIFT Ends
        end //if (SEsys === 1
        else if (SEsys === X) begin
            ScanChainX;
            ScanOutX;
            delScanOutX;
        end//if (SEint ==X
      
      end///if (CKint === 
    
      else if (CKint_dft === 0 && lastCK_dft === 1 ) begin
        Latch_open=1;
      end
    end  //if (STDByint === 0 && SLEEPint === 0
 end//if(supply_ok
end
endtask






// BEHAVIOURAL MODULE DESCRIPTION
// ================================

initial
begin
  // Define format for timing value
  $timeformat (-9, 3, " ns", 0);
  `ifdef slm
  $slm_RegisterMemory(MemAddr, Words, Bits);
  `endif   
   reg_mem_block=0;
   flag_mem_block=0;
  `ifdef functional
  `else
   TimingViol_data=0;
   TimingViol_mask=0;
   `endif
   decoding_start=0;
  
   //Parameter Assignment
   
   reg_Fault_file_name = Fault_file_name; 
   reg_ConfigFault     = ConfigFault;
   reg_MEM_INITIALIZE  = MEM_INITIALIZE;
   reg_BinaryInit      = BinaryInit;
   reg_InitFileName    = InitFileName;
   reg_Initn_reset_value = Initn_reset_value;
   reg_File_load_time    = File_load_time;

   time_fall_sleep=0;
   time_fall_PSWLARGEMP=0;
   time_fall_PSWLARGEMP_0=0;
   time_fall_PSWLARGEMA=0;
   time_fall_PSWLARGEMA_0=0;
   time_fall_PSWSMALLMP=0;
   time_fall_PSWSMALLMA=0;

   vddmp_rise_time=0;
   vddmp_fall_time=0;
   vddsmp_rise_time=0;
   vddsmp_fall_time=0;
   vddma_rise_time=0;
   vddma_fall_time=0;
   vddsma_rise_time=0;
   vddsma_fall_time=0;
   vddm_fall_time=0;  
   vddm_rise_time=0;  
   vddsm_fall_time=0; 
   vddsm_rise_time=0;

   next_cycle_corrupt_func=0;
   next_cycle_corrupt_dft=0;
   init_pulse_done = 0;
   power_up_done = 0;
   file_loaded=1;
   debug_level= 2'b01;
   message_status = "ONLY WARNINGS/ERRORS are Switched ON.For INFO also use debug_level=2'b00";
  `ifdef  NO_WARNING_MODE
     debug_level = 2'b11;
     message_status = "All Warning/Errors/Info Messages are Switched OFF";
  `endif  
  `ifdef  ONLY_ERROR_MODE
     debug_level = 2'b10;
     message_status = "All Warning/Info Messages are Switched OFF.Errors are switched on";
  `endif 
  `ifdef  ALL_MSG_MODE
     debug_level = 2'b00;
     message_status = "All Messages are Switched ON";
  `endif 
  
  `ifdef slm
     operating_mode = "SLM";
   `else
      `ifdef functional
         operating_mode = "FUNCTIONAL";
       `else
         operating_mode = "TIMING";
      `endif
   `endif   
  
  if (debug_level < 1) begin
  $display ("%m INFORMATION ");
  $display ("***************************************");
  $display ("The Model is Operating in %s MODE", operating_mode);
  $display ("%s", message_status);
  if(reg_ConfigFault)
  $display ("Configurable Fault Functionality is ON");   
  else
  $display ("Configurable Fault Functionality is OFF");   
  $display("Fault File used by the model Fault_File_Name=%s" ,reg_Fault_file_name);
  $display("Values of Config_fault used in model=%d" ,reg_ConfigFault);
  $display("Values of Mem_INITALIZE used in model=%d" ,reg_MEM_INITIALIZE);
  $display("Values of BinaryInit used in model=%d" ,reg_BinaryInit);
  $display("Values of InitFileName used in model=%s" ,reg_InitFileName);
  $display("Values of Initn_reset_value used in model=%d" ,reg_Initn_reset_value);
  $display("Values of File_load_time used in model=%t" ,reg_File_load_time);

  $display ("***************************************");
  end
     
  task_read_fault_file; 
   if(!INITNint) begin
    if(supply_ok ) begin 
      init_pulse_done = 1;
      power_up_done = 1;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif 
    end 
   end 
        
   lastCK_func = CKint_func;
   lastCK_dft = CKint_dft;

 `ifdef MEM_CONTENTS_SLEEP
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","w");
   $fclose(ptr);
 `endif 

   
end  // initial block ends



//+++++++++++++++++++++++++++++++ CONFIG FAULT IMPLEMETATION ENDS+++++++++++++++++++++++++++++++//
        




//INITN block starts
//================================
always @(INITNint  or supply_ok )
begin
 if (INITNint === 1'b0) begin
   if(supply_ok) begin
     init_pulse_done = 1;
     power_up_done = 1;
     lastCK_func=CKint_func;
     lastCK_dft=CKint_dft;
     next_cycle_corrupt_func = 0;
     next_cycle_corrupt_dft = 0;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif     
   end 
 end        

 if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && INITNint !== 1)
   begin
     ScanOutX;
     ScanChainX;
     delScanOutX;
   end  
         
 if (init_pulse_done === 0 && INITNint !== 0) begin
     if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) INFO: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
 end
 
end//always @(INITNint)


// Clock Generation 
//wire gated_clock;
//wire clock_gate_en;
//ST_SPREG_LOLEAK_1024x19m2_Tl_lock_up_latch CK_SE_latch (!CK , SE, SE_latch_CK);
//and (clock_gate_en, ATP, TBYPASS, !SE_latch_CK);

//ST_SPREG_LOLEAK_1024x19m2_Tl_lock_up_latch LP_latch (!CK , scanreg_ctrl_wire[14], LP_latch_CK);
//and (gated_clock,CK,!LP_latch_CK);
//assign CK_new= clock_gate_en ===0 ? CK : (clock_gate_en ===1 ? gated_clock: (CK===0) ? 0 :1'bx);


// Clock Generation Ends


// Functional CK block starts
//======================================
always @(CKint_func)
begin
   lastCK_func=CKreg_func;  
   CKreg_func=CKint_func;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
        if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
      if (CKreg_func === 1'bX || (CKreg_func === 1'b1 && lastCK_func === 1'bx)) begin
        if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
         
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
         Invalid_next_cycle_func;
        end
      end
      else if (CKreg_func === 1'b1 && lastCK_func === 1'b0 ) begin
        time_CK_func_rise=$realtime;
        MEMEN_prev = MEMEN_reg;
        MEMEN_reg = MEMEN;
        CSNreg = CSNint;
        IGreg = IGint;
        DEreg = DEint;
        SE_reg = SEsys;
        TBYPASS_reg = TBYPASSsys;
        ATPreg = ATPint;
        INITNreg = INITNint;
        SLEEPreg = SLEEPint;
        STDBYreg = STDBYint;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 

    `ifdef functional
    `else
        Mem_last=Mem[Aint];
    `endif 
        if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.INITN pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SLEEP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.STANDBY pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg === X && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.chip select  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg === X && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.IG pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg === X && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.Debug pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg === X && (SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.ATP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg === X && TBYPASS_reg !== 1) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SE pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg !== 1 && TBYPASS_reg === X) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.TBYPASS pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end

        else if ((INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0))) && WENint === X) begin
            // Uncertain write cycle
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: write enable going to X  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end 
        else if (next_cycle_corrupt_func === 1) begin
          next_cycle_corrupt_func = X;
        end
        else if (next_cycle_corrupt_func === 1'bx) begin
          next_cycle_corrupt_func = 0;
        end 
        
//        if (next_cycle_corrupt_func === 0 ) begin 
         
          /*---------------------- File initialization -----------------*/
          
          if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0)) && flag_mem_block === 1'b0) begin
                 Areg=Aint;
                 Dreg=Dint;
                 Mreg=Mint;
                 WENreg=WENint;     
             if (reg_MEM_INITIALIZE === 1'b1 && $realtime >= reg_File_load_time && file_loaded ) begin   
                `ifdef slm
                  if (reg_BinaryInit)
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_BIN");
                  else
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_HEX");
   
                `else
                  if (reg_BinaryInit)
                     $readmemb(reg_InitFileName, Mem, 0, Words-1);
                  else
                     $readmemh(reg_InitFileName, Mem, 0, Words-1);
                `endif
                 file_loaded = 0;
             end
   
             if (^Aint === X)
               ValidAddress = X;
             else if (Aint < Words)
               ValidAddress = 1;
             else    
               ValidAddress = 0;
   
             if(red_en === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Redundancy Enable is Invalid. Either RRAE is X or TRRAE is X",$realtime);
                ValidAddress = X; 
           end
           else if(red_en === 1'b1 && ^repair_add === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Repair Address is invalid.RRA is X",$realtime);
                ValidAddress = X;
           end
             
             if (ValidAddress)
               `ifdef slm
                   $slm_ReadMemoryS(MemAddr, Aint, Mem_temp);
               `else
                    Mem_temp = Mem[Aint];
               `endif
             else
                Mem_temp = WordX;  
          
     /*---------------------- Normal Read and Write -----------------*/
     
             if (WENint === 1) begin
               ReadCycle(Aint);
             end
       
             else if (WENint === 0) begin
               WriteCycle(Aint);
             end 
                
          
          end //  if (MEMEN === 1'b1 
       
//        end  // if (next_cycle_corrupt_func === 0
      
      end // if (CKint = 1   
   end // if (init_pulse_done === 1           
 end 
end // always @(CKint_func)
        
always @(MEMEN)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) && CKint_func === 1'bx) begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.clock pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
    Invalid_next_cycle_func;
  end
 end 
end

// DFT CK block starts
//======================================
always @(CKint_dft) 
begin
   lastCK_dft=CKreg_dft;
   CKreg_dft=CKint_dft;
   
   Latch_open=0;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
     if (CKreg_dft === 1'bX || (CKreg_dft === 1'b1 && lastCK_dft === 1'bx)) begin
       if (INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0 ) begin
        
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: DFT clock  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime); 
         Invalid_next_cycle_dft;
         if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
           WriteOutX;
         end
       end
     end 

     if(CKint_dft === 0 && lastCK_dft === 1) begin
      if(ATPreg === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
       if(SE_reg === 1'b1 && SEsys === 1'b0) begin
        if(TBYPASSint === 1'b1) begin   
            
    
    OutReg_data_scan = { scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8], scanreg_dl_wire[scanlen_l-1]}; 
 
         for (i = 0; i < Bits; i = i + 1)
         begin
          if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
         end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
        end 
       end
      end
     end 
     
     else if (CKreg_dft === 1'b1 && lastCK_dft === 1'b0 ) begin
       SE_reg = SEsys;
       TBYPASS_reg = TBYPASSsys;
       ATPreg = ATPint;
       INITNreg = INITNint;
       SLEEPreg = SLEEPint;
       STDBYreg = STDBYint;
       MEMEN_dft_prev = MEMEN_dft_reg;
       MEMEN_dft_reg = MEMEN_dft;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 
       if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ) begin 
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
 //     else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys === X && TBYPASSsys !== 1) begin
///           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
//           Invalid_next_cycle_dft;
//        end       
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys === X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
        end 
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys !== 0 && LP_CK_gate===X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: LP FLOP Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           ScanChainX;
           ScanOutX;   
          if( TBYPASSint !== 0 && SEint !== 1) begin
            WriteOutX;
          end
          next_cycle_corrupt_dft=0;
        end        
       else if (next_cycle_corrupt_dft === 1'b1) begin 
         next_cycle_corrupt_dft = X;
       end 
       else if (next_cycle_corrupt_dft === 1'bx) begin
         next_cycle_corrupt_dft = 0;
       end
       
       if (next_cycle_corrupt_dft === 0 ) begin
         
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1 && flag_mem_block === 1'b0) begin
           
           if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0  && LP_CK_gate===0) begin
              OutReg_data_tbypass = Dint;
              for (i = 0; i < Bits; i = i + 1)
              begin
               if (OutReg_data_tbypass[i] !== OutReg_data[i])
                 OutReg_data[i] = WordX[i];
              end//for (i = 0; i < */ 
              OutReg_data <= OutReg_data_tbypass;
           end
           
             scan_acquire;
         end //MEMEN_dft == 1        
       end // if ( next_cycle_corrupt_dft
       
     end // if (CKint_dft === 1'b1
      //  if (next_cycle_corrupt_dft === 0 ) begin 
       if (SE_reg !== 0) begin
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1  && flag_mem_block === 1'b0) begin
           next_cycle_corrupt_dft = 0;
           if ( next_cycle_corrupt_func === 1) begin
	    next_cycle_corrupt_func = 0 ;
	   end	
           scan_shift;
         end
       end
     //end // if ( next_cycle_corrupt_dft    
     if ((!(TBYPASSsys!==0 && SEsys!==1 && LP_CK_gate!==0 ) && next_cycle_corrupt_dft === 0) || CKint_dft !==1) begin          
       CK_sc=INITNreg & !STDBYreg & !SLEEPreg & ATPreg & CKreg_dft ;
     end     
   end // if (init_pulse_done 
 end // if (supply_ok 
end // always @(CKint_dft)

always @(MEMEN_dft)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) && CKint_dft === 1'bx)  begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.MEMEN_dft and clock should not be X at this time instant. ScanChains and ScanOuts Corrupted ",$realtime); 
    Invalid_next_cycle_dft;
    
    if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
      WriteOutX;
    end
  end
  if ( MEMEN_dft !== 0 && TBYPASSsys !== 0 && SEsys !== 1) begin
     WriteOutX;
     OutReg_data = WordX; 
     delOutReg_data=WordX;
 end 
end
end //always @(MEMEN_dft

always @(TBYPASSsys or ATPint)
begin
   if(supply_ok === 1'b1) begin 
    if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0 && INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1) begin
      if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
    end  
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint === X && SEsys !== 1) ) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end 
end //always @(TBYPASSint





always @(SEsys)
begin
 if(supply_ok === 1'b1) begin 
  if(CKint_dft === 0 && ATPint === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
    if(SE_reg === 1'b1 && SEsys === 1'b0) begin
      if(TBYPASSsys === 1'b1) begin
          
  
        OutReg_data_scan = { scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8], scanreg_dl_wire[scanlen_l-1]};  


        for (i = 0; i < Bits; i = i + 1)
        begin
         if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
        end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
      end
    end
  end
  if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0) begin
      if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
  end 
  else if ((TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint === X && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end   
end

//assign output data
`ifdef functional        

   
always @(SDLOint)
#0.001 delSDLO_data<=SDLOint;

always @(SDROint)
#0.001 delSDRO_data<=SDROint;

 
always @(SCTRLOint)
#0.001 delSCTRLO_data<=SCTRLOint;


always @(OutReg_data)
   #0.001 delOutReg_data = OutReg_data;
`else
`endif

/***************************** Embeded switch functionality starts here ***********************************/





always @(STDBYint)
begin
  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0 && STDBYint !== 1'b0)
    begin
      ScanOutX;
      ScanChainX;
     delScanOutX;     
    end
  end
end



always @(SLEEPint)
begin


  if (SLEEPint !== 1'b1) begin
    time_fall_sleep = $realtime;
  end

  if (power_up_done === 0)
    begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
    end
  else begin
    if (SLEEPint === 1'b1 && lastSLEEP === 1'b0 ) begin 
      
    end
    else if (SLEEPint !== 1'b1 && lastSLEEP === 1'b1 && full_shutdown !== 1) begin 
      
      if (supply_ok !== 1 && ($realtime > 0)) begin
         if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID LOW_POWER) ERROR: ISOLATION signal removed from the memory but array and periphery supply is not completely switched on.Very High Current would be drawn by the memory. All further operations on memory are blocked",$realtime);
          WriteMemX;
          WriteOutX;
          ScanChainX;
          OutReg_data = WordX; 
          delOutReg_data=WordX;
          ScanOutX;//immediately;
          delScanOutX;//immediately;
          init_pulse_done = 0;
          power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            debug_level = 2'b11;
          `endif
          
      end        
      
       
    end   
    else if (SLEEPint === X && lastSLEEP === 1'b0 && full_shutdown !== 1'b1) begin 
     
    end 
  end  


  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && SLEEPint !== 0)
    begin
      ScanOutX;
      ScanChainX;
        delScanOutX;      
    end
  end

// if (init_pulse_done === 0)
//   begin
//     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
//   end
//
// else if ( SLEEPint !== 1 && (supply_ok !==1) ) begin
//    
//    WriteOutX;
//    OutReg_data = WordX; 
//    delOutReg_data=WordX;
//    ScanOutX;//immediately;
//    delScanOutX;//immediately;
//    ScanChainX;
//    WriteMemX;
//    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies with sleep/Power down signal being low.This scenario can lead to high dc currents and some reliability issues Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
// end

 print_sleep;    
 lastSLEEP=SLEEPint;
end

/********************************** Embeded switch functionality ends here *******************************/

task print_sleep;
begin
  if (SLEEPint === 1'b0) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been deasserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end  
  else if (SLEEPint === 1'b1) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been asserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_ACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif

  end        
  else begin
      if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) ERROR: SLEEP pin is at an invalid state.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INVALID in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end        
end
endtask





 

//// C28SOI non flip compiler power functionality 
always @(gndmreg )
begin
 if (power_up_done === 1 && $realtime > 0) begin    
    if(gndmreg !== 1'b0 ) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or gndsm is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
        corrupt_all;
        init_pulse_done = 0;
        power_up_done = 0;
     `ifdef NO_BLOCK_MEM
     `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of ground pins.Ground must be maintained at 0 Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime);
        debug_level = 2'b11;
     `endif   

    end   
 end

end




always @(vddmareg )
begin

if (vddmareg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddma(Array Supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 
    end
   end   
   else if (SLEEPint === 1) begin
    WriteMemX;
   end

end

if ((vddmareg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1 ) && $realtime > 0) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddm or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         corrupt_all;
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif

end


end

always @(vddmpreg )
begin
 if (vddmpreg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or vddsmp is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmp(Periphery Supply)/vddsmp(Substrate power supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 

    end
   end   
   else if (SLEEPint === 1) begin
    WriteOutX;
    ScanChainX;
    ScanOutX;
    delScanOutX;//immediately;
    OutReg_data = WordX; 
    delOutReg_data=WordX;
   end
 end

if( (vddmpreg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1'b1 )  && $realtime > 0) begin
         corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif
end
 
 
end


always @(vddmoreg)
begin
  if (power_up_done === 1 && $realtime > 0) begin   
      if (vddmoreg !== 1'b1)  begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin
           corrupt_all;
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
         end //if (vddmareg === 1'b1 

      else if (vddmareg === 1'b0 && vddmpreg === 1'b0   && SLEEPint === 1'b1 &&  $realtime > 0)
        begin 
            if((debug_level < 2) && ($realtime > 0)) $display("%m - %t WARNING: Illegal Value on power pin(s). Memory and Output Corrupted ", $realtime);
 
           corrupt_all;
        end //else if (vddmareg === 1'b 
     end   // if (vddmoreg !== 1'b1)
     else if (vddmoreg === 1'b1 && $realtime > 0 ) begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin     
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           corrupt_all;
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
        end        
     end // else if (vddmoreg === 1'b1
  end 
end // always @(vddmoreg)












always @(gndmreg) begin
 if (gndmreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 0. ",$realtime);
 end
 else if (gndmreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 1. ",$realtime);
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to invalid state. ",$realtime);
 end
end




 
always @(vddmareg) begin
 if (vddmareg === 0) begin 
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 0. ",$realtime);
  vddma_fall_time = $realtime;
 end
 else if (vddmareg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 1. ",$realtime);
  vddma_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to invalid state. ",$realtime);
  vddma_fall_time = $realtime;
 end 

 

end

always @(vddmpreg) begin
 if (vddmpreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 0. ",$realtime);
  vddmp_fall_time = $realtime;
 end
 else if (vddmpreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 1. ",$realtime);
  vddmp_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to invalid state. ",$realtime);
  vddmp_fall_time = $realtime;
 end

 
 
end



// end of C28SOI power functionality 
 


assign supply_ok          =  (vddmareg === 1'b1 && vddmpreg  === 1'b1  && gndmreg === 1'b0 && vddmoreg === 1'b1 ) ? 1'b1 : 1'b0;
assign core_supply_ok     =  (vddmoreg === 1'b1 && vddmareg === 1'b1 && gndmreg === 1'b0 ) ? 1'b1 : 1'b0;
assign peri_supply_ok     =  (vddmoreg === 1'b1 && vddmpreg === 1'b1 && gndmreg === 1'b0  ) ? 1'b1 : 1'b0;

assign full_shutdown = (vddmpreg === 1'b0 && vddmareg === 1'b0   ) ? 1'b1 : 1'b0 ;




`ifdef functional
`else


task WriteLocMskX_bwise;
   input [Addr-1 : 0] Address;
   input [Bits-1 : 0] Mask;

reg [Bits+Red_extrabit:0] tempReg1;
integer num1; 
begin
   tempReg1 = WordX;
   if (^Address !== X )
   begin
      tempReg1 = Mem[Address];
             
      for (j = 0;j< Bits; j=j+1) begin
         num1=j;
        if (Mask[j] === 1'bx)
            tempReg1[num1] = 1'bx;
      end
      Mem[Address] = tempReg1;
      task_insert_faults_in_memory;
   end//if (^Address !== X
   else begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      WriteMemX;
   end   
end
endtask


/****************Actions taken on timing violations*****************/

 always @(TimingViol_data)
// tds or tdh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  for (l = 0; l < Bits; l = l + 1) begin   
    if (CSWEMTBYPASS[l] !== 0) begin
     if((TimingViol_data[l] !== TimingViol_data_last[l])) begin


         Mreg[l] = 1'bx;
     end    
     WriteLocMskX_bwise(Areg,Mreg);
    end   
   end 
  end
    if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin
     scanreg_dl =1'bx; 
     scanreg_dr =1'bx; 
     SDLOint=X;
     SDROint=X;
     `ifdef functional
     `else
     SDLO_data<=1'bx;
     SDRO_data<=1'bx;
     `endif
    end
     TimingViol_data_last = TimingViol_data; 
end





always @(TimingViol_addr)
// tas or tah
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
      scanreg_ctrl=1'bx; 
      SCTRLOint=X;
      `ifdef functional
      `else
      SCTRLO_data<=1'bx;
      `endif
  end
end


always @(TimingViol_WEN)
//tws or twh
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WEN pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end 

always @(TimingViol_CSN )
// tps or tph 
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;

   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CSN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end

always @(TimingViol_tcycle )
//tcycle
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
   if (MEMEN !== 0 && MEMEN_prev !== 0) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckl )
// tckl 
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckh) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end


always @(TimingViol_tcycle_se )
//tcycle_se
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckl_se  )
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckh_se) begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tbist) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
   end
   if (TBYPASSint !== 1'b0) begin 
    WriteOutX;
   end 
   if (INITNreg !==0 && STDBYreg !== 1 && TBYPASS_reg !== 1 && SLEEPreg !== 1 && SE_reg !== 1 && IGreg !== 1 && DEreg !== 1) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBIST pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end






always @(TimingViol_tbypass)
//ttmck
begin
#0  
  WriteOutX;
  if (INITNreg !== 0 && SLEEPreg !== 1 && SE_reg !== 1 && STDBYreg !== 1 &&  DEreg !== 1) begin
   Invalid_next_cycle_dft_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
end



always @(TimingViol_sleep)
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_stdby)
begin
#0
  if (CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin 
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (ATPreg !== 0) begin 
   Invalid_next_cycle_dft_tim;
  end
end






always @(TimingViol_se) begin
#0
   if (TBYPASS_reg !== 0) begin 
    WriteOutX;
   end 
  if (TBYPASS_reg === 0) begin
     WriteOutX;
     WriteMemX;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE timing violation  Memory State Machine is corrupted. Output Corrupted ",$realtime); 
  end 
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
  end
end

always @(TimingViol_sctrli) begin
  scanreg_ctrl=1'bx; 
end


always @(TimingViol_sdli) begin
 scanreg_dl=1'bx; 
end

always @(TimingViol_sdri) begin
   scanreg_dr=1'bx;
end

 

always @(TimingViol_initnl) begin
init_pulse_done=0;
WriteOutX;
OutReg_data = WordX; 
delOutReg_data=WordX;
ScanOutX;
delScanOutX;
ScanChainX;
WriteMemX;
end

always @(TimingViol_initn) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end

always @(TimingViol_ig) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && INITNreg !== 0 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: IG pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   ScanChainX;
   ScanOutX;
   delScanOutX;       
  end
end

always @(TimingViol_atp) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin  
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_rm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^WMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: RM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
   end
end
 
always @(TimingViol_wm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^RMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);        
   end
end 


`endif


endmodule




module ST_SPREG_LOLEAK_1024x19m2_Tl_lock_up_latch (EN,D,Q);
input EN,D;
output reg Q;

  always @ (EN or D) begin
    if (EN === 1) begin
       Q = D;
    end
    else if ((EN === 1'bz || EN === 1'bx  )&& D !== Q) begin
        Q=1'bx;
    end    
  end
endmodule

module ST_SPREG_LOLEAK_1024x19m2_Tl_SCFF (D,TI,TE,CP,Q,OUTX);
input D,TI,TE,CP;
input OUTX;
output reg Q;
wire Dint;
assign Dint= (TE===1)?TI:(TE===0)?D:1'bx;

always @(posedge CP)
        begin
          if(Dint === 1'bZ || CP ===1'bx || OUTX === 1'bx)
          begin
                  Q = 1'bx;
          end
          else
          begin
                  Q = Dint;
          end        
        end
always @(posedge OUTX)
Q = 1'bx;
endmodule



`undef setup_time
`undef hold_time
`undef access_time
`undef retain_time
`undef cycle_time
`undef pulse_width_time
`undef initin_low_pulse


`delay_mode_path
`endcelldefine
`nosuppress_faults






/****************************************************************
--  Description         : Verilog Model 
--  ModelVersion        : 1.2
--  Date                : Apr, 2013
--  Changes Made by	: PS
--  Revision History    : 
 
****************************************************************/


/******************** START OF HEADER****************************
   This Header Gives Information about the parameters & options present in the Model
   
   words = 1024
   bits  = 19
   mux   = 4 
   
   
   
   write_mask = no 
   
   margin_control = yes 
   
   
   Dft = Yes  

    ------------------------------------------------------------------------------------
     Signal Name             | Description       |             Port Mode        | Active When
                             |                   |          r    |  w   | rw    |
   ------------------------------------------------------------------------------------

    D 	        Data in                     na     x      na       -  
    IG    Input Gate Enable           x      x      na       High     
    ATP            ATPG Enable                 x      x      na       High     
    INITN                 INITN pin                   x      x      na       Low
    
    
     
    Q 	        Data out	            x      na     na       -
    A              Address                     x      x      na       high and low
    
    CK                Clock	                    x      x      na       posedge
    CSN          Chip Enable                 x      x      na       low
    
    RM         Read Margins                 x      x      na       High 
    SCTRLI         Scan Input (Control)
    SCTRLO        Scan Output (Control)
    SDLI         Scan Input (Data-Left)
    SDLO        Scan Output (Data-Left)
    SDRI         Scan Input (Data-Right)
    SDRO        Scan Output (Data-Right)
    SE          Scan Enable pin 
    STDBY              Standby pin                 x      x      na       High
    
    SLEEP                        Sleep pin                   x      x      na        High 
    
     
     
    TBIST          Bist Enable Pin 
    
    TBYPASS                      Memory Bypass                na     na     na        High
    
    TED        Bist Even Data pin
    TOD         Bist Odd Data Pin
     
    TA         Bist Read Address
    TCSN     Bist Read Chip Select
    
    TWEN    Bist Write Enable 
    WEN         Write Enable                na     x      na       Low 
    
    WM        Write Margins Code          x      x      na       -
     

******************** END OF HEADER ****************************/


//********************************************//
// ST_SPREG_LOLEAK_1024x19m4_Tl Verilog Model                 //  
//********************************************//




`ifdef slm
        `define functional
`endif

`celldefine
`suppress_faults
  `ifdef functional
   `delay_mode_unit
  `else
   `delay_mode_path
  `endif

`define setup_time 0.0
`define hold_time 0.0
`define access_time 1.0
`define retain_time 0.9
`define cycle_time 0.0
`define pulse_width_time 0.0
`define initin_low_pulse 0.0



 






`timescale 1ns / 1ps


module ST_SPREG_LOLEAK_1024x19m4_Tl (A,ATP,CK,CSN,D ,IG,INITN , Q ,RM    ,SCTRLI,SCTRLO,SDLI,SDLO,SDRI,SDRO,SE,SLEEP   , STDBY  ,TA,TBIST   ,TBYPASS ,TCSN,TED ,TOD   ,TWEN ,WEN,WM  );

 parameter
  Words = 1024,
  Bits = 19,
  Addr = 10,
  mux = 4,
  repair_address_width = 8,
  write_margin_size = 2, 
  read_margin_size = 3; 

 //  INPUT OUTPUT PORTS DECLARATION DONE SEPARATELY FOR SPREG and ROM
 // ========================


        output [Bits-1 : 0] Q;
         
        output SCTRLO;
        input SE,SCTRLI;
        
        input [Addr-1 : 0] A;
        
        input [read_margin_size-1 : 0] RM;
        
         
        input CK,CSN,INITN,IG,ATP; 
        
        
        input [Addr-1 :0 ] TA;
input TBIST,TCSN ;
        
        input STDBY;
        
        input SLEEP; 
        
         
        
        
         
        output SDLO;
        output SDRO;
        
        
        
        
        input [Bits-1 : 0] D ;
	
          
         
        
        input [write_margin_size-1 : 0] WM;
        
        
        input TBYPASS;
        
        input WEN;
        
        
         
        input SDLI,SDRI  ; 
        
        
        
        //Bist inputs
        // ===========
        input TWEN,TED,TOD; 
        
        
        
        

        






    parameter
        Fault_file_name = "ST_SPREG_LOLEAK_1024x19m4_Tl_faults.txt",
        `ifdef ConfigFault
        ConfigFault = 1,
        `else
        ConfigFault = 0,
        `endif
        max_faults = 1026,
        
        MEM_INITIALIZE  = 1'b0,
        BinaryInit = 1'b0, 
        InitFileName = "ST_SPREG_LOLEAK_1024x19m4_Tl.cde",
        Debug_mode = "all_warning_mode",
        File_load_time=0,
        Initn_reset_value={19{1'b0}},
        InstancePath = "ST_SPREG_LOLEAK_1024x19m4_Tl";
    
    parameter
        
        bank = 1, 
        mux_bits=2,
        Red_extrabit=0,
        bank_bits = 0,
        RedWords = mux * 2 * bank,
        max_address_bits = 15 ,
        Rows = Words/mux;

  
    parameter 

     

        
           scanchains=3,    
          
        
        scanlen_ctrl=15,
        
        

      

        
        scanlen_r=(Bits)/2,
        
        scanlen_l=(Bits+1)/2 ; 
      
      

    parameter
        
        `ifdef functional  
            RW_assertions_en = 0,
        `endif
        WordX = {Bits{1'bx}},
        AddrX = {Addr{1'bx}},
        Word0 = {Bits{1'b0}},
        X = 1'bx;
   



//  WIRE DECLARATION RELATED TO POWER PINS
//  ======================================
	
        wire supply_ok, full_shutdown;
        
        wire core_supply_ok;
        wire peri_supply_ok;

        wire gndmint, gndsmint;
         
        
        wire vddmpint;
        wire vddmoint;
        wire vddmaint;
        wire vddsmpint;  
        wire vddsmaint;  
        
        

//  WIRE DECLARATION 
//  ==================
        wire [Bits-1 : 0] CSWEMTBYPASS;
        wire [Bits-1 : 0] Dint, Dsys;
        wire [Bits-1 : 0] Mint; 
        wire [19-1:0] Msys;
	wire [Addr-1 : 0] Aint;
        wire [Addr-1 : 0] Asys;

       


        wire [max_address_bits-1 : 0] A_int; 
                
	wire CKint_dft;
	wire CKint_func;
	wire CSNint;
        wire MEMEN;
        wire MEMEN_dft;
        wire TSE;

	wire WENint;
	wire WENsys;
        wire SLEEPint;
        wire STDBYint;
        wire SEint;
        wire SEsys;
        wire SCTRLIint;
        wire SDLIint;
        wire SDRIint;
        
        wire INITNint;
        wire TBYPASSint;
        wire TBYPASSsys;
        wire LSint; 
        wire HSint; 
        wire ATPint;
        wire DEint;
        
        wire [Addr-1 : 0] TAint;
        wire TBISTint;
        wire TBISTsys;
        wire TCSNint;
        wire TEDint;
        wire TODint;
        wire TEMint;
        wire TOMint;
        wire [Bits-1 : 0] TMint;
        wire [Bits-1 : 0] TDint;
        wire TWENint;
        wire IGint;
        wire IGbuf;
        wire CSNbuf;
        wire WENbuf;
        wire [read_margin_size-1:0] RMint;
        wire [write_margin_size-1:0] WMint;

        //Wires for scan chains
        //  ====================     
        wire [scanlen_ctrl -1:0]scanreg_ctrl_wire;
        wire [scanlen_l -1:0]  scanreg_dl_wire; 
        wire [scanlen_r -1:0]  scanreg_dr_wire; 
   
        wire [scanlen_l -1:0]  scanreg_ml_wire; 
        wire [scanlen_r -1:0]  scanreg_mr_wire; 


        wire [repair_address_width -1 : 0] RRAint;
        wire RRAEint;
        wire TRRAEint;    
        wire red_en;
        wire [repair_address_width -1 : 0] repair_add, next_repair_add;


//  REG DECLARATION
//  ====================     
        reg MEMEN_reg;
        reg MEMEN_prev;
        reg reg_mem_block;
        reg flag_mem_block;
        reg SCTRLIint_temp;
        reg SDLIint_temp;
        reg SDRIint_temp;
        reg SMLIint_temp;
        reg SMRIint_temp;

        //  REG DECLARATION
        //  ====================
        reg SCTRLOint;
        
        reg SDLOint,SDROint;
         
        
        reg next_cycle_corrupt_func;
        reg next_cycle_corrupt_dft;
        reg [Bits-1 : 0] delOutReg_data;//delayed Output Register
        reg [Bits-1 : 0] OutReg_data;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_tbypass;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_scan;   // Data Output registe
        reg [Bits-1 : 0] OutReg_rado_retained;   // register for retaining rado data when SLEEP --> 1
        reg delSCTRLO_data,SCTRLO_data;      // delayed Output Register
        reg delSDLO_data,SDLO_data;      // delayed Output Register
        reg delSDRO_data,SDRO_data;      // delayed Output Register
        
        
        // SCAN CHAINS register
        reg scanreg_ctrl; 
        reg scanreg_dl; 
        reg scanreg_dr; 
        
        
        reg CK_sc;
        reg Latch_open=0;
        reg lastCK_dft,CKreg_dft;
        reg lastCK_func,CKreg_func;
        reg lastSLEEP;
        reg lastPSWLARGEMP,lastPSWLARGEMA,lastPSWSMALLMP,lastPSWSMALLMA;
        reg CSNreg;
        reg init_pulse_done; //if == 1 then it implies that initb low pulse has been applied
        reg power_up_done; //if == 1 then it implies that power up has been done
        `ifdef slm
        `else
	      
             reg [Bits-1 : 0] Mem [Words-1 : 0];
             reg [Bits-1 : 0] RedMem [RedWords-1 : 0];
 
        `endif
        
	reg [Bits-1 :0] Mem_temp;
        reg [Bits-1 :0] Mem_slm; 
	reg ValidAddress;
	reg ValidDebugCode;
        reg decoding_start;
        reg file_loaded;
        reg [Bits-1 :0] Dreg;
        reg [Bits-1 :0] Mreg;
        reg WENreg;
        reg [Addr-1 :0] Areg;
        reg SE_reg;
        reg TBYPASS_reg;
        reg INITNreg;
        reg IGreg;
        reg DEreg;
        reg SLEEPreg;
        reg STDBYreg;
        reg ATPreg;
        reg MEMEN_dft_reg;
        reg MEMEN_dft_prev;
        reg RRMATCHreg;
        reg RRMATCHreg_last;//changes_made
        reg RRMATCHreg_glitch;
        reg [repair_address_width -1 : 0] repair_add_last;
        reg RRAEint_last;
        reg [Addr-mux_bits-1:0] row_add_temp;
        reg [Addr-mux_bits-bank_bits-1:0] row_add_cmp_temp;

       
        //parameter registers
        reg [2047:0] reg_Fault_file_name;
        reg reg_ConfigFault;
        reg reg_MEM_INITIALIZE;
        reg reg_BinaryInit;
        reg [2047:0] reg_InitFileName;
        reg [Bits -1 :0] reg_Initn_reset_value;
        time reg_File_load_time;

        //Power Supply Registers        
        reg vddmireg;
        reg vddmreg;
        reg vddsmreg;
        reg gndmreg;
        reg gndsmreg;   
        reg vddmpreg;
        reg vddmpireg;
        reg vddmareg;
        reg vddsmpreg;
        reg vddsmareg;
        reg vddmoreg;
        time vddmp_rise_time;
        time vddmp_fall_time;
        time vddsmp_rise_time;
        time vddsmp_fall_time;
        time vddma_rise_time;
        time vddma_fall_time;
        time vddsma_rise_time;
        time vddsma_fall_time;
        reg reg_check_rise;
        reg reg_check_fall;
        reg reg_check_rise_vddma;
        reg reg_check_fall_vddsma;
        reg  reg_check_rise_vddm, reg_check_fall_vddsm ;
        time vddm_fall_time,  vddm_rise_time,  vddsm_fall_time, vddsm_rise_time ;
  /* This register is used to force all warning messages 
  ** OFF during run time.
  ** It is a 2 bit register.
  ** USAGE :
  ** debug_level_off = 2'b00 -> ALL MESSAGES(INFO/WARNINGS/ERRORS) will be DISPLAYED 
  ** debug_level = 2'b01     -> ONLY WARNINGS/ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b10     -> ONLY ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b11     -> NO MESSAGES will be DISPLAYED.
  */ 
        reg [1:0] debug_level;
        reg [8*10: 0] operating_mode;
        reg [8*44: 0] message_status;

        integer i, k, j, l,m,q,w,r,s,num1,redcnt,n,num2,FirstHalf,Bfaileff,memcnt,ptr;
        integer decoder[Bits-1:0];
        `ifdef slm
           integer MemAddr;
        `endif


        //************************************************************
        //****** CONFIG FAULT IMPLEMENTATION VARIABLES*************** 
        //************************************************************ 

        integer file_ptr, ret_val;
        integer fault_word;
        integer fault_bit;
        integer fcnt, Fault_in_memory,faultnum,stop_loop,count;
        integer t;  
        integer FailureLocn [max_faults -1 :0];
        integer Failurebit [max_faults -1 :0];
        reg [100 : 0] stuck_at;
        reg [100 : 0] fault_array;
        reg [200 : 0] tempStr;
        reg [7:0] fault_char;
        reg [7:0] fault_char1; // 8 Bit File Pointer
        reg [Addr -1 : 0] std_fault_word;
        reg [Addr -1 : mux_bits] fault_row_add [max_faults -1 :0];
        reg [max_faults -1 :0] fault_repair_flag;
        reg [max_faults -1 :0] dont_insert_fault;
        reg [max_faults -1 :0] repair_flag;
        reg [100 : 0] array_stuck_at[max_faults -1 : 0] ;
        reg [100 : 0] mem_red_array_stuck_at[max_faults -1 : 0] ; 
        reg msgcnt;
        
       
        reg [Bits - 1: 0] stuck_at_0fault [max_faults -1 : 0];
        reg [Bits - 1: 0] stuck_at_1fault [max_faults -1 : 0];
        reg [Bits -1 : 0] stuck0;
        reg [Bits -1 : 0] stuck1;

        reg [Bits+Red_extrabit :0] Mem_last;
        

        `ifdef slm
        reg [Bits -1 : 0] slm_temp_data;
        `endif
        
        real time_CK_func_rise , time_RADCK_rise;
        real time_fall_sleep,time_fall_PSWLARGEMP,time_fall_PSWLARGEMP_0,time_fall_PSWLARGEMA,time_fall_PSWLARGEMA_0,time_fall_PSWSMALLMP,time_fall_PSWSMALLMA;
        integer flag_error;
        
//BUFFER INSTANTIATION
//=========================
       `ifdef functional
       
         buf (SCTRLO,delSCTRLO_data); 
         buf bufq [Bits-1:0] (Q,delOutReg_data);
      `else
       
         buf (SCTRLO,SCTRLO_data);
         buf bufq [Bits-1:0] (Q,OutReg_data);
      `endif
      
  
        buf (SEsys,SE);
	buf (SCTRLIint, SCTRLI);
   

	buf (CKint_func, CK);
	buf (CKint_dft, CK);
        buf bufaddr [Addr-1:0] (Asys,A);
        buf (INITNint,INITN);
        
        buf (LSint,1'b0); 
        buf (IGbuf,IG);
        buf (ATPint,ATP);

        buf bufTaddr [Addr-1 : 0] (TAint,TA);
        buf (TBISTsys,TBIST);
        buf (TCSNint,TCSN);

        buf (CSNsys,CSN);
        buf (STDBYint,STDBY );   
        
        buf (SLEEPint,SLEEP ); 

        buf bufrm [read_margin_size-1:0] (RMint, RM); 

        
        

        assign RRAEint = 1'b0;
        assign TRRAEint = 1'b0;
        assign repair_add = 0;
        assign next_repair_add = 0;
        assign red_en = 1'b0; 
        
        
        
        
        
        
        
        buf (PSWLARGEMPint,1'b0);
        buf (PSWSMALLMPint,1'b0); 
        buf (PSWLARGEMAint,1'b0);
        buf (PSWSMALLMAint,1'b0);   

      `ifdef functional
       
       
         buf (SDLO,delSDLO_data);
         buf (SDRO,delSDRO_data);
        
      `else
       
         buf (SDLO,SDLO_data);
         buf (SDRO,SDRO_data);
         
      `endif
       
         
       
        buf bufdata [Bits-1:0] (Dsys,D);
        
        
        assign Msys=19'b0; 
	

        
        buf (TBYPASSsys, TBYPASS);
        


        buf (WENsys,WEN);
	 
	buf (SDLIint, SDLI);
	buf (SDRIint, SDRI);
	 
        
        buf (HSint,1'b0); 

        
        buf (TEDint,TED);
        buf (TODint,TOD);
         
        buf (TWENint,TWEN);
        
        
        buf bufwm [write_margin_size-1:0] (WMint, WM); 
        



//      assign scanreg_ctrl_wire={scanreg_ctrl[scanlen_ctrl - 2:0],SCTRLIint};
//      assign scanreg_dl_wire={scanreg_dl[scanlen_l - 2:0],SDLIint};
//      assign scanreg_dr_wire={scanreg_dr[scanlen_r - 2:0],SDRIint};
      
        
      assign Aint   = (TBISTint === 1'b0 ) ? Asys : (TBISTint === 1'bx ) ? {Addr{1'bx}} : TAint;  

        
//        assign A_int = Aint;
	
        
                
        assign Dint[0] = (TBISTint === 1'b0) ? Dsys[0] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[1] = (TBISTint === 1'b0) ? Dsys[1] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[2] = (TBISTint === 1'b0) ? Dsys[2] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[3] = (TBISTint === 1'b0) ? Dsys[3] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[4] = (TBISTint === 1'b0) ? Dsys[4] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[5] = (TBISTint === 1'b0) ? Dsys[5] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[6] = (TBISTint === 1'b0) ? Dsys[6] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[7] = (TBISTint === 1'b0) ? Dsys[7] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[8] = (TBISTint === 1'b0) ? Dsys[8] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[9] = (TBISTint === 1'b0) ? Dsys[9] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[10] = (TBISTint === 1'b0) ? Dsys[10] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[11] = (TBISTint === 1'b0) ? Dsys[11] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[12] = (TBISTint === 1'b0) ? Dsys[12] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[13] = (TBISTint === 1'b0) ? Dsys[13] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[14] = (TBISTint === 1'b0) ? Dsys[14] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[15] = (TBISTint === 1'b0) ? Dsys[15] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[16] = (TBISTint === 1'b0) ? Dsys[16] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[17] = (TBISTint === 1'b0) ? Dsys[17] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[18] = (TBISTint === 1'b0) ? Dsys[18] : (TBISTint === 1'b1) ? TEDint : 1'bx;          
	 
        assign Mint = 19'b0;
         

        assign WENbuf = (TBISTint === 1'b0 ) ? WENsys : (TBISTint === 1'bx ) ? 1'bx : TWENint;  
        assign WENint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? WENbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[13] : (ATPint === 1'b0 ) ? WENsys : 1'bx ; 
        
        assign CSNbuf = (TBISTint === 1'b0 ) ? CSNsys : (TBISTint === 1'bx ) ? 1'bx : TCSNint;  
        assign CSNint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? CSNbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[11] : (ATPint === 1'b0 ) ? CSNsys : 1'bx ; 
        assign IGint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? IGbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[14] : (ATPint === 1'b0 ) ? IGbuf : 1'bx;

        
        assign DEint = (LSint === 1'bx || (LSint === 1'b0 && HSint === 1'bx) || ^RMint !== 1'b0 || ^WMint !== 1'b0 ) ? 1'bx : 1'b0;
        
     
     and (TBISTint, ATPint, TBISTsys);
     and (SEint, ATPint, SEsys);
     and (TBYPASSint, ATPint, TBYPASSsys);
     and (TSE,TBYPASSint,!SEsys);
     and (MEMEN,INITNint,!CSNint,!SLEEPint,!TBYPASSint,!SEint,!IGint,!DEint,!STDBYint );
     and (MEMEN_dft,INITNint, !SLEEPint, ATPint,!STDBYint);

 `ifdef functional
/*****************assertions added to optimize dynamic power consumption**********/

//psl a_M: assert always ({( RW_assertions_en);(MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1))  } |-> (stable(Msys))) @(posedge CK); 

//psl a_WEN: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(WENsys))) @(posedge CK); 

//psl a_A: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(Asys))) @(posedge CK); 

//psl a_D: assert always ({( RW_assertions_en);((MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1)) && TBYPASSint === 1'b0)  } |-> (stable(Dsys))) @(posedge CK); 

/**********************************************************************************************/
`endif       

     

         
reg vddmp,vddmo, vddma, vddsmp, vddsma, gndsm, gndm,  vddmpi ; 
 
initial 
begin

        vddmp = 1'b1 ; 
        vddmo = 1'b1 ;
        vddma = 1'b1 ;
        
        vddsmp = 1'b1 ;
        
        
         gndm = 1'b0 ;
          
end

        
         assign gndmint = (reg_mem_block === 0) ? gndm : 1'b1;
         
         
         
         
         assign vddmpint = vddmp;
         assign vddmoint = vddmo;
         assign vddmaint = vddma;
         
          
        
         

        //CPF Changes

        
                
        initial
        begin : cpfvddmp 
           vddmpreg = vddmpint;
        end

        always @(vddmpint) begin
           vddmpreg = vddmpint;
        end
        
        initial
        begin : cpfvddmo 
           vddmoreg = vddmoint;
        end

        always @(vddmoint) begin
           vddmoreg = vddmoint;
        end
        
        initial
        begin : cpfvddma 
           vddmareg = vddmaint;
        end

        always @(vddmaint) begin
           vddmareg = vddmaint;
        end

        
        
 
        initial
        begin : cpfgndm 
           gndmreg = gndmint;
        end

        always @(gndmint) begin
           gndmreg = gndmint;
        end

        
        



 `ifdef functional
  `else
  initial begin
    if (debug_level < 1) begin
     $display ("%m  INFORMATION");
     $display ("***************************************");
     $display ("The Model is Operating in TIMING MODE");
     $display ("Please make sure that SDF is properly annotated otherwise dummy values will be used");
     $display ("%s", message_status);
     $display ("***************************************");
    end
  end

//////////////////////////
 //REG DECLARATIONS
   //======================

   reg [Bits-1 : 0] TimingViol_data;
   reg  [Bits-1 : 0] TimingViol_mask;
   reg [Bits-1 : 0] TimingViol_data_last, TimingViol_mask_last;
	reg TimingViol_data_0;
	reg TimingViol_data_1;
	reg TimingViol_data_2;
	reg TimingViol_data_3;
	reg TimingViol_data_4;
	reg TimingViol_data_5;
	reg TimingViol_data_6;
	reg TimingViol_data_7;
	reg TimingViol_data_8;
	reg TimingViol_data_9;
	reg TimingViol_data_10;
	reg TimingViol_data_11;
	reg TimingViol_data_12;
	reg TimingViol_data_13;
	reg TimingViol_data_14;
	reg TimingViol_data_15;
	reg TimingViol_data_16;
	reg TimingViol_data_17;
	reg TimingViol_data_18;
 reg TimingViol_mask_0;
 reg TimingViol_mask_1;
 reg TimingViol_mask_2;
 reg TimingViol_mask_3;
 reg TimingViol_mask_4;
 reg TimingViol_mask_5;
 reg TimingViol_mask_6;
 reg TimingViol_mask_7;
 reg TimingViol_mask_8;
 reg TimingViol_mask_9;
 reg TimingViol_mask_10;
 reg TimingViol_mask_11;
 reg TimingViol_mask_12;
 reg TimingViol_mask_13;
 reg TimingViol_mask_14;
 reg TimingViol_mask_15;
 reg TimingViol_mask_16;
 reg TimingViol_mask_17;
 reg TimingViol_mask_18;

   reg TimingViol_addr;
   reg TimingViol_CSN, TimingViol_WEN, TimingViol_tbypass;
   reg TimingViol_tckh, TimingViol_tckl, TimingViol_tcycle;
   reg TimingViol_tckh_se, TimingViol_tckl_se, TimingViol_tcycle_se;
   reg TimingViol_sctrli,TimingViol_sdli,TimingViol_sdri,TimingViol_se;
   reg TimingViol_smli,TimingViol_smri;
   reg TimingViol_sctrli_flag,TimingViol_sdli_flag,TimingViol_sdri_flag;
   reg TimingViol_smli_flag,TimingViol_smri_flag;
   reg TimingViol_initnl;
   reg TimingViol_initn;
   reg TimingViol_ls;
   reg TimingViol_hs;
   reg TimingViol_sleep;
   reg TimingViol_stdby;
   reg TimingViol_rm;
   reg TimingViol_wm;
   reg TimingViol_tbist,TimingViol_ig,TimingViol_atp,TimingViol_TED,TimingViol_TOD,TimingViol_TEM,TimingViol_TOM;
   reg TimingViolRRAE,TimingViolRRA;

   wire CSTBYPASSN,cond_sdf_tas,cond_sdf_tds,cond_sdf_tms,cond_sdf_tws,cond_sdf_tbas,cond_sdf_tbps,cond_sdf_tbws,cond_sdf_tbdes,cond_sdf_tbdos,cond_sdf_tbmes,cond_sdf_tbmos;
   wire SETB_EN,CSIG_EN,MEM_ACT,EN_ADM,CS_EN,CS_ADM,cond_sdf_tps,IG_EN,IG_ADM,cond_sdf_tigs,cond_sdf_taa,cond_sdf_taa_ls1,cond_sdf_taa_hs1,cond_tseq_tm;
   wire cond_sdf_tcycle,cond_sdf_tcycle_ls1,cond_sdf_tcycle_hs1,cond_sdf_tcycle_se,cond_sdf_tckl_se,cond_sdf_tsctrlis,cond_sdf_tsdlis,cond_sdf_tsdris,cond_sdf_tsmlis,cond_sdf_tsmris;
   wire cond_sdf_tckh_se,cond_sdf_taa_sctrlo_se,cond_sdf_taa_sdlo_se,cond_sdf_taa_sdro_se,cond_sdf_taa_smlo_se,cond_sdf_taa_smro_se,cond_sdf_tckl,cond_sdf_tckh;
   wire cond_sdf_ttms,cond_sdf_tbists,INITNandnotSLEEPandATPandnotSE,cond_sdf_taa_sctrlo,cond_sdf_taa_sdlo,cond_sdf_taa_sdro,cond_sdf_taa_smlo,cond_sdf_taa_smro;
   wire cond_sdf_taa_tm,cond_sdf_taa_tm_ls1, cond_sdf_taa_tm_hs1,cond_sdf_taa_tckq_tm,cond_sdf_taa_tseq_tm;

   wire CSWETBYPASSN;
   wire cond_sdf_tstdbys,cond_sdf_tsls,sleep_en,atp_csn_en;
   wire cond_sdf_tlss,cond_sdf_thss,cond_sdf_trms,cond_sdf_twms; 
   wire cond_sdf_tses,cond_sdf_tinitns;
   wire tby_se_en;
   wire rra_en;
   wire tbist_atp_en;
   wire rrae_en;
   wire tbist_rrae_en;
   wire cond_sdf_trraes;
   wire cond_sdf_ttrraes;
   wire cond_sdf_taa_trramatch;
   wire cond_sdf_ttrraematch;
   wire cond_sdf_tamatch;
   wire cond_sdf_ttamatch;
   wire cond_sdf_tatpmatch;
   wire cond_sdf_ttbistmatch;



 and (CSWEMTBYPASS[0], !Mreg[0], CSWETBYPASSN);
 and (CSWEMTBYPASS[1], !Mreg[1], CSWETBYPASSN);
 and (CSWEMTBYPASS[2], !Mreg[2], CSWETBYPASSN);
 and (CSWEMTBYPASS[3], !Mreg[3], CSWETBYPASSN);
 and (CSWEMTBYPASS[4], !Mreg[4], CSWETBYPASSN);
 and (CSWEMTBYPASS[5], !Mreg[5], CSWETBYPASSN);
 and (CSWEMTBYPASS[6], !Mreg[6], CSWETBYPASSN);
 and (CSWEMTBYPASS[7], !Mreg[7], CSWETBYPASSN);
 and (CSWEMTBYPASS[8], !Mreg[8], CSWETBYPASSN);
 and (CSWEMTBYPASS[9], !Mreg[9], CSWETBYPASSN);
 and (CSWEMTBYPASS[10], !Mreg[10], CSWETBYPASSN);
 and (CSWEMTBYPASS[11], !Mreg[11], CSWETBYPASSN);
 and (CSWEMTBYPASS[12], !Mreg[12], CSWETBYPASSN);
 and (CSWEMTBYPASS[13], !Mreg[13], CSWETBYPASSN);
 and (CSWEMTBYPASS[14], !Mreg[14], CSWETBYPASSN);
 and (CSWEMTBYPASS[15], !Mreg[15], CSWETBYPASSN);
 and (CSWEMTBYPASS[16], !Mreg[16], CSWETBYPASSN);
 and (CSWEMTBYPASS[17], !Mreg[17], CSWETBYPASSN);
 and (CSWEMTBYPASS[18], !Mreg[18], CSWETBYPASSN);

and (atp_csn_en,!ATPint,!CSNint,!IGint);
or (sleep_en,atp_csn_en,ATPint);
or (SETB_EN,SEint,TBISTint);
and (ATP_SETB_EN,ATPint,SETB_EN); 
or (CSIG_EN,IGint,CSNint);
and (MEM_ACT,!ATPint,CSIG_EN);
or (EN_ADM,MEM_ACT,ATP_SETB_EN);
and (CS_EN,!ATPint,IGint);
or (CS_ADM,CS_EN,ATP_SETB_EN);
and (atp_ig_csn_en,!ATPint,!CSNint,!IGint);
and (atp_se_en,!SEsys,ATPint);
or (cycle_en,atp_ig_csn_en,atp_se_en);
and (atp_ig_csn_en_reg,!ATPreg,!CSNreg,!IGreg);
and (atp_se_en_reg,!SE_reg,ATPreg);
or (cycle_en_reg,atp_ig_csn_en,atp_se_en);
and (INITNandnotSLEEPandATPandnotSE,cond_gac,!SEsys,ATPint);
and (csn_ig_en,!IGint,!CSNint);
and (atp_tby_ls_en,atp_se_en,cond_ls_tby_en);
and (IG_EN,!ATPint,!CSNint);
or (IG_ADM,IG_EN,atp_se_en);
and (CSWETBYPASSN, !WENreg, 1'b1);



assign cond_sdf_tsls=((sleep_en && INITNint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tstdbys=((sleep_en && INITNint && !SLEEPint) !==0) ? 1:0;
assign cond_sdf_atps=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_gac=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tas=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tds=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tms=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tws=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tps=((cond_gac && !CS_ADM) !==0) ? 1:0;
assign cond_sdf_tcycle=((cond_gac && cycle_en && !LSint && !HSint) !==0) ? 1:0;  
assign cond_sdf_tcycle_ls1=((cond_gac && cycle_en && LSint) !==0) ? 1:0;
assign cond_sdf_tcycle_hs1=((cond_gac && cycle_en && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_tckh=((cond_gac && cycle_en_reg) !==0) ? 1:0;
assign cond_sdf_tckl=((cond_gac && cycle_en) !==0) ? 1:0;
assign cond_sdf_tcycle_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckl_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsctrlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckh_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_ttms=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_tbists=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_tckq_tm=((cond_gac && SE_reg && ATPreg && TBYPASSsys) !==0) ? 1:0;
assign cond_ls_en=((atp_ig_csn_en || atp_tby_ls_en) !==0) ? 1:0;
assign cond_sdf_tlss=((cond_ls_en && cond_gac) !==0) ? 1:0;
assign cond_sdf_thss=((cond_ls_en && cond_gac && !LSint) !==0) ? 1:0;
assign cond_sdf_trms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_twms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_tses=((cond_gac && ATPint) !==0) ? 1:0;
assign cond_sdf_tbas=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbps=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbws=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tigs=((cond_gac && IG_ADM) !==0) ? 1:0;
assign cond_sdf_taa=((MEMEN_reg && WENreg && !LSint && !HSint) !==0) ? 1:0; 
// assign cond_sdf_taa_tbypass_q = ((MEMEN_reg && ATPint && TBYPASSint) !== 1'b0) ? 1'b1 : 1'b0;
assign cond_sdf_taa_ls1=((MEMEN_reg && WENreg && LSint) !==0) ? 1:0; 
assign cond_sdf_taa_hs1=((MEMEN_reg && WENreg && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && !HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_ls1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && LSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_hs1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tseq_tm=((cond_gac && TBYPASSint) !==0) ? 1:0;
assign cond_sdf_tinitns =(( sleep_en && !STDBYint && !SLEEPint) !==0) ? 1:0;
assign cond_ls_tby_en=((TBYPASSsys || csn_ig_en) !==0) ? 1:0;



//specify block begins

specify
    specparam
    
         PATHPULSE$CK$Q = 0,
         PATHPULSE$CK$SCTRLO = 0,

         PATHPULSE$CK$SDLO = 0,
         PATHPULSE$CK$SDRO = 0,
        
         PATHPULSE$SE$Q = 0,
         
//         PATHPULSE$TBYPASS$Q = 0,


        
         
        
         tsls = `setup_time,
         tslh = `hold_time ,
         tstdbys = `setup_time,
         tstdbyh = `hold_time , 
	 

         
         tcycle = `cycle_time,
         
         
         tckh = `pulse_width_time,
         tckl = `pulse_width_time,
         tcycle_se = `cycle_time,
         tckh_se = `pulse_width_time,
         tckl_se = `pulse_width_time,
         
         ttms = `setup_time,
         ttmh = `hold_time ,
         tps = `setup_time,
         tph = `hold_time ,
         tws = `setup_time,
         twh = `hold_time ,
         tds = `setup_time,
         tdh = `hold_time , 
         tas = `setup_time,
         tah = `hold_time ,
         tses= `setup_time,
         tseh= `hold_time ,
         tsctrlis=`setup_time,
         tsctrlih=`hold_time ,
         tsdlis=`setup_time,
         tsdlih=`hold_time ,
         tsdris=`setup_time,
         tsdrih=`hold_time , 
         tbists=`setup_time,
         tbisth=`hold_time ,
         tbps=`setup_time,
         tbph=`hold_time ,
         tbws=`setup_time,
         tbwh=`hold_time ,
         tbdes=`setup_time,
         tbdeh=`hold_time ,
         tbdos=`setup_time,
         tbdoh=`hold_time ,
         
         tbas=`setup_time,
         tbah=`hold_time ,
         tinitnl=`initin_low_pulse,
         tinitns=`setup_time,
         tinitnh=`hold_time ,
         tatps=`setup_time,
         tatph=`hold_time ,
         tigs=`setup_time,
         tigh=`hold_time ,
         
         
         trms=`setup_time,
         trmh=`hold_time ,
         twms=`setup_time,
         twmh=`hold_time , 

/*************************************************************************************************/
           // taa_tbypass_q = `access_time,
           // th_tbypass_q  = `retain_time,
            taa =`access_time,
            th = `retain_time,

 


            taa_tm =`access_time,
            th_tm = `retain_time,

            
            taa_tseq_tm =`access_time,
            th_tseq_tm = `retain_time,
            taa_tckq_tm   = `access_time,
            th_tckq_tm    = `retain_time,
            taa_sctrlo=`access_time,
            th_sctrlo= `retain_time,
            taa_sdlo=`access_time,
            th_sdlo= `retain_time,
            taa_sdro=`access_time,
            th_sdro= `retain_time,
            
         
            taa_sctrlo_se=`access_time,
            th_sctrlo_se= `retain_time
,
            taa_sdlo_se=`access_time,
            th_sdlo_se= `retain_time,
            taa_sdro_se=`access_time,
            th_sdro_se= `retain_time
         ;  


        /*---------------------- Timing Checks ---------------------*/

	$setup(posedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[7], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[8], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[9], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[5], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[6], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[7], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[8], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[9], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[7], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[8], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[9], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[5], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[6], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[7], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[8], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[9], tah, TimingViol_addr);

	$setup(posedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(posedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(posedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(posedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(posedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(posedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(posedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(posedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(posedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(posedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(posedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(posedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(posedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(posedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(posedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(posedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(posedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(posedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(posedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(negedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(negedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(negedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(negedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(negedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(negedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(negedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(negedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(negedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(negedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(negedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(negedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(negedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(negedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(negedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(negedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(negedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(negedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(negedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[18], tdh, TimingViol_data_18);

        



        $setup(posedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $setup(negedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, posedge WEN, twh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, negedge WEN, twh, TimingViol_WEN); 
        $setup(posedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$setup(negedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, posedge CSN, tph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, negedge CSN, tph, TimingViol_CSN);
        $period(posedge CK &&& cond_sdf_tcycle, tcycle, TimingViol_tcycle);  

        
        $width(posedge CK  &&& cond_sdf_tckh, tckh, 0, TimingViol_tckh);
        $width(negedge CK  &&& cond_sdf_tckl, tckl, 0, TimingViol_tckl);
        $period(posedge CK &&& cond_sdf_tcycle_se, tcycle_se, TimingViol_tcycle_se);
        $width(posedge CK  &&& cond_sdf_tckh_se, tckh_se, 0, TimingViol_tckh_se);
        $width(negedge CK  &&& cond_sdf_tckl_se, tckl_se, 0, TimingViol_tckl_se);

        
        $setup(posedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $setup(negedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $hold(posedge CK &&& cond_sdf_ttms, posedge TBYPASS, ttmh, TimingViol_tbypass); 
        $hold(posedge CK &&& cond_sdf_ttms, negedge TBYPASS, ttmh, TimingViol_tbypass); 
 



        
        $setup(posedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $setup(negedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $hold(posedge CK &&& cond_sdf_tsls, posedge SLEEP, tslh, TimingViol_sleep);        
        $hold(posedge CK &&& cond_sdf_tsls, negedge SLEEP, tslh, TimingViol_sleep);

        $setup(posedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $setup(negedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $hold(posedge CK &&& cond_sdf_tstdbys, posedge STDBY, tstdbyh, TimingViol_stdby);        
        $hold(posedge CK &&& cond_sdf_tstdbys, negedge STDBY, tstdbyh, TimingViol_stdby); 
        
        
        $setup (posedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
	$setup (negedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
        
        $hold (posedge CK &&& cond_sdf_tses, posedge SE ,tseh,TimingViol_se);
	$hold (posedge CK &&& cond_sdf_tses, negedge SE ,tseh,TimingViol_se);
        
        $setup(posedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis , tsctrlis, TimingViol_sctrli);
        $setup(negedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis, tsctrlis, TimingViol_sctrli);
        $hold(posedge CK &&& cond_sdf_tsctrlis , posedge SCTRLI, tsctrlih, TimingViol_sctrli);        
        $hold(posedge CK &&& cond_sdf_tsctrlis , negedge SCTRLI, tsctrlih, TimingViol_sctrli);

        $setup(posedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $setup(negedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $hold(posedge CK &&& cond_sdf_tsdlis, posedge SDLI, tsdlih, TimingViol_sdli);        
        $hold(posedge CK &&& cond_sdf_tsdlis, negedge SDLI, tsdlih, TimingViol_sdli);

        $setup(posedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $setup(negedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $hold(posedge CK &&& cond_sdf_tsdris, posedge SDRI, tsdrih, TimingViol_sdri);        
        $hold(posedge CK &&& cond_sdf_tsdris, negedge SDRI, tsdrih, TimingViol_sdri);
        
 
	
         
        $width(negedge INITN , tinitnl, 0, TimingViol_initnl);
        
        $setup(posedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        $setup(negedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        
        $hold (posedge CK &&& cond_sdf_tinitns,posedge INITN, tinitnh, TimingViol_initn);
        $hold (posedge CK &&& cond_sdf_tinitns,negedge INITN, tinitnh, TimingViol_initn);

        $setup(posedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $setup(negedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $hold(posedge CK &&& cond_sdf_atps, posedge ATP, tatph, TimingViol_atp);        
        $hold(posedge CK &&& cond_sdf_atps, negedge ATP, tatph, TimingViol_atp);
        
        $setup(posedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $setup(negedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $hold(posedge CK &&& cond_sdf_tigs, posedge IG, tigh, TimingViol_ig);        
        $hold(posedge CK &&& cond_sdf_tigs, negedge IG, tigh, TimingViol_ig);



         
$setup(posedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[2], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[2], trmh, TimingViol_rm); 

        
$setup(posedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(posedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[1], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[1], twmh, TimingViol_wm);
 
        
        $setup(posedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $setup(negedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $hold(posedge CK &&& cond_sdf_tbists, posedge TBIST, tbisth, TimingViol_tbist);        
        $hold(posedge CK &&& cond_sdf_tbists, negedge TBIST, tbisth, TimingViol_tbist);
        
        	$setup(posedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[7], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[8], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[9], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$setup(negedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[5], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[6], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[7], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[8], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[9], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[6], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[7], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[8], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[9], tbah, TimingViol_addr);
       	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[4], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[5], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[6], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[7], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[8], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[9], tbah, TimingViol_addr);

        $setup(posedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$setup(negedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, posedge TCSN, tbph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, negedge TCSN, tbph, TimingViol_CSN); 
       
        $setup(posedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $setup(negedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, posedge TWEN, tbwh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, negedge TWEN, tbwh, TimingViol_WEN);
       
       
        $setup(posedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $setup(negedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, posedge TED, tbdeh, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, negedge TED, tbdeh, TimingViol_TED);

        $setup(posedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $setup(negedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, posedge TOD, tbdoh, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, negedge TOD, tbdoh, TimingViol_TOD);

          


          

          /*-------------------- Propagation Delays ------------------*/
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa, taa, th, taa, th, taa);
                 

/* // //	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[0] +: OutReg_data[0])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[1] +: OutReg_data[1])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[2] +: OutReg_data[2])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[3] +: OutReg_data[3])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[4] +: OutReg_data[4])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[5] +: OutReg_data[5])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[6] +: OutReg_data[6])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[7] +: OutReg_data[7])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[8] +: OutReg_data[8])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[9] +: OutReg_data[9])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[10] +: OutReg_data[10])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[11] +: OutReg_data[11])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[12] +: OutReg_data[12])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[13] +: OutReg_data[13])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[14] +: OutReg_data[14])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[15] +: OutReg_data[15])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[16] +: OutReg_data[16])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[17] +: OutReg_data[17])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[18] +: OutReg_data[18])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q); */ 








	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                





	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                 

	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[0] +: OutReg_data[0])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[1] +: OutReg_data[1])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[2] +: OutReg_data[2])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[3] +: OutReg_data[3])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[4] +: OutReg_data[4])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[5] +: OutReg_data[5])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[6] +: OutReg_data[6])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[7] +: OutReg_data[7])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[8] +: OutReg_data[8])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[9] +: OutReg_data[9])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[10] +: OutReg_data[10])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[11] +: OutReg_data[11])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[12] +: OutReg_data[12])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[13] +: OutReg_data[13])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[14] +: OutReg_data[14])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[15] +: OutReg_data[15])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[16] +: OutReg_data[16])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[17] +: OutReg_data[17])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[18] +: OutReg_data[18])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                



if (cond_sdf_taa_sctrlo) 
        (posedge CK *> (SCTRLO :  SCTRLI)) = (taa_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo); 

if (cond_sdf_taa_sctrlo_se) 
        (negedge CK *> (SCTRLO : SCTRLI)) = (taa_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se); 
 

if (cond_sdf_taa_sdlo) 
        (posedge CK *> (SDLO :  SDLI)) = (taa_sdlo,taa_sdlo,th_sdlo,taa_sdlo,th_sdlo,taa_sdlo); 

if (cond_sdf_taa_sdlo_se) 
        (negedge CK *> (SDLO : SDLI)) = (taa_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se);

if (cond_sdf_taa_sdro) 
        (posedge CK *> (SDRO :  SDRI)) = (taa_sdro,taa_sdro,th_sdro,taa_sdro,th_sdro,taa_sdro); 

if (cond_sdf_taa_sdro_se) 
        (negedge CK *> (SDRO : SDRI)) = (taa_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se); 

  
     




endspecify //specify block ends






// conversion from registers to array elements for data setup violation notifiers

always @(TimingViol_data_0   or TimingViol_TED  )
begin
        TimingViol_data[0]=~TimingViol_data[0];   
end


always @(TimingViol_data_1   or TimingViol_TOD  )
begin
        TimingViol_data[1]=~TimingViol_data[1];   
end


always @(TimingViol_data_2   or TimingViol_TED  )
begin
        TimingViol_data[2]=~TimingViol_data[2];   
end


always @(TimingViol_data_3   or TimingViol_TOD  )
begin
        TimingViol_data[3]=~TimingViol_data[3];   
end


always @(TimingViol_data_4   or TimingViol_TED  )
begin
        TimingViol_data[4]=~TimingViol_data[4];   
end


always @(TimingViol_data_5   or TimingViol_TOD  )
begin
        TimingViol_data[5]=~TimingViol_data[5];   
end


always @(TimingViol_data_6   or TimingViol_TED  )
begin
        TimingViol_data[6]=~TimingViol_data[6];   
end


always @(TimingViol_data_7   or TimingViol_TOD  )
begin
        TimingViol_data[7]=~TimingViol_data[7];   
end


always @(TimingViol_data_8   or TimingViol_TED  )
begin
        TimingViol_data[8]=~TimingViol_data[8];   
end


always @(TimingViol_data_9   or TimingViol_TOD  )
begin
        TimingViol_data[9]=~TimingViol_data[9];   
end


always @(TimingViol_data_10   or TimingViol_TED  )
begin
        TimingViol_data[10]=~TimingViol_data[10];   
end


always @(TimingViol_data_11   or TimingViol_TOD  )
begin
        TimingViol_data[11]=~TimingViol_data[11];   
end


always @(TimingViol_data_12   or TimingViol_TED  )
begin
        TimingViol_data[12]=~TimingViol_data[12];   
end


always @(TimingViol_data_13   or TimingViol_TOD  )
begin
        TimingViol_data[13]=~TimingViol_data[13];   
end


always @(TimingViol_data_14   or TimingViol_TED  )
begin
        TimingViol_data[14]=~TimingViol_data[14];   
end


always @(TimingViol_data_15   or TimingViol_TOD  )
begin
        TimingViol_data[15]=~TimingViol_data[15];   
end


always @(TimingViol_data_16   or TimingViol_TED  )
begin
        TimingViol_data[16]=~TimingViol_data[16];   
end


always @(TimingViol_data_17   or TimingViol_TOD  )
begin
        TimingViol_data[17]=~TimingViol_data[17];   
end


always @(TimingViol_data_18   or TimingViol_TED  )
begin
        TimingViol_data[18]=~TimingViol_data[18];   
end


`endif


// TASK DEFINITION DESCRIPTION
// ================================



task task_insert_faults_in_memory;
begin
   if (reg_ConfigFault)
   begin   
     for(i = 0;i< fcnt;i = i+ 1) begin
        if(mem_red_array_stuck_at[i] === "mem_array") begin
          if (array_stuck_at[i] === "sa0") begin
           `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data & stuck_at_0fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
          `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] & stuck_at_0fault[i];
          `endif
         end //if(array_stuck_at)
                                        
         if(array_stuck_at[i] === "sa1") begin
         `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data | stuck_at_1fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
         `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] | stuck_at_1fault[i]; 
         `endif
         end //if(array_stuck_at)
       end //if mem_red_array_stuck_at
    
    
     end    // end of for
   end  
end
endtask



task task_read_fault_file;
begin
/*  -----------Implemetation for config fault starts------*/
   msgcnt = X;
   t = 0;
   fault_repair_flag = {max_faults{1'b1}};
   repair_flag = {max_faults{1'b1}};
   if(reg_ConfigFault) 
   begin
      file_ptr = $fopen(reg_Fault_file_name , "r");
      if(file_ptr == 0)
      begin     
          if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: File cannot be opened ",$realtime);
      end        
      else                
      begin : read_fault_file
        t = 0;
        for (i = 0; i< max_faults; i= i + 1)
        begin
         
           stuck0 = {Bits{1'b1}};
           stuck1 = {Bits{1'b0}};
           fault_char1 = $fgetc (file_ptr);
           if (fault_char1 == 8'b11111111)
              disable read_fault_file;
           ret_val = $ungetc (fault_char1, file_ptr);
           ret_val = $fgets(tempStr, file_ptr);
           ret_val = $sscanf(tempStr, "%s %d %d %s",fault_array,fault_word, fault_bit, stuck_at) ;
           flag_error = 0; 
           if(ret_val !== 0)
           begin         
              if(ret_val == 3 || ret_val == 4)
              begin
                if(ret_val == 3)
                   stuck_at = "sa0";

                if(stuck_at !== "sa0" && stuck_at !== "sa1" && stuck_at !== "none")
                begin
                    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: Wrong value for stuck at in fault file ",$realtime);
                   flag_error = 1;
                end    
                      
                if(fault_word >= Words)
                begin
                   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Address out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                if(fault_bit >= Bits)
                begin  
                    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Faulty bit out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                
                        
                if(fault_array !== "mem_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array is not mem_array ",$realtime);
                  flag_error = 1;
                end

                if(fault_array === "red_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array can't be on redundancy array in non redundancy cut.",$realtime);
                  flag_error = 1;
                end

                
                

                if(flag_error == 0)
                //Correct Inputs
                begin
                   if(stuck_at === "none")
                   begin
                       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
                   end
                   else
                   //Adding the faults
                   begin
                      FailureLocn[t] = fault_word;
                      Failurebit[t]  = fault_bit ;
                      std_fault_word = fault_word;
                      fault_row_add[t] = std_fault_word[Addr-1:mux_bits];
                      mem_red_array_stuck_at[t] = fault_array;
                      fault_repair_flag[t] = 1'b0;
                      if (stuck_at === "sa0" )
                      begin
                         stuck0[fault_bit] = 1'b0;         
                         stuck_at_0fault[t] = stuck0;
                      end     
                      if (stuck_at === "sa1" )
                      begin
                         stuck1[fault_bit] = 1'b1;
                         stuck_at_1fault[t] = stuck1; 
                      end

                      array_stuck_at[t] = stuck_at;
                      t = t + 1;
                   end //if(stuck_at === "none")  
                end //if(flag_error == 0)
              end //if(ret_val == 2 || ret_val == 3 
              else
              //wrong number of arguments
              begin
                if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: WRONG VALUES ENTERED FOR FAULTY WORD OR FAULTY BIT OR STUCK_AT IN Fault_file_name ",$realtime); 
                flag_error = 1;
              end
           end //if(ret_val !== 0)
           else
           begin 
               if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
           end    
        end //for (i = 0; i< m
      end //begin: read_fault_file  
      $fclose (file_ptr);

      fcnt = t;
      
      //fault injection at time 0.
      task_insert_faults_in_memory;
  end // config_fault 
end
endtask


task WriteMemX;
begin

`ifdef slm
   $slm_ResetMemory(MemAddr, WordX);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = WordX;
   
`endif        
 task_insert_faults_in_memory;
end
endtask

task WriteMem0;
begin
`ifdef slm
   $slm_ResetMemory(MemAddr, Word0);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = Word0;
  
`endif 
   task_insert_faults_in_memory;
end
endtask


task WriteOutX;                
begin
   OutReg_data <= #0 WordX;
end
endtask


task Invalid_next_cycle_func;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_func = 1;
     `else 
       #0 next_cycle_corrupt_func = 0; 
     `endif  
   end 
end
endtask

task Invalid_next_cycle_dft;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_dft = 1;
     `else 
       #0 next_cycle_corrupt_dft = 0; 
     `endif  
  end
end
endtask

task Invalid_next_cycle_func_tim;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
   #0 next_cycle_corrupt_func <= 1;
  end 
end
endtask

task Invalid_next_cycle_dft_tim;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
  #0 next_cycle_corrupt_dft <= 1;
  end
end
endtask


task ScanOutX;                
begin
   
   dff_SCTRLO_SE.Q <= 1'bx;   
   dff_SDLO_SE.Q <= 1'bx; 
   dff_SDRO_SE.Q <= 1'bx; 
    
   
   SCTRLOint=X;
   SDLOint=X;
   SDROint=X;
    
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   SDLO_data<=1'bx;
   SDRO_data<=1'bx;
    
   `endif
end
endtask

task delScanOutX;                
begin
   delSCTRLO_data<=X;
   delSDLO_data<=X;
   delSDRO_data<=X;
    
end
endtask

task ScanChainX;                
begin
 scanreg_ctrl=1'bx; 
 scanreg_dl=1'bx; 
 scanreg_dr =1'bx; 
  
end
endtask

task mem_blocked;
begin
 
   WriteMemX;
   WriteOutX;
   ScanChainX;
   ScanOutX;//immediately;
   delScanOutX;//immediately
   `ifdef POWER_SEQUENCING_OFF
   `else
   reg_mem_block=1;
   `endif
   debug_level = 2'b11;
end
endtask

task corrupt_all;
begin
 
  WriteMemX;
  WriteOutX;
  ScanChainX;
  ScanOutX;
  delScanOutX;//immediately;
  OutReg_data = WordX; 
  delOutReg_data=WordX;
  
end
endtask

task WriteCycle;                  
input [Addr-1 : 0] Address;
reg [Bits-1:0] tempReg1;
reg [Bits-1:0] tempReg_slm;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;


reg repair_flag;

integer po,i,num,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;
begin

   tempReg1 = WordX;
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];

   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};
   
   if (ValidAddress === X )   begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
        WriteMemX;
        if (INITNint !== 0) begin
        `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
           #0 next_cycle_corrupt_func = 1;
       `else 
           #0 next_cycle_corrupt_func = 0; 
       `endif  
   end 

   end


   if (ValidAddress !== X && next_cycle_corrupt_func === 0  )
   begin
         if (red_en === 1 && ((Row_Add_cmp === repair_add) || (Row_Add_cmp === next_repair_add)) ) begin
             repair_flag = 1'b1;
             
             Bank_sel_integer = 0;
                     
             if (Row_Add_cmp === repair_add) begin
               Col_Add_integer  = Col_Add; 
             end
             else if (Row_Add_cmp === next_repair_add) begin
               Col_Add_integer  = Col_Add + mux; 
             end  
             RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
        end  

        if(repair_flag === 0 && ValidAddress === 1) begin
           `ifdef slm
              $slm_ReadMemoryS(MemAddr, Address, tempReg_slm);
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = Mem[Address];
            `endif
          end  
        else if(repair_flag === 1) begin
           `ifdef slm
//              $slm_ReadMemoryS(RedMemAddr, RedMem_address, tempReg_slm);
          
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = RedMem[RedMem_address];
            `endif
        end
        
        for (num=0;num<Bits;num=num+1) begin
             po=num;        
             if ( Dint [num] !== tempReg1 [po]) begin
                if (Mint[num] === 1'b0)
                   tempReg1[po] = Dint[num];
                else if (Mint[num] === 1'bX)
                   tempReg1[po] = 1'bx;
             end                
        end //for (num=0
            
         if(repair_flag === 0 ) begin    
            if(ValidAddress === 1) begin  
              `ifdef slm
                  tempReg_slm=tempReg1; 
                  $slm_WriteMemory(MemAddr, Address, tempReg_slm);
              `else
                   Mem[Address] = tempReg1;
              `endif
            end
            else begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address Out Of Range. ",$realtime);
            end        
         end
         else if (repair_flag === 1 ) begin
            `ifdef slm
                tempReg_slm=tempReg1; 
//                $slm_WriteMemory(RedMemAddr, RedMem_address, tempReg_slm);
            `else
                RedMem[RedMem_address] = tempReg1;
            `endif
         end
   end //if (ValidAddress !== X
   task_insert_faults_in_memory;
end
endtask 

task ReadCycle;
input [Addr-1 : 0] Address;

reg [Bits-1:0] MemData_tmp;
reg [Bits-1:0] MemData;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;

reg repair_flag;

integer a,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;

begin
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];
   
   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};

   

   if (ValidAddress !== X && next_cycle_corrupt_func === 0 ) begin   
       if(red_en === 1 && ( Row_Add_cmp === repair_add ||  Row_Add_cmp === next_repair_add )) begin
              repair_flag = 1;
              
              Bank_sel_integer = 0;
               
              if(Row_Add_cmp === repair_add) begin
                Col_Add_integer = Col_Add;
              end
              else if (Row_Add_cmp === next_repair_add) begin
                Col_Add_integer = Col_Add + mux; 
              end
              RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
       end

      if(repair_flag === 0) begin
          if(ValidAddress === 1) begin 
           `ifdef slm
              $slm_ReadMemory(MemAddr, Address, MemData);
           `else
              MemData = Mem[Address];
           `endif
          end
          else begin
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Address Out Of Range. Output Corrupted ",$realtime);
             MemData = WordX;
          end
     end
      else if(repair_flag === 1) begin
        `ifdef slm
//           $slm_ReadMemory(RedMemAddr, RedMem_address, MemData);
        `else
           MemData = RedMem[RedMem_address];
        `endif
      end
   end //if (ValidAddress)  
   
   if(ValidAddress === X)
   begin
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Illegal Value on Address Bus. Memory and Output Corrupted ",$realtime); 
         Invalid_next_cycle_func;
   end 
   
  if(ValidAddress !== X && next_cycle_corrupt_func === 0 )
   begin
   for (a = 0; a < Bits; a = a + 1)
   begin
      if (MemData[a] !== OutReg_data[a])
         OutReg_data[a] = WordX[a];
   end//for (a = 0; a <  
         OutReg_data <= MemData;
   end     
end
endtask



// SCAN CHAINS
supply0 gnd;
buf (A_int[0], Aint[0]);
buf (A_int[1], Aint[1]);
buf (A_int[2], Aint[2]);
buf (A_int[3], Aint[3]);
buf (A_int[4], Aint[4]);
buf (A_int[5], Aint[5]);
buf (A_int[6], Aint[6]);
buf (A_int[7], Aint[7]);
buf (A_int[8], Aint[8]);
buf (A_int[9], Aint[9]);                  //used for capturing
buf (A_int[10], gnd);
buf (A_int[11], gnd);
buf (A_int[12], gnd);
buf (A_int[13], gnd);
buf (A_int[14], gnd);   //used for capturing

buf (WEN_int, WENint);
buf (CSN_int, CSNint);
buf (IG_int, IGint);


// Scan flops



// CONTROL SCAN CHAIN
     ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF cntrl_scff_0 (.D(1'b0), .TI(SCTRLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[0]), .OUTX(scanreg_ctrl));

      
 ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF cntrl_scff_1 (.D(A_int[3]), .TI(scanreg_ctrl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[1]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF cntrl_scff_2 (.D(A_int[5]), .TI(scanreg_ctrl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[2]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF cntrl_scff_3 (.D(A_int[8]), .TI(scanreg_ctrl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[3]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF cntrl_scff_4 (.D(A_int[2]), .TI(scanreg_ctrl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[4]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF cntrl_scff_5 (.D(A_int[10]), .TI(scanreg_ctrl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[5]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF cntrl_scff_6 (.D(A_int[9]), .TI(scanreg_ctrl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[6]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF cntrl_scff_7 (.D(A_int[1]), .TI(scanreg_ctrl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[7]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF cntrl_scff_8 (.D(A_int[0]), .TI(scanreg_ctrl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[8]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF cntrl_scff_9 (.D(A_int[4]), .TI(scanreg_ctrl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[9]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF cntrl_scff_10 (.D(A_int[6]), .TI(scanreg_ctrl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[10]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF cntrl_scff_11 (.D(CSN_int), .TI(scanreg_ctrl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[11]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF cntrl_scff_12 (.D(A_int[7]), .TI(scanreg_ctrl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[12]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF cntrl_scff_13 (.D(WEN_int), .TI(scanreg_ctrl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[13]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF cntrl_scff_14 (.D(scanreg_ctrl_wire[14]), .TI(scanreg_ctrl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[14]), .OUTX(scanreg_ctrl));  

reg LP_CK_gate;

// Lock Up Latch
wire SCTRLO_temp;
 ST_SPREG_LOLEAK_1024x19m4_Tl_lock_up_latch  dff_SCTRLO_SE (Latch_open, scanreg_ctrl_wire[14], SCTRLO_temp);

always @(SCTRLO_temp) begin
     SCTRLOint= SCTRLO_temp;
 `ifdef functional
 `else
 if (SCTRLOint !== SCTRLO_data) begin 
  if (SCTRLOint !==X)
   SCTRLO_data=1'bx;
   SCTRLO_data <= SCTRLOint;
 end 
 `endif
end  


// LEFT DATA SCAN CHAIN
     ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF ldata_scff_0 (.D(Dint[9]), .TI(SDLI), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[0]), .OUTX(scanreg_dl));
      
   
 
        ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF ldata_scff_1 (.D(Dint[8]), .TI(scanreg_dl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[1]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF ldata_scff_2 (.D(Dint[7]), .TI(scanreg_dl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[2]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF ldata_scff_3 (.D(Dint[6]), .TI(scanreg_dl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[3]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF ldata_scff_4 (.D(Dint[5]), .TI(scanreg_dl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[4]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF ldata_scff_5 (.D(Dint[4]), .TI(scanreg_dl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[5]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF ldata_scff_6 (.D(Dint[3]), .TI(scanreg_dl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[6]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF ldata_scff_7 (.D(Dint[2]), .TI(scanreg_dl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[7]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF ldata_scff_8 (.D(Dint[1]), .TI(scanreg_dl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[8]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF ldata_scff_9 (.D(Dint[0]), .TI(scanreg_dl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[9]), .OUTX(scanreg_dl));



// Lock Up Latch
wire SDLO_temp;
 ST_SPREG_LOLEAK_1024x19m4_Tl_lock_up_latch  dff_SDLO_SE (Latch_open, scanreg_dl_wire[9], SDLO_temp);

always @(SDLO_temp) begin
     SDLOint= SDLO_temp;
 `ifdef functional
 `else
 if (SDLOint !== SDLO_data) begin 
  if (SDLOint !==X)
   SDLO_data=1'bx;
   SDLO_data <= SDLOint;
 end 
 `endif
end  






// RIGHT DATA SCAN CHAIN

     ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF rdata_scff_0 (.D(Dint[18]), .TI(SDRI), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[0]), .OUTX(scanreg_dr));
     
 
 
        ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF rdata_scff_1 (.D(Dint[17]), .TI(scanreg_dr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[1]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF rdata_scff_2 (.D(Dint[16]), .TI(scanreg_dr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[2]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF rdata_scff_3 (.D(Dint[15]), .TI(scanreg_dr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[3]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF rdata_scff_4 (.D(Dint[14]), .TI(scanreg_dr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[4]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF rdata_scff_5 (.D(Dint[13]), .TI(scanreg_dr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[5]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF rdata_scff_6 (.D(Dint[12]), .TI(scanreg_dr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[6]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF rdata_scff_7 (.D(Dint[11]), .TI(scanreg_dr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[7]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF rdata_scff_8 (.D(Dint[10]), .TI(scanreg_dr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[8]), .OUTX(scanreg_dr)); 


// Lock Up Latch
wire SDRO_temp;
 ST_SPREG_LOLEAK_1024x19m4_Tl_lock_up_latch  dff_SDRO_SE (Latch_open, scanreg_dr_wire[8], SDRO_temp);


always @(SDRO_temp) begin
     SDROint= SDRO_temp;
 `ifdef functional
 `else
 if (SDROint !== SDRO_data) begin 
  if (SDROint !==X)
   SDRO_data=1'bx;
   SDRO_data <= SDROint;
 end 
 `endif
end






//


 //////// CAPTURE TASK //////
task scan_acquire;
begin
   if (supply_ok === 1) begin 
      if ( SEsys === 0 && ((LP_CK_gate === 0 && TBYPASSsys !== 1'bx)|| TBYPASSsys===0)) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
         
         Latch_open=1;
         

      end //if ( SEint === 0
   end//if(supply_ok 
end
endtask

task scan_shift;
begin
 if (supply_ok === 1) begin
   if (STDBYint === 0 && SLEEPint === 0) begin
      if (CKint_dft === X && INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0) begin
         ScanChainX;
         ScanOutX;
      end
      else if (CKint_dft === 1 && lastCK_dft === 0 ) begin
          //// SHIFT
        if (SEsys === 1) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
           
        //// SHIFT Ends
        end //if (SEsys === 1
        else if (SEsys === X) begin
            ScanChainX;
            ScanOutX;
            delScanOutX;
        end//if (SEint ==X
      
      end///if (CKint === 
    
      else if (CKint_dft === 0 && lastCK_dft === 1 ) begin
        Latch_open=1;
      end
    end  //if (STDByint === 0 && SLEEPint === 0
 end//if(supply_ok
end
endtask






// BEHAVIOURAL MODULE DESCRIPTION
// ================================

initial
begin
  // Define format for timing value
  $timeformat (-9, 3, " ns", 0);
  `ifdef slm
  $slm_RegisterMemory(MemAddr, Words, Bits);
  `endif   
   reg_mem_block=0;
   flag_mem_block=0;
  `ifdef functional
  `else
   TimingViol_data=0;
   TimingViol_mask=0;
   `endif
   decoding_start=0;
  
   //Parameter Assignment
   
   reg_Fault_file_name = Fault_file_name; 
   reg_ConfigFault     = ConfigFault;
   reg_MEM_INITIALIZE  = MEM_INITIALIZE;
   reg_BinaryInit      = BinaryInit;
   reg_InitFileName    = InitFileName;
   reg_Initn_reset_value = Initn_reset_value;
   reg_File_load_time    = File_load_time;

   time_fall_sleep=0;
   time_fall_PSWLARGEMP=0;
   time_fall_PSWLARGEMP_0=0;
   time_fall_PSWLARGEMA=0;
   time_fall_PSWLARGEMA_0=0;
   time_fall_PSWSMALLMP=0;
   time_fall_PSWSMALLMA=0;

   vddmp_rise_time=0;
   vddmp_fall_time=0;
   vddsmp_rise_time=0;
   vddsmp_fall_time=0;
   vddma_rise_time=0;
   vddma_fall_time=0;
   vddsma_rise_time=0;
   vddsma_fall_time=0;
   vddm_fall_time=0;  
   vddm_rise_time=0;  
   vddsm_fall_time=0; 
   vddsm_rise_time=0;

   next_cycle_corrupt_func=0;
   next_cycle_corrupt_dft=0;
   init_pulse_done = 0;
   power_up_done = 0;
   file_loaded=1;
   debug_level= 2'b01;
   message_status = "ONLY WARNINGS/ERRORS are Switched ON.For INFO also use debug_level=2'b00";
  `ifdef  NO_WARNING_MODE
     debug_level = 2'b11;
     message_status = "All Warning/Errors/Info Messages are Switched OFF";
  `endif  
  `ifdef  ONLY_ERROR_MODE
     debug_level = 2'b10;
     message_status = "All Warning/Info Messages are Switched OFF.Errors are switched on";
  `endif 
  `ifdef  ALL_MSG_MODE
     debug_level = 2'b00;
     message_status = "All Messages are Switched ON";
  `endif 
  
  `ifdef slm
     operating_mode = "SLM";
   `else
      `ifdef functional
         operating_mode = "FUNCTIONAL";
       `else
         operating_mode = "TIMING";
      `endif
   `endif   
  
  if (debug_level < 1) begin
  $display ("%m INFORMATION ");
  $display ("***************************************");
  $display ("The Model is Operating in %s MODE", operating_mode);
  $display ("%s", message_status);
  if(reg_ConfigFault)
  $display ("Configurable Fault Functionality is ON");   
  else
  $display ("Configurable Fault Functionality is OFF");   
  $display("Fault File used by the model Fault_File_Name=%s" ,reg_Fault_file_name);
  $display("Values of Config_fault used in model=%d" ,reg_ConfigFault);
  $display("Values of Mem_INITALIZE used in model=%d" ,reg_MEM_INITIALIZE);
  $display("Values of BinaryInit used in model=%d" ,reg_BinaryInit);
  $display("Values of InitFileName used in model=%s" ,reg_InitFileName);
  $display("Values of Initn_reset_value used in model=%d" ,reg_Initn_reset_value);
  $display("Values of File_load_time used in model=%t" ,reg_File_load_time);

  $display ("***************************************");
  end
     
  task_read_fault_file; 
   if(!INITNint) begin
    if(supply_ok ) begin 
      init_pulse_done = 1;
      power_up_done = 1;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif 
    end 
   end 
        
   lastCK_func = CKint_func;
   lastCK_dft = CKint_dft;

 `ifdef MEM_CONTENTS_SLEEP
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","w");
   $fclose(ptr);
 `endif 

   
end  // initial block ends



//+++++++++++++++++++++++++++++++ CONFIG FAULT IMPLEMETATION ENDS+++++++++++++++++++++++++++++++//
        




//INITN block starts
//================================
always @(INITNint  or supply_ok )
begin
 if (INITNint === 1'b0) begin
   if(supply_ok) begin
     init_pulse_done = 1;
     power_up_done = 1;
     lastCK_func=CKint_func;
     lastCK_dft=CKint_dft;
     next_cycle_corrupt_func = 0;
     next_cycle_corrupt_dft = 0;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif     
   end 
 end        

 if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && INITNint !== 1)
   begin
     ScanOutX;
     ScanChainX;
     delScanOutX;
   end  
         
 if (init_pulse_done === 0 && INITNint !== 0) begin
     if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) INFO: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
 end
 
end//always @(INITNint)


// Clock Generation 
//wire gated_clock;
//wire clock_gate_en;
//ST_SPREG_LOLEAK_1024x19m4_Tl_lock_up_latch CK_SE_latch (!CK , SE, SE_latch_CK);
//and (clock_gate_en, ATP, TBYPASS, !SE_latch_CK);

//ST_SPREG_LOLEAK_1024x19m4_Tl_lock_up_latch LP_latch (!CK , scanreg_ctrl_wire[14], LP_latch_CK);
//and (gated_clock,CK,!LP_latch_CK);
//assign CK_new= clock_gate_en ===0 ? CK : (clock_gate_en ===1 ? gated_clock: (CK===0) ? 0 :1'bx);


// Clock Generation Ends


// Functional CK block starts
//======================================
always @(CKint_func)
begin
   lastCK_func=CKreg_func;  
   CKreg_func=CKint_func;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
        if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
      if (CKreg_func === 1'bX || (CKreg_func === 1'b1 && lastCK_func === 1'bx)) begin
        if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
         
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
         Invalid_next_cycle_func;
        end
      end
      else if (CKreg_func === 1'b1 && lastCK_func === 1'b0 ) begin
        time_CK_func_rise=$realtime;
        MEMEN_prev = MEMEN_reg;
        MEMEN_reg = MEMEN;
        CSNreg = CSNint;
        IGreg = IGint;
        DEreg = DEint;
        SE_reg = SEsys;
        TBYPASS_reg = TBYPASSsys;
        ATPreg = ATPint;
        INITNreg = INITNint;
        SLEEPreg = SLEEPint;
        STDBYreg = STDBYint;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 

    `ifdef functional
    `else
        Mem_last=Mem[Aint];
    `endif 
        if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.INITN pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SLEEP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.STANDBY pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg === X && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.chip select  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg === X && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.IG pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg === X && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.Debug pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg === X && (SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.ATP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg === X && TBYPASS_reg !== 1) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SE pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg !== 1 && TBYPASS_reg === X) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.TBYPASS pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end

        else if ((INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0))) && WENint === X) begin
            // Uncertain write cycle
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: write enable going to X  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end 
        else if (next_cycle_corrupt_func === 1) begin
          next_cycle_corrupt_func = X;
        end
        else if (next_cycle_corrupt_func === 1'bx) begin
          next_cycle_corrupt_func = 0;
        end 
        
//        if (next_cycle_corrupt_func === 0 ) begin 
         
          /*---------------------- File initialization -----------------*/
          
          if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0)) && flag_mem_block === 1'b0) begin
                 Areg=Aint;
                 Dreg=Dint;
                 Mreg=Mint;
                 WENreg=WENint;     
             if (reg_MEM_INITIALIZE === 1'b1 && $realtime >= reg_File_load_time && file_loaded ) begin   
                `ifdef slm
                  if (reg_BinaryInit)
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_BIN");
                  else
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_HEX");
   
                `else
                  if (reg_BinaryInit)
                     $readmemb(reg_InitFileName, Mem, 0, Words-1);
                  else
                     $readmemh(reg_InitFileName, Mem, 0, Words-1);
                `endif
                 file_loaded = 0;
             end
   
             if (^Aint === X)
               ValidAddress = X;
             else if (Aint < Words)
               ValidAddress = 1;
             else    
               ValidAddress = 0;
   
             if(red_en === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Redundancy Enable is Invalid. Either RRAE is X or TRRAE is X",$realtime);
                ValidAddress = X; 
           end
           else if(red_en === 1'b1 && ^repair_add === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Repair Address is invalid.RRA is X",$realtime);
                ValidAddress = X;
           end
             
             if (ValidAddress)
               `ifdef slm
                   $slm_ReadMemoryS(MemAddr, Aint, Mem_temp);
               `else
                    Mem_temp = Mem[Aint];
               `endif
             else
                Mem_temp = WordX;  
          
     /*---------------------- Normal Read and Write -----------------*/
     
             if (WENint === 1) begin
               ReadCycle(Aint);
             end
       
             else if (WENint === 0) begin
               WriteCycle(Aint);
             end 
                
          
          end //  if (MEMEN === 1'b1 
       
//        end  // if (next_cycle_corrupt_func === 0
      
      end // if (CKint = 1   
   end // if (init_pulse_done === 1           
 end 
end // always @(CKint_func)
        
always @(MEMEN)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) && CKint_func === 1'bx) begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.clock pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
    Invalid_next_cycle_func;
  end
 end 
end

// DFT CK block starts
//======================================
always @(CKint_dft) 
begin
   lastCK_dft=CKreg_dft;
   CKreg_dft=CKint_dft;
   
   Latch_open=0;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
     if (CKreg_dft === 1'bX || (CKreg_dft === 1'b1 && lastCK_dft === 1'bx)) begin
       if (INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0 ) begin
        
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: DFT clock  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime); 
         Invalid_next_cycle_dft;
         if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
           WriteOutX;
         end
       end
     end 

     if(CKint_dft === 0 && lastCK_dft === 1) begin
      if(ATPreg === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
       if(SE_reg === 1'b1 && SEsys === 1'b0) begin
        if(TBYPASSint === 1'b1) begin   
    
       
       
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8], scanreg_dl_wire[scanlen_l-1]}; 
       


         for (i = 0; i < Bits; i = i + 1)
         begin
          if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
         end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
        end 
       end
      end
     end 
     
     else if (CKreg_dft === 1'b1 && lastCK_dft === 1'b0 ) begin
       SE_reg = SEsys;
       TBYPASS_reg = TBYPASSsys;
       ATPreg = ATPint;
       INITNreg = INITNint;
       SLEEPreg = SLEEPint;
       STDBYreg = STDBYint;
       MEMEN_dft_prev = MEMEN_dft_reg;
       MEMEN_dft_reg = MEMEN_dft;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 
       if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ) begin 
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
 //     else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys === X && TBYPASSsys !== 1) begin
///           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
//           Invalid_next_cycle_dft;
//        end       
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys === X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
        end 
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys !== 0 && LP_CK_gate===X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: LP FLOP Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           ScanChainX;
           ScanOutX;   
          if( TBYPASSint !== 0 && SEint !== 1) begin
            WriteOutX;
          end
          next_cycle_corrupt_dft=0;
        end        
       else if (next_cycle_corrupt_dft === 1'b1) begin 
         next_cycle_corrupt_dft = X;
       end 
       else if (next_cycle_corrupt_dft === 1'bx) begin
         next_cycle_corrupt_dft = 0;
       end
       
       if (next_cycle_corrupt_dft === 0 ) begin
         
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1 && flag_mem_block === 1'b0) begin
           
           if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0  && LP_CK_gate===0) begin
              OutReg_data_tbypass = Dint;
              for (i = 0; i < Bits; i = i + 1)
              begin
               if (OutReg_data_tbypass[i] !== OutReg_data[i])
                 OutReg_data[i] = WordX[i];
              end//for (i = 0; i < */ 
              OutReg_data <= OutReg_data_tbypass;
           end
           
             scan_acquire;
         end //MEMEN_dft == 1        
       end // if ( next_cycle_corrupt_dft
       
     end // if (CKint_dft === 1'b1
      //  if (next_cycle_corrupt_dft === 0 ) begin 
       if (SE_reg !== 0) begin
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1  && flag_mem_block === 1'b0) begin
           next_cycle_corrupt_dft = 0;
           if ( next_cycle_corrupt_func === 1) begin
	    next_cycle_corrupt_func = 0 ;
	   end	
           scan_shift;
         end
       end
     //end // if ( next_cycle_corrupt_dft    
     if ((!(TBYPASSsys!==0 && SEsys!==1 && LP_CK_gate!==0 ) && next_cycle_corrupt_dft === 0) || CKint_dft !==1) begin          
       CK_sc=INITNreg & !STDBYreg & !SLEEPreg & ATPreg & CKreg_dft ;
     end     
   end // if (init_pulse_done 
 end // if (supply_ok 
end // always @(CKint_dft)

always @(MEMEN_dft)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) && CKint_dft === 1'bx)  begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.MEMEN_dft and clock should not be X at this time instant. ScanChains and ScanOuts Corrupted ",$realtime); 
    Invalid_next_cycle_dft;
    
    if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
      WriteOutX;
    end
  end
  if ( MEMEN_dft !== 0 && TBYPASSsys !== 0 && SEsys !== 1) begin
     WriteOutX;
     OutReg_data = WordX; 
     delOutReg_data=WordX;
 end 
end
end //always @(MEMEN_dft

always @(TBYPASSsys or ATPint)
begin
   if(supply_ok === 1'b1) begin 
    if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0 && INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1) begin
      if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
    end  
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint === X && SEsys !== 1) ) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end 
end //always @(TBYPASSint





always @(SEsys)
begin
 if(supply_ok === 1'b1) begin 
  if(CKint_dft === 0 && ATPint === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
    if(SE_reg === 1'b1 && SEsys === 1'b0) begin
      if(TBYPASSsys === 1'b1) begin
  
     
         
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8], scanreg_dl_wire[scanlen_l-1]};
           
      


        for (i = 0; i < Bits; i = i + 1)
        begin
         if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
        end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
      end
    end
  end
  if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0) begin
      if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
  end 
  else if ((TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint === X && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end   
end

//assign output data
`ifdef functional        

   
always @(SDLOint)
#0.001 delSDLO_data<=SDLOint;

always @(SDROint)
#0.001 delSDRO_data<=SDROint;

 
always @(SCTRLOint)
#0.001 delSCTRLO_data<=SCTRLOint;


always @(OutReg_data)
   #0.001 delOutReg_data = OutReg_data;
`else
`endif

/***************************** Embeded switch functionality starts here ***********************************/





always @(STDBYint)
begin
  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0 && STDBYint !== 1'b0)
    begin
      ScanOutX;
      ScanChainX;
     delScanOutX;     
    end
  end
end



always @(SLEEPint)
begin


  if (SLEEPint !== 1'b1) begin
    time_fall_sleep = $realtime;
  end

  if (power_up_done === 0)
    begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
    end
  else begin
    if (SLEEPint === 1'b1 && lastSLEEP === 1'b0 ) begin 
      
    end
    else if (SLEEPint !== 1'b1 && lastSLEEP === 1'b1 && full_shutdown !== 1) begin 
      
      if (supply_ok !== 1 && ($realtime > 0)) begin
         if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID LOW_POWER) ERROR: ISOLATION signal removed from the memory but array and periphery supply is not completely switched on.Very High Current would be drawn by the memory. All further operations on memory are blocked",$realtime);
          WriteMemX;
          WriteOutX;
          ScanChainX;
          OutReg_data = WordX; 
          delOutReg_data=WordX;
          ScanOutX;//immediately;
          delScanOutX;//immediately;
          init_pulse_done = 0;
          power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            debug_level = 2'b11;
          `endif
          
      end        
      
       
    end   
    else if (SLEEPint === X && lastSLEEP === 1'b0 && full_shutdown !== 1'b1) begin 
     
    end 
  end  


  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && SLEEPint !== 0)
    begin
      ScanOutX;
      ScanChainX;
        delScanOutX;      
    end
  end

// if (init_pulse_done === 0)
//   begin
//     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
//   end
//
// else if ( SLEEPint !== 1 && (supply_ok !==1) ) begin
//    
//    WriteOutX;
//    OutReg_data = WordX; 
//    delOutReg_data=WordX;
//    ScanOutX;//immediately;
//    delScanOutX;//immediately;
//    ScanChainX;
//    WriteMemX;
//    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies with sleep/Power down signal being low.This scenario can lead to high dc currents and some reliability issues Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
// end

 print_sleep;    
 lastSLEEP=SLEEPint;
end

/********************************** Embeded switch functionality ends here *******************************/

task print_sleep;
begin
  if (SLEEPint === 1'b0) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been deasserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end  
  else if (SLEEPint === 1'b1) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been asserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_ACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif

  end        
  else begin
      if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) ERROR: SLEEP pin is at an invalid state.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INVALID in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end        
end
endtask





 

//// C28SOI non flip compiler power functionality 
always @(gndmreg )
begin
 if (power_up_done === 1 && $realtime > 0) begin    
    if(gndmreg !== 1'b0 ) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or gndsm is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
        corrupt_all;
        init_pulse_done = 0;
        power_up_done = 0;
     `ifdef NO_BLOCK_MEM
     `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of ground pins.Ground must be maintained at 0 Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime);
        debug_level = 2'b11;
     `endif   

    end   
 end

end




always @(vddmareg )
begin

if (vddmareg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddma(Array Supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 
    end
   end   
   else if (SLEEPint === 1) begin
    WriteMemX;
   end

end

if ((vddmareg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1 ) && $realtime > 0) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddm or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         corrupt_all;
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif

end


end

always @(vddmpreg )
begin
 if (vddmpreg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or vddsmp is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmp(Periphery Supply)/vddsmp(Substrate power supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 

    end
   end   
   else if (SLEEPint === 1) begin
    WriteOutX;
    ScanChainX;
    ScanOutX;
    delScanOutX;//immediately;
    OutReg_data = WordX; 
    delOutReg_data=WordX;
   end
 end

if( (vddmpreg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1'b1 )  && $realtime > 0) begin
         corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif
end
 
 
end


always @(vddmoreg)
begin
  if (power_up_done === 1 && $realtime > 0) begin   
      if (vddmoreg !== 1'b1)  begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin
           corrupt_all;
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
         end //if (vddmareg === 1'b1 

      else if (vddmareg === 1'b0 && vddmpreg === 1'b0   && SLEEPint === 1'b1 &&  $realtime > 0)
        begin 
            if((debug_level < 2) && ($realtime > 0)) $display("%m - %t WARNING: Illegal Value on power pin(s). Memory and Output Corrupted ", $realtime);
 
           corrupt_all;
        end //else if (vddmareg === 1'b 
     end   // if (vddmoreg !== 1'b1)
     else if (vddmoreg === 1'b1 && $realtime > 0 ) begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin     
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           corrupt_all;
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
        end        
     end // else if (vddmoreg === 1'b1
  end 
end // always @(vddmoreg)












always @(gndmreg) begin
 if (gndmreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 0. ",$realtime);
 end
 else if (gndmreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 1. ",$realtime);
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to invalid state. ",$realtime);
 end
end




 
always @(vddmareg) begin
 if (vddmareg === 0) begin 
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 0. ",$realtime);
  vddma_fall_time = $realtime;
 end
 else if (vddmareg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 1. ",$realtime);
  vddma_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to invalid state. ",$realtime);
  vddma_fall_time = $realtime;
 end 

 

end

always @(vddmpreg) begin
 if (vddmpreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 0. ",$realtime);
  vddmp_fall_time = $realtime;
 end
 else if (vddmpreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 1. ",$realtime);
  vddmp_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to invalid state. ",$realtime);
  vddmp_fall_time = $realtime;
 end

 
 
end



// end of C28SOI power functionality 
 


assign supply_ok          =  (vddmareg === 1'b1 && vddmpreg  === 1'b1  && gndmreg === 1'b0 && vddmoreg === 1'b1 ) ? 1'b1 : 1'b0;
assign core_supply_ok     =  (vddmoreg === 1'b1 && vddmareg === 1'b1 && gndmreg === 1'b0 ) ? 1'b1 : 1'b0;
assign peri_supply_ok     =  (vddmoreg === 1'b1 && vddmpreg === 1'b1 && gndmreg === 1'b0  ) ? 1'b1 : 1'b0;

assign full_shutdown = (vddmpreg === 1'b0 && vddmareg === 1'b0   ) ? 1'b1 : 1'b0 ;




`ifdef functional
`else


task WriteLocMskX_bwise;
   input [Addr-1 : 0] Address;
   input [Bits-1 : 0] Mask;

reg [Bits+Red_extrabit:0] tempReg1;
integer num1; 
begin
   tempReg1 = WordX;
   if (^Address !== X )
   begin
      tempReg1 = Mem[Address];
             
      for (j = 0;j< Bits; j=j+1) begin
         num1=j;
        if (Mask[j] === 1'bx)
            tempReg1[num1] = 1'bx;
      end
      Mem[Address] = tempReg1;
      task_insert_faults_in_memory;
   end//if (^Address !== X
   else begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      WriteMemX;
   end   
end
endtask


/****************Actions taken on timing violations*****************/

 always @(TimingViol_data)
// tds or tdh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  for (l = 0; l < Bits; l = l + 1) begin   
    if (CSWEMTBYPASS[l] !== 0) begin
     if((TimingViol_data[l] !== TimingViol_data_last[l])) begin


         Mreg[l] = 1'bx;
     end    
     WriteLocMskX_bwise(Areg,Mreg);
    end   
   end 
  end
    if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin
     scanreg_dl =1'bx; 
     scanreg_dr =1'bx; 
     SDLOint=X;
     SDROint=X;
     `ifdef functional
     `else
     SDLO_data<=1'bx;
     SDRO_data<=1'bx;
     `endif
    end
     TimingViol_data_last = TimingViol_data; 
end





always @(TimingViol_addr)
// tas or tah
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
      scanreg_ctrl=1'bx; 
      SCTRLOint=X;
      `ifdef functional
      `else
      SCTRLO_data<=1'bx;
      `endif
  end
end


always @(TimingViol_WEN)
//tws or twh
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WEN pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end 

always @(TimingViol_CSN )
// tps or tph 
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;

   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CSN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end

always @(TimingViol_tcycle )
//tcycle
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
   if (MEMEN !== 0 && MEMEN_prev !== 0) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckl )
// tckl 
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckh) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end


always @(TimingViol_tcycle_se )
//tcycle_se
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckl_se  )
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckh_se) begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tbist) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
   end
   if (TBYPASSint !== 1'b0) begin 
    WriteOutX;
   end 
   if (INITNreg !==0 && STDBYreg !== 1 && TBYPASS_reg !== 1 && SLEEPreg !== 1 && SE_reg !== 1 && IGreg !== 1 && DEreg !== 1) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBIST pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end






always @(TimingViol_tbypass)
//ttmck
begin
#0  
  WriteOutX;
  if (INITNreg !== 0 && SLEEPreg !== 1 && SE_reg !== 1 && STDBYreg !== 1 &&  DEreg !== 1) begin
   Invalid_next_cycle_dft_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
end



always @(TimingViol_sleep)
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_stdby)
begin
#0
  if (CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin 
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (ATPreg !== 0) begin 
   Invalid_next_cycle_dft_tim;
  end
end






always @(TimingViol_se) begin
#0
   if (TBYPASS_reg !== 0) begin 
    WriteOutX;
   end 
  if (TBYPASS_reg === 0) begin
     WriteOutX;
     WriteMemX;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE timing violation  Memory State Machine is corrupted. Output Corrupted ",$realtime); 
  end 
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
  end
end

always @(TimingViol_sctrli) begin
  scanreg_ctrl=1'bx; 
end


always @(TimingViol_sdli) begin
 scanreg_dl=1'bx; 
end

always @(TimingViol_sdri) begin
   scanreg_dr=1'bx;
end

 

always @(TimingViol_initnl) begin
init_pulse_done=0;
WriteOutX;
OutReg_data = WordX; 
delOutReg_data=WordX;
ScanOutX;
delScanOutX;
ScanChainX;
WriteMemX;
end

always @(TimingViol_initn) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end

always @(TimingViol_ig) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && INITNreg !== 0 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: IG pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   ScanChainX;
   ScanOutX;
   delScanOutX;       
  end
end

always @(TimingViol_atp) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin  
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_rm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^WMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: RM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
   end
end
 
always @(TimingViol_wm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^RMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);        
   end
end 


`endif


endmodule




module ST_SPREG_LOLEAK_1024x19m4_Tl_lock_up_latch (EN,D,Q);
input EN,D;
output reg Q;

  always @ (EN or D) begin
    if (EN === 1) begin
       Q = D;
    end
    else if ((EN === 1'bz || EN === 1'bx  )&& D !== Q) begin
        Q=1'bx;
    end    
  end
endmodule

module ST_SPREG_LOLEAK_1024x19m4_Tl_SCFF (D,TI,TE,CP,Q,OUTX);
input D,TI,TE,CP;
input OUTX;
output reg Q;
wire Dint;
assign Dint= (TE===1)?TI:(TE===0)?D:1'bx;

always @(posedge CP)
        begin
          if(Dint === 1'bZ || CP ===1'bx || OUTX === 1'bx)
          begin
                  Q = 1'bx;
          end
          else
          begin
                  Q = Dint;
          end        
        end
always @(posedge OUTX)
Q = 1'bx;
endmodule



`undef setup_time
`undef hold_time
`undef access_time
`undef retain_time
`undef cycle_time
`undef pulse_width_time
`undef initin_low_pulse


`delay_mode_path
`endcelldefine
`nosuppress_faults






/****************************************************************
--  Description         : Verilog Model 
--  ModelVersion        : 1.2
--  Date                : Apr, 2013
--  Changes Made by	: PS
--  Revision History    : 
 
****************************************************************/


/******************** START OF HEADER****************************
   This Header Gives Information about the parameters & options present in the Model
   
   words = 32
   bits  = 24
   mux   = 2 
   
   
   
   write_mask = no 
   
   margin_control = yes 
   
   
   Dft = Yes  

    ------------------------------------------------------------------------------------
     Signal Name             | Description       |             Port Mode        | Active When
                             |                   |          r    |  w   | rw    |
   ------------------------------------------------------------------------------------

    D 	        Data in                     na     x      na       -  
    IG    Input Gate Enable           x      x      na       High     
    ATP            ATPG Enable                 x      x      na       High     
    INITN                 INITN pin                   x      x      na       Low
    
    
     
    Q 	        Data out	            x      na     na       -
    A              Address                     x      x      na       high and low
    
    CK                Clock	                    x      x      na       posedge
    CSN          Chip Enable                 x      x      na       low
    
    RM         Read Margins                 x      x      na       High 
    SCTRLI         Scan Input (Control)
    SCTRLO        Scan Output (Control)
    SDLI         Scan Input (Data-Left)
    SDLO        Scan Output (Data-Left)
    SDRI         Scan Input (Data-Right)
    SDRO        Scan Output (Data-Right)
    SE          Scan Enable pin 
    STDBY              Standby pin                 x      x      na       High
    
    SLEEP                        Sleep pin                   x      x      na        High 
    
     
     
    TBIST          Bist Enable Pin 
    
    TBYPASS                      Memory Bypass                na     na     na        High
    
    TED        Bist Even Data pin
    TOD         Bist Odd Data Pin
     
    TA         Bist Read Address
    TCSN     Bist Read Chip Select
    
    TWEN    Bist Write Enable 
    WEN         Write Enable                na     x      na       Low 
    
    WM        Write Margins Code          x      x      na       -
     

******************** END OF HEADER ****************************/


//********************************************//
// ST_SPREG_LOLEAK_32x24m2_Tl Verilog Model                 //  
//********************************************//




`ifdef slm
        `define functional
`endif

`celldefine
`suppress_faults
  `ifdef functional
   `delay_mode_unit
  `else
   `delay_mode_path
  `endif

`define setup_time 0.0
`define hold_time 0.0
`define access_time 1.0
`define retain_time 0.9
`define cycle_time 0.0
`define pulse_width_time 0.0
`define initin_low_pulse 0.0



 






`timescale 1ns / 1ps


module ST_SPREG_LOLEAK_32x24m2_Tl (A,ATP,CK,CSN,D ,IG,INITN , Q ,RM    ,SCTRLI,SCTRLO,SDLI,SDLO,SDRI,SDRO,SE,SLEEP   , STDBY  ,TA,TBIST   ,TBYPASS ,TCSN,TED ,TOD   ,TWEN ,WEN,WM  );

 parameter
  Words = 32,
  Bits = 24,
  Addr = 5,
  mux = 2,
  repair_address_width = 4,
  write_margin_size = 2, 
  read_margin_size = 3; 

 //  INPUT OUTPUT PORTS DECLARATION DONE SEPARATELY FOR SPREG and ROM
 // ========================


        output [Bits-1 : 0] Q;
         
        output SCTRLO;
        input SE,SCTRLI;
        
        input [Addr-1 : 0] A;
        
        input [read_margin_size-1 : 0] RM;
        
         
        input CK,CSN,INITN,IG,ATP; 
        
        
        input [Addr-1 :0 ] TA;
input TBIST,TCSN ;
        
        input STDBY;
        
        input SLEEP; 
        
         
        
        
         
        output SDLO;
        output SDRO;
        
        
        
        
        input [Bits-1 : 0] D ;
	
          
         
        
        input [write_margin_size-1 : 0] WM;
        
        
        input TBYPASS;
        
        input WEN;
        
        
         
        input SDLI,SDRI  ; 
        
        
        
        //Bist inputs
        // ===========
        input TWEN,TED,TOD; 
        
        
        
        

        






    parameter
        Fault_file_name = "ST_SPREG_LOLEAK_32x24m2_Tl_faults.txt",
        `ifdef ConfigFault
        ConfigFault = 1,
        `else
        ConfigFault = 0,
        `endif
        max_faults = 34,
        
        MEM_INITIALIZE  = 1'b0,
        BinaryInit = 1'b0, 
        InitFileName = "ST_SPREG_LOLEAK_32x24m2_Tl.cde",
        Debug_mode = "all_warning_mode",
        File_load_time=0,
        Initn_reset_value={24{1'b0}},
        InstancePath = "ST_SPREG_LOLEAK_32x24m2_Tl";
    
    parameter
        
        bank = 1, 
        mux_bits=1,
        Red_extrabit=0,
        bank_bits = 0,
        RedWords = mux * 2 * bank,
        max_address_bits = 15 ,
        Rows = Words/mux;

  
    parameter 

     

        
           scanchains=3,    
          
        
        scanlen_ctrl=15,
        
        

      

        
        
        scanlen_r=(2*(Bits/4)),
        
        scanlen_l=(Bits-(2*(Bits/4)))  ; 
      
      

    parameter
        
        `ifdef functional  
            RW_assertions_en = 0,
        `endif
        WordX = {Bits{1'bx}},
        AddrX = {Addr{1'bx}},
        Word0 = {Bits{1'b0}},
        X = 1'bx;
   



//  WIRE DECLARATION RELATED TO POWER PINS
//  ======================================
	
        wire supply_ok, full_shutdown;
        
        wire core_supply_ok;
        wire peri_supply_ok;

        wire gndmint, gndsmint;
         
        
        wire vddmpint;
        wire vddmoint;
        wire vddmaint;
        wire vddsmpint;  
        wire vddsmaint;  
        
        

//  WIRE DECLARATION 
//  ==================
        wire [Bits-1 : 0] CSWEMTBYPASS;
        wire [Bits-1 : 0] Dint, Dsys;
        wire [Bits-1 : 0] Mint; 
        wire [24-1:0] Msys;
	wire [Addr-1 : 0] Aint;
        wire [Addr-1 : 0] Asys;

       


        wire [max_address_bits-1 : 0] A_int; 
                
	wire CKint_dft;
	wire CKint_func;
	wire CSNint;
        wire MEMEN;
        wire MEMEN_dft;
        wire TSE;

	wire WENint;
	wire WENsys;
        wire SLEEPint;
        wire STDBYint;
        wire SEint;
        wire SEsys;
        wire SCTRLIint;
        wire SDLIint;
        wire SDRIint;
        
        wire INITNint;
        wire TBYPASSint;
        wire TBYPASSsys;
        wire LSint; 
        wire HSint; 
        wire ATPint;
        wire DEint;
        
        wire [Addr-1 : 0] TAint;
        wire TBISTint;
        wire TBISTsys;
        wire TCSNint;
        wire TEDint;
        wire TODint;
        wire TEMint;
        wire TOMint;
        wire [Bits-1 : 0] TMint;
        wire [Bits-1 : 0] TDint;
        wire TWENint;
        wire IGint;
        wire IGbuf;
        wire CSNbuf;
        wire WENbuf;
        wire [read_margin_size-1:0] RMint;
        wire [write_margin_size-1:0] WMint;

        //Wires for scan chains
        //  ====================     
        wire [scanlen_ctrl -1:0]scanreg_ctrl_wire;
        wire [scanlen_l -1:0]  scanreg_dl_wire; 
        wire [scanlen_r -1:0]  scanreg_dr_wire; 
   
        wire [scanlen_l -1:0]  scanreg_ml_wire; 
        wire [scanlen_r -1:0]  scanreg_mr_wire; 


        wire [repair_address_width -1 : 0] RRAint;
        wire RRAEint;
        wire TRRAEint;    
        wire red_en;
        wire [repair_address_width -1 : 0] repair_add, next_repair_add;


//  REG DECLARATION
//  ====================     
        reg MEMEN_reg;
        reg MEMEN_prev;
        reg reg_mem_block;
        reg flag_mem_block;
        reg SCTRLIint_temp;
        reg SDLIint_temp;
        reg SDRIint_temp;
        reg SMLIint_temp;
        reg SMRIint_temp;

        //  REG DECLARATION
        //  ====================
        reg SCTRLOint;
        
        reg SDLOint,SDROint;
         
        
        reg next_cycle_corrupt_func;
        reg next_cycle_corrupt_dft;
        reg [Bits-1 : 0] delOutReg_data;//delayed Output Register
        reg [Bits-1 : 0] OutReg_data;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_tbypass;   // Data Output register
        reg [Bits-1 : 0] OutReg_data_scan;   // Data Output registe
        reg [Bits-1 : 0] OutReg_rado_retained;   // register for retaining rado data when SLEEP --> 1
        reg delSCTRLO_data,SCTRLO_data;      // delayed Output Register
        reg delSDLO_data,SDLO_data;      // delayed Output Register
        reg delSDRO_data,SDRO_data;      // delayed Output Register
        
        
        // SCAN CHAINS register
        reg scanreg_ctrl; 
        reg scanreg_dl; 
        reg scanreg_dr; 
        
        
        reg CK_sc;
        reg Latch_open=0;
        reg lastCK_dft,CKreg_dft;
        reg lastCK_func,CKreg_func;
        reg lastSLEEP;
        reg lastPSWLARGEMP,lastPSWLARGEMA,lastPSWSMALLMP,lastPSWSMALLMA;
        reg CSNreg;
        reg init_pulse_done; //if == 1 then it implies that initb low pulse has been applied
        reg power_up_done; //if == 1 then it implies that power up has been done
        `ifdef slm
        `else
	      
             reg [Bits-1 : 0] Mem [Words-1 : 0];
             reg [Bits-1 : 0] RedMem [RedWords-1 : 0];
 
        `endif
        
	reg [Bits-1 :0] Mem_temp;
        reg [Bits-1 :0] Mem_slm; 
	reg ValidAddress;
	reg ValidDebugCode;
        reg decoding_start;
        reg file_loaded;
        reg [Bits-1 :0] Dreg;
        reg [Bits-1 :0] Mreg;
        reg WENreg;
        reg [Addr-1 :0] Areg;
        reg SE_reg;
        reg TBYPASS_reg;
        reg INITNreg;
        reg IGreg;
        reg DEreg;
        reg SLEEPreg;
        reg STDBYreg;
        reg ATPreg;
        reg MEMEN_dft_reg;
        reg MEMEN_dft_prev;
        reg RRMATCHreg;
        reg RRMATCHreg_last;//changes_made
        reg RRMATCHreg_glitch;
        reg [repair_address_width -1 : 0] repair_add_last;
        reg RRAEint_last;
        reg [Addr-mux_bits-1:0] row_add_temp;
        reg [Addr-mux_bits-bank_bits-1:0] row_add_cmp_temp;

       
        //parameter registers
        reg [2047:0] reg_Fault_file_name;
        reg reg_ConfigFault;
        reg reg_MEM_INITIALIZE;
        reg reg_BinaryInit;
        reg [2047:0] reg_InitFileName;
        reg [Bits -1 :0] reg_Initn_reset_value;
        time reg_File_load_time;

        //Power Supply Registers        
        reg vddmireg;
        reg vddmreg;
        reg vddsmreg;
        reg gndmreg;
        reg gndsmreg;   
        reg vddmpreg;
        reg vddmpireg;
        reg vddmareg;
        reg vddsmpreg;
        reg vddsmareg;
        reg vddmoreg;
        time vddmp_rise_time;
        time vddmp_fall_time;
        time vddsmp_rise_time;
        time vddsmp_fall_time;
        time vddma_rise_time;
        time vddma_fall_time;
        time vddsma_rise_time;
        time vddsma_fall_time;
        reg reg_check_rise;
        reg reg_check_fall;
        reg reg_check_rise_vddma;
        reg reg_check_fall_vddsma;
        reg  reg_check_rise_vddm, reg_check_fall_vddsm ;
        time vddm_fall_time,  vddm_rise_time,  vddsm_fall_time, vddsm_rise_time ;
  /* This register is used to force all warning messages 
  ** OFF during run time.
  ** It is a 2 bit register.
  ** USAGE :
  ** debug_level_off = 2'b00 -> ALL MESSAGES(INFO/WARNINGS/ERRORS) will be DISPLAYED 
  ** debug_level = 2'b01     -> ONLY WARNINGS/ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b10     -> ONLY ERRORS WILL BE DISPLAYED.
  ** debug_level = 2'b11     -> NO MESSAGES will be DISPLAYED.
  */ 
        reg [1:0] debug_level;
        reg [8*10: 0] operating_mode;
        reg [8*44: 0] message_status;

        integer i, k, j, l,m,q,w,r,s,num1,redcnt,n,num2,FirstHalf,Bfaileff,memcnt,ptr;
        integer decoder[Bits-1:0];
        `ifdef slm
           integer MemAddr;
        `endif


        //************************************************************
        //****** CONFIG FAULT IMPLEMENTATION VARIABLES*************** 
        //************************************************************ 

        integer file_ptr, ret_val;
        integer fault_word;
        integer fault_bit;
        integer fcnt, Fault_in_memory,faultnum,stop_loop,count;
        integer t;  
        integer FailureLocn [max_faults -1 :0];
        integer Failurebit [max_faults -1 :0];
        reg [100 : 0] stuck_at;
        reg [100 : 0] fault_array;
        reg [200 : 0] tempStr;
        reg [7:0] fault_char;
        reg [7:0] fault_char1; // 8 Bit File Pointer
        reg [Addr -1 : 0] std_fault_word;
        reg [Addr -1 : mux_bits] fault_row_add [max_faults -1 :0];
        reg [max_faults -1 :0] fault_repair_flag;
        reg [max_faults -1 :0] dont_insert_fault;
        reg [max_faults -1 :0] repair_flag;
        reg [100 : 0] array_stuck_at[max_faults -1 : 0] ;
        reg [100 : 0] mem_red_array_stuck_at[max_faults -1 : 0] ; 
        reg msgcnt;
        
       
        reg [Bits - 1: 0] stuck_at_0fault [max_faults -1 : 0];
        reg [Bits - 1: 0] stuck_at_1fault [max_faults -1 : 0];
        reg [Bits -1 : 0] stuck0;
        reg [Bits -1 : 0] stuck1;

        reg [Bits+Red_extrabit :0] Mem_last;
        

        `ifdef slm
        reg [Bits -1 : 0] slm_temp_data;
        `endif
        
        real time_CK_func_rise , time_RADCK_rise;
        real time_fall_sleep,time_fall_PSWLARGEMP,time_fall_PSWLARGEMP_0,time_fall_PSWLARGEMA,time_fall_PSWLARGEMA_0,time_fall_PSWSMALLMP,time_fall_PSWSMALLMA;
        integer flag_error;
        
//BUFFER INSTANTIATION
//=========================
       `ifdef functional
       
         buf (SCTRLO,delSCTRLO_data); 
         buf bufq [Bits-1:0] (Q,delOutReg_data);
      `else
       
         buf (SCTRLO,SCTRLO_data);
         buf bufq [Bits-1:0] (Q,OutReg_data);
      `endif
      
  
        buf (SEsys,SE);
	buf (SCTRLIint, SCTRLI);
   

	buf (CKint_func, CK);
	buf (CKint_dft, CK);
        buf bufaddr [Addr-1:0] (Asys,A);
        buf (INITNint,INITN);
        
        buf (LSint,1'b0); 
        buf (IGbuf,IG);
        buf (ATPint,ATP);

        buf bufTaddr [Addr-1 : 0] (TAint,TA);
        buf (TBISTsys,TBIST);
        buf (TCSNint,TCSN);

        buf (CSNsys,CSN);
        buf (STDBYint,STDBY );   
        
        buf (SLEEPint,SLEEP ); 

        buf bufrm [read_margin_size-1:0] (RMint, RM); 

        
        

        assign RRAEint = 1'b0;
        assign TRRAEint = 1'b0;
        assign repair_add = 0;
        assign next_repair_add = 0;
        assign red_en = 1'b0; 
        
        
        
        
        
        
        
        buf (PSWLARGEMPint,1'b0);
        buf (PSWSMALLMPint,1'b0); 
        buf (PSWLARGEMAint,1'b0);
        buf (PSWSMALLMAint,1'b0);   

      `ifdef functional
       
       
         buf (SDLO,delSDLO_data);
         buf (SDRO,delSDRO_data);
        
      `else
       
         buf (SDLO,SDLO_data);
         buf (SDRO,SDRO_data);
         
      `endif
       
         
       
        buf bufdata [Bits-1:0] (Dsys,D);
        
        
        assign Msys=24'b0; 
	

        
        buf (TBYPASSsys, TBYPASS);
        


        buf (WENsys,WEN);
	 
	buf (SDLIint, SDLI);
	buf (SDRIint, SDRI);
	 
        
        buf (HSint,1'b0); 

        
        buf (TEDint,TED);
        buf (TODint,TOD);
         
        buf (TWENint,TWEN);
        
        
        buf bufwm [write_margin_size-1:0] (WMint, WM); 
        



//      assign scanreg_ctrl_wire={scanreg_ctrl[scanlen_ctrl - 2:0],SCTRLIint};
//      assign scanreg_dl_wire={scanreg_dl[scanlen_l - 2:0],SDLIint};
//      assign scanreg_dr_wire={scanreg_dr[scanlen_r - 2:0],SDRIint};
      
        
      assign Aint   = (TBISTint === 1'b0 ) ? Asys : (TBISTint === 1'bx ) ? {Addr{1'bx}} : TAint;  

        
//        assign A_int = Aint;
	
        
                
        assign Dint[0] = (TBISTint === 1'b0) ? Dsys[0] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[1] = (TBISTint === 1'b0) ? Dsys[1] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[2] = (TBISTint === 1'b0) ? Dsys[2] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[3] = (TBISTint === 1'b0) ? Dsys[3] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[4] = (TBISTint === 1'b0) ? Dsys[4] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[5] = (TBISTint === 1'b0) ? Dsys[5] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[6] = (TBISTint === 1'b0) ? Dsys[6] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[7] = (TBISTint === 1'b0) ? Dsys[7] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[8] = (TBISTint === 1'b0) ? Dsys[8] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[9] = (TBISTint === 1'b0) ? Dsys[9] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[10] = (TBISTint === 1'b0) ? Dsys[10] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[11] = (TBISTint === 1'b0) ? Dsys[11] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[12] = (TBISTint === 1'b0) ? Dsys[12] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[13] = (TBISTint === 1'b0) ? Dsys[13] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[14] = (TBISTint === 1'b0) ? Dsys[14] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[15] = (TBISTint === 1'b0) ? Dsys[15] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[16] = (TBISTint === 1'b0) ? Dsys[16] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[17] = (TBISTint === 1'b0) ? Dsys[17] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[18] = (TBISTint === 1'b0) ? Dsys[18] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[19] = (TBISTint === 1'b0) ? Dsys[19] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[20] = (TBISTint === 1'b0) ? Dsys[20] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[21] = (TBISTint === 1'b0) ? Dsys[21] : (TBISTint === 1'b1) ? TODint : 1'bx;  

                
        assign Dint[22] = (TBISTint === 1'b0) ? Dsys[22] : (TBISTint === 1'b1) ? TEDint : 1'bx;  

        
        assign Dint[23] = (TBISTint === 1'b0) ? Dsys[23] : (TBISTint === 1'b1) ? TODint : 1'bx;          
	 
        assign Mint = 24'b0;
         

        assign WENbuf = (TBISTint === 1'b0 ) ? WENsys : (TBISTint === 1'bx ) ? 1'bx : TWENint;  
        assign WENint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? WENbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[13] : (ATPint === 1'b0 ) ? WENsys : 1'bx ; 
        
        assign CSNbuf = (TBISTint === 1'b0 ) ? CSNsys : (TBISTint === 1'bx ) ? 1'bx : TCSNint;  
        assign CSNint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? CSNbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[11] : (ATPint === 1'b0 ) ? CSNsys : 1'bx ; 
        assign IGint = (ATPint === 1'b1) ? (SEint === 1'b0 ) ? IGbuf : (SEint === 1'bx ) ? 1'bx :scanreg_ctrl_wire[14] : (ATPint === 1'b0 ) ? IGbuf : 1'bx;

        
        assign DEint = (LSint === 1'bx || (LSint === 1'b0 && HSint === 1'bx) || ^RMint !== 1'b0 || ^WMint !== 1'b0 ) ? 1'bx : 1'b0;
        
     
     and (TBISTint, ATPint, TBISTsys);
     and (SEint, ATPint, SEsys);
     and (TBYPASSint, ATPint, TBYPASSsys);
     and (TSE,TBYPASSint,!SEsys);
     and (MEMEN,INITNint,!CSNint,!SLEEPint,!TBYPASSint,!SEint,!IGint,!DEint,!STDBYint );
     and (MEMEN_dft,INITNint, !SLEEPint, ATPint,!STDBYint);

 `ifdef functional
/*****************assertions added to optimize dynamic power consumption**********/

//psl a_M: assert always ({( RW_assertions_en);(MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1))  } |-> (stable(Msys))) @(posedge CK); 

//psl a_WEN: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(WENsys))) @(posedge CK); 

//psl a_A: assert always ({( RW_assertions_en);(MEMEN === 1'b0)  } |-> (stable(Asys))) @(posedge CK); 

//psl a_D: assert always ({( RW_assertions_en);((MEMEN === 1'b0 || (MEMEN === 1'b1 && WENint ===1'b1)) && TBYPASSint === 1'b0)  } |-> (stable(Dsys))) @(posedge CK); 

/**********************************************************************************************/
`endif       

     

         
reg vddmp,vddmo, vddma, vddsmp, vddsma, gndsm, gndm,  vddmpi ; 
 
initial 
begin

        vddmp = 1'b1 ; 
        vddmo = 1'b1 ;
        vddma = 1'b1 ;
        
        vddsmp = 1'b1 ;
        
        
         gndm = 1'b0 ;
          
end

        
         assign gndmint = (reg_mem_block === 0) ? gndm : 1'b1;
         
         
         
         
         assign vddmpint = vddmp;
         assign vddmoint = vddmo;
         assign vddmaint = vddma;
         
          
        
         

        //CPF Changes

        
                
        initial
        begin : cpfvddmp 
           vddmpreg = vddmpint;
        end

        always @(vddmpint) begin
           vddmpreg = vddmpint;
        end
        
        initial
        begin : cpfvddmo 
           vddmoreg = vddmoint;
        end

        always @(vddmoint) begin
           vddmoreg = vddmoint;
        end
        
        initial
        begin : cpfvddma 
           vddmareg = vddmaint;
        end

        always @(vddmaint) begin
           vddmareg = vddmaint;
        end

        
        
 
        initial
        begin : cpfgndm 
           gndmreg = gndmint;
        end

        always @(gndmint) begin
           gndmreg = gndmint;
        end

        
        



 `ifdef functional
  `else
  initial begin
    if (debug_level < 1) begin
     $display ("%m  INFORMATION");
     $display ("***************************************");
     $display ("The Model is Operating in TIMING MODE");
     $display ("Please make sure that SDF is properly annotated otherwise dummy values will be used");
     $display ("%s", message_status);
     $display ("***************************************");
    end
  end

//////////////////////////
 //REG DECLARATIONS
   //======================

   reg [Bits-1 : 0] TimingViol_data;
   reg  [Bits-1 : 0] TimingViol_mask;
   reg [Bits-1 : 0] TimingViol_data_last, TimingViol_mask_last;
	reg TimingViol_data_0;
	reg TimingViol_data_1;
	reg TimingViol_data_2;
	reg TimingViol_data_3;
	reg TimingViol_data_4;
	reg TimingViol_data_5;
	reg TimingViol_data_6;
	reg TimingViol_data_7;
	reg TimingViol_data_8;
	reg TimingViol_data_9;
	reg TimingViol_data_10;
	reg TimingViol_data_11;
	reg TimingViol_data_12;
	reg TimingViol_data_13;
	reg TimingViol_data_14;
	reg TimingViol_data_15;
	reg TimingViol_data_16;
	reg TimingViol_data_17;
	reg TimingViol_data_18;
	reg TimingViol_data_19;
	reg TimingViol_data_20;
	reg TimingViol_data_21;
	reg TimingViol_data_22;
	reg TimingViol_data_23;
 reg TimingViol_mask_0;
 reg TimingViol_mask_1;
 reg TimingViol_mask_2;
 reg TimingViol_mask_3;
 reg TimingViol_mask_4;
 reg TimingViol_mask_5;
 reg TimingViol_mask_6;
 reg TimingViol_mask_7;
 reg TimingViol_mask_8;
 reg TimingViol_mask_9;
 reg TimingViol_mask_10;
 reg TimingViol_mask_11;
 reg TimingViol_mask_12;
 reg TimingViol_mask_13;
 reg TimingViol_mask_14;
 reg TimingViol_mask_15;
 reg TimingViol_mask_16;
 reg TimingViol_mask_17;
 reg TimingViol_mask_18;
 reg TimingViol_mask_19;
 reg TimingViol_mask_20;
 reg TimingViol_mask_21;
 reg TimingViol_mask_22;
 reg TimingViol_mask_23;

   reg TimingViol_addr;
   reg TimingViol_CSN, TimingViol_WEN, TimingViol_tbypass;
   reg TimingViol_tckh, TimingViol_tckl, TimingViol_tcycle;
   reg TimingViol_tckh_se, TimingViol_tckl_se, TimingViol_tcycle_se;
   reg TimingViol_sctrli,TimingViol_sdli,TimingViol_sdri,TimingViol_se;
   reg TimingViol_smli,TimingViol_smri;
   reg TimingViol_sctrli_flag,TimingViol_sdli_flag,TimingViol_sdri_flag;
   reg TimingViol_smli_flag,TimingViol_smri_flag;
   reg TimingViol_initnl;
   reg TimingViol_initn;
   reg TimingViol_ls;
   reg TimingViol_hs;
   reg TimingViol_sleep;
   reg TimingViol_stdby;
   reg TimingViol_rm;
   reg TimingViol_wm;
   reg TimingViol_tbist,TimingViol_ig,TimingViol_atp,TimingViol_TED,TimingViol_TOD,TimingViol_TEM,TimingViol_TOM;
   reg TimingViolRRAE,TimingViolRRA;

   wire CSTBYPASSN,cond_sdf_tas,cond_sdf_tds,cond_sdf_tms,cond_sdf_tws,cond_sdf_tbas,cond_sdf_tbps,cond_sdf_tbws,cond_sdf_tbdes,cond_sdf_tbdos,cond_sdf_tbmes,cond_sdf_tbmos;
   wire SETB_EN,CSIG_EN,MEM_ACT,EN_ADM,CS_EN,CS_ADM,cond_sdf_tps,IG_EN,IG_ADM,cond_sdf_tigs,cond_sdf_taa,cond_sdf_taa_ls1,cond_sdf_taa_hs1,cond_tseq_tm;
   wire cond_sdf_tcycle,cond_sdf_tcycle_ls1,cond_sdf_tcycle_hs1,cond_sdf_tcycle_se,cond_sdf_tckl_se,cond_sdf_tsctrlis,cond_sdf_tsdlis,cond_sdf_tsdris,cond_sdf_tsmlis,cond_sdf_tsmris;
   wire cond_sdf_tckh_se,cond_sdf_taa_sctrlo_se,cond_sdf_taa_sdlo_se,cond_sdf_taa_sdro_se,cond_sdf_taa_smlo_se,cond_sdf_taa_smro_se,cond_sdf_tckl,cond_sdf_tckh;
   wire cond_sdf_ttms,cond_sdf_tbists,INITNandnotSLEEPandATPandnotSE,cond_sdf_taa_sctrlo,cond_sdf_taa_sdlo,cond_sdf_taa_sdro,cond_sdf_taa_smlo,cond_sdf_taa_smro;
   wire cond_sdf_taa_tm,cond_sdf_taa_tm_ls1, cond_sdf_taa_tm_hs1,cond_sdf_taa_tckq_tm,cond_sdf_taa_tseq_tm;

   wire CSWETBYPASSN;
   wire cond_sdf_tstdbys,cond_sdf_tsls,sleep_en,atp_csn_en;
   wire cond_sdf_tlss,cond_sdf_thss,cond_sdf_trms,cond_sdf_twms; 
   wire cond_sdf_tses,cond_sdf_tinitns;
   wire tby_se_en;
   wire rra_en;
   wire tbist_atp_en;
   wire rrae_en;
   wire tbist_rrae_en;
   wire cond_sdf_trraes;
   wire cond_sdf_ttrraes;
   wire cond_sdf_taa_trramatch;
   wire cond_sdf_ttrraematch;
   wire cond_sdf_tamatch;
   wire cond_sdf_ttamatch;
   wire cond_sdf_tatpmatch;
   wire cond_sdf_ttbistmatch;



 and (CSWEMTBYPASS[0], !Mreg[0], CSWETBYPASSN);
 and (CSWEMTBYPASS[1], !Mreg[1], CSWETBYPASSN);
 and (CSWEMTBYPASS[2], !Mreg[2], CSWETBYPASSN);
 and (CSWEMTBYPASS[3], !Mreg[3], CSWETBYPASSN);
 and (CSWEMTBYPASS[4], !Mreg[4], CSWETBYPASSN);
 and (CSWEMTBYPASS[5], !Mreg[5], CSWETBYPASSN);
 and (CSWEMTBYPASS[6], !Mreg[6], CSWETBYPASSN);
 and (CSWEMTBYPASS[7], !Mreg[7], CSWETBYPASSN);
 and (CSWEMTBYPASS[8], !Mreg[8], CSWETBYPASSN);
 and (CSWEMTBYPASS[9], !Mreg[9], CSWETBYPASSN);
 and (CSWEMTBYPASS[10], !Mreg[10], CSWETBYPASSN);
 and (CSWEMTBYPASS[11], !Mreg[11], CSWETBYPASSN);
 and (CSWEMTBYPASS[12], !Mreg[12], CSWETBYPASSN);
 and (CSWEMTBYPASS[13], !Mreg[13], CSWETBYPASSN);
 and (CSWEMTBYPASS[14], !Mreg[14], CSWETBYPASSN);
 and (CSWEMTBYPASS[15], !Mreg[15], CSWETBYPASSN);
 and (CSWEMTBYPASS[16], !Mreg[16], CSWETBYPASSN);
 and (CSWEMTBYPASS[17], !Mreg[17], CSWETBYPASSN);
 and (CSWEMTBYPASS[18], !Mreg[18], CSWETBYPASSN);
 and (CSWEMTBYPASS[19], !Mreg[19], CSWETBYPASSN);
 and (CSWEMTBYPASS[20], !Mreg[20], CSWETBYPASSN);
 and (CSWEMTBYPASS[21], !Mreg[21], CSWETBYPASSN);
 and (CSWEMTBYPASS[22], !Mreg[22], CSWETBYPASSN);
 and (CSWEMTBYPASS[23], !Mreg[23], CSWETBYPASSN);

and (atp_csn_en,!ATPint,!CSNint,!IGint);
or (sleep_en,atp_csn_en,ATPint);
or (SETB_EN,SEint,TBISTint);
and (ATP_SETB_EN,ATPint,SETB_EN); 
or (CSIG_EN,IGint,CSNint);
and (MEM_ACT,!ATPint,CSIG_EN);
or (EN_ADM,MEM_ACT,ATP_SETB_EN);
and (CS_EN,!ATPint,IGint);
or (CS_ADM,CS_EN,ATP_SETB_EN);
and (atp_ig_csn_en,!ATPint,!CSNint,!IGint);
and (atp_se_en,!SEsys,ATPint);
or (cycle_en,atp_ig_csn_en,atp_se_en);
and (atp_ig_csn_en_reg,!ATPreg,!CSNreg,!IGreg);
and (atp_se_en_reg,!SE_reg,ATPreg);
or (cycle_en_reg,atp_ig_csn_en,atp_se_en);
and (INITNandnotSLEEPandATPandnotSE,cond_gac,!SEsys,ATPint);
and (csn_ig_en,!IGint,!CSNint);
and (atp_tby_ls_en,atp_se_en,cond_ls_tby_en);
and (IG_EN,!ATPint,!CSNint);
or (IG_ADM,IG_EN,atp_se_en);
and (CSWETBYPASSN, !WENreg, 1'b1);



assign cond_sdf_tsls=((sleep_en && INITNint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tstdbys=((sleep_en && INITNint && !SLEEPint) !==0) ? 1:0;
assign cond_sdf_atps=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_gac=((INITNint && !SLEEPint && !STDBYint) !==0) ? 1:0;
assign cond_sdf_tas=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tds=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tms=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tws=((cond_gac && !EN_ADM) !==0) ? 1:0;
assign cond_sdf_tps=((cond_gac && !CS_ADM) !==0) ? 1:0;
assign cond_sdf_tcycle=((cond_gac && cycle_en && !LSint && !HSint) !==0) ? 1:0;  
assign cond_sdf_tcycle_ls1=((cond_gac && cycle_en && LSint) !==0) ? 1:0;
assign cond_sdf_tcycle_hs1=((cond_gac && cycle_en && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_tckh=((cond_gac && cycle_en_reg) !==0) ? 1:0;
assign cond_sdf_tckl=((cond_gac && cycle_en) !==0) ? 1:0;
assign cond_sdf_tcycle_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckl_se=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsctrlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsdris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmlis=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tsmris=((cond_gac && SEint) !==0) ? 1:0;
assign cond_sdf_tckh_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro_se=((cond_gac && SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_ttms=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_tbists=((cond_gac && !SEsys && ATPint) !==0) ? 1:0;
assign cond_sdf_taa_sctrlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_sdro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smlo=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_smro=((cond_gac && !SE_reg && ATPreg) !==0) ? 1:0;
assign cond_sdf_taa_tckq_tm=((cond_gac && SE_reg && ATPreg && TBYPASSsys) !==0) ? 1:0;
assign cond_ls_en=((atp_ig_csn_en || atp_tby_ls_en) !==0) ? 1:0;
assign cond_sdf_tlss=((cond_ls_en && cond_gac) !==0) ? 1:0;
assign cond_sdf_thss=((cond_ls_en && cond_gac && !LSint) !==0) ? 1:0;
assign cond_sdf_trms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_twms=((cond_gac && !CSNint && !TBYPASSint && !SEint && !IGint && !DEint) !==0) ? 1:0; 
assign cond_sdf_tses=((cond_gac && ATPint) !==0) ? 1:0;
assign cond_sdf_tbas=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbps=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbws=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbdos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmes=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tbmos=((cond_gac && TBISTint && !SEsys) !==0) ? 1:0;
assign cond_sdf_tigs=((cond_gac && IG_ADM) !==0) ? 1:0;
assign cond_sdf_taa=((MEMEN_reg && WENreg && !LSint && !HSint) !==0) ? 1:0; 
// assign cond_sdf_taa_tbypass_q = ((MEMEN_reg && ATPint && TBYPASSint) !== 1'b0) ? 1'b1 : 1'b0;
assign cond_sdf_taa_ls1=((MEMEN_reg && WENreg && LSint) !==0) ? 1:0; 
assign cond_sdf_taa_hs1=((MEMEN_reg && WENreg && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && !HSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_ls1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && LSint) !==0) ? 1:0;
assign cond_sdf_taa_tm_hs1=((INITNandnotSLEEPandATPandnotSE && TBYPASSsys && !LSint && HSint) !==0) ? 1:0;
assign cond_sdf_taa_tseq_tm=((cond_gac && TBYPASSint) !==0) ? 1:0;
assign cond_sdf_tinitns =(( sleep_en && !STDBYint && !SLEEPint) !==0) ? 1:0;
assign cond_ls_tby_en=((TBYPASSsys || csn_ig_en) !==0) ? 1:0;



//specify block begins

specify
    specparam
    
         PATHPULSE$CK$Q = 0,
         PATHPULSE$CK$SCTRLO = 0,

         PATHPULSE$CK$SDLO = 0,
         PATHPULSE$CK$SDRO = 0,
        
         PATHPULSE$SE$Q = 0,
         
//         PATHPULSE$TBYPASS$Q = 0,


        
         
        
         tsls = `setup_time,
         tslh = `hold_time ,
         tstdbys = `setup_time,
         tstdbyh = `hold_time , 
	 

         
         tcycle = `cycle_time,
         
         
         tckh = `pulse_width_time,
         tckl = `pulse_width_time,
         tcycle_se = `cycle_time,
         tckh_se = `pulse_width_time,
         tckl_se = `pulse_width_time,
         
         ttms = `setup_time,
         ttmh = `hold_time ,
         tps = `setup_time,
         tph = `hold_time ,
         tws = `setup_time,
         twh = `hold_time ,
         tds = `setup_time,
         tdh = `hold_time , 
         tas = `setup_time,
         tah = `hold_time ,
         tses= `setup_time,
         tseh= `hold_time ,
         tsctrlis=`setup_time,
         tsctrlih=`hold_time ,
         tsdlis=`setup_time,
         tsdlih=`hold_time ,
         tsdris=`setup_time,
         tsdrih=`hold_time , 
         tbists=`setup_time,
         tbisth=`hold_time ,
         tbps=`setup_time,
         tbph=`hold_time ,
         tbws=`setup_time,
         tbwh=`hold_time ,
         tbdes=`setup_time,
         tbdeh=`hold_time ,
         tbdos=`setup_time,
         tbdoh=`hold_time ,
         
         tbas=`setup_time,
         tbah=`hold_time ,
         tinitnl=`initin_low_pulse,
         tinitns=`setup_time,
         tinitnh=`hold_time ,
         tatps=`setup_time,
         tatph=`hold_time ,
         tigs=`setup_time,
         tigh=`hold_time ,
         
         
         trms=`setup_time,
         trmh=`hold_time ,
         twms=`setup_time,
         twmh=`hold_time , 

/*************************************************************************************************/
           // taa_tbypass_q = `access_time,
           // th_tbypass_q  = `retain_time,
            taa =`access_time,
            th = `retain_time,

 


            taa_tm =`access_time,
            th_tm = `retain_time,

            
            taa_tseq_tm =`access_time,
            th_tseq_tm = `retain_time,
            taa_tckq_tm   = `access_time,
            th_tckq_tm    = `retain_time,
            taa_sctrlo=`access_time,
            th_sctrlo= `retain_time,
            taa_sdlo=`access_time,
            th_sdlo= `retain_time,
            taa_sdro=`access_time,
            th_sdro= `retain_time,
            
         
            taa_sctrlo_se=`access_time,
            th_sctrlo_se= `retain_time
,
            taa_sdlo_se=`access_time,
            th_sdlo_se= `retain_time,
            taa_sdro_se=`access_time,
            th_sdro_se= `retain_time
         ;  


        /*---------------------- Timing Checks ---------------------*/

	$setup(posedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(posedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[0], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[1], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[2], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[3], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$setup(negedge A[4], posedge CK &&& cond_sdf_tas , tas, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, posedge A[4], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[0], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[1], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[2], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[3], tah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tas, negedge A[4], tah, TimingViol_addr);

	$setup(posedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(posedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(posedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(posedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(posedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(posedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(posedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(posedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(posedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(posedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(posedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(posedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(posedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(posedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(posedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(posedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(posedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(posedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(posedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(posedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(posedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(posedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$setup(posedge D[22], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_22);
	$setup(posedge D[23], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_23);
	$setup(negedge D[0], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_0);
	$setup(negedge D[1], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_1);
	$setup(negedge D[2], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_2);
	$setup(negedge D[3], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_3);
	$setup(negedge D[4], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_4);
	$setup(negedge D[5], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_5);
	$setup(negedge D[6], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_6);
	$setup(negedge D[7], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_7);
	$setup(negedge D[8], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_8);
	$setup(negedge D[9], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_9);
	$setup(negedge D[10], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_10);
	$setup(negedge D[11], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_11);
	$setup(negedge D[12], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_12);
	$setup(negedge D[13], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_13);
	$setup(negedge D[14], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_14);
	$setup(negedge D[15], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_15);
	$setup(negedge D[16], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_16);
	$setup(negedge D[17], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_17);
	$setup(negedge D[18], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_18);
	$setup(negedge D[19], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_19);
	$setup(negedge D[20], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_20);
	$setup(negedge D[21], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_21);
	$setup(negedge D[22], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_22);
	$setup(negedge D[23], posedge CK &&& cond_sdf_tds, tds, TimingViol_data_23);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[21], tdh, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[22], tdh, TimingViol_data_22);
	$hold(posedge CK &&& cond_sdf_tds, posedge D[23], tdh, TimingViol_data_23);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[0], tdh, TimingViol_data_0);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[1], tdh, TimingViol_data_1);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[2], tdh, TimingViol_data_2);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[3], tdh, TimingViol_data_3);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[4], tdh, TimingViol_data_4);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[5], tdh, TimingViol_data_5);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[6], tdh, TimingViol_data_6);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[7], tdh, TimingViol_data_7);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[8], tdh, TimingViol_data_8);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[9], tdh, TimingViol_data_9);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[10], tdh, TimingViol_data_10);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[11], tdh, TimingViol_data_11);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[12], tdh, TimingViol_data_12);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[13], tdh, TimingViol_data_13);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[14], tdh, TimingViol_data_14);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[15], tdh, TimingViol_data_15);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[16], tdh, TimingViol_data_16);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[17], tdh, TimingViol_data_17);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[18], tdh, TimingViol_data_18);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[19], tdh, TimingViol_data_19);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[20], tdh, TimingViol_data_20);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[21], tdh, TimingViol_data_21);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[22], tdh, TimingViol_data_22);
	$hold(posedge CK &&& cond_sdf_tds, negedge D[23], tdh, TimingViol_data_23);

        



        $setup(posedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $setup(negedge WEN, posedge CK &&& cond_sdf_tws, tws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, posedge WEN, twh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tws, negedge WEN, twh, TimingViol_WEN); 
        $setup(posedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$setup(negedge CSN, posedge CK &&& cond_sdf_tps, tps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, posedge CSN, tph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tps, negedge CSN, tph, TimingViol_CSN);
        $period(posedge CK &&& cond_sdf_tcycle, tcycle, TimingViol_tcycle);  

        
        $width(posedge CK  &&& cond_sdf_tckh, tckh, 0, TimingViol_tckh);
        $width(negedge CK  &&& cond_sdf_tckl, tckl, 0, TimingViol_tckl);
        $period(posedge CK &&& cond_sdf_tcycle_se, tcycle_se, TimingViol_tcycle_se);
        $width(posedge CK  &&& cond_sdf_tckh_se, tckh_se, 0, TimingViol_tckh_se);
        $width(negedge CK  &&& cond_sdf_tckl_se, tckl_se, 0, TimingViol_tckl_se);

        
        $setup(posedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $setup(negedge TBYPASS, posedge CK &&& cond_sdf_ttms,ttms, TimingViol_tbypass);
        $hold(posedge CK &&& cond_sdf_ttms, posedge TBYPASS, ttmh, TimingViol_tbypass); 
        $hold(posedge CK &&& cond_sdf_ttms, negedge TBYPASS, ttmh, TimingViol_tbypass); 
 



        
        $setup(posedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $setup(negedge SLEEP, posedge CK &&& cond_sdf_tsls, tsls, TimingViol_sleep);
        $hold(posedge CK &&& cond_sdf_tsls, posedge SLEEP, tslh, TimingViol_sleep);        
        $hold(posedge CK &&& cond_sdf_tsls, negedge SLEEP, tslh, TimingViol_sleep);

        $setup(posedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $setup(negedge STDBY, posedge CK &&& cond_sdf_tstdbys, tstdbys, TimingViol_stdby);
        $hold(posedge CK &&& cond_sdf_tstdbys, posedge STDBY, tstdbyh, TimingViol_stdby);        
        $hold(posedge CK &&& cond_sdf_tstdbys, negedge STDBY, tstdbyh, TimingViol_stdby); 
        
        
        $setup (posedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
	$setup (negedge SE ,posedge CK &&& cond_sdf_tses,tses,TimingViol_se);
        
        $hold (posedge CK &&& cond_sdf_tses, posedge SE ,tseh,TimingViol_se);
	$hold (posedge CK &&& cond_sdf_tses, negedge SE ,tseh,TimingViol_se);
        
        $setup(posedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis , tsctrlis, TimingViol_sctrli);
        $setup(negedge SCTRLI, posedge CK  &&& cond_sdf_tsctrlis, tsctrlis, TimingViol_sctrli);
        $hold(posedge CK &&& cond_sdf_tsctrlis , posedge SCTRLI, tsctrlih, TimingViol_sctrli);        
        $hold(posedge CK &&& cond_sdf_tsctrlis , negedge SCTRLI, tsctrlih, TimingViol_sctrli);

        $setup(posedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $setup(negedge SDLI, posedge CK &&& cond_sdf_tsdlis, tsdlis, TimingViol_sdli);
        $hold(posedge CK &&& cond_sdf_tsdlis, posedge SDLI, tsdlih, TimingViol_sdli);        
        $hold(posedge CK &&& cond_sdf_tsdlis, negedge SDLI, tsdlih, TimingViol_sdli);

        $setup(posedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $setup(negedge SDRI, posedge CK &&& cond_sdf_tsdris, tsdris, TimingViol_sdri);
        $hold(posedge CK &&& cond_sdf_tsdris, posedge SDRI, tsdrih, TimingViol_sdri);        
        $hold(posedge CK &&& cond_sdf_tsdris, negedge SDRI, tsdrih, TimingViol_sdri);
        
 
	
         
        $width(negedge INITN , tinitnl, 0, TimingViol_initnl);
        
        $setup(posedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        $setup(negedge INITN, posedge CK &&& cond_sdf_tinitns, tinitns, TimingViol_initn);
        
        $hold (posedge CK &&& cond_sdf_tinitns,posedge INITN, tinitnh, TimingViol_initn);
        $hold (posedge CK &&& cond_sdf_tinitns,negedge INITN, tinitnh, TimingViol_initn);

        $setup(posedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $setup(negedge ATP, posedge CK &&& cond_sdf_atps , tatps, TimingViol_atp);
        $hold(posedge CK &&& cond_sdf_atps, posedge ATP, tatph, TimingViol_atp);        
        $hold(posedge CK &&& cond_sdf_atps, negedge ATP, tatph, TimingViol_atp);
        
        $setup(posedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $setup(negedge IG, posedge CK &&& cond_sdf_tigs , tigs, TimingViol_ig);
        $hold(posedge CK &&& cond_sdf_tigs, posedge IG, tigh, TimingViol_ig);        
        $hold(posedge CK &&& cond_sdf_tigs, negedge IG, tigh, TimingViol_ig);



         
$setup(posedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(posedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[0], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[1], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$setup(negedge RM[2], posedge CK &&& cond_sdf_trms, trms, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, posedge RM[2], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[0], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[1], trmh, TimingViol_rm);
$hold(posedge CK &&& cond_sdf_trms, negedge RM[2], trmh, TimingViol_rm); 

        
$setup(posedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(posedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[0], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$setup(negedge WM[1], posedge CK &&& cond_sdf_twms, twms, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, posedge WM[1], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[0], twmh, TimingViol_wm);
$hold(posedge CK &&& cond_sdf_twms, negedge WM[1], twmh, TimingViol_wm);
 
        
        $setup(posedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $setup(negedge TBIST, posedge CK &&& cond_sdf_tbists , tbists, TimingViol_tbist);
        $hold(posedge CK &&& cond_sdf_tbists, posedge TBIST, tbisth, TimingViol_tbist);        
        $hold(posedge CK &&& cond_sdf_tbists, negedge TBIST, tbisth, TimingViol_tbist);
        
        	$setup(posedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(posedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$setup(negedge TA[0], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[1], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[2], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[3], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
	$setup(negedge TA[4], posedge CK &&& cond_sdf_tbas , tbas, TimingViol_addr);
        	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, posedge TA[4], tbah, TimingViol_addr);
       	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[0], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[1], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[2], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[3], tbah, TimingViol_addr);
	$hold(posedge CK &&& cond_sdf_tbas, negedge TA[4], tbah, TimingViol_addr);

        $setup(posedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$setup(negedge TCSN, posedge CK &&& cond_sdf_tbps, tbps, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, posedge TCSN, tbph, TimingViol_CSN);
	$hold(posedge CK &&& cond_sdf_tbps, negedge TCSN, tbph, TimingViol_CSN); 
       
        $setup(posedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $setup(negedge TWEN, posedge CK &&& cond_sdf_tbws, tbws, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, posedge TWEN, tbwh, TimingViol_WEN);
        $hold(posedge CK &&& cond_sdf_tbws, negedge TWEN, tbwh, TimingViol_WEN);
       
       
        $setup(posedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $setup(negedge TED, posedge CK &&& cond_sdf_tbdes, tbdes, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, posedge TED, tbdeh, TimingViol_TED);
        $hold(posedge CK &&& cond_sdf_tbdes, negedge TED, tbdeh, TimingViol_TED);

        $setup(posedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $setup(negedge TOD, posedge CK &&& cond_sdf_tbdos, tbdos, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, posedge TOD, tbdoh, TimingViol_TOD);
        $hold(posedge CK &&& cond_sdf_tbdos, negedge TOD, tbdoh, TimingViol_TOD);

          


          

          /*-------------------- Propagation Delays ------------------*/
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[22] +: OutReg_data[22])) = (taa, taa, th, taa, th, taa);
                
	
        if (cond_sdf_taa) 
                (posedge CK => (Q[23] +: OutReg_data[23])) = (taa, taa, th, taa, th, taa);
                 

/* // //	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[0] +: OutReg_data[0])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[1] +: OutReg_data[1])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[2] +: OutReg_data[2])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[3] +: OutReg_data[3])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[4] +: OutReg_data[4])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[5] +: OutReg_data[5])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[6] +: OutReg_data[6])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[7] +: OutReg_data[7])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[8] +: OutReg_data[8])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[9] +: OutReg_data[9])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[10] +: OutReg_data[10])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[11] +: OutReg_data[11])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[12] +: OutReg_data[12])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[13] +: OutReg_data[13])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[14] +: OutReg_data[14])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[15] +: OutReg_data[15])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[16] +: OutReg_data[16])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[17] +: OutReg_data[17])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[18] +: OutReg_data[18])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[19] +: OutReg_data[19])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[20] +: OutReg_data[20])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[21] +: OutReg_data[21])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[22] +: OutReg_data[22])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q);
//	if (cond_sdf_taa_tbypass_q) (posedge TBYPASS => (Q[23] +: OutReg_data[23])) = (taa_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q, th_tbypass_q, taa_tbypass_q); */ 








	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[0] +: OutReg_data[0])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[1] +: OutReg_data[1])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[2] +: OutReg_data[2])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[3] +: OutReg_data[3])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[4] +: OutReg_data[4])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[5] +: OutReg_data[5])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[6] +: OutReg_data[6])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[7] +: OutReg_data[7])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[8] +: OutReg_data[8])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[9] +: OutReg_data[9])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[10] +: OutReg_data[10])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[11] +: OutReg_data[11])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[12] +: OutReg_data[12])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[13] +: OutReg_data[13])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[14] +: OutReg_data[14])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[15] +: OutReg_data[15])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[16] +: OutReg_data[16])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[17] +: OutReg_data[17])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[18] +: OutReg_data[18])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[19] +: OutReg_data[19])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[20] +: OutReg_data[20])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[21] +: OutReg_data[21])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[22] +: OutReg_data[22])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                
	
        if (cond_sdf_taa_tm) 
                (posedge CK => (Q[23] +: OutReg_data[23])) = (taa_tm, taa_tm, th_tm, taa_tm, th_tm, taa_tm);
                





	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[0] +: OutReg_data[0])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[1] +: OutReg_data[1])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[2] +: OutReg_data[2])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[3] +: OutReg_data[3])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[4] +: OutReg_data[4])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[5] +: OutReg_data[5])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[6] +: OutReg_data[6])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[7] +: OutReg_data[7])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[8] +: OutReg_data[8])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[9] +: OutReg_data[9])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[10] +: OutReg_data[10])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[11] +: OutReg_data[11])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[12] +: OutReg_data[12])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[13] +: OutReg_data[13])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[14] +: OutReg_data[14])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[15] +: OutReg_data[15])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[16] +: OutReg_data[16])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[17] +: OutReg_data[17])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[18] +: OutReg_data[18])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[19] +: OutReg_data[19])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[20] +: OutReg_data[20])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[21] +: OutReg_data[21])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[22] +: OutReg_data[22])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[22] +: OutReg_data[22])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                
	
        if (cond_sdf_taa_tseq_tm) 
                (posedge SE => (Q[23] +: OutReg_data[23])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
        if (cond_sdf_taa_tseq_tm) 
                (negedge SE => (Q[23] +: OutReg_data[23])) = (taa_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm, th_tseq_tm, taa_tseq_tm);
                 

	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[0] +: OutReg_data[0])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[1] +: OutReg_data[1])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[2] +: OutReg_data[2])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[3] +: OutReg_data[3])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[4] +: OutReg_data[4])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[5] +: OutReg_data[5])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[6] +: OutReg_data[6])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[7] +: OutReg_data[7])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[8] +: OutReg_data[8])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[9] +: OutReg_data[9])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[10] +: OutReg_data[10])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[11] +: OutReg_data[11])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[12] +: OutReg_data[12])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[13] +: OutReg_data[13])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[14] +: OutReg_data[14])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[15] +: OutReg_data[15])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[16] +: OutReg_data[16])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[17] +: OutReg_data[17])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[18] +: OutReg_data[18])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[19] +: OutReg_data[19])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[20] +: OutReg_data[20])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[21] +: OutReg_data[21])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[22] +: OutReg_data[22])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                
	
        if (cond_sdf_taa_tckq_tm) 
                (negedge CK => (Q[23] +: OutReg_data[23])) = (taa_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm, th_tckq_tm, taa_tckq_tm);
                



if (cond_sdf_taa_sctrlo) 
        (posedge CK *> (SCTRLO :  SCTRLI)) = (taa_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo,th_sctrlo,taa_sctrlo); 

if (cond_sdf_taa_sctrlo_se) 
        (negedge CK *> (SCTRLO : SCTRLI)) = (taa_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se,th_sctrlo_se,taa_sctrlo_se); 
 

if (cond_sdf_taa_sdlo) 
        (posedge CK *> (SDLO :  SDLI)) = (taa_sdlo,taa_sdlo,th_sdlo,taa_sdlo,th_sdlo,taa_sdlo); 

if (cond_sdf_taa_sdlo_se) 
        (negedge CK *> (SDLO : SDLI)) = (taa_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se,th_sdlo_se,taa_sdlo_se);

if (cond_sdf_taa_sdro) 
        (posedge CK *> (SDRO :  SDRI)) = (taa_sdro,taa_sdro,th_sdro,taa_sdro,th_sdro,taa_sdro); 

if (cond_sdf_taa_sdro_se) 
        (negedge CK *> (SDRO : SDRI)) = (taa_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se,th_sdro_se,taa_sdro_se); 

  
     




endspecify //specify block ends






// conversion from registers to array elements for data setup violation notifiers

always @(TimingViol_data_0   or TimingViol_TED  )
begin
        TimingViol_data[0]=~TimingViol_data[0];   
end


always @(TimingViol_data_1   or TimingViol_TOD  )
begin
        TimingViol_data[1]=~TimingViol_data[1];   
end


always @(TimingViol_data_2   or TimingViol_TED  )
begin
        TimingViol_data[2]=~TimingViol_data[2];   
end


always @(TimingViol_data_3   or TimingViol_TOD  )
begin
        TimingViol_data[3]=~TimingViol_data[3];   
end


always @(TimingViol_data_4   or TimingViol_TED  )
begin
        TimingViol_data[4]=~TimingViol_data[4];   
end


always @(TimingViol_data_5   or TimingViol_TOD  )
begin
        TimingViol_data[5]=~TimingViol_data[5];   
end


always @(TimingViol_data_6   or TimingViol_TED  )
begin
        TimingViol_data[6]=~TimingViol_data[6];   
end


always @(TimingViol_data_7   or TimingViol_TOD  )
begin
        TimingViol_data[7]=~TimingViol_data[7];   
end


always @(TimingViol_data_8   or TimingViol_TED  )
begin
        TimingViol_data[8]=~TimingViol_data[8];   
end


always @(TimingViol_data_9   or TimingViol_TOD  )
begin
        TimingViol_data[9]=~TimingViol_data[9];   
end


always @(TimingViol_data_10   or TimingViol_TED  )
begin
        TimingViol_data[10]=~TimingViol_data[10];   
end


always @(TimingViol_data_11   or TimingViol_TOD  )
begin
        TimingViol_data[11]=~TimingViol_data[11];   
end


always @(TimingViol_data_12   or TimingViol_TED  )
begin
        TimingViol_data[12]=~TimingViol_data[12];   
end


always @(TimingViol_data_13   or TimingViol_TOD  )
begin
        TimingViol_data[13]=~TimingViol_data[13];   
end


always @(TimingViol_data_14   or TimingViol_TED  )
begin
        TimingViol_data[14]=~TimingViol_data[14];   
end


always @(TimingViol_data_15   or TimingViol_TOD  )
begin
        TimingViol_data[15]=~TimingViol_data[15];   
end


always @(TimingViol_data_16   or TimingViol_TED  )
begin
        TimingViol_data[16]=~TimingViol_data[16];   
end


always @(TimingViol_data_17   or TimingViol_TOD  )
begin
        TimingViol_data[17]=~TimingViol_data[17];   
end


always @(TimingViol_data_18   or TimingViol_TED  )
begin
        TimingViol_data[18]=~TimingViol_data[18];   
end


always @(TimingViol_data_19   or TimingViol_TOD  )
begin
        TimingViol_data[19]=~TimingViol_data[19];   
end


always @(TimingViol_data_20   or TimingViol_TED  )
begin
        TimingViol_data[20]=~TimingViol_data[20];   
end


always @(TimingViol_data_21   or TimingViol_TOD  )
begin
        TimingViol_data[21]=~TimingViol_data[21];   
end


always @(TimingViol_data_22   or TimingViol_TED  )
begin
        TimingViol_data[22]=~TimingViol_data[22];   
end


always @(TimingViol_data_23   or TimingViol_TOD  )
begin
        TimingViol_data[23]=~TimingViol_data[23];   
end


`endif


// TASK DEFINITION DESCRIPTION
// ================================



task task_insert_faults_in_memory;
begin
   if (reg_ConfigFault)
   begin   
     for(i = 0;i< fcnt;i = i+ 1) begin
        if(mem_red_array_stuck_at[i] === "mem_array") begin
          if (array_stuck_at[i] === "sa0") begin
           `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data & stuck_at_0fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
          `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] & stuck_at_0fault[i];
          `endif
         end //if(array_stuck_at)
                                        
         if(array_stuck_at[i] === "sa1") begin
         `ifdef slm
            //Read first
            $slm_ReadMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
            //operation
            slm_temp_data = slm_temp_data | stuck_at_1fault[i];
            //write back
            $slm_WriteMemoryS(MemAddr, FailureLocn[i], slm_temp_data);
         `else
            Mem[FailureLocn[i]] = Mem[FailureLocn[i]] | stuck_at_1fault[i]; 
         `endif
         end //if(array_stuck_at)
       end //if mem_red_array_stuck_at
    
    
     end    // end of for
   end  
end
endtask



task task_read_fault_file;
begin
/*  -----------Implemetation for config fault starts------*/
   msgcnt = X;
   t = 0;
   fault_repair_flag = {max_faults{1'b1}};
   repair_flag = {max_faults{1'b1}};
   if(reg_ConfigFault) 
   begin
      file_ptr = $fopen(reg_Fault_file_name , "r");
      if(file_ptr == 0)
      begin     
          if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: File cannot be opened ",$realtime);
      end        
      else                
      begin : read_fault_file
        t = 0;
        for (i = 0; i< max_faults; i= i + 1)
        begin
         
           stuck0 = {Bits{1'b1}};
           stuck1 = {Bits{1'b0}};
           fault_char1 = $fgetc (file_ptr);
           if (fault_char1 == 8'b11111111)
              disable read_fault_file;
           ret_val = $ungetc (fault_char1, file_ptr);
           ret_val = $fgets(tempStr, file_ptr);
           ret_val = $sscanf(tempStr, "%s %d %d %s",fault_array,fault_word, fault_bit, stuck_at) ;
           flag_error = 0; 
           if(ret_val !== 0)
           begin         
              if(ret_val == 3 || ret_val == 4)
              begin
                if(ret_val == 3)
                   stuck_at = "sa0";

                if(stuck_at !== "sa0" && stuck_at !== "sa1" && stuck_at !== "none")
                begin
                    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: Wrong value for stuck at in fault file ",$realtime);
                   flag_error = 1;
                end    
                      
                if(fault_word >= Words)
                begin
                   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Address out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                if(fault_bit >= Bits)
                begin  
                    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Faulty bit out of range in fault file ",$realtime);
                   flag_error = 1;
                end    

                
                        
                if(fault_array !== "mem_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array is not mem_array ",$realtime);
                  flag_error = 1;
                end

                if(fault_array === "red_array")
                begin
                  if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Fault array can't be on redundancy array in non redundancy cut.",$realtime);
                  flag_error = 1;
                end

                
                

                if(flag_error == 0)
                //Correct Inputs
                begin
                   if(stuck_at === "none")
                   begin
                       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
                   end
                   else
                   //Adding the faults
                   begin
                      FailureLocn[t] = fault_word;
                      Failurebit[t]  = fault_bit ;
                      std_fault_word = fault_word;
                      fault_row_add[t] = std_fault_word[Addr-1:mux_bits];
                      mem_red_array_stuck_at[t] = fault_array;
                      fault_repair_flag[t] = 1'b0;
                      if (stuck_at === "sa0" )
                      begin
                         stuck0[fault_bit] = 1'b0;         
                         stuck_at_0fault[t] = stuck0;
                      end     
                      if (stuck_at === "sa1" )
                      begin
                         stuck1[fault_bit] = 1'b1;
                         stuck_at_1fault[t] = stuck1; 
                      end

                      array_stuck_at[t] = stuck_at;
                      t = t + 1;
                   end //if(stuck_at === "none")  
                end //if(flag_error == 0)
              end //if(ret_val == 2 || ret_val == 3 
              else
              //wrong number of arguments
              begin
                if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) ERROR: WRONG VALUES ENTERED FOR FAULTY WORD OR FAULTY BIT OR STUCK_AT IN Fault_file_name ",$realtime); 
                flag_error = 1;
              end
           end //if(ret_val !== 0)
           else
           begin 
               if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: No fault injected, empty fault file ",$realtime);
           end    
        end //for (i = 0; i< m
      end //begin: read_fault_file  
      $fclose (file_ptr);

      fcnt = t;
      
      //fault injection at time 0.
      task_insert_faults_in_memory;
  end // config_fault 
end
endtask


task WriteMemX;
begin

`ifdef slm
   $slm_ResetMemory(MemAddr, WordX);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = WordX;
   
`endif        
 task_insert_faults_in_memory;
end
endtask

task WriteMem0;
begin
`ifdef slm
   $slm_ResetMemory(MemAddr, Word0);
 
`else
    for (i = 0; i < Words; i = i + 1)
       Mem[i] = Word0;
  
`endif 
   task_insert_faults_in_memory;
end
endtask


task WriteOutX;                
begin
   OutReg_data <= #0 WordX;
end
endtask


task Invalid_next_cycle_func;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_func = 1;
     `else 
       #0 next_cycle_corrupt_func = 0; 
     `endif  
   end 
end
endtask

task Invalid_next_cycle_dft;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
    `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
       #0 next_cycle_corrupt_dft = 1;
     `else 
       #0 next_cycle_corrupt_dft = 0; 
     `endif  
  end
end
endtask

task Invalid_next_cycle_func_tim;
begin
  WriteOutX;
  WriteMemX;
  if (INITNint !== 0) begin
   #0 next_cycle_corrupt_func <= 1;
  end 
end
endtask

task Invalid_next_cycle_dft_tim;
begin
  ScanChainX;
  ScanOutX;   
  if( TBYPASSint !== 0 && SEint !== 1) begin
    WriteOutX;
  end
  if (INITNint !== 0) begin
  #0 next_cycle_corrupt_dft <= 1;
  end
end
endtask


task ScanOutX;                
begin
   
   dff_SCTRLO_SE.Q <= 1'bx;   
   dff_SDLO_SE.Q <= 1'bx; 
   dff_SDRO_SE.Q <= 1'bx; 
    
   
   SCTRLOint=X;
   SDLOint=X;
   SDROint=X;
    
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   SDLO_data<=1'bx;
   SDRO_data<=1'bx;
    
   `endif
end
endtask

task delScanOutX;                
begin
   delSCTRLO_data<=X;
   delSDLO_data<=X;
   delSDRO_data<=X;
    
end
endtask

task ScanChainX;                
begin
 scanreg_ctrl=1'bx; 
 scanreg_dl=1'bx; 
 scanreg_dr =1'bx; 
  
end
endtask

task mem_blocked;
begin
 
   WriteMemX;
   WriteOutX;
   ScanChainX;
   ScanOutX;//immediately;
   delScanOutX;//immediately
   `ifdef POWER_SEQUENCING_OFF
   `else
   reg_mem_block=1;
   `endif
   debug_level = 2'b11;
end
endtask

task corrupt_all;
begin
 
  WriteMemX;
  WriteOutX;
  ScanChainX;
  ScanOutX;
  delScanOutX;//immediately;
  OutReg_data = WordX; 
  delOutReg_data=WordX;
  
end
endtask

task WriteCycle;                  
input [Addr-1 : 0] Address;
reg [Bits-1:0] tempReg1;
reg [Bits-1:0] tempReg_slm;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;


reg repair_flag;

integer po,i,num,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;
begin

   tempReg1 = WordX;
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];

   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};
   
   if (ValidAddress === X )   begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
        WriteMemX;
        if (INITNint !== 0) begin
        `ifdef ST_FUNCTION_NEXT_CYCLE_CORRUPTION_ON         
           #0 next_cycle_corrupt_func = 1;
       `else 
           #0 next_cycle_corrupt_func = 0; 
       `endif  
   end 

   end


   if (ValidAddress !== X && next_cycle_corrupt_func === 0  )
   begin
         if (red_en === 1 && ((Row_Add_cmp === repair_add) || (Row_Add_cmp === next_repair_add)) ) begin
             repair_flag = 1'b1;
             
             Bank_sel_integer = 0;
                     
             if (Row_Add_cmp === repair_add) begin
               Col_Add_integer  = Col_Add; 
             end
             else if (Row_Add_cmp === next_repair_add) begin
               Col_Add_integer  = Col_Add + mux; 
             end  
             RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
        end  

        if(repair_flag === 0 && ValidAddress === 1) begin
           `ifdef slm
              $slm_ReadMemoryS(MemAddr, Address, tempReg_slm);
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = Mem[Address];
            `endif
          end  
        else if(repair_flag === 1) begin
           `ifdef slm
//              $slm_ReadMemoryS(RedMemAddr, RedMem_address, tempReg_slm);
          
               tempReg1=tempReg_slm; 
            `else
               tempReg1 = RedMem[RedMem_address];
            `endif
        end
        
        for (num=0;num<Bits;num=num+1) begin
             po=num;        
             if ( Dint [num] !== tempReg1 [po]) begin
                if (Mint[num] === 1'b0)
                   tempReg1[po] = Dint[num];
                else if (Mint[num] === 1'bX)
                   tempReg1[po] = 1'bx;
             end                
        end //for (num=0
            
         if(repair_flag === 0 ) begin    
            if(ValidAddress === 1) begin  
              `ifdef slm
                  tempReg_slm=tempReg1; 
                  $slm_WriteMemory(MemAddr, Address, tempReg_slm);
              `else
                   Mem[Address] = tempReg1;
              `endif
            end
            else begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address Out Of Range. ",$realtime);
            end        
         end
         else if (repair_flag === 1 ) begin
            `ifdef slm
                tempReg_slm=tempReg1; 
//                $slm_WriteMemory(RedMemAddr, RedMem_address, tempReg_slm);
            `else
                RedMem[RedMem_address] = tempReg1;
            `endif
         end
   end //if (ValidAddress !== X
   task_insert_faults_in_memory;
end
endtask 

task ReadCycle;
input [Addr-1 : 0] Address;

reg [Bits-1:0] MemData_tmp;
reg [Bits-1:0] MemData;

reg [Addr-mux_bits-1:0]Row_Add;
reg [Addr-mux_bits-bank_bits-1:0]Row_Add_cmp;

reg Col_Add;

reg repair_flag;

integer a,numr,Col_Add_integer,Bank_sel_integer,RedMem_address;

begin
   
   repair_flag = 0;
   Row_Add = Address[Addr-1: mux_bits];
   
   Row_Add_cmp = {Row_Add[Addr-mux_bits-1:2+bank_bits],Row_Add[1:0]};

   

   if (ValidAddress !== X && next_cycle_corrupt_func === 0 ) begin   
       if(red_en === 1 && ( Row_Add_cmp === repair_add ||  Row_Add_cmp === next_repair_add )) begin
              repair_flag = 1;
              
              Bank_sel_integer = 0;
               
              if(Row_Add_cmp === repair_add) begin
                Col_Add_integer = Col_Add;
              end
              else if (Row_Add_cmp === next_repair_add) begin
                Col_Add_integer = Col_Add + mux; 
              end
              RedMem_address = ( (2*Bank_sel_integer*mux) + Col_Add_integer );
       end

      if(repair_flag === 0) begin
          if(ValidAddress === 1) begin 
           `ifdef slm
              $slm_ReadMemory(MemAddr, Address, MemData);
           `else
              MemData = Mem[Address];
           `endif
          end
          else begin
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Address Out Of Range. Output Corrupted ",$realtime);
             MemData = WordX;
          end
     end
      else if(repair_flag === 1) begin
        `ifdef slm
//           $slm_ReadMemory(RedMemAddr, RedMem_address, MemData);
        `else
           MemData = RedMem[RedMem_address];
        `endif
      end
   end //if (ValidAddress)  
   
   if(ValidAddress === X)
   begin
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Read Port:  Illegal Value on Address Bus. Memory and Output Corrupted ",$realtime); 
         Invalid_next_cycle_func;
   end 
   
  if(ValidAddress !== X && next_cycle_corrupt_func === 0 )
   begin
   for (a = 0; a < Bits; a = a + 1)
   begin
      if (MemData[a] !== OutReg_data[a])
         OutReg_data[a] = WordX[a];
   end//for (a = 0; a <  
         OutReg_data <= MemData;
   end     
end
endtask



// SCAN CHAINS
supply0 gnd;
buf (A_int[0], Aint[0]);
buf (A_int[1], Aint[1]);
buf (A_int[2], Aint[2]);
buf (A_int[3], Aint[3]);
buf (A_int[4], Aint[4]);                  //used for capturing
buf (A_int[5], gnd);
buf (A_int[6], gnd);
buf (A_int[7], gnd);
buf (A_int[8], gnd);
buf (A_int[9], gnd);
buf (A_int[10], gnd);
buf (A_int[11], gnd);
buf (A_int[12], gnd);
buf (A_int[13], gnd);
buf (A_int[14], gnd);   //used for capturing

buf (WEN_int, WENint);
buf (CSN_int, CSNint);
buf (IG_int, IGint);


// Scan flops



// CONTROL SCAN CHAIN
     ST_SPREG_LOLEAK_32x24m2_Tl_SCFF cntrl_scff_0 (.D(1'b0), .TI(SCTRLI), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[0]), .OUTX(scanreg_ctrl));

      
 ST_SPREG_LOLEAK_32x24m2_Tl_SCFF cntrl_scff_1 (.D(A_int[2]), .TI(scanreg_ctrl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[1]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m2_Tl_SCFF cntrl_scff_2 (.D(A_int[4]), .TI(scanreg_ctrl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[2]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m2_Tl_SCFF cntrl_scff_3 (.D(A_int[7]), .TI(scanreg_ctrl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[3]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m2_Tl_SCFF cntrl_scff_4 (.D(A_int[1]), .TI(scanreg_ctrl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[4]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m2_Tl_SCFF cntrl_scff_5 (.D(A_int[9]), .TI(scanreg_ctrl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[5]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m2_Tl_SCFF cntrl_scff_6 (.D(A_int[8]), .TI(scanreg_ctrl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[6]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m2_Tl_SCFF cntrl_scff_7 (.D(1'b0), .TI(scanreg_ctrl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[7]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m2_Tl_SCFF cntrl_scff_8 (.D(A_int[0]), .TI(scanreg_ctrl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[8]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m2_Tl_SCFF cntrl_scff_9 (.D(A_int[3]), .TI(scanreg_ctrl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[9]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m2_Tl_SCFF cntrl_scff_10 (.D(A_int[5]), .TI(scanreg_ctrl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[10]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m2_Tl_SCFF cntrl_scff_11 (.D(CSN_int), .TI(scanreg_ctrl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[11]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m2_Tl_SCFF cntrl_scff_12 (.D(A_int[6]), .TI(scanreg_ctrl_wire[11]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[12]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m2_Tl_SCFF cntrl_scff_13 (.D(WEN_int), .TI(scanreg_ctrl_wire[12]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[13]), .OUTX(scanreg_ctrl));  
      
 ST_SPREG_LOLEAK_32x24m2_Tl_SCFF cntrl_scff_14 (.D(scanreg_ctrl_wire[14]), .TI(scanreg_ctrl_wire[13]), .TE(SE), .CP(CK_sc), .Q(scanreg_ctrl_wire[14]), .OUTX(scanreg_ctrl));  

reg LP_CK_gate;

// Lock Up Latch
wire SCTRLO_temp;
 ST_SPREG_LOLEAK_32x24m2_Tl_lock_up_latch  dff_SCTRLO_SE (Latch_open, scanreg_ctrl_wire[14], SCTRLO_temp);

always @(SCTRLO_temp) begin
     SCTRLOint= SCTRLO_temp;
 `ifdef functional
 `else
 if (SCTRLOint !== SCTRLO_data) begin 
  if (SCTRLOint !==X)
   SCTRLO_data=1'bx;
   SCTRLO_data <= SCTRLOint;
 end 
 `endif
end  


// LEFT DATA SCAN CHAIN
     ST_SPREG_LOLEAK_32x24m2_Tl_SCFF ldata_scff_0 (.D(Dint[11]), .TI(SDLI), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[0]), .OUTX(scanreg_dl));
      
   
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF ldata_scff_1 (.D(Dint[10]), .TI(scanreg_dl_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[1]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF ldata_scff_2 (.D(Dint[9]), .TI(scanreg_dl_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[2]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF ldata_scff_3 (.D(Dint[8]), .TI(scanreg_dl_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[3]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF ldata_scff_4 (.D(Dint[7]), .TI(scanreg_dl_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[4]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF ldata_scff_5 (.D(Dint[6]), .TI(scanreg_dl_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[5]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF ldata_scff_6 (.D(Dint[5]), .TI(scanreg_dl_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[6]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF ldata_scff_7 (.D(Dint[4]), .TI(scanreg_dl_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[7]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF ldata_scff_8 (.D(Dint[3]), .TI(scanreg_dl_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[8]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF ldata_scff_9 (.D(Dint[2]), .TI(scanreg_dl_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[9]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF ldata_scff_10 (.D(Dint[1]), .TI(scanreg_dl_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[10]), .OUTX(scanreg_dl));

   
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF ldata_scff_11 (.D(Dint[0]), .TI(scanreg_dl_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_dl_wire[11]), .OUTX(scanreg_dl));



// Lock Up Latch
wire SDLO_temp;
 ST_SPREG_LOLEAK_32x24m2_Tl_lock_up_latch  dff_SDLO_SE (Latch_open, scanreg_dl_wire[11], SDLO_temp);

always @(SDLO_temp) begin
     SDLOint= SDLO_temp;
 `ifdef functional
 `else
 if (SDLOint !== SDLO_data) begin 
  if (SDLOint !==X)
   SDLO_data=1'bx;
   SDLO_data <= SDLOint;
 end 
 `endif
end  






// RIGHT DATA SCAN CHAIN

     ST_SPREG_LOLEAK_32x24m2_Tl_SCFF rdata_scff_0 (.D(Dint[23]), .TI(SDRI), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[0]), .OUTX(scanreg_dr));
     
 
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF rdata_scff_1 (.D(Dint[22]), .TI(scanreg_dr_wire[0]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[1]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF rdata_scff_2 (.D(Dint[21]), .TI(scanreg_dr_wire[1]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[2]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF rdata_scff_3 (.D(Dint[20]), .TI(scanreg_dr_wire[2]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[3]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF rdata_scff_4 (.D(Dint[19]), .TI(scanreg_dr_wire[3]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[4]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF rdata_scff_5 (.D(Dint[18]), .TI(scanreg_dr_wire[4]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[5]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF rdata_scff_6 (.D(Dint[17]), .TI(scanreg_dr_wire[5]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[6]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF rdata_scff_7 (.D(Dint[16]), .TI(scanreg_dr_wire[6]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[7]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF rdata_scff_8 (.D(Dint[15]), .TI(scanreg_dr_wire[7]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[8]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF rdata_scff_9 (.D(Dint[14]), .TI(scanreg_dr_wire[8]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[9]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF rdata_scff_10 (.D(Dint[13]), .TI(scanreg_dr_wire[9]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[10]), .OUTX(scanreg_dr)); 

 
 
        ST_SPREG_LOLEAK_32x24m2_Tl_SCFF rdata_scff_11 (.D(Dint[12]), .TI(scanreg_dr_wire[10]), .TE(SE), .CP(CK_sc), .Q(scanreg_dr_wire[11]), .OUTX(scanreg_dr)); 


// Lock Up Latch
wire SDRO_temp;
 ST_SPREG_LOLEAK_32x24m2_Tl_lock_up_latch  dff_SDRO_SE (Latch_open, scanreg_dr_wire[11], SDRO_temp);


always @(SDRO_temp) begin
     SDROint= SDRO_temp;
 `ifdef functional
 `else
 if (SDROint !== SDRO_data) begin 
  if (SDROint !==X)
   SDRO_data=1'bx;
   SDRO_data <= SDROint;
 end 
 `endif
end






//


 //////// CAPTURE TASK //////
task scan_acquire;
begin
   if (supply_ok === 1) begin 
      if ( SEsys === 0 && ((LP_CK_gate === 0 && TBYPASSsys !== 1'bx)|| TBYPASSsys===0)) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
         
         Latch_open=1;
         

      end //if ( SEint === 0
   end//if(supply_ok 
end
endtask

task scan_shift;
begin
 if (supply_ok === 1) begin
   if (STDBYint === 0 && SLEEPint === 0) begin
      if (CKint_dft === X && INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0) begin
         ScanChainX;
         ScanOutX;
      end
      else if (CKint_dft === 1 && lastCK_dft === 0 ) begin
          //// SHIFT
        if (SEsys === 1) begin
         scanreg_ctrl=1'b0;
         scanreg_dl=1'b0;
         scanreg_dr=1'b0;
           
        //// SHIFT Ends
        end //if (SEsys === 1
        else if (SEsys === X) begin
            ScanChainX;
            ScanOutX;
            delScanOutX;
        end//if (SEint ==X
      
      end///if (CKint === 
    
      else if (CKint_dft === 0 && lastCK_dft === 1 ) begin
        Latch_open=1;
      end
    end  //if (STDByint === 0 && SLEEPint === 0
 end//if(supply_ok
end
endtask






// BEHAVIOURAL MODULE DESCRIPTION
// ================================

initial
begin
  // Define format for timing value
  $timeformat (-9, 3, " ns", 0);
  `ifdef slm
  $slm_RegisterMemory(MemAddr, Words, Bits);
  `endif   
   reg_mem_block=0;
   flag_mem_block=0;
  `ifdef functional
  `else
   TimingViol_data=0;
   TimingViol_mask=0;
   `endif
   decoding_start=0;
  
   //Parameter Assignment
   
   reg_Fault_file_name = Fault_file_name; 
   reg_ConfigFault     = ConfigFault;
   reg_MEM_INITIALIZE  = MEM_INITIALIZE;
   reg_BinaryInit      = BinaryInit;
   reg_InitFileName    = InitFileName;
   reg_Initn_reset_value = Initn_reset_value;
   reg_File_load_time    = File_load_time;

   time_fall_sleep=0;
   time_fall_PSWLARGEMP=0;
   time_fall_PSWLARGEMP_0=0;
   time_fall_PSWLARGEMA=0;
   time_fall_PSWLARGEMA_0=0;
   time_fall_PSWSMALLMP=0;
   time_fall_PSWSMALLMA=0;

   vddmp_rise_time=0;
   vddmp_fall_time=0;
   vddsmp_rise_time=0;
   vddsmp_fall_time=0;
   vddma_rise_time=0;
   vddma_fall_time=0;
   vddsma_rise_time=0;
   vddsma_fall_time=0;
   vddm_fall_time=0;  
   vddm_rise_time=0;  
   vddsm_fall_time=0; 
   vddsm_rise_time=0;

   next_cycle_corrupt_func=0;
   next_cycle_corrupt_dft=0;
   init_pulse_done = 0;
   power_up_done = 0;
   file_loaded=1;
   debug_level= 2'b01;
   message_status = "ONLY WARNINGS/ERRORS are Switched ON.For INFO also use debug_level=2'b00";
  `ifdef  NO_WARNING_MODE
     debug_level = 2'b11;
     message_status = "All Warning/Errors/Info Messages are Switched OFF";
  `endif  
  `ifdef  ONLY_ERROR_MODE
     debug_level = 2'b10;
     message_status = "All Warning/Info Messages are Switched OFF.Errors are switched on";
  `endif 
  `ifdef  ALL_MSG_MODE
     debug_level = 2'b00;
     message_status = "All Messages are Switched ON";
  `endif 
  
  `ifdef slm
     operating_mode = "SLM";
   `else
      `ifdef functional
         operating_mode = "FUNCTIONAL";
       `else
         operating_mode = "TIMING";
      `endif
   `endif   
  
  if (debug_level < 1) begin
  $display ("%m INFORMATION ");
  $display ("***************************************");
  $display ("The Model is Operating in %s MODE", operating_mode);
  $display ("%s", message_status);
  if(reg_ConfigFault)
  $display ("Configurable Fault Functionality is ON");   
  else
  $display ("Configurable Fault Functionality is OFF");   
  $display("Fault File used by the model Fault_File_Name=%s" ,reg_Fault_file_name);
  $display("Values of Config_fault used in model=%d" ,reg_ConfigFault);
  $display("Values of Mem_INITALIZE used in model=%d" ,reg_MEM_INITIALIZE);
  $display("Values of BinaryInit used in model=%d" ,reg_BinaryInit);
  $display("Values of InitFileName used in model=%s" ,reg_InitFileName);
  $display("Values of Initn_reset_value used in model=%d" ,reg_Initn_reset_value);
  $display("Values of File_load_time used in model=%t" ,reg_File_load_time);

  $display ("***************************************");
  end
     
  task_read_fault_file; 
   if(!INITNint) begin
    if(supply_ok ) begin 
      init_pulse_done = 1;
      power_up_done = 1;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif 
    end 
   end 
        
   lastCK_func = CKint_func;
   lastCK_dft = CKint_dft;

 `ifdef MEM_CONTENTS_SLEEP
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","w");
   $fclose(ptr);
   ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","w");
   $fclose(ptr);
 `endif 

   
end  // initial block ends



//+++++++++++++++++++++++++++++++ CONFIG FAULT IMPLEMETATION ENDS+++++++++++++++++++++++++++++++//
        




//INITN block starts
//================================
always @(INITNint  or supply_ok )
begin
 if (INITNint === 1'b0) begin
   if(supply_ok) begin
     init_pulse_done = 1;
     power_up_done = 1;
     lastCK_func=CKint_func;
     lastCK_dft=CKint_dft;
     next_cycle_corrupt_func = 0;
     next_cycle_corrupt_dft = 0;
     
     `ifdef INITN_OUTPUT_RESET
       OutReg_data = reg_Initn_reset_value;
     `endif
     // Reset memory contents     
     `ifdef INITN_MEM_RESET
      WriteMem0;
     `endif     
   end 
 end        

 if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && INITNint !== 1)
   begin
     ScanOutX;
     ScanChainX;
     delScanOutX;
   end  
         
 if (init_pulse_done === 0 && INITNint !== 0) begin
     if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) INFO: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
 end
 
end//always @(INITNint)


// Clock Generation 
//wire gated_clock;
//wire clock_gate_en;
//ST_SPREG_LOLEAK_32x24m2_Tl_lock_up_latch CK_SE_latch (!CK , SE, SE_latch_CK);
//and (clock_gate_en, ATP, TBYPASS, !SE_latch_CK);

//ST_SPREG_LOLEAK_32x24m2_Tl_lock_up_latch LP_latch (!CK , scanreg_ctrl_wire[14], LP_latch_CK);
//and (gated_clock,CK,!LP_latch_CK);
//assign CK_new= clock_gate_en ===0 ? CK : (clock_gate_en ===1 ? gated_clock: (CK===0) ? 0 :1'bx);


// Clock Generation Ends


// Functional CK block starts
//======================================
always @(CKint_func)
begin
   lastCK_func=CKreg_func;  
   CKreg_func=CKint_func;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
        if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
      if (CKreg_func === 1'bX || (CKreg_func === 1'b1 && lastCK_func === 1'bx)) begin
        if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
         
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
         Invalid_next_cycle_func;
        end
      end
      else if (CKreg_func === 1'b1 && lastCK_func === 1'b0 ) begin
        time_CK_func_rise=$realtime;
        MEMEN_prev = MEMEN_reg;
        MEMEN_reg = MEMEN;
        CSNreg = CSNint;
        IGreg = IGint;
        DEreg = DEint;
        SE_reg = SEsys;
        TBYPASS_reg = TBYPASSsys;
        ATPreg = ATPint;
        INITNreg = INITNint;
        SLEEPreg = SLEEPint;
        STDBYreg = STDBYint;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 

    `ifdef functional
    `else
        Mem_last=Mem[Aint];
    `endif 
        if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.INITN pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SLEEP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.STANDBY pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg === X && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.chip select  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg === X && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.IG pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg === X && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.Debug pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg === X && (SE_reg !== 1 && TBYPASS_reg !== 1))) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.ATP pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg === X && TBYPASS_reg !== 1) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.SE pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end
        else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && ATPreg !== 0 && SE_reg !== 1 && TBYPASS_reg === X) begin
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.TBYPASS pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end

        else if ((INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0))) && WENint === X) begin
            // Uncertain write cycle
         
            if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: write enable going to X  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
            Invalid_next_cycle_func;
        end 
        else if (next_cycle_corrupt_func === 1) begin
          next_cycle_corrupt_func = X;
        end
        else if (next_cycle_corrupt_func === 1'bx) begin
          next_cycle_corrupt_func = 0;
        end 
        
//        if (next_cycle_corrupt_func === 0 ) begin 
         
          /*---------------------- File initialization -----------------*/
          
          if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && CSNreg === 0 && IGreg === 0 && DEreg === 0 && (ATPreg === 0 ||(ATPreg === 1 && SE_reg === 0 && TBYPASS_reg === 0)) && flag_mem_block === 1'b0) begin
                 Areg=Aint;
                 Dreg=Dint;
                 Mreg=Mint;
                 WENreg=WENint;     
             if (reg_MEM_INITIALIZE === 1'b1 && $realtime >= reg_File_load_time && file_loaded ) begin   
                `ifdef slm
                  if (reg_BinaryInit)
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_BIN");
                  else
                     $slm_LoadMemory(MemAddr, reg_InitFileName, "VERILOG_HEX");
   
                `else
                  if (reg_BinaryInit)
                     $readmemb(reg_InitFileName, Mem, 0, Words-1);
                  else
                     $readmemh(reg_InitFileName, Mem, 0, Words-1);
                `endif
                 file_loaded = 0;
             end
   
             if (^Aint === X)
               ValidAddress = X;
             else if (Aint < Words)
               ValidAddress = 1;
             else    
               ValidAddress = 0;
   
             if(red_en === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Redundancy Enable is Invalid. Either RRAE is X or TRRAE is X",$realtime);
                ValidAddress = X; 
           end
           else if(red_en === 1'b1 && ^repair_add === X) begin
                if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID REDUNDANCY) WARNING: Repair Address is invalid.RRA is X",$realtime);
                ValidAddress = X;
           end
             
             if (ValidAddress)
               `ifdef slm
                   $slm_ReadMemoryS(MemAddr, Aint, Mem_temp);
               `else
                    Mem_temp = Mem[Aint];
               `endif
             else
                Mem_temp = WordX;  
          
     /*---------------------- Normal Read and Write -----------------*/
     
             if (WENint === 1) begin
               ReadCycle(Aint);
             end
       
             else if (WENint === 0) begin
               WriteCycle(Aint);
             end 
                
          
          end //  if (MEMEN === 1'b1 
       
//        end  // if (next_cycle_corrupt_func === 0
      
      end // if (CKint = 1   
   end // if (init_pulse_done === 1           
 end 
end // always @(CKint_func)
        
always @(MEMEN)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) && CKint_func === 1'bx) begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.clock pin  should not be X at this time instant. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
    Invalid_next_cycle_func;
  end
 end 
end

// DFT CK block starts
//======================================
always @(CKint_dft) 
begin
   lastCK_dft=CKreg_dft;
   CKreg_dft=CKint_dft;
   
   Latch_open=0;
 if(supply_ok === 1) begin
   if (init_pulse_done === 0) begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
   end
   else begin
     if (CKreg_dft === 1'bX || (CKreg_dft === 1'b1 && lastCK_dft === 1'bx)) begin
       if (INITNint !== 0 && SLEEPint !== 1 && STDBYint !== 1 && ATPint !== 0 ) begin
        
         if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: DFT clock  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime); 
         Invalid_next_cycle_dft;
         if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
           WriteOutX;
         end
       end
     end 

     if(CKint_dft === 0 && lastCK_dft === 1) begin
      if(ATPreg === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
       if(SE_reg === 1'b1 && SEsys === 1'b0) begin
        if(TBYPASSint === 1'b1) begin   
            
            
    OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],
scanreg_dr_wire[10],
scanreg_dr_wire[11],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9],
scanreg_dl_wire[10], scanreg_dl_wire[scanlen_l-1]}; 
 
         for (i = 0; i < Bits; i = i + 1)
         begin
          if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
         end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
        end 
       end
      end
     end 
     
     else if (CKreg_dft === 1'b1 && lastCK_dft === 1'b0 ) begin
       SE_reg = SEsys;
       TBYPASS_reg = TBYPASSsys;
       ATPreg = ATPint;
       INITNreg = INITNint;
       SLEEPreg = SLEEPint;
       STDBYreg = STDBYint;
       MEMEN_dft_prev = MEMEN_dft_reg;
       MEMEN_dft_reg = MEMEN_dft;
       
        LP_CK_gate=scanreg_ctrl_wire[14]; 
       if (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
       else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ) begin 
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
           if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1 && LP_CK_gate!==1) begin
             WriteOutX;
           end
       end
 //     else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys === X && TBYPASSsys !== 1) begin
///           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
//           Invalid_next_cycle_dft;
//        end       
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys === X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin  Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           Invalid_next_cycle_dft;
        end 
      else if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 && SEsys !== 1 && TBYPASSsys !== 0 && LP_CK_gate===X) begin
           if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: LP FLOP Memory State Machine is corrupted. ScanChains and ScanOuts Corrupted ",$realtime);
           ScanChainX;
           ScanOutX;   
          if( TBYPASSint !== 0 && SEint !== 1) begin
            WriteOutX;
          end
          next_cycle_corrupt_dft=0;
        end        
       else if (next_cycle_corrupt_dft === 1'b1) begin 
         next_cycle_corrupt_dft = X;
       end 
       else if (next_cycle_corrupt_dft === 1'bx) begin
         next_cycle_corrupt_dft = 0;
       end
       
       if (next_cycle_corrupt_dft === 0 ) begin
         
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1 && flag_mem_block === 1'b0) begin
           
           if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0  && LP_CK_gate===0) begin
              OutReg_data_tbypass = Dint;
              for (i = 0; i < Bits; i = i + 1)
              begin
               if (OutReg_data_tbypass[i] !== OutReg_data[i])
                 OutReg_data[i] = WordX[i];
              end//for (i = 0; i < */ 
              OutReg_data <= OutReg_data_tbypass;
           end
           
             scan_acquire;
         end //MEMEN_dft == 1        
       end // if ( next_cycle_corrupt_dft
       
     end // if (CKint_dft === 1'b1
      //  if (next_cycle_corrupt_dft === 0 ) begin 
       if (SE_reg !== 0) begin
         if (INITNreg === 1 && STDBYreg === 0 && SLEEPreg === 0 && ATPreg === 1  && flag_mem_block === 1'b0) begin
           next_cycle_corrupt_dft = 0;
           if ( next_cycle_corrupt_func === 1) begin
	    next_cycle_corrupt_func = 0 ;
	   end	
           scan_shift;
         end
       end
     //end // if ( next_cycle_corrupt_dft    
     if ((!(TBYPASSsys!==0 && SEsys!==1 && LP_CK_gate!==0 ) && next_cycle_corrupt_dft === 0) || CKint_dft !==1) begin          
       CK_sc=INITNreg & !STDBYreg & !SLEEPreg & ATPreg & CKreg_dft ;
     end     
   end // if (init_pulse_done 
 end // if (supply_ok 
end // always @(CKint_dft)

always @(MEMEN_dft)
begin
 if(supply_ok === 1) begin
  if ((INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) && CKint_dft === 1'bx)  begin
       
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Memory State Machine is corrupted.MEMEN_dft and clock should not be X at this time instant. ScanChains and ScanOuts Corrupted ",$realtime); 
    Invalid_next_cycle_dft;
    
    if (TBYPASSsys !== 0 && ATPint !== 0 && SEsys !== 1) begin
      WriteOutX;
    end
  end
  if ( MEMEN_dft !== 0 && TBYPASSsys !== 0 && SEsys !== 1) begin
     WriteOutX;
     OutReg_data = WordX; 
     delOutReg_data=WordX;
 end 
end
end //always @(MEMEN_dft

always @(TBYPASSsys or ATPint)
begin
   if(supply_ok === 1'b1) begin 
    if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0 && INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1) begin
      if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((SEsys === 1'b0) || (CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
    end  
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint === X && SEsys !== 1) ) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
    else if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && (TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end 
end //always @(TBYPASSint





always @(SEsys)
begin
 if(supply_ok === 1'b1) begin 
  if(CKint_dft === 0 && ATPint === 1'b1 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0) begin
    if(SE_reg === 1'b1 && SEsys === 1'b0) begin
      if(TBYPASSsys === 1'b1) begin
          
          
        OutReg_data_scan = { scanreg_dr_wire[0],
scanreg_dr_wire[1],
scanreg_dr_wire[2],
scanreg_dr_wire[3],
scanreg_dr_wire[4],
scanreg_dr_wire[5],
scanreg_dr_wire[6],
scanreg_dr_wire[7],
scanreg_dr_wire[8],
scanreg_dr_wire[9],
scanreg_dr_wire[10],
scanreg_dr_wire[11],scanreg_dl_wire[0],
scanreg_dl_wire[1],
scanreg_dl_wire[2],
scanreg_dl_wire[3],
scanreg_dl_wire[4],
scanreg_dl_wire[5],
scanreg_dl_wire[6],
scanreg_dl_wire[7],
scanreg_dl_wire[8],
scanreg_dl_wire[9],
scanreg_dl_wire[10], scanreg_dl_wire[scanlen_l-1]};  


        for (i = 0; i < Bits; i = i + 1)
        begin
         if (OutReg_data[i] !== OutReg_data_scan[i])
          OutReg_data[i] = WordX[i];
        end  //for (i = 0; i <  
        OutReg_data <= OutReg_data_scan;
      end
    end
  end
  if (TBYPASSsys === 1 && ATPint === 1 && SEsys === 0) begin
      if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg === X && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg === X && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg === X ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
      else if ((CKint_dft === 1'bx && (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 )) || (CKint_dft !== 1'b0 && (INITNreg !== 0 && STDBYreg === X && SLEEPreg !== 1 && ATPreg !== 0 ))) begin
       OutReg_data = WordX;
       delOutReg_data = WordX;       
      end
  end 
  else if ((TBYPASSsys === X && ATPint !== 0 && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint === X && SEsys !== 1)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
  else if ((TBYPASSsys !== 0 && ATPint !== 0 && SEsys === X)) begin
     OutReg_data = WordX;
     delOutReg_data = WordX;
    end
 end   
end

//assign output data
`ifdef functional        

   
always @(SDLOint)
#0.001 delSDLO_data<=SDLOint;

always @(SDROint)
#0.001 delSDRO_data<=SDROint;

 
always @(SCTRLOint)
#0.001 delSCTRLO_data<=SCTRLOint;


always @(OutReg_data)
   #0.001 delOutReg_data = OutReg_data;
`else
`endif

/***************************** Embeded switch functionality starts here ***********************************/





always @(STDBYint)
begin
  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && SLEEPreg === 1'b0 && STDBYreg === 1'b0 && STDBYint !== 1'b0)
    begin
      ScanOutX;
      ScanChainX;
     delScanOutX;     
    end
  end
end



always @(SLEEPint)
begin


  if (SLEEPint !== 1'b1) begin
    time_fall_sleep = $realtime;
  end

  if (power_up_done === 0)
    begin
     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
    end
  else begin
    if (SLEEPint === 1'b1 && lastSLEEP === 1'b0 ) begin 
      
    end
    else if (SLEEPint !== 1'b1 && lastSLEEP === 1'b1 && full_shutdown !== 1) begin 
      
      if (supply_ok !== 1 && ($realtime > 0)) begin
         if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID LOW_POWER) ERROR: ISOLATION signal removed from the memory but array and periphery supply is not completely switched on.Very High Current would be drawn by the memory. All further operations on memory are blocked",$realtime);
          WriteMemX;
          WriteOutX;
          ScanChainX;
          OutReg_data = WordX; 
          delOutReg_data=WordX;
          ScanOutX;//immediately;
          delScanOutX;//immediately;
          init_pulse_done = 0;
          power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            debug_level = 2'b11;
          `endif
          
      end        
      
       
    end   
    else if (SLEEPint === X && lastSLEEP === 1'b0 && full_shutdown !== 1'b1) begin 
     
    end 
  end  


  if (supply_ok === 1'b1) begin
   if (init_pulse_done === 0)
     begin
       if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
     end
   else if (CKint_dft === 1'b1 && SE_reg !== 0 && ATPreg !== 0 && INITNreg === 1'b1 && STDBYreg === 1'b0 && SLEEPreg === 1'b0 && SLEEPint !== 0)
    begin
      ScanOutX;
      ScanChainX;
        delScanOutX;      
    end
  end

// if (init_pulse_done === 0)
//   begin
//     if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID INIT) WARNING: Init pulse not applied yet,No operation allowed before initialisation pulse ",$realtime);
//   end
//
// else if ( SLEEPint !== 1 && (supply_ok !==1) ) begin
//    
//    WriteOutX;
//    OutReg_data = WordX; 
//    delOutReg_data=WordX;
//    ScanOutX;//immediately;
//    delScanOutX;//immediately;
//    ScanChainX;
//    WriteMemX;
//    if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies with sleep/Power down signal being low.This scenario can lead to high dc currents and some reliability issues Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
// end

 print_sleep;    
 lastSLEEP=SLEEPint;
end

/********************************** Embeded switch functionality ends here *******************************/

task print_sleep;
begin
  if (SLEEPint === 1'b0) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been deasserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_DEASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end  
  else if (SLEEPint === 1'b1) begin
      if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) INFO: SLEEP pin has been asserted.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_ACTIVE in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_ASSERT.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif

  end        
  else begin
      if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID SLEEP) ERROR: SLEEP pin is at an invalid state.The contents of memory are dumped in a file named MEM_CONTENTS_SLEEP_INVALID in the current simulation directory. ",$realtime);
      `ifdef MEM_CONTENTS_SLEEP
        ptr=$fopen("MEMORY_CONTENTS_SLEEP_INVALID.dat","a");
        for(memcnt = 0; memcnt < Words; memcnt = memcnt+ 1) begin 
         $fdisplay(ptr,"contents at location %d are = %b ",memcnt,Mem[memcnt],$realtime);
        end
        $fclose(ptr);
      `endif
  end        
end
endtask





 

//// C28SOI non flip compiler power functionality 
always @(gndmreg )
begin
 if (power_up_done === 1 && $realtime > 0) begin    
    if(gndmreg !== 1'b0 ) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or gndsm is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
        corrupt_all;
        init_pulse_done = 0;
        power_up_done = 0;
     `ifdef NO_BLOCK_MEM
     `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of ground pins.Ground must be maintained at 0 Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime);
        debug_level = 2'b11;
     `endif   

    end   
 end

end




always @(vddmareg )
begin

if (vddmareg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddma(Array Supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 
    end
   end   
   else if (SLEEPint === 1) begin
    WriteMemX;
   end

end

if ((vddmareg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1 ) && $realtime > 0) begin
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddm or vddsma is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         corrupt_all;
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif

end


end

always @(vddmpreg )
begin
 if (vddmpreg !== 1'b1 ) begin
   if(SLEEPint !== 1) begin
    if(power_up_done === 1 && $realtime > 0) begin
      corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or vddsmp is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
      init_pulse_done = 0;
      power_up_done = 0;
   
      `ifdef NO_BLOCK_MEM
      `else
        flag_mem_block = 1;
        if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmp(Periphery Supply)/vddsmp(Substrate power supply). Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
        debug_level = 2'b11;
      `endif 

    end
   end   
   else if (SLEEPint === 1) begin
    WriteOutX;
    ScanChainX;
    ScanOutX;
    delScanOutX;//immediately;
    OutReg_data = WordX; 
    delOutReg_data=WordX;
   end
 end

if( (vddmpreg !== 1'b0 ) && (vddmoreg !== 1'b1 || SLEEPint !== 1'b1 )  && $realtime > 0) begin
         corrupt_all;
        if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
         init_pulse_done = 0;
         power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
     `endif
end
 
 
end


always @(vddmoreg)
begin
  if (power_up_done === 1 && $realtime > 0) begin   
      if (vddmoreg !== 1'b1)  begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin
           corrupt_all;
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
         end //if (vddmareg === 1'b1 

      else if (vddmareg === 1'b0 && vddmpreg === 1'b0   && SLEEPint === 1'b1 &&  $realtime > 0)
        begin 
            if((debug_level < 2) && ($realtime > 0)) $display("%m - %t WARNING: Illegal Value on power pin(s). Memory and Output Corrupted ", $realtime);
 
           corrupt_all;
        end //else if (vddmareg === 1'b 
     end   // if (vddmoreg !== 1'b1)
     else if (vddmoreg === 1'b1 && $realtime > 0 ) begin
         if (vddmareg !== 1'b0 || vddmpreg !== 1'b0  )  begin     
           if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmo  is being powered down. Memory,Output,ScanChains,ScanOuts  are corrupted. ",$realtime); 
           corrupt_all;
           init_pulse_done = 0;
           power_up_done = 0;
          `ifdef NO_BLOCK_MEM
          `else
            flag_mem_block = 1'b1;
            if( (debug_level < 3) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) ERROR: Invalid state of power supplies vddmo. Memory,Output,ScanChains,ScanOuts are corrupted.All further operations(R/W,Scan,TBYPASS etc) on memory are blocked. ",$realtime); 
            debug_level = 2'b11;
            
           `endif
        end        
     end // else if (vddmoreg === 1'b1
  end 
end // always @(vddmoreg)












always @(gndmreg) begin
 if (gndmreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 0. ",$realtime);
 end
 else if (gndmreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to logic 1. ",$realtime);
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: gndm or Common ground is going to invalid state. ",$realtime);
 end
end




 
always @(vddmareg) begin
 if (vddmareg === 0) begin 
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 0. ",$realtime);
  vddma_fall_time = $realtime;
 end
 else if (vddmareg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to logic 1. ",$realtime);
  vddma_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddma or Array Power supply is going to invalid state. ",$realtime);
  vddma_fall_time = $realtime;
 end 

 

end

always @(vddmpreg) begin
 if (vddmpreg === 0) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 0. ",$realtime);
  vddmp_fall_time = $realtime;
 end
 else if (vddmpreg === 1) begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to logic 1. ",$realtime);
  vddmp_rise_time = $realtime;
 end
 else begin
  if( (debug_level < 1) && ($realtime > 0) ) $display("%m - %t (MSG_ID POWER) INFO: vddmp or Periphery Power supply is going to invalid state. ",$realtime);
  vddmp_fall_time = $realtime;
 end

 
 
end



// end of C28SOI power functionality 
 


assign supply_ok          =  (vddmareg === 1'b1 && vddmpreg  === 1'b1  && gndmreg === 1'b0 && vddmoreg === 1'b1 ) ? 1'b1 : 1'b0;
assign core_supply_ok     =  (vddmoreg === 1'b1 && vddmareg === 1'b1 && gndmreg === 1'b0 ) ? 1'b1 : 1'b0;
assign peri_supply_ok     =  (vddmoreg === 1'b1 && vddmpreg === 1'b1 && gndmreg === 1'b0  ) ? 1'b1 : 1'b0;

assign full_shutdown = (vddmpreg === 1'b0 && vddmareg === 1'b0   ) ? 1'b1 : 1'b0 ;




`ifdef functional
`else


task WriteLocMskX_bwise;
   input [Addr-1 : 0] Address;
   input [Bits-1 : 0] Mask;

reg [Bits+Red_extrabit:0] tempReg1;
integer num1; 
begin
   tempReg1 = WordX;
   if (^Address !== X )
   begin
      tempReg1 = Mem[Address];
             
      for (j = 0;j< Bits; j=j+1) begin
         num1=j;
        if (Mask[j] === 1'bx)
            tempReg1[num1] = 1'bx;
      end
      Mem[Address] = tempReg1;
      task_insert_faults_in_memory;
   end//if (^Address !== X
   else begin
      if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Write Port:  Illegal Value on Address Bus. Memory Corrupted ",$realtime);
      WriteMemX;
   end   
end
endtask


/****************Actions taken on timing violations*****************/

 always @(TimingViol_data)
// tds or tdh violation
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
  for (l = 0; l < Bits; l = l + 1) begin   
    if (CSWEMTBYPASS[l] !== 0) begin
     if((TimingViol_data[l] !== TimingViol_data_last[l])) begin


         Mreg[l] = 1'bx;
     end    
     WriteLocMskX_bwise(Areg,Mreg);
    end   
   end 
  end
    if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin
     scanreg_dl =1'bx; 
     scanreg_dr =1'bx; 
     SDLOint=X;
     SDROint=X;
     `ifdef functional
     `else
     SDLO_data<=1'bx;
     SDRO_data<=1'bx;
     `endif
    end
     TimingViol_data_last = TimingViol_data; 
end





always @(TimingViol_addr)
// tas or tah
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: Address pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
      scanreg_ctrl=1'bx; 
      SCTRLOint=X;
      `ifdef functional
      `else
      SCTRLO_data<=1'bx;
      `endif
  end
end


always @(TimingViol_WEN)
//tws or twh
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WEN pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);
  end
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end 

always @(TimingViol_CSN )
// tps or tph 
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
   Invalid_next_cycle_func_tim;

   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CSN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
   scanreg_ctrl=1'bx; 
   SCTRLOint=X;
   `ifdef functional
   `else
   SCTRLO_data<=1'bx;
   `endif
  end
end

always @(TimingViol_tcycle )
//tcycle
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
   if (MEMEN !== 0 && MEMEN_prev !== 0) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckl )
// tckl 
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && CSNint !== 1 && IGint !== 1 && DEint !== 1 && (ATPint !== 1 ||(ATPint === 1 && SEsys !== 1 && TBYPASSsys !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end

always @(TimingViol_tckh) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1))) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: CK pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end


always @(TimingViol_tcycle_se )
//tcycle_se
begin
#0
   if (MEMEN_dft !== 0 && MEMEN_dft_prev !== 0) begin
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckl_se  )
begin
#0
   if (INITNint !== 0 && STDBYint !== 1 && SLEEPint !== 1 && ATPint !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tckh_se) begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    Invalid_next_cycle_dft_tim;
   end
end

always @(TimingViol_tbist) begin
#0
   if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
   end
   if (TBYPASSint !== 1'b0) begin 
    WriteOutX;
   end 
   if (INITNreg !==0 && STDBYreg !== 1 && TBYPASS_reg !== 1 && SLEEPreg !== 1 && SE_reg !== 1 && IGreg !== 1 && DEreg !== 1) begin
    Invalid_next_cycle_func_tim;

    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBIST pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
   end
end






always @(TimingViol_tbypass)
//ttmck
begin
#0  
  WriteOutX;
  if (INITNreg !== 0 && SLEEPreg !== 1 && SE_reg !== 1 && STDBYreg !== 1 &&  DEreg !== 1) begin
   Invalid_next_cycle_dft_tim;
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
  if (CSNreg !== 1 && IGreg !== 1 && DEreg !== 1 && SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: TBYPASS pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end
end



always @(TimingViol_sleep)
begin
#0
  if (INITNreg !== 0 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SLEEP pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_stdby)
begin
#0
  if (CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin 
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: STDBY pin timing violation Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (ATPreg !== 0) begin 
   Invalid_next_cycle_dft_tim;
  end
end






always @(TimingViol_se) begin
#0
   if (TBYPASS_reg !== 0) begin 
    WriteOutX;
   end 
  if (TBYPASS_reg === 0) begin
     WriteOutX;
     WriteMemX;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: SE timing violation  Memory State Machine is corrupted. Output Corrupted ",$realtime); 
  end 
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
    ScanChainX;
    ScanOutX;
    delScanOutX;       
  end
end

always @(TimingViol_sctrli) begin
  scanreg_ctrl=1'bx; 
end


always @(TimingViol_sdli) begin
 scanreg_dl=1'bx; 
end

always @(TimingViol_sdri) begin
   scanreg_dr=1'bx;
end

 

always @(TimingViol_initnl) begin
init_pulse_done=0;
WriteOutX;
OutReg_data = WordX; 
delOutReg_data=WordX;
ScanOutX;
delScanOutX;
ScanChainX;
WriteMemX;
end

always @(TimingViol_initn) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: INITN timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && ATPreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end

always @(TimingViol_ig) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && INITNreg !== 0 && DEreg !== 1) begin
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: IG pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (INITNreg !== 0 && STDBYreg !== 1 && SLEEPreg !== 1 && ATPreg !== 0 ) begin      
   ScanChainX;
   ScanOutX;
   delScanOutX;       
  end
end

always @(TimingViol_atp) begin
#0
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin  
   Invalid_next_cycle_func_tim;
   
   if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: ATP pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime); 
  end  
  if (SLEEPreg !== 1 && STDBYreg !== 1 && INITNreg !== 0) begin
   Invalid_next_cycle_dft_tim;
  end
end


always @(TimingViol_rm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^WMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: RM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);  
   end
end
 
always @(TimingViol_wm) begin
#0
   if (INITNreg !== 0 && SLEEPreg !== 1 && STDBYreg !== 1 && CSNreg !== 1 && (ATPreg !== 1 ||(ATPreg === 1 && SE_reg !== 1 && TBYPASS_reg !== 1)) && IGreg !== 1 && (LSint !== X) && (HSint !== X) && (^RMint === 0)) begin 
    Invalid_next_cycle_func_tim;
    if( (debug_level < 2) && ($realtime > 0) ) $display("%m - %t (MSG_ID R/W) WARNING: WM pin timing violation  Memory State Machine is corrupted. Memory and Output Corrupted.Next Clock cycle will be not functional ",$realtime);        
   end
end 


`endif


endmodule




module ST_SPREG_LOLEAK_32x24m2_Tl_lock_up_latch (EN,D,Q);
input EN,D;
output reg Q;

  always @ (EN or D) begin
    if (EN === 1) begin
       Q = D;
    end
    else if ((EN === 1'bz || EN === 1'bx  )&& D !== Q) begin
        Q=1'bx;
    end    
  end
endmodule

module ST_SPREG_LOLEAK_32x24m2_Tl_SCFF (D,TI,TE,CP,Q,OUTX);
input D,TI,TE,CP;
input OUTX;
output reg Q;
wire Dint;
assign Dint= (TE===1)?TI:(TE===0)?D:1'bx;

always @(posedge CP)
        begin
          if(Dint === 1'bZ || CP ===1'bx || OUTX === 1'bx)
          begin
                  Q = 1'bx;
          end
          else
          begin
                  Q = Dint;
          end        
        end
always @(posedge OUTX)
Q = 1'bx;
endmodule



`undef setup_time
`undef hold_time
`undef access_time
`undef retain_time
`undef cycle_time
`undef pulse_width_time
`undef initin_low_pulse


`delay_mode_path
`endcelldefine
`nosuppress_faults



